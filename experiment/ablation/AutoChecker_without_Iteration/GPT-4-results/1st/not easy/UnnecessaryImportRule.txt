开始

========================================== Rule UnnecessaryImportRule ===========================================
一共 73 个测试用例
正例 50 个
反例 23 个
12
9
157
137
23
19
10
8
38
34
40
37
11
9
15
13
11
8
85
71
84
70
19
14
97
91
12
10
9
7
12
10
9
7
85
71
27
17
12
10
30
28
90
76
=========================logics=========================
1. Get the name of the package where the class is located.
2. Get all import statements of the class.
3. For each import statement, check whether imported class/method is used in the class.
4. Check whether the imported class/method is in java.lang package.
5. Check whether the imported class/method is in the same package as the class.
6. Check for duplicate import statements.

If an import statement is not used or it imports a class/method from java.lang, or it imports a class/method from the same package, or there are duplicate import statements, then the import statement violates the rule. The test case above has one unused import statement, which violates the rule.
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Get all import statements of the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each import statement, check whether imported class/method is used in the class.* 匹配到的元操作或API：
query: For each import statement, check whether imported class/method is used in the class.
most similar API: Check whether the import equals
cosine Similarity: 0.8123972415924072
*Check whether the imported class/method is in java.lang package.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the imported class/method is in the same package as the class.* 匹配到的元操作或API：
query: Check whether the imported class/method is in the same package as the class.
most similar API: Check whether the import equals
cosine Similarity: 0.8336756229400635
*Check for duplicate import statements.* 匹配到的元操作或API：
query: Check for duplicate import statements.
most similar API: Check whether the import equals
cosine Similarity: 0.86394864320755
107
91
83
69
149
133
117
102
=========================logics=========================
1. Get all import statements in the file.
2. For each import statement, check if it is a single type import or a wildcard import.
3. Check if the imported class or package is used within the file.
4. Check if the imported class or package is from java.lang.
5. Get the name of the package where the class is located.
6. Check if the imported class or package is in the same package as the class.
7. Check for duplicated import statements.
8. If any import statement is unused, duplicated, or imports members that are implicitly in scope, mark it as violating the rule.

According to the steps, this test case does not violate the described rule, as it uses the imported class `java.io.File` exactly once and the import is neither duplicated nor implicitly in scope.
*Get all import statements in the file.* 匹配到的元操作或API：
query: Get all import statements in the file.
most similar API: get text of import
cosine Similarity: 0.8178805708885193
*For each import statement, check if it is a single type import or a wildcard import.* 匹配到的元操作或API：
query: For each import statement, check if it is a single type import or a wildcard import.
most similar API: Check whether the import equals
cosine Similarity: 0.8472434878349304
*Check if the imported class or package is used within the file.* 匹配到的元操作或API：
query: Check if the imported class or package is used within the file.
most similar API: Check whether the import equals
cosine Similarity: 0.8060230612754822
*Check if the imported class or package is from java.lang.* 匹配到的元操作或API：
query: Check if the imported class or package is from java.lang.
most similar API: Check whether the import equals
cosine Similarity: 0.8056533336639404
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check if the imported class or package is in the same package as the class.* 匹配到的元操作或API：
query: Check if the imported class or package is in the same package as the class.
most similar API: Check whether the import equals
cosine Similarity: 0.8486741185188293
*Check for duplicated import statements.* 匹配到的元操作或API：
query: Check for duplicated import statements.
most similar API: Check whether the import equals
cosine Similarity: 0.8610569834709167
*If any import statement is unused, duplicated, or imports members that are implicitly in scope, mark it as violating the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
=========================logics=========================
1. Get all import statements in the file.
2. Check whether the imported class is used within the file.
3. Check whether the imported class is from the java.lang package.
4. Check whether the imported class is from the current package.
5. Check for duplicate import statements.

If any import statement is not used within the file, or if it imports a class from java.lang or the current package, or if there are duplicate import statements, then those import statements violate the rule. In this test case, since `java.io.File` and `java.util.List` are not used within the class `Foo`, each unused import statement counts as a violation of the rule. The number of violations in this test case is 2.
*Get all import statements in the file.* 匹配到的元操作或API：
query: Get all import statements in the file.
most similar API: get text of import
cosine Similarity: 0.8178805708885193
*Check whether the imported class is used within the file.* 匹配到的元操作或API：
query: Check whether the imported class is used within the file.
most similar API: Check whether the import equals
cosine Similarity: 0.8004677295684814
*Check whether the imported class is from the java.lang package.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the imported class is from the current package.* 匹配到的元操作或API：
query: Check whether the imported class is from the current package.
most similar API: get class of import
cosine Similarity: 0.8281128406524658
*Check for duplicate import statements.* 匹配到的元操作或API：
query: Check for duplicate import statements.
most similar API: Check whether the import equals
cosine Similarity: 0.86394864320755
94
78
144
127
106
90
96
81
96
79
92
78
96
79
77
63
97
81
=========================logics=========================
1. Get the name of imported class.
2. Check whether the imported class is used in the file.
3. Check whether the imported class belongs to java.lang package.
4. Get the name of the package where the class is located.
5. Check whether the imported class belongs to the same package as the class where it's used.
6. Check whether there are duplicate imports of the same class.

Since the class `AccessController` from `java.security` package is used in the `Foo` class and it does not belong to `java.lang` or the same package as `Foo`, and there are no duplicate imports, this test case does not violate the rule.
*Get the name of imported class.* 匹配到的元操作或API：
logic: Get the name of imported class.
most similar meta operation: Get the name of class
cosine Similarity: 0.8612569570541382
*Check whether the imported class is used in the file.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the imported class belongs to java.lang package.* 匹配到的元操作或API：
query: Check whether the imported class belongs to java.lang package.
most similar API: Check whether the import equals
cosine Similarity: 0.8001062870025635
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the imported class belongs to the same package as the class where it's used.* 匹配到的元操作或API：
query: Check whether the imported class belongs to the same package as the class where it's used.
most similar API: Check whether the import equals
cosine Similarity: 0.8245632648468018
*Check whether there are duplicate imports of the same class.* 匹配到的元操作或API：
query: Check whether there are duplicate imports of the same class.
most similar API: Check whether the import equals
cosine Similarity: 0.848162829875946
96
80
=========================logics=========================
1. Get the name of the package where the class is located.
2. Check whether the class has any methods that throw exceptions.
3. Get a throw exception in method signature.
4. Get the type of exception thrown in throw statement.
5. Check whether the exception type thrown by the throw statement is RemoteException.
6. Check whether RemoteException is in java.lang package or in the same package as the class.

Since RemoteException is neither in java.lang nor in the same package as the class, and it is used in the throws clause, the import statement is necessary. Therefore, this test case does not violate the rule.
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the class has any methods that throw exceptions.* 匹配到的元操作或API：
query: Check whether the class has any methods that throw exceptions.
most similar API: Check whether the method is any annotation present
cosine Similarity: 0.8085362315177917
*Get a throw exception in method signature.* 匹配到的元操作或API：
logic: Get a throw exception in method signature.
most similar meta operation: Get a throw exception in method signature
cosine Similarity: 0.9811146259307861
*Get the type of exception thrown in throw statement.* 匹配到的元操作或API：
logic: Get the type of exception thrown in throw statement.
most similar meta operation: Get the type of exception thrown in throw statement
cosine Similarity: 0.9913610219955444
*Check whether the exception type thrown by the throw statement is RemoteException.* 匹配到的元操作或API：
query: Check whether the exception type thrown by the throw statement is RemoteException.
most similar API: Check whether is just rethrow exception
cosine Similarity: 0.8052792549133301
*Check whether RemoteException is in java.lang package or in the same package as the class.* 匹配到的元操作或API：
未匹配成功元操作或API
82
68
116
101
93
78
119
103
=========================logics=========================
1. Get the name of the class where the import statement is used.
2. Get the name of the package where the class is located.
3. Check whether the imported class/package is 'java.lang'.
4. Check whether the imported class/package is the same as the package of the class.
5. Check whether any class, method, or field from the imported package/class is used in the class.
6. Check for duplicate import statements.

If the import statement imports 'java.util.ArrayList' and it is used in the method parameters or body, and it is not from 'java.lang' or the same package, and there are no duplicate imports, then it is not violating the rule.
*Get the name of the class where the import statement is used.* 匹配到的元操作或API：
query: Get the name of the class where the import statement is used.
most similar API: get class of import
cosine Similarity: 0.8748841285705566
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the imported class/package is 'java.lang'.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the imported class/package is the same as the package of the class.* 匹配到的元操作或API：
query: Check whether the imported class/package is the same as the package of the class.
most similar API: Check whether the import equals
cosine Similarity: 0.860205352306366
*Check whether any class, method, or field from the imported package/class is used in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check for duplicate import statements.* 匹配到的元操作或API：
query: Check for duplicate import statements.
most similar API: Check whether the import equals
cosine Similarity: 0.86394864320755
106
91
96
80
=========================logics=========================
1. Get all import statements in the test case.
2. Check whether the imported classes or packages are used within the code.
3. Check for any duplicate import statements.
4. Check if imported classes are from the `java.lang` package or the same package as the class `Foo`.
5. Check whether the imported class or package is implicitly imported (like `java.lang.*`).

If none of the imports are unused, duplicated, or unnecessary due to implicit import, then this test case adheres to the rule without violations.
*Get all import statements in the test case.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the imported classes or packages are used within the code.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check for any duplicate import statements.* 匹配到的元操作或API：
query: Check for any duplicate import statements.
most similar API: Check whether the import equals
cosine Similarity: 0.8667840957641602
*Check if imported classes are from the `java.lang` package or the same package as the class `Foo`.* 匹配到的元操作或API：
query: Check if imported classes are from the `java.lang` package or the same package as the class `Foo`.
most similar API: Check whether the import equals
cosine Similarity: 0.8145990371704102
*Check whether the imported class or package is implicitly imported (like `java.lang.*`).* 匹配到的元操作或API：
query: Check whether the imported class or package is implicitly imported (like `java.lang.*`).
most similar API: Check whether the import equals
cosine Similarity: 0.8114451169967651
=========================logics=========================
1. Get the name of the package where the class is located.
2. Check for each import statement:
    1. Check whether the imported class or interface is used in the code.
    2. Check whether the import statement is duplicated.
    3. Check whether the imported class or interface is from java.lang package.
    4. Check whether the imported class or interface is from the same package as the class.
    5. Get the name of all classes and interfaces declared in the file.
    6. Check whether the imported class or interface is implicitly in scope (either because it's in java.lang, the current package, or declared in the file).
If no import statement is unused, duplicated, or imports members that are already implicitly in scope, then the number of violations of the rule in this test case is 0.
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check for each import statement:* 匹配到的元操作或API：
query: Check for each import statement:
most similar API: Check whether the import equals
cosine Similarity: 0.888525128364563
*Check whether the imported class or interface is used in the code.* 匹配到的元操作或API：
query: Check whether the imported class or interface is used in the code.
most similar API: Check whether the class or interface is interface
cosine Similarity: 0.827958345413208
*Check whether the import statement is duplicated.* 匹配到的元操作或API：
query: Check whether the import statement is duplicated.
most similar API: Check whether the import equals
cosine Similarity: 0.8743733763694763
*Check whether the imported class or interface is from java.lang package.* 匹配到的元操作或API：
query: Check whether the imported class or interface is from java.lang package.
most similar API: Check whether the class or interface is native
cosine Similarity: 0.8305354118347168
*Check whether the imported class or interface is from the same package as the class.* 匹配到的元操作或API：
query: Check whether the imported class or interface is from the same package as the class.
most similar API: Check whether the class or interface equals
cosine Similarity: 0.849847674369812
*Get the name of all classes and interfaces declared in the file.* 匹配到的元操作或API：
query: Get the name of all classes and interfaces declared in the file.
most similar API: get declarations of class or interface
cosine Similarity: 0.8442292809486389
*Check whether the imported class or interface is implicitly in scope (either because it's in java.lang, the current package, or declared in the file).* 匹配到的元操作或API：
query: Check whether the imported class or interface is implicitly in scope (either because it's in java.lang, the current package, or declared in the file).
most similar API: Check whether the class or interface is local
cosine Similarity: 0.8021851181983948
96
80
95
78
81
67
99
82
90
76
156
136
=========================logics=========================
1. Check whether import statements are duplicated.
2. Check whether imported classes or interfaces are used in the code.
3. Check whether imported classes or interfaces are in the `java.lang` package.
4. Check whether imported classes or interfaces are in the current package.
5. Get the name of the package where the annotation declaration is located.
6. Check whether the imported classes or interfaces are referenced in annotations.

Based on the given test case, the imported classes `foo.annotation.Retention` and `foo.annotation.RetentionPolicy` are used in defining the `@Retention` annotation on the `@interface Foo`. Therefore, these import statements are necessary for the code to compile correctly, and there are no violations of the rule.
*Check whether import statements are duplicated.* 匹配到的元操作或API：
query: Check whether import statements are duplicated.
most similar API: Check whether the import equals
cosine Similarity: 0.8710426688194275
*Check whether imported classes or interfaces are used in the code.* 匹配到的元操作或API：
query: Check whether imported classes or interfaces are used in the code.
most similar API: Check whether the class or interface type is class or interface type
cosine Similarity: 0.8062644004821777
*Check whether imported classes or interfaces are in the `java.lang` package.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether imported classes or interfaces are in the current package.* 匹配到的元操作或API：
query: Check whether imported classes or interfaces are in the current package.
most similar API: Check whether the import equals
cosine Similarity: 0.8067322373390198
*Get the name of the package where the annotation declaration is located.* 匹配到的元操作或API：
logic: Get the name of the package where the annotation declaration is located.
most similar meta operation: Get the name of the package where the annotation declaration is located
cosine Similarity: 0.9882047176361084
*Check whether the imported classes or interfaces are referenced in annotations.* 匹配到的元操作或API：
logic: Check whether the imported classes or interfaces are referenced in annotations.
most similar meta operation: Check whether interface has declared annotations
cosine Similarity: 0.8684656023979187
=========================logics=========================
1. Get the declared annotations of the class.
2. Get a declared annotation of class.
3. Get the name of each declared annotation.
4. Check whether each import statement directly corresponds to a used annotation in the class.
5. Check whether the imported entities are from the java.lang package.
6. Get the name of the package where the class is located.
7. Check whether the imported entities are from the same package as the class.

If all imports are used as annotations on the class, and none of the imports are from java.lang or the same package as the class, then the test case does not violate the rule.
*Get the declared annotations of the class.* 匹配到的元操作或API：
logic: Get the declared annotations of the class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9216006994247437
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.987838864326477
*Get the name of each declared annotation.* 匹配到的元操作或API：
logic: Get the name of each declared annotation.
most similar meta operation: Get the name of annotation declaration
cosine Similarity: 0.936881422996521
*Check whether each import statement directly corresponds to a used annotation in the class.* 匹配到的元操作或API：
query: Check whether each import statement directly corresponds to a used annotation in the class.
most similar API: Check whether the import equals
cosine Similarity: 0.8010499477386475
*Check whether the imported entities are from the java.lang package.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the imported entities are from the same package as the class.* 匹配到的元操作或API：
query: Check whether the imported entities are from the same package as the class.
most similar API: Check whether the import equals
cosine Similarity: 0.8238783478736877
=========================logics=========================
1. Get the name of the package where the class is located.
2. Check whether the imported class is from the same package.
3. Check whether the imported class is from the `java.lang` package.
4. Get all methods declared in class.
5. Get the return type of method.
6. Check whether the return type of the method is the same as the imported class.
7. Get all fields declared in class.
8. Get the type of field.
9. Check whether the type of field is the same as the imported class.
10. Get all formal parameters declared in methods and constructors.
11. Get the type of formal parameter.
12. Check whether the type of formal parameter is the same as the imported class.

If the imported class is not used in the return type of methods, fields, or formal parameters, or if it is from the `java.lang` package or the same package as the class, then the import statement is unnecessary and violates the rule.
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the imported class is from the same package.* 匹配到的元操作或API：
query: Check whether the imported class is from the same package.
most similar API: Check whether the import equals
cosine Similarity: 0.8518099784851074
*Check whether the imported class is from the `java.lang` package.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366355895996094
*Get the return type of method.* 匹配到的元操作或API：
logic: Get the return type of method.
most similar meta operation: Get the return type of method
cosine Similarity: 0.9835968017578125
*Check whether the return type of the method is the same as the imported class.* 匹配到的元操作或API：
logic: Check whether the return type of the method is the same as the imported class.
most similar meta operation: Check whether the return type of method is x class type
cosine Similarity: 0.8671395182609558
*Get all fields declared in class.* 匹配到的元操作或API：
query: Get all fields declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8290461301803589
*Get the type of field.* 匹配到的元操作或API：
logic: Get the type of field.
most similar meta operation: Get the type of field
cosine Similarity: 0.983250081539154
*Check whether the type of field is the same as the imported class.* 匹配到的元操作或API：
query: Check whether the type of field is the same as the imported class.
most similar API: Check whether the import equals
cosine Similarity: 0.8175473213195801
*Get all formal parameters declared in methods and constructors.* 匹配到的元操作或API：
logic: Get all formal parameters declared in methods and constructors.
most similar meta operation: Get the number of formal parameters of method
cosine Similarity: 0.8661162853240967
*Get the type of formal parameter.* 匹配到的元操作或API：
logic: Get the type of formal parameter.
most similar meta operation: Get the type of formal parameter
cosine Similarity: 0.9854807257652283
*Check whether the type of formal parameter is the same as the imported class.* 匹配到的元操作或API：
logic: Check whether the type of formal parameter is the same as the imported class.
most similar meta operation: Check whether the formal parameter is a x class type
cosine Similarity: 0.8500607013702393
89
74
=========================logics=========================
1. Get the name of the package where the class is located.
2. Check whether there are any import statements in the file.
3. For each import statement, check whether the imported class or member is used in the file.
4. For each import statement, check whether it imports a class or member from the `java.lang` package.
5. For each import statement, check whether it imports a class or member that is in the same package as the current class.
6. For each import statement, check whether it is duplicated elsewhere in the import section.

If none of the import statements are unused, duplicated, or import members that are implicitly in scope (either from `java.lang` or the current package), then the number of violations of the rule is 0.
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether there are any import statements in the file.* 匹配到的元操作或API：
query: Check whether there are any import statements in the file.
most similar API: Check whether the import equals
cosine Similarity: 0.8658274412155151
*For each import statement, check whether the imported class or member is used in the file.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each import statement, check whether it imports a class or member from the `java.lang` package.* 匹配到的元操作或API：
query: For each import statement, check whether it imports a class or member from the `java.lang` package.
most similar API: Check whether the import equals
cosine Similarity: 0.8172816634178162
*For each import statement, check whether it imports a class or member that is in the same package as the current class.* 匹配到的元操作或API：
query: For each import statement, check whether it imports a class or member that is in the same package as the current class.
most similar API: Check whether the import equals
cosine Similarity: 0.837130069732666
*For each import statement, check whether it is duplicated elsewhere in the import section.* 匹配到的元操作或API：
query: For each import statement, check whether it is duplicated elsewhere in the import section.
most similar API: Check whether the import equals
cosine Similarity: 0.8327282667160034
=========================logics=========================
1. Get the name of the package where the class is located.
2. Get the name of the imported class.
3. Check whether the imported class is in the same package as the class where it is being used.
4. Check whether the imported class is in the java.lang package.

If the imported class is in the same package or is part of java.lang, then this test case violates the rule.
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Get the name of the imported class.* 匹配到的元操作或API：
logic: Get the name of the imported class.
most similar meta operation: Get the name of class
cosine Similarity: 0.8629580736160278
*Check whether the imported class is in the same package as the class where it is being used.* 匹配到的元操作或API：
query: Check whether the imported class is in the same package as the class where it is being used.
most similar API: Check whether the import equals
cosine Similarity: 0.8278308510780334
*Check whether the imported class is in the java.lang package.* 匹配到的元操作或API：
未匹配成功元操作或API
125
108
114
98
=========================logics=========================
To evaluate this test case against the rule, we need to check for unused imports, duplicated imports, or imports from `java.lang` or the current package. Since the test case uses a static import from `com.foo.MyClass`, we will check if the imported static method is used in the class `Foo`.

1. Get the name of the package where the class is located.
2. Check whether the imported static method is used in the class.
3. Check whether there are any duplicated import statements.
4. Check whether the imported members are from package `java.lang` or the same package as the class.
5. Check whether the imported members are implicitly in scope.

If the imported static method `staticMethod` is not used, or if there are any duplicated import statements, or the imported members are from `java.lang` or the same package and are implicitly in scope, then the test case violates the rule. However, from the provided example, it seems that `staticMethod` is used within the constructor of the class `Foo`, which would indicate that the import statement is necessary and not a violation of the rule. The description "bad 5" and the number of violations "1" are not consistent with the visible code and usage pattern.
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the imported static method is used in the class.* 匹配到的元操作或API：
query: Check whether the imported static method is used in the class.
most similar API: Check whether the import is static
cosine Similarity: 0.8349623680114746
*Check whether there are any duplicated import statements.* 匹配到的元操作或API：
query: Check whether there are any duplicated import statements.
most similar API: Check whether the import equals
cosine Similarity: 0.8639262318611145
*Check whether the imported members are from package `java.lang` or the same package as the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the imported members are implicitly in scope.* 匹配到的元操作或API：
未匹配成功元操作或API
=========================logics=========================
1. Get all import statements from the file.
2. For each import statement, get the type of import (static or regular).
3. Check whether the imported member (class, method, or field) is used within the file.
4. Check whether the import is from the package java.lang.
5. Get the name of the package where the class is located.
6. Check whether the imported member is from the same package as the class.
7. Check for any duplicate imports.

If an import statement imports a member that is not used within the file, or the import is from the package java.lang, or the imported member is from the same package as the class, or there are duplicate imports, then this test case violates the rule. The given test case has one unused static import, which violates the rule.
*Get all import statements from the file.* 匹配到的元操作或API：
query: Get all import statements from the file.
most similar API: get text of import
cosine Similarity: 0.8162394762039185
*For each import statement, get the type of import (static or regular).* 匹配到的元操作或API：
query: For each import statement, get the type of import (static or regular).
most similar API: get type system of import
cosine Similarity: 0.8484052419662476
*Check whether the imported member (class, method, or field) is used within the file.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the import is from the package java.lang.* 匹配到的元操作或API：
query: Check whether the import is from the package java.lang.
most similar API: Check whether the import equals
cosine Similarity: 0.835130512714386
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the imported member is from the same package as the class.* 匹配到的元操作或API：
query: Check whether the imported member is from the same package as the class.
most similar API: Check whether the import equals
cosine Similarity: 0.8227953910827637
*Check for any duplicate imports.* 匹配到的元操作或API：
query: Check for any duplicate imports.
most similar API: Check whether the import equals
cosine Similarity: 0.8767476677894592
=========================logics=========================
1. Get all import statements in the code.
2. Check whether the import statement is importing a package with wildcard (*).
3. Get all types used in the class.
4. Check whether the types used in the class are from the java.lang package or the same package as the class.
5. Check if any type used is directly from the imported package.
6. Check for duplicated import statements.

Since the import statement uses a wildcard to import from java.util, and the classes List and ArrayList are used in the code and belong to java.util, this import statement is necessary. Thus, there are no violations of the rule in this test case.
*Get all import statements in the code.* 匹配到的元操作或API：
query: Get all import statements in the code.
most similar API: get text of import
cosine Similarity: 0.8101215362548828
*Check whether the import statement is importing a package with wildcard (*).* 匹配到的元操作或API：
query: Check whether the import statement is importing a package with wildcard (*).
most similar API: Check whether the import equals
cosine Similarity: 0.8274582028388977
*Get all types used in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the types used in the class are from the java.lang package or the same package as the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check if any type used is directly from the imported package.* 匹配到的元操作或API：
query: Check if any type used is directly from the imported package.
most similar API: Check whether the import has descendant of type
cosine Similarity: 0.8307108879089355
*Check for duplicated import statements.* 匹配到的元操作或API：
query: Check for duplicated import statements.
most similar API: Check whether the import equals
cosine Similarity: 0.8610569834709167
=========================logics=========================
To check whether the import statements in the provided test case can be removed based on the given rule, the following steps must be performed:

1. Get all import statements from the class.
2. For each import statement, perform the following checks:
    1. Check whether the imported class is used in any javadoc comment in the class.
    2. Check whether the imported class is used in the class body (outside of javadoc comments).
    3. Check whether the imported class is from the `java.lang` package or the current package of the class (which would make the import implicit and unnecessary).
    4. Check for duplicate import statements.

Based on the rule, if an import statement is unused, duplicated, or imports members that are implicitly in scope, it should be reported. However, the provided test case indicates that all the import statements are used in javadoc comments, and there are no duplicates or imports from `java.lang` or the current package which would be implicitly in scope. Thus, according to the rule and the test case description, there are no violations, and the number of imports that violate the rule is 0.
*Get all import statements from the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each import statement, perform the following checks:* 匹配到的元操作或API：
query: For each import statement, perform the following checks:
most similar API: Check whether the import equals
cosine Similarity: 0.8578749299049377
*Check whether the imported class is used in any javadoc comment in the class.* 匹配到的元操作或API：
query: Check whether the imported class is used in any javadoc comment in the class.
most similar API: get javadoc comment of class or interface
cosine Similarity: 0.824364960193634
*Check whether the imported class is used in the class body (outside of javadoc comments).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the imported class is from the `java.lang` package or the current package of the class (which would make the import implicit and unnecessary).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check for duplicate import statements.* 匹配到的元操作或API：
query: Check for duplicate import statements.
most similar API: Check whether the import equals
cosine Similarity: 0.86394864320755
=========================logics=========================
1. Get all import statements in the file.
2. Check each import statement whether it is used in the code or javadoc comments.
3. Check whether the imported class or member is in the current package.
4. Check whether the imported class or member is in java.lang package.
5. Check for duplicate import statements.

In this test case, since the import is explicitly used in javadoc comments, it does not violate the rule regarding unnecessary imports.
*Get all import statements in the file.* 匹配到的元操作或API：
query: Get all import statements in the file.
most similar API: get text of import
cosine Similarity: 0.8178805708885193
*Check each import statement whether it is used in the code or javadoc comments.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the imported class or member is in the current package.* 匹配到的元操作或API：
query: Check whether the imported class or member is in the current package.
most similar API: Check whether the import equals
cosine Similarity: 0.8043054342269897
*Check whether the imported class or member is in java.lang package.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check for duplicate import statements.* 匹配到的元操作或API：
query: Check for duplicate import statements.
most similar API: Check whether the import equals
cosine Similarity: 0.86394864320755
=========================logics=========================
1. Get all import statements in the file.
2. For each import statement, check whether it is used in javadoc comments.
3. For each import statement, check whether it is used in the class body.
4. Check whether the imported class or member is from the package `java.lang`.
5. Get the name of the package where the class is located.
6. Check whether the imported class or member is from the current package.
7. Check for duplicated import statements.
If an import statement is not used in javadoc comments, not used in the class body, is from `java.lang`, from the current package, or is duplicated, then it violates the rule. However, this test case does not violate the rule as the import statement is used in a Javadoc comment, indicating a valid use case.
*Get all import statements in the file.* 匹配到的元操作或API：
query: Get all import statements in the file.
most similar API: get text of import
cosine Similarity: 0.8178805708885193
*For each import statement, check whether it is used in javadoc comments.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each import statement, check whether it is used in the class body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the imported class or member is from the package `java.lang`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the imported class or member is from the current package.* 匹配到的元操作或API：
query: Check whether the imported class or member is from the current package.
most similar API: Check whether the import equals
cosine Similarity: 0.8108734488487244
*Check for duplicated import statements.* 匹配到的元操作或API：
query: Check for duplicated import statements.
most similar API: Check whether the import equals
cosine Similarity: 0.8610569834709167
90
75
=========================logics=========================
To analyze this test case according to the provided rule description, we need to perform several checks to identify if any import statements violate the specified conditions. The rule states that import statements to be reported as unnecessary are those that are unused, duplicated, or the members they import are implicitly in scope due to being in `java.lang` or the current package.

Given the test case:

```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```

The checks to be performed are as follows:

1. Check whether the imported classes (`DefaultAnnotation`, `NonNull`) are used in the file. 
    - Both the `DefaultAnnotation` and `NonNull` annotations are used, so they are not unused imports.

2. Check whether there are any duplicated import statements.
    - There are no duplicated import statements in this test case.

3. Check whether the imported members are from `java.lang` or the same package as the current file.
    - The imported classes are from `edu.umd.cs.findbugs.annotations`, not from `java.lang` or `net.sourceforge.pmd.test` (the current package), so they are not implicitly in scope.

Based on these checks:

- The `DefaultAnnotation` import is used to specify the annotation at the package level, and `NonNull` is used within that annotation, making both imports necessary and correctly used.
- There are no violations of the described rule in this test case. The number of import statements that can be considered unnecessary according to the provided rule description is 0.
*Check whether the imported classes (`DefaultAnnotation`, `NonNull`) are used in the file.* 匹配到的元操作或API：
query: Check whether the imported classes (`DefaultAnnotation`, `NonNull`) are used in the file.
most similar API: Check whether the package is any annotation present
cosine Similarity: 0.8053629994392395
*Check whether there are any duplicated import statements.* 匹配到的元操作或API：
query: Check whether there are any duplicated import statements.
most similar API: Check whether the import equals
cosine Similarity: 0.8639262318611145
*Check whether the imported members are from `java.lang` or the same package as the current file.* 匹配到的元操作或API：
query: Check whether the imported members are from `java.lang` or the same package as the current file.
most similar API: Check whether the import equals
cosine Similarity: 0.8202395439147949
94
78
97
81
87
72
=========================logics=========================
1. Get all import statements in the source code.
2. Check each import statement whether it is used in the source code outside Javadoc comments.
3. Check each import statement whether it is used in Javadoc comments as {@link ...} or @see tags.
4. Check for duplicate import statements.
5. Check whether imported classes are from `java.lang` or the current package.
6. Check whether imported classes are implicitly in scope due to being in the same package or inherited classes/interfaces.

In the provided test case:
- The `java.util.ArrayList` import is used in a Javadoc link.
- The `java.util.Collections` import is referenced in a Javadoc @see tag.
- The `java.util.NoSuchElementException` import is used in a Javadoc @throws tag.

This fulfills the usage criteria in Javadoc, ensuring no rule violations for unused imports. Additionally, there are no duplicates, and the imports are necessary as they are not from `java.lang` or the same package. Thus, there are 0 violations in this test case for the rule described.
*Get all import statements in the source code.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check each import statement whether it is used in the source code outside Javadoc comments.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check each import statement whether it is used in Javadoc comments as {@link ...} or @see tags.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check for duplicate import statements.* 匹配到的元操作或API：
query: Check for duplicate import statements.
most similar API: Check whether the import equals
cosine Similarity: 0.86394864320755
*Check whether imported classes are from `java.lang` or the current package.* 匹配到的元操作或API：
query: Check whether imported classes are from `java.lang` or the current package.
most similar API: Check whether the import equals
cosine Similarity: 0.8032597303390503
*Check whether imported classes are implicitly in scope due to being in the same package or inherited classes/interfaces.* 匹配到的元操作或API：
未匹配成功元操作或API
=========================logics=========================
To analyze this test case according to the given rule, we need to perform checks to determine if any of the import statements are unnecessary. The rule specifies that imports can be removed if they are unused, duplicated, or import members that are already in scope implicitly.

1. Get all import statements.
2. For each import, check if it is duplicated within the list of imports.
3. For each import, check if it is implicitly in scope (i.e., a member of `java.lang` or the current package).
4. For each import, check if it is referenced in javadoc comments.
5. For each import, check if it is referenced in the body of the class `Foo`.

In this specific test case, the `Collections` class is referenced in the javadoc comments, and since javadoc usage is considered valid for the purpose of import statements, none of the imports related to it should be considered unused. Therefore, no imports in this test case violate the rule, which matches the provided description and number of violations.
*Get all import statements.* 匹配到的元操作或API：
query: Get all import statements.
most similar API: get text of import
cosine Similarity: 0.8120477199554443
*For each import, check if it is duplicated within the list of imports.* 匹配到的元操作或API：
query: For each import, check if it is duplicated within the list of imports.
most similar API: Check whether the import equals
cosine Similarity: 0.8469600677490234
*For each import, check if it is implicitly in scope (i.e., a member of `java.lang` or the current package).* 匹配到的元操作或API：
query: For each import, check if it is implicitly in scope (i.e., a member of `java.lang` or the current package).
most similar API: Check whether the import equals
cosine Similarity: 0.8072270154953003
*For each import, check if it is referenced in javadoc comments.* 匹配到的元操作或API：
query: For each import, check if it is referenced in javadoc comments.
most similar API: Check whether the import equals
cosine Similarity: 0.820410966873169
*For each import, check if it is referenced in the body of the class `Foo`.* 匹配到的元操作或API：
query: For each import, check if it is referenced in the body of the class `Foo`.
most similar API: Check whether the import equals
cosine Similarity: 0.8370789885520935
=========================logics=========================
1. Get the name of the imported class or package.
2. Check whether the imported class or package is used in the body of the code.
3. Get the javadoc comment of class.
4. Check whether the imported class or package is referenced in the javadoc comment.

If the imported class or package is neither used in the body of the code nor referenced in any javadoc comment, then it violates the rule. In this test case, the imported class is referenced in the javadoc comment, so it does not violate the rule.
*Get the name of the imported class or package.* 匹配到的元操作或API：
logic: Get the name of the imported class or package.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.8578386306762695
*Check whether the imported class or package is used in the body of the code.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Check whether the imported class or package is referenced in the javadoc comment.* 匹配到的元操作或API：
query: Check whether the imported class or package is referenced in the javadoc comment.
most similar API: get javadoc comment of class or interface
cosine Similarity: 0.8143489360809326
107
91
=========================logics=========================
1. Get the name of the package where the class is located.
2. Check whether the class has imports.
3. For each import, get the name of the imported class, method, or field.
4. Check whether each import is a wildcard import.
5. Check whether imported members are used within the class.
6. Check whether imported members are from `java.lang`.
7. Check whether imported members are from the current package.
8. Check for duplicate imports.
9. Check for static imports that are used in the class.

For the given test case, you should ensure that all static imports are actually used within the class and are not implicitly imported (e.g., from `java.lang` or the current package). If the static imports are necessary and there are no duplicates or unused imports, then there would be no violations of the rule. Based on the description and the number of violations (0), it's indicated that the test case does not violate the import statement rule.
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the class has imports.* 匹配到的元操作或API：
query: Check whether the class has imports.
most similar API: Check whether the import equals
cosine Similarity: 0.8711298108100891
*For each import, get the name of the imported class, method, or field.* 匹配到的元操作或API：
query: For each import, get the name of the imported class, method, or field.
most similar API: get imported name of import
cosine Similarity: 0.8708298802375793
*Check whether each import is a wildcard import.* 匹配到的元操作或API：
query: Check whether each import is a wildcard import.
most similar API: Check whether the import equals
cosine Similarity: 0.860833466053009
*Check whether imported members are used within the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether imported members are from `java.lang`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether imported members are from the current package.* 匹配到的元操作或API：
query: Check whether imported members are from the current package.
most similar API: Check whether the import equals
cosine Similarity: 0.8185208439826965
*Check for duplicate imports.* 匹配到的元操作或API：
query: Check for duplicate imports.
most similar API: Check whether the import equals
cosine Similarity: 0.873688817024231
*Check for static imports that are used in the class.* 匹配到的元操作或API：
query: Check for static imports that are used in the class.
most similar API: Check whether the import is static
cosine Similarity: 0.8801031112670898
=========================logics=========================
1. Get all import statements from the file.
2. For each import statement, check if any class, method, or field from that import is used in the code or javadoc comments.
3. Check if any import is duplicated.
4. Check if the imported class is from the `java.lang` package or the same package as the current class.
5. Check if the imported entities are referenced in javadoc comments through `@link` or `@see` tags.

For this test case:
- `AgentState` is referenced in a javadoc comment with `@link AgentState#TERMINATED`.
- `OtherState` is referenced in a javadoc comment with `@see OtherState#TERMINATED`.

Both imports are used and neither is from `java.lang` or the same package unnecessarily, nor are they duplicated. Therefore, there are no violations of the rule in this test case as it correctly uses the imports in the javadoc comments.
*Get all import statements from the file.* 匹配到的元操作或API：
query: Get all import statements from the file.
most similar API: get text of import
cosine Similarity: 0.8162394762039185
*For each import statement, check if any class, method, or field from that import is used in the code or javadoc comments.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check if any import is duplicated.* 匹配到的元操作或API：
query: Check if any import is duplicated.
most similar API: Check whether the import equals
cosine Similarity: 0.8786623477935791
*Check if the imported class is from the `java.lang` package or the same package as the current class.* 匹配到的元操作或API：
query: Check if the imported class is from the `java.lang` package or the same package as the current class.
most similar API: Check whether the import equals
cosine Similarity: 0.8026546239852905
*Check if the imported entities are referenced in javadoc comments through `@link` or `@see` tags.* 匹配到的元操作或API：
未匹配成功元操作或API
=========================logics=========================
1. Get the name of the package where the interface is located.
2. For each import statement:
    a. Get the class or member being imported.
    b. Check whether the imported class or member is used in the javadoc comments.
    c. Check whether the imported class or member is used in the interface declaration or method signatures.
    d. Check whether the imported class or member is from the same package as the interface.
    e. Check whether the imported class or member is from the java.lang package.
    f. Check for any duplicate import statements.
If none of the import statements are unused, duplicated, or the members they import are already implicitly in scope, then the test case does not violate the rule.
*Get the name of the package where the interface is located.* 匹配到的元操作或API：
logic: Get the name of the package where the interface is located.
most similar meta operation: Get the name of the package where the interface is located
cosine Similarity: 0.9859917163848877
*For each import statement:* 匹配到的元操作或API：
query: For each import statement:
most similar API: to string of import
cosine Similarity: 0.8046340346336365
=========================logics=========================
1. Get all import statements in the file.
2. Check whether the imported class or member is used in the javadoc comments.
3. Check whether the imported class or member is used in the code outside of javadoc.
4. Check whether the imported class or member is in the `java.lang` package.
5. Get the name of the package where the current class is located.
6. Check whether the imported class or member is in the same package as the current class.
7. Check whether there are any duplicate imports.

In this test case, `javax.swing.GroupLayout` is used in the javadoc comments. Therefore, it is not an unused import. There are no indications of it being duplicated or being in `java.lang` or the same package as the current class. Hence, the number of violations for this rule in the test case is indeed 0.
*Get all import statements in the file.* 匹配到的元操作或API：
query: Get all import statements in the file.
most similar API: get text of import
cosine Similarity: 0.8178805708885193
*Check whether the imported class or member is used in the javadoc comments.* 匹配到的元操作或API：
query: Check whether the imported class or member is used in the javadoc comments.
most similar API: get javadoc comment of class or interface
cosine Similarity: 0.8145633935928345
*Check whether the imported class or member is used in the code outside of javadoc.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the imported class or member is in the `java.lang` package.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the package where the current class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the current class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9542690515518188
*Check whether the imported class or member is in the same package as the current class.* 匹配到的元操作或API：
query: Check whether the imported class or member is in the same package as the current class.
most similar API: Check whether the import equals
cosine Similarity: 0.8209801912307739
*Check whether there are any duplicate imports.* 匹配到的元操作或API：
query: Check whether there are any duplicate imports.
most similar API: Check whether the import equals
cosine Similarity: 0.8777129650115967
100
82
=========================logics=========================
1. Get the name of the package where the class is located.
2. Get all import statements from the class.
3. For each import statement:
   - Determine if it is a static import.
   - Extract the class part of the import and check if it matches the class being used in the current file.
   - Check usages of the imported members within the class.
4. Check if the imported class is from the java.lang package or the current package.
5. Check for duplicate import statements.

For this specific test case:
- The static import from `net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*` is used in the class since `LIST1` and `LIST2` are accessed.
- The import is not from `java.lang` or the same package as `ClassWithImport`.
- There are no duplicate imports in the provided code snippet.

Thus, there are no violations of the rule in this test case as the static imports are used effectively within the class.
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Get all import statements from the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each import statement:* 匹配到的元操作或API：
query: For each import statement:
most similar API: to string of import
cosine Similarity: 0.8046340346336365
*Check if the imported class is from the java.lang package or the current package.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check for duplicate import statements.* 匹配到的元操作或API：
query: Check for duplicate import statements.
most similar API: Check whether the import equals
cosine Similarity: 0.86394864320755
84
69
109
93
=========================logics=========================
1. Get the name of the package where the class is located.
2. Get all import statements from the file.
3. Check whether imported class or member is used within the file.
4. Check whether the import is a static import.
5. Check whether the imported static members are used within the class.
6. Check for the presence of any duplicate import statements.
7. Check whether imported members are from the package `java.lang`.
8. Check whether imported members are from the same package as the class.

If none of the imports are unused, duplicated, implicitly in scope from `java.lang`, or the current package, and if static imports are properly used, then this test case does not violate the rule.
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Get all import statements from the file.* 匹配到的元操作或API：
query: Get all import statements from the file.
most similar API: get text of import
cosine Similarity: 0.8162394762039185
*Check whether imported class or member is used within the file.* 匹配到的元操作或API：
query: Check whether imported class or member is used within the file.
most similar API: Check whether is declared in class
cosine Similarity: 0.8084834814071655
*Check whether the import is a static import.* 匹配到的元操作或API：
query: Check whether the import is a static import.
most similar API: Check whether the import is static
cosine Similarity: 0.9727514386177063
*Check whether the imported static members are used within the class.* 匹配到的元操作或API：
query: Check whether the imported static members are used within the class.
most similar API: Check whether the import is static
cosine Similarity: 0.8337089419364929
*Check for the presence of any duplicate import statements.* 匹配到的元操作或API：
query: Check for the presence of any duplicate import statements.
most similar API: Check whether the import equals
cosine Similarity: 0.846528172492981
*Check whether imported members are from the package `java.lang`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether imported members are from the same package as the class.* 匹配到的元操作或API：
query: Check whether imported members are from the same package as the class.
most similar API: Check whether the import equals
cosine Similarity: 0.8230189681053162
==========================第1轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody

2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'file')

3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody

4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'doPrivileged')
            ――ASTTypeExpression
              ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArgumentList (size = 1)
              ――ASTNullLiteral

5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTThrowsList
        ――ASTClassOrInterfaceType (this is a class type)
      ――ASTBlock

6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'list')
      ――ASTBlock
        ――ASTForeachStatement
          ――ASTLocalVariableDeclaration
            ――ASTModifierList
            ――ASTClassOrInterfaceType (this is a class type)
            ――ASTVariableDeclarator
              ――ASTVariableDeclaratorId (declared variable name = 's')
          ――ASTVariableAccess (referenced variable name = 'list')
          ――ASTBlock

7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
        ――ASTTypeArguments
          ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'x')
        ――ASTConstructorCall
          ――ASTClassOrInterfaceType (this is a class type)
            ――ASTTypeArguments
              ――ASTClassOrInterfaceType (this is a class type)
          ――ASTArgumentList (size = 0)

8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
        ――ASTTypeArguments
          ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'x')
        ――ASTConstructorCall
          ――ASTClassOrInterfaceType (this is a class type)
            ――ASTTypeArguments
              ――ASTClassOrInterfaceType (this is a class type)
          ――ASTArgumentList (size = 0)

9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTAnnotationTypeDeclaration
  ――ASTModifierList
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTFieldAccess
            ――ASTTypeExpression
              ――ASTClassOrInterfaceType (this is a class type)
  ――ASTAnnotationTypeBody

10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
  ――ASTClassOrInterfaceBody

11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'Bar')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTPackageDeclaration
  ――ASTModifierList
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'Bar')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTPackageDeclaration
  ――ASTModifierList
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTConstructorDeclaration
      ――ASTModifierList
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'staticMethod')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTConstructorDeclaration
      ――ASTModifierList
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'list')
        ――ASTConstructorCall
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTArgumentList (size = 0)

17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'test')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'someMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'someMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTPackageDeclaration
  ――ASTModifierList
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTClassLiteral
            ――ASTClassOrInterfaceType (this is a class type)
――ASTImportDeclaration
――ASTImportDeclaration

21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Test')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'getList')
      ――ASTModifierList
      ――ASTArrayType (method return type = 'String[]')
        ――ASTClassOrInterfaceType (this is a class type)
        ――ASTArrayDimensions
          ――ASTArrayTypeDim
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'Object')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'someMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'FooTest')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'testStuff')
      ――ASTModifierList
        ――ASTAnnotation
          ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'assertEquals')
            ――ASTArgumentList (size = 2)
              ――ASTStringLiteral
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'assertFalse')
            ――ASTArgumentList (size = 1)
              ――ASTBooleanLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'assertTrue')
            ――ASTArgumentList (size = 1)
              ――ASTBooleanLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'assertNull')
            ――ASTArgumentList (size = 1)
              ――ASTNullLiteral
    ――ASTMethodDeclaration (method name = 'main')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTArrayType (this is a primitive type)
            ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArrayDimensions
              ――ASTArrayTypeDim
          ――ASTVariableDeclaratorId (declared variable name = 'args')
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'println')
            ――ASTFieldAccess
              ――ASTTypeExpression
                ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArgumentList (size = 1)
              ――ASTVariableAccess (referenced variable name = 'PI')

25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (interface name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'getAgentHandles')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'Iterable<AgentHandle>')
        ――ASTTypeArguments
          ――ASTClassOrInterfaceType (this is a class type)
      ――ASTFormalParameters (size = 0)

26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (interface name = 'Interface')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'doSomething')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)

27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'doSomething')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)

28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTPackageDeclaration
  ――ASTModifierList
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'ClassWithImport')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'main')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTArrayType (this is a primitive type)
            ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArrayDimensions
              ――ASTArrayTypeDim
          ――ASTVariableDeclaratorId (declared variable name = 'args')
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'println')
            ――ASTFieldAccess
              ――ASTTypeExpression
                ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArgumentList (size = 1)
              ――ASTInfixExpression
                ――ASTStringLiteral
                ――ASTVariableAccess (referenced variable name = 'LIST1')
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'println')
            ――ASTFieldAccess
              ――ASTTypeExpression
                ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArgumentList (size = 1)
              ――ASTInfixExpression
                ――ASTStringLiteral
                ――ASTVariableAccess (referenced variable name = 'LIST2')



The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:
1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
2. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public net.sourceforge.pmd.lang.document.Chars getText()
4. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public java.lang.Class<Class<?> getClass()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection), //Checks whether any annotation is present on this node. @param binaryNames            Collection that contains binary names of annotations.            Note: for now, canonical names are tolerated, this may be changed in PMD 7. @return <code>true</code> if any annotation is present on this node, else <code>false</code>
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTThrowsList getThrowsList()
8. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isJustRethrowException(net.sourceforge.pmd.lang.java.ast.ASTCatchClause), //Return true if the catch clause just rethrows the caught exception immediately.
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNative()
11. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean equals(java.lang.Object)
12. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
13. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isLocal(), //Returns true if the class is declared inside a block other than the body of another class, or the top level. Anonymous classes are not considered local. Only class declarations can be local. Local classes cannot be static.
14. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isClassOrInterfaceType()
15. net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration: public java.lang.String getPackageName()
16. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
17. net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration: public java.lang.String getSimpleName()
18. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
19. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getResultTypeNode()
20. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
21. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
22. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public boolean isStatic(), //Returns true if this is a static import. If this import is not on-demand, {@link #getImportedSimpleName()} returns the name of the imported member.
23. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public net.sourceforge.pmd.lang.java.types.TypeSystem getTypeSystem()
24. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public boolean hasDescendantOfType(java.lang.Class)
25. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment(), //Returns the javadoc comment that applies to this declaration. If there is none, returns null.
26. net.sourceforge.pmd.lang.java.ast.ASTPackageDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection), //Checks whether any annotation is present on this node. @param binaryNames            Collection that contains binary names of annotations.            Note: for now, canonical names are tolerated, this may be changed in PMD 7. @return <code>true</code> if any annotation is present on this node, else <code>false</code>
27. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
28. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public java.lang.String getImportedName(), //Returns the full name of the import. For on-demand imports, this is the name without the final dot and asterisk.
29. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public java.lang.String toString()

1.  //Get the type of exception thrown in throw statement
```java
import net.sourceforge.pmd.lang.java.ast.ASTThrowStatement;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getThrownExceptionType(ASTThrowStatement node) {
    JTypeMirror thrownType = node.getExpr().getTypeMirror();
    return thrownType;
}
```
2.  //Check whether interface has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
3.  //Check whether the return type of method is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnValueClassType(ASTMethodDeclaration method) {
    return TypeTestUtil.isA(x.class, method.getResultTypeNode());
}
```
4.  //Get the number of formal parameters of method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTMethodDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```
5.  //Check whether the formal parameter is a x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFormalParameterClassType(ASTFormalParameter node) {
    return TypeTestUtil.isA(x.class, node.getTypeNode());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:
1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


出现语法错误，这一轮舍弃，直接重新生成
==========================第2轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody

2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'file')

3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody

4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'doPrivileged')
            ――ASTTypeExpression
              ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArgumentList (size = 1)
              ――ASTNullLiteral

5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTThrowsList
        ――ASTClassOrInterfaceType (this is a class type)
      ――ASTBlock

6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'list')
      ――ASTBlock
        ――ASTForeachStatement
          ――ASTLocalVariableDeclaration
            ――ASTModifierList
            ――ASTClassOrInterfaceType (this is a class type)
            ――ASTVariableDeclarator
              ――ASTVariableDeclaratorId (declared variable name = 's')
          ――ASTVariableAccess (referenced variable name = 'list')
          ――ASTBlock

7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
        ――ASTTypeArguments
          ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'x')
        ――ASTConstructorCall
          ――ASTClassOrInterfaceType (this is a class type)
            ――ASTTypeArguments
              ――ASTClassOrInterfaceType (this is a class type)
          ――ASTArgumentList (size = 0)

8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
        ――ASTTypeArguments
          ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'x')
        ――ASTConstructorCall
          ――ASTClassOrInterfaceType (this is a class type)
            ――ASTTypeArguments
              ――ASTClassOrInterfaceType (this is a class type)
          ――ASTArgumentList (size = 0)

9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTAnnotationTypeDeclaration
  ――ASTModifierList
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTFieldAccess
            ――ASTTypeExpression
              ――ASTClassOrInterfaceType (this is a class type)
  ――ASTAnnotationTypeBody

10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
  ――ASTClassOrInterfaceBody

11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'Bar')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTPackageDeclaration
  ――ASTModifierList
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'Bar')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTPackageDeclaration
  ――ASTModifierList
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTConstructorDeclaration
      ――ASTModifierList
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'staticMethod')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTConstructorDeclaration
      ――ASTModifierList
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'list')
        ――ASTConstructorCall
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTArgumentList (size = 0)

17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'test')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'someMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'someMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTPackageDeclaration
  ――ASTModifierList
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTClassLiteral
            ――ASTClassOrInterfaceType (this is a class type)
――ASTImportDeclaration
――ASTImportDeclaration

21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Test')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'getList')
      ――ASTModifierList
      ――ASTArrayType (method return type = 'String[]')
        ――ASTClassOrInterfaceType (this is a class type)
        ――ASTArrayDimensions
          ――ASTArrayTypeDim
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'Object')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'someMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'FooTest')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'testStuff')
      ――ASTModifierList
        ――ASTAnnotation
          ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'assertEquals')
            ――ASTArgumentList (size = 2)
              ――ASTStringLiteral
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'assertFalse')
            ――ASTArgumentList (size = 1)
              ――ASTBooleanLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'assertTrue')
            ――ASTArgumentList (size = 1)
              ――ASTBooleanLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'assertNull')
            ――ASTArgumentList (size = 1)
              ――ASTNullLiteral
    ――ASTMethodDeclaration (method name = 'main')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTArrayType (this is a primitive type)
            ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArrayDimensions
              ――ASTArrayTypeDim
          ――ASTVariableDeclaratorId (declared variable name = 'args')
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'println')
            ――ASTFieldAccess
              ――ASTTypeExpression
                ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArgumentList (size = 1)
              ――ASTVariableAccess (referenced variable name = 'PI')

25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (interface name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'getAgentHandles')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'Iterable<AgentHandle>')
        ――ASTTypeArguments
          ――ASTClassOrInterfaceType (this is a class type)
      ――ASTFormalParameters (size = 0)

26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (interface name = 'Interface')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'doSomething')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)

27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'doSomething')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)

28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTPackageDeclaration
  ――ASTModifierList
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'ClassWithImport')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'main')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTArrayType (this is a primitive type)
            ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArrayDimensions
              ――ASTArrayTypeDim
          ――ASTVariableDeclaratorId (declared variable name = 'args')
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'println')
            ――ASTFieldAccess
              ――ASTTypeExpression
                ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArgumentList (size = 1)
              ――ASTInfixExpression
                ――ASTStringLiteral
                ――ASTVariableAccess (referenced variable name = 'LIST1')
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'println')
            ――ASTFieldAccess
              ――ASTTypeExpression
                ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArgumentList (size = 1)
              ――ASTInfixExpression
                ――ASTStringLiteral
                ――ASTVariableAccess (referenced variable name = 'LIST2')



The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:
1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
2. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public net.sourceforge.pmd.lang.document.Chars getText()
4. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public java.lang.Class<Class<?> getClass()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection), //Checks whether any annotation is present on this node. @param binaryNames            Collection that contains binary names of annotations.            Note: for now, canonical names are tolerated, this may be changed in PMD 7. @return <code>true</code> if any annotation is present on this node, else <code>false</code>
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTThrowsList getThrowsList()
8. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isJustRethrowException(net.sourceforge.pmd.lang.java.ast.ASTCatchClause), //Return true if the catch clause just rethrows the caught exception immediately.
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNative()
11. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean equals(java.lang.Object)
12. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
13. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isLocal(), //Returns true if the class is declared inside a block other than the body of another class, or the top level. Anonymous classes are not considered local. Only class declarations can be local. Local classes cannot be static.
14. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isClassOrInterfaceType()
15. net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration: public java.lang.String getPackageName()
16. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
17. net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration: public java.lang.String getSimpleName()
18. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
19. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getResultTypeNode()
20. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
21. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
22. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public boolean isStatic(), //Returns true if this is a static import. If this import is not on-demand, {@link #getImportedSimpleName()} returns the name of the imported member.
23. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public net.sourceforge.pmd.lang.java.types.TypeSystem getTypeSystem()
24. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public boolean hasDescendantOfType(java.lang.Class)
25. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment(), //Returns the javadoc comment that applies to this declaration. If there is none, returns null.
26. net.sourceforge.pmd.lang.java.ast.ASTPackageDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection), //Checks whether any annotation is present on this node. @param binaryNames            Collection that contains binary names of annotations.            Note: for now, canonical names are tolerated, this may be changed in PMD 7. @return <code>true</code> if any annotation is present on this node, else <code>false</code>
27. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
28. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public java.lang.String getImportedName(), //Returns the full name of the import. For on-demand imports, this is the name without the final dot and asterisk.
29. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public java.lang.String toString()

1.  //Get the type of exception thrown in throw statement
```java
import net.sourceforge.pmd.lang.java.ast.ASTThrowStatement;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getThrownExceptionType(ASTThrowStatement node) {
    JTypeMirror thrownType = node.getExpr().getTypeMirror();
    return thrownType;
}
```
2.  //Check whether interface has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
3.  //Check whether the return type of method is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnValueClassType(ASTMethodDeclaration method) {
    return TypeTestUtil.isA(x.class, method.getResultTypeNode());
}
```
4.  //Get the number of formal parameters of method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTMethodDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```
5.  //Check whether the formal parameter is a x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFormalParameterClassType(ASTFormalParameter node) {
    return TypeTestUtil.isA(x.class, node.getTypeNode());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:
1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


出现语法错误，这一轮舍弃，直接重新生成
==========================第3轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody

2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'file')

3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody

4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'doPrivileged')
            ――ASTTypeExpression
              ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArgumentList (size = 1)
              ――ASTNullLiteral

5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTThrowsList
        ――ASTClassOrInterfaceType (this is a class type)
      ――ASTBlock

6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'list')
      ――ASTBlock
        ――ASTForeachStatement
          ――ASTLocalVariableDeclaration
            ――ASTModifierList
            ――ASTClassOrInterfaceType (this is a class type)
            ――ASTVariableDeclarator
              ――ASTVariableDeclaratorId (declared variable name = 's')
          ――ASTVariableAccess (referenced variable name = 'list')
          ――ASTBlock

7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
        ――ASTTypeArguments
          ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'x')
        ――ASTConstructorCall
          ――ASTClassOrInterfaceType (this is a class type)
            ――ASTTypeArguments
              ――ASTClassOrInterfaceType (this is a class type)
          ――ASTArgumentList (size = 0)

8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
        ――ASTTypeArguments
          ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'x')
        ――ASTConstructorCall
          ――ASTClassOrInterfaceType (this is a class type)
            ――ASTTypeArguments
              ――ASTClassOrInterfaceType (this is a class type)
          ――ASTArgumentList (size = 0)

9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTAnnotationTypeDeclaration
  ――ASTModifierList
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTFieldAccess
            ――ASTTypeExpression
              ――ASTClassOrInterfaceType (this is a class type)
  ――ASTAnnotationTypeBody

10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
  ――ASTClassOrInterfaceBody

11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'Bar')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTPackageDeclaration
  ――ASTModifierList
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'Bar')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTPackageDeclaration
  ――ASTModifierList
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTConstructorDeclaration
      ――ASTModifierList
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'staticMethod')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTConstructorDeclaration
      ――ASTModifierList
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'list')
        ――ASTConstructorCall
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTArgumentList (size = 0)

17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'test')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'someMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'someMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTPackageDeclaration
  ――ASTModifierList
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTClassLiteral
            ――ASTClassOrInterfaceType (this is a class type)
――ASTImportDeclaration
――ASTImportDeclaration

21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Test')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'getList')
      ――ASTModifierList
      ――ASTArrayType (method return type = 'String[]')
        ――ASTClassOrInterfaceType (this is a class type)
        ――ASTArrayDimensions
          ――ASTArrayTypeDim
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'Object')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'someMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'FooTest')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'testStuff')
      ――ASTModifierList
        ――ASTAnnotation
          ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'assertEquals')
            ――ASTArgumentList (size = 2)
              ――ASTStringLiteral
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'assertFalse')
            ――ASTArgumentList (size = 1)
              ――ASTBooleanLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'assertTrue')
            ――ASTArgumentList (size = 1)
              ――ASTBooleanLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'assertNull')
            ――ASTArgumentList (size = 1)
              ――ASTNullLiteral
    ――ASTMethodDeclaration (method name = 'main')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTArrayType (this is a primitive type)
            ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArrayDimensions
              ――ASTArrayTypeDim
          ――ASTVariableDeclaratorId (declared variable name = 'args')
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'println')
            ――ASTFieldAccess
              ――ASTTypeExpression
                ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArgumentList (size = 1)
              ――ASTVariableAccess (referenced variable name = 'PI')

25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (interface name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'getAgentHandles')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'Iterable<AgentHandle>')
        ――ASTTypeArguments
          ――ASTClassOrInterfaceType (this is a class type)
      ――ASTFormalParameters (size = 0)

26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (interface name = 'Interface')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'doSomething')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)

27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'doSomething')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)

28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTPackageDeclaration
  ――ASTModifierList
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'ClassWithImport')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'main')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTArrayType (this is a primitive type)
            ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArrayDimensions
              ――ASTArrayTypeDim
          ――ASTVariableDeclaratorId (declared variable name = 'args')
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'println')
            ――ASTFieldAccess
              ――ASTTypeExpression
                ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArgumentList (size = 1)
              ――ASTInfixExpression
                ――ASTStringLiteral
                ――ASTVariableAccess (referenced variable name = 'LIST1')
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'println')
            ――ASTFieldAccess
              ――ASTTypeExpression
                ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArgumentList (size = 1)
              ――ASTInfixExpression
                ――ASTStringLiteral
                ――ASTVariableAccess (referenced variable name = 'LIST2')



The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:
1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
2. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public net.sourceforge.pmd.lang.document.Chars getText()
4. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public java.lang.Class<Class<?> getClass()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection), //Checks whether any annotation is present on this node. @param binaryNames            Collection that contains binary names of annotations.            Note: for now, canonical names are tolerated, this may be changed in PMD 7. @return <code>true</code> if any annotation is present on this node, else <code>false</code>
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTThrowsList getThrowsList()
8. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isJustRethrowException(net.sourceforge.pmd.lang.java.ast.ASTCatchClause), //Return true if the catch clause just rethrows the caught exception immediately.
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNative()
11. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean equals(java.lang.Object)
12. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
13. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isLocal(), //Returns true if the class is declared inside a block other than the body of another class, or the top level. Anonymous classes are not considered local. Only class declarations can be local. Local classes cannot be static.
14. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isClassOrInterfaceType()
15. net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration: public java.lang.String getPackageName()
16. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
17. net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration: public java.lang.String getSimpleName()
18. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
19. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getResultTypeNode()
20. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
21. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
22. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public boolean isStatic(), //Returns true if this is a static import. If this import is not on-demand, {@link #getImportedSimpleName()} returns the name of the imported member.
23. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public net.sourceforge.pmd.lang.java.types.TypeSystem getTypeSystem()
24. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public boolean hasDescendantOfType(java.lang.Class)
25. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment(), //Returns the javadoc comment that applies to this declaration. If there is none, returns null.
26. net.sourceforge.pmd.lang.java.ast.ASTPackageDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection), //Checks whether any annotation is present on this node. @param binaryNames            Collection that contains binary names of annotations.            Note: for now, canonical names are tolerated, this may be changed in PMD 7. @return <code>true</code> if any annotation is present on this node, else <code>false</code>
27. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
28. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public java.lang.String getImportedName(), //Returns the full name of the import. For on-demand imports, this is the name without the final dot and asterisk.
29. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public java.lang.String toString()

1.  //Get the type of exception thrown in throw statement
```java
import net.sourceforge.pmd.lang.java.ast.ASTThrowStatement;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getThrownExceptionType(ASTThrowStatement node) {
    JTypeMirror thrownType = node.getExpr().getTypeMirror();
    return thrownType;
}
```
2.  //Check whether interface has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
3.  //Check whether the return type of method is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnValueClassType(ASTMethodDeclaration method) {
    return TypeTestUtil.isA(x.class, method.getResultTypeNode());
}
```
4.  //Get the number of formal parameters of method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTMethodDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```
5.  //Check whether the formal parameter is a x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFormalParameterClassType(ASTFormalParameter node) {
    return TypeTestUtil.isA(x.class, node.getTypeNode());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:
1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


出现语法错误，这一轮舍弃，直接重新生成
==========================第4轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody

2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'file')

3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody

4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'doPrivileged')
            ――ASTTypeExpression
              ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArgumentList (size = 1)
              ――ASTNullLiteral

5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTThrowsList
        ――ASTClassOrInterfaceType (this is a class type)
      ――ASTBlock

6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'list')
      ――ASTBlock
        ――ASTForeachStatement
          ――ASTLocalVariableDeclaration
            ――ASTModifierList
            ――ASTClassOrInterfaceType (this is a class type)
            ――ASTVariableDeclarator
              ――ASTVariableDeclaratorId (declared variable name = 's')
          ――ASTVariableAccess (referenced variable name = 'list')
          ――ASTBlock

7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
        ――ASTTypeArguments
          ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'x')
        ――ASTConstructorCall
          ――ASTClassOrInterfaceType (this is a class type)
            ――ASTTypeArguments
              ――ASTClassOrInterfaceType (this is a class type)
          ――ASTArgumentList (size = 0)

8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
        ――ASTTypeArguments
          ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'x')
        ――ASTConstructorCall
          ――ASTClassOrInterfaceType (this is a class type)
            ――ASTTypeArguments
              ――ASTClassOrInterfaceType (this is a class type)
          ――ASTArgumentList (size = 0)

9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTAnnotationTypeDeclaration
  ――ASTModifierList
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTFieldAccess
            ――ASTTypeExpression
              ――ASTClassOrInterfaceType (this is a class type)
  ――ASTAnnotationTypeBody

10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
  ――ASTClassOrInterfaceBody

11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'Bar')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTPackageDeclaration
  ――ASTModifierList
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'Bar')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTPackageDeclaration
  ――ASTModifierList
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTConstructorDeclaration
      ――ASTModifierList
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'staticMethod')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTConstructorDeclaration
      ――ASTModifierList
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'list')
        ――ASTConstructorCall
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTArgumentList (size = 0)

17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'test')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'someMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'someMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTPackageDeclaration
  ――ASTModifierList
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTClassLiteral
            ――ASTClassOrInterfaceType (this is a class type)
――ASTImportDeclaration
――ASTImportDeclaration

21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Test')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'getList')
      ――ASTModifierList
      ――ASTArrayType (method return type = 'String[]')
        ――ASTClassOrInterfaceType (this is a class type)
        ――ASTArrayDimensions
          ――ASTArrayTypeDim
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'Object')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'someMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'FooTest')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'testStuff')
      ――ASTModifierList
        ――ASTAnnotation
          ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'assertEquals')
            ――ASTArgumentList (size = 2)
              ――ASTStringLiteral
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'assertFalse')
            ――ASTArgumentList (size = 1)
              ――ASTBooleanLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'assertTrue')
            ――ASTArgumentList (size = 1)
              ――ASTBooleanLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'assertNull')
            ――ASTArgumentList (size = 1)
              ――ASTNullLiteral
    ――ASTMethodDeclaration (method name = 'main')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTArrayType (this is a primitive type)
            ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArrayDimensions
              ――ASTArrayTypeDim
          ――ASTVariableDeclaratorId (declared variable name = 'args')
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'println')
            ――ASTFieldAccess
              ――ASTTypeExpression
                ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArgumentList (size = 1)
              ――ASTVariableAccess (referenced variable name = 'PI')

25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (interface name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'getAgentHandles')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'Iterable<AgentHandle>')
        ――ASTTypeArguments
          ――ASTClassOrInterfaceType (this is a class type)
      ――ASTFormalParameters (size = 0)

26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (interface name = 'Interface')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'doSomething')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)

27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'doSomething')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)

28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTPackageDeclaration
  ――ASTModifierList
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'ClassWithImport')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'main')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTArrayType (this is a primitive type)
            ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArrayDimensions
              ――ASTArrayTypeDim
          ――ASTVariableDeclaratorId (declared variable name = 'args')
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'println')
            ――ASTFieldAccess
              ――ASTTypeExpression
                ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArgumentList (size = 1)
              ――ASTInfixExpression
                ――ASTStringLiteral
                ――ASTVariableAccess (referenced variable name = 'LIST1')
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'println')
            ――ASTFieldAccess
              ――ASTTypeExpression
                ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArgumentList (size = 1)
              ――ASTInfixExpression
                ――ASTStringLiteral
                ――ASTVariableAccess (referenced variable name = 'LIST2')



The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:
1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
2. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public net.sourceforge.pmd.lang.document.Chars getText()
4. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public java.lang.Class<Class<?> getClass()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection), //Checks whether any annotation is present on this node. @param binaryNames            Collection that contains binary names of annotations.            Note: for now, canonical names are tolerated, this may be changed in PMD 7. @return <code>true</code> if any annotation is present on this node, else <code>false</code>
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTThrowsList getThrowsList()
8. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isJustRethrowException(net.sourceforge.pmd.lang.java.ast.ASTCatchClause), //Return true if the catch clause just rethrows the caught exception immediately.
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNative()
11. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean equals(java.lang.Object)
12. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
13. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isLocal(), //Returns true if the class is declared inside a block other than the body of another class, or the top level. Anonymous classes are not considered local. Only class declarations can be local. Local classes cannot be static.
14. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isClassOrInterfaceType()
15. net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration: public java.lang.String getPackageName()
16. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
17. net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration: public java.lang.String getSimpleName()
18. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
19. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getResultTypeNode()
20. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
21. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
22. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public boolean isStatic(), //Returns true if this is a static import. If this import is not on-demand, {@link #getImportedSimpleName()} returns the name of the imported member.
23. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public net.sourceforge.pmd.lang.java.types.TypeSystem getTypeSystem()
24. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public boolean hasDescendantOfType(java.lang.Class)
25. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment(), //Returns the javadoc comment that applies to this declaration. If there is none, returns null.
26. net.sourceforge.pmd.lang.java.ast.ASTPackageDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection), //Checks whether any annotation is present on this node. @param binaryNames            Collection that contains binary names of annotations.            Note: for now, canonical names are tolerated, this may be changed in PMD 7. @return <code>true</code> if any annotation is present on this node, else <code>false</code>
27. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
28. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public java.lang.String getImportedName(), //Returns the full name of the import. For on-demand imports, this is the name without the final dot and asterisk.
29. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public java.lang.String toString()

1.  //Get the type of exception thrown in throw statement
```java
import net.sourceforge.pmd.lang.java.ast.ASTThrowStatement;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getThrownExceptionType(ASTThrowStatement node) {
    JTypeMirror thrownType = node.getExpr().getTypeMirror();
    return thrownType;
}
```
2.  //Check whether interface has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
3.  //Check whether the return type of method is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnValueClassType(ASTMethodDeclaration method) {
    return TypeTestUtil.isA(x.class, method.getResultTypeNode());
}
```
4.  //Get the number of formal parameters of method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTMethodDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```
5.  //Check whether the formal parameter is a x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFormalParameterClassType(ASTFormalParameter node) {
    return TypeTestUtil.isA(x.class, node.getTypeNode());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:
1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


出现语法错误，这一轮舍弃，直接重新生成
==========================第5轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody

2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'file')

3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody

4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'doPrivileged')
            ――ASTTypeExpression
              ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArgumentList (size = 1)
              ――ASTNullLiteral

5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTThrowsList
        ――ASTClassOrInterfaceType (this is a class type)
      ――ASTBlock

6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'list')
      ――ASTBlock
        ――ASTForeachStatement
          ――ASTLocalVariableDeclaration
            ――ASTModifierList
            ――ASTClassOrInterfaceType (this is a class type)
            ――ASTVariableDeclarator
              ――ASTVariableDeclaratorId (declared variable name = 's')
          ――ASTVariableAccess (referenced variable name = 'list')
          ――ASTBlock

7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
        ――ASTTypeArguments
          ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'x')
        ――ASTConstructorCall
          ――ASTClassOrInterfaceType (this is a class type)
            ――ASTTypeArguments
              ――ASTClassOrInterfaceType (this is a class type)
          ――ASTArgumentList (size = 0)

8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
        ――ASTTypeArguments
          ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'x')
        ――ASTConstructorCall
          ――ASTClassOrInterfaceType (this is a class type)
            ――ASTTypeArguments
              ――ASTClassOrInterfaceType (this is a class type)
          ――ASTArgumentList (size = 0)

9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTAnnotationTypeDeclaration
  ――ASTModifierList
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTFieldAccess
            ――ASTTypeExpression
              ――ASTClassOrInterfaceType (this is a class type)
  ――ASTAnnotationTypeBody

10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
  ――ASTClassOrInterfaceBody

11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'Bar')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTPackageDeclaration
  ――ASTModifierList
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'Bar')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTPackageDeclaration
  ――ASTModifierList
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTConstructorDeclaration
      ――ASTModifierList
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'staticMethod')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTConstructorDeclaration
      ――ASTModifierList
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'list')
        ――ASTConstructorCall
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTArgumentList (size = 0)

17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'test')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'someMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'someMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTPackageDeclaration
  ――ASTModifierList
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTClassLiteral
            ――ASTClassOrInterfaceType (this is a class type)
――ASTImportDeclaration
――ASTImportDeclaration

21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Test')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'getList')
      ――ASTModifierList
      ――ASTArrayType (method return type = 'String[]')
        ――ASTClassOrInterfaceType (this is a class type)
        ――ASTArrayDimensions
          ――ASTArrayTypeDim
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'Object')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'someMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock

24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'FooTest')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'testStuff')
      ――ASTModifierList
        ――ASTAnnotation
          ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'assertEquals')
            ――ASTArgumentList (size = 2)
              ――ASTStringLiteral
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'assertFalse')
            ――ASTArgumentList (size = 1)
              ――ASTBooleanLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'assertTrue')
            ――ASTArgumentList (size = 1)
              ――ASTBooleanLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'assertNull')
            ――ASTArgumentList (size = 1)
              ――ASTNullLiteral
    ――ASTMethodDeclaration (method name = 'main')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTArrayType (this is a primitive type)
            ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArrayDimensions
              ――ASTArrayTypeDim
          ――ASTVariableDeclaratorId (declared variable name = 'args')
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'println')
            ――ASTFieldAccess
              ――ASTTypeExpression
                ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArgumentList (size = 1)
              ――ASTVariableAccess (referenced variable name = 'PI')

25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (interface name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'getAgentHandles')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'Iterable<AgentHandle>')
        ――ASTTypeArguments
          ――ASTClassOrInterfaceType (this is a class type)
      ――ASTFormalParameters (size = 0)

26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (interface name = 'Interface')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'doSomething')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)

27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'doSomething')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)

28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTPackageDeclaration
  ――ASTModifierList
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'ClassWithImport')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'main')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTArrayType (this is a primitive type)
            ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArrayDimensions
              ――ASTArrayTypeDim
          ――ASTVariableDeclaratorId (declared variable name = 'args')
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'println')
            ――ASTFieldAccess
              ――ASTTypeExpression
                ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArgumentList (size = 1)
              ――ASTInfixExpression
                ――ASTStringLiteral
                ――ASTVariableAccess (referenced variable name = 'LIST1')
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'println')
            ――ASTFieldAccess
              ――ASTTypeExpression
                ――ASTClassOrInterfaceType (this is a class type)
            ――ASTArgumentList (size = 1)
              ――ASTInfixExpression
                ――ASTStringLiteral
                ――ASTVariableAccess (referenced variable name = 'LIST2')



The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:
1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
2. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public net.sourceforge.pmd.lang.document.Chars getText()
4. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public java.lang.Class<Class<?> getClass()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection), //Checks whether any annotation is present on this node. @param binaryNames            Collection that contains binary names of annotations.            Note: for now, canonical names are tolerated, this may be changed in PMD 7. @return <code>true</code> if any annotation is present on this node, else <code>false</code>
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTThrowsList getThrowsList()
8. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isJustRethrowException(net.sourceforge.pmd.lang.java.ast.ASTCatchClause), //Return true if the catch clause just rethrows the caught exception immediately.
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNative()
11. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean equals(java.lang.Object)
12. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
13. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isLocal(), //Returns true if the class is declared inside a block other than the body of another class, or the top level. Anonymous classes are not considered local. Only class declarations can be local. Local classes cannot be static.
14. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isClassOrInterfaceType()
15. net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration: public java.lang.String getPackageName()
16. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
17. net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration: public java.lang.String getSimpleName()
18. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
19. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getResultTypeNode()
20. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
21. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
22. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public boolean isStatic(), //Returns true if this is a static import. If this import is not on-demand, {@link #getImportedSimpleName()} returns the name of the imported member.
23. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public net.sourceforge.pmd.lang.java.types.TypeSystem getTypeSystem()
24. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public boolean hasDescendantOfType(java.lang.Class)
25. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment(), //Returns the javadoc comment that applies to this declaration. If there is none, returns null.
26. net.sourceforge.pmd.lang.java.ast.ASTPackageDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection), //Checks whether any annotation is present on this node. @param binaryNames            Collection that contains binary names of annotations.            Note: for now, canonical names are tolerated, this may be changed in PMD 7. @return <code>true</code> if any annotation is present on this node, else <code>false</code>
27. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
28. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public java.lang.String getImportedName(), //Returns the full name of the import. For on-demand imports, this is the name without the final dot and asterisk.
29. net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration: public java.lang.String toString()

1.  //Get the type of exception thrown in throw statement
```java
import net.sourceforge.pmd.lang.java.ast.ASTThrowStatement;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getThrownExceptionType(ASTThrowStatement node) {
    JTypeMirror thrownType = node.getExpr().getTypeMirror();
    return thrownType;
}
```
2.  //Check whether interface has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
3.  //Check whether the return type of method is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnValueClassType(ASTMethodDeclaration method) {
    return TypeTestUtil.isA(x.class, method.getResultTypeNode());
}
```
4.  //Get the number of formal parameters of method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTMethodDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```
5.  //Check whether the formal parameter is a x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFormalParameterClassType(ASTFormalParameter node) {
    return TypeTestUtil.isA(x.class, node.getTypeNode());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:
1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


出现语法错误，这一轮舍弃，直接重新生成
5轮生成失败
结束

规则执行完毕，时间总花销： 1901.2246491909027 秒
