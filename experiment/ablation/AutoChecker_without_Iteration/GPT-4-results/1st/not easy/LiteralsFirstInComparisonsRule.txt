开始

========================================== Rule LiteralsFirstInComparisonsRule ===========================================
一共 33 个测试用例
正例 22 个
反例 11 个
94
78
144
127
12
9
157
137
23
19
77
63
114
98
107
91
10
8
38
34
40
37
11
9
15
13
11
8
85
71
96
81
99
82
19
14
149
133
97
91
12
10
9
7
93
78
12
10
92
78
9
7
85
71
96
79
27
17
12
10
119
103
30
28
90
76
=========================logics=========================
1. Get the name of called method.
2. Check whether the called method is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
3. Get the first argument of the called method.
4. Check whether the first argument is a string literal.
If the called method is one of the specified string comparison methods and the first argument is a string literal, then this test case adheres to the rule and does not violate it.
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376136779785
*Check whether the called method is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.* 匹配到的元操作或API：
query: Check whether the called method is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
most similar API: Check whether the method call equals
cosine Similarity: 0.8578868508338928
*Get the first argument of the called method.* 匹配到的元操作或API：
logic: Get the first argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9071929454803467
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803799152374268
=========================logics=========================
1. Get the name of called method.
2. Check whether the called method name is one of "equals", "equalsIgnoreCase", "compareTo", "compareToIgnoreCase", "contentEquals".
3. Get the arguments of the called method.
4. Check whether the first argument of the method is a literal.
5. Check whether the second argument of the method is a variable.

If the called method name is one of the specified string methods and the first argument is not a literal and the second argument is a variable, then this test case violates the rule.
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376136779785
*Check whether the called method name is one of "equals", "equalsIgnoreCase", "compareTo", "compareToIgnoreCase", "contentEquals".* 匹配到的元操作或API：
query: Check whether the called method name is one of "equals", "equalsIgnoreCase", "compareTo", "compareToIgnoreCase", "contentEquals".
most similar API: Check whether the method call equals
cosine Similarity: 0.8626678586006165
*Get the arguments of the called method.* 匹配到的元操作或API：
logic: Get the arguments of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9324952960014343
*Check whether the first argument of the method is a literal.* 匹配到的元操作或API：
query: Check whether the first argument of the method is a literal.
most similar API: Check whether the method is syntactically abstract
cosine Similarity: 0.8078509569168091
*Check whether the second argument of the method is a variable.* 匹配到的元操作或API：
query: Check whether the second argument of the method is a variable.
most similar API: Check whether the method is varargs
cosine Similarity: 0.8260148167610168
84
69
106
90
100
82
97
80
77
63
97
81
=========================logics=========================
1. Get all method calls within the class.
2. Get the name of each called method.
3. Check whether the called method is one of 'equals', 'equalsIgnoreCase', 'compareTo', 'compareToIgnoreCase', or 'contentEquals'.
4. For each identified method call:
    - Get the argument list.
    - Check whether the first argument is a string literal.
    - Get the type of the second argument.
    - Check whether the second argument is null.
5. Count all method calls that violate the position literals first in the String comparison method rule.
If the count of violating method calls is 4 as specified, then this test case violates the rule with 4 instances.
*Get all method calls within the class.* 匹配到的元操作或API：
query: Get all method calls within the class.
most similar API: get method name of method call
cosine Similarity: 0.8104215264320374
*Get the name of each called method.* 匹配到的元操作或API：
logic: Get the name of each called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.935656726360321
*Check whether the called method is one of 'equals', 'equalsIgnoreCase', 'compareTo', 'compareToIgnoreCase', or 'contentEquals'.* 匹配到的元操作或API：
query: Check whether the called method is one of 'equals', 'equalsIgnoreCase', 'compareTo', 'compareToIgnoreCase', or 'contentEquals'.
most similar API: Check whether the method call equals
cosine Similarity: 0.8680468797683716
*For each identified method call:* 匹配到的元操作或API：
query: For each identified method call:
most similar API: get method name of method call
cosine Similarity: 0.8132593631744385
*Count all method calls that violate the position literals first in the String comparison method rule.* 匹配到的元操作或API：
未匹配成功元操作或API
84
70
106
91
=========================logics=========================
1. Get the name of called method.
2. Check whether the name is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
3. Get the number of arguments of called method.
4. Check whether the number of arguments is 1.
5. Get an argument of called method.
6. Check whether the first argument is a string literal.
7. Get the method caller.
8. Check whether the method caller is a string type.

If the called method is a string comparison method and the first argument is not a string literal and the method caller is a string type, then this test case might violate the rule. However, if the first argument is null, it's acceptable for the literal to be second to avoid NullPointerExceptions.

In the provided test case, the caller is a 'Number' object, not a string. Therefore, this specific rule doesn't apply, so this test case does not violate the rule. The number of violations is correctly reported as 0.
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376136779785
*Check whether the name is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803799152374268
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796931147575378
*Check whether the method caller is a string type.* 匹配到的元操作或API：
logic: Check whether the method caller is a string type.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.9876718521118164
=========================logics=========================
1. Get the name of called method.
2. Check whether the called method is equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, or contentEquals.
3. Get the number of arguments of called method.
4. Get the first argument of called method.
5. Check whether the first argument is a string literal.
6. Get the second argument of called method (if applicable).
7. Check whether the second argument is null.

Given that the provided test case calls the equals method on a variable (str) and uses a method call (getAnotherString("abc")) as the argument, it does not violate the rule because:
- The rule specifies that literals should be positioned first to avoid NullPointerExceptions. However, this rule primarily applies when comparing a known string literal to a variable or method call that could potentially be null. In the provided test case, the comparison is initiated by a variable and not a literal, and there is no direct comparison with a null value.
- The method call within the equals method does not directly involve a string literal or a null check in the method call itself.

Therefore, based on the checks outlined, the test case does not violate the specified rule as it does not directly compare a variable to a string literal or null in a manner that would risk a NullPointerException without the literal being positioned first.
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376136779785
*Check whether the called method is equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, or contentEquals.* 匹配到的元操作或API：
query: Check whether the called method is equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, or contentEquals.
most similar API: Check whether the method call equals
cosine Similarity: 0.8634228706359863
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Get the first argument of called method.* 匹配到的元操作或API：
logic: Get the first argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9160764813423157
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803799152374268
*Get the second argument of called method (if applicable).* 匹配到的元操作或API：
logic: Get the second argument of called method (if applicable).
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8932290077209473
*Check whether the second argument is null.* 匹配到的元操作或API：
query: Check whether the second argument is null.
most similar API: Check whether is null check
cosine Similarity: 0.8355706930160522
125
108
83
69
107
91
117
102
=========================logics=========================
1. Get the name of called method.
2. Check whether the called method is equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, or contentEquals.
3. Get the type of argument.
4. Check whether the argument is string type.
5. Get the number of arguments of called method.
6. Check whether the number of arguments is 1.
7. Get the argument of called method.
8. Check whether the argument is a literal.
9. Check the type of literal is not string.
10. Check whether the method caller is not a string literal.
If the called method is one of the specified string comparison methods, and the argument is not a string literal but the method caller is not a string literal either, and the argument's type is not string, this test case does not violate the rule as the primary focus is on string literals being the method caller to avoid NullPointerException, and in this case, the argument is not a string literal.
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376136779785
*Check whether the called method is equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, or contentEquals.* 匹配到的元操作或API：
query: Check whether the called method is equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, or contentEquals.
most similar API: Check whether the method call equals
cosine Similarity: 0.8634228706359863
*Get the type of argument.* 匹配到的元操作或API：
logic: Get the type of argument.
most similar meta operation: Get the type of argument
cosine Similarity: 0.9841679334640503
*Check whether the argument is string type.* 匹配到的元操作或API：
logic: Check whether the argument is string type.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9880461692810059
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the argument of called method.* 匹配到的元操作或API：
logic: Get the argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.97557133436203
*Check whether the argument is a literal.* 匹配到的元操作或API：
query: Check whether the argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8468949198722839
*Check the type of literal is not string.* 匹配到的元操作或API：
query: Check the type of literal is not string.
most similar API: Check whether the char literal is string literal
cosine Similarity: 0.8526137471199036
*Check whether the method caller is not a string literal.* 匹配到的元操作或API：
logic: Check whether the method caller is not a string literal.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.9055060744285583
=========================logics=========================
1. Get the name of called method.
2. Check whether the called method is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
3. Get the first argument of the called method.
4. Check whether the first argument is a string literal.
If the called method is one of the specified string comparison methods and the first argument is a string literal, then this test case adheres to the rule and does not violate it.

*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376136779785
*Check whether the called method is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.* 匹配到的元操作或API：
query: Check whether the called method is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
most similar API: Check whether the method call equals
cosine Similarity: 0.8578868508338928
*Get the first argument of the called method.* 匹配到的元操作或API：
logic: Get the first argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9071929454803467
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803799152374268
=========================logics=========================
1. Get all methods declared in class.
2. Get the body of method.
3. Find all method call expressions in method body.
4. Get the name of called method.
5. Check whether the name of called method is equalsIgnoreCase, equals, compareTo, compareToIgnoreCase, or contentEquals.
6. Get the number of arguments of called method.
7. Check whether the number of arguments is 1.
8. Get the first argument of called method.
9. Check whether the first argument is a string literal.
10. Get the method caller.
11. Check whether the method caller is a string type.
12. Check whether the method caller is not a string literal.

If the called method is one of the specified comparison methods (equalsIgnoreCase, equals, compareTo, compareToIgnoreCase, contentEquals), the first argument is not a string literal, and the method caller is a string type but not a string literal, then this test case violates the rule.
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366355895996094
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752806425094604
*Find all method call expressions in method body.* 匹配到的元操作或API：
query: Find all method call expressions in method body.
most similar API: Check whether the method call is expression
cosine Similarity: 0.8156483769416809
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376136779785
*Check whether the name of called method is equalsIgnoreCase, equals, compareTo, compareToIgnoreCase, or contentEquals.* 匹配到的元操作或API：
query: Check whether the name of called method is equalsIgnoreCase, equals, compareTo, compareToIgnoreCase, or contentEquals.
most similar API: Check whether the method call equals
cosine Similarity: 0.8462667465209961
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of called method.* 匹配到的元操作或API：
logic: Get the first argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9160764813423157
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803799152374268
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796931147575378
*Check whether the method caller is a string type.* 匹配到的元操作或API：
logic: Check whether the method caller is a string type.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.9876718521118164
*Check whether the method caller is not a string literal.* 匹配到的元操作或API：
logic: Check whether the method caller is not a string literal.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.9055060744285583
=========================logics=========================
1. Get the condition of if statement.
2. Check whether the condition contains method call.
3. Get the name of called method.
4. Check whether the method name is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
5. Get the argument list of the method call.
6. Get the first argument of the method call.
7. Check whether the first argument is a string literal.
8. Get the second argument of the method call.
9. Check whether the second argument is a variable.

If the method name matches one of the specified comparison methods, the first argument is not a string literal, and the second argument is a variable (potentially null), then this test case would violate the rule. However, based on the provided code and checks, no rule violations are present in the test case as the method call and arguments do not align with the rule's conditions, therefore the count of violations is correctly identified as 0.
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797652363777161
*Check whether the condition contains method call.* 匹配到的元操作或API：
query: Check whether the condition contains method call.
most similar API: Check whether the method call equals
cosine Similarity: 0.869232177734375
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376136779785
*Check whether the method name is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.* 匹配到的元操作或API：
query: Check whether the method name is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
most similar API: Check whether the method equals
cosine Similarity: 0.8276054859161377
*Get the argument list of the method call.* 匹配到的元操作或API：
logic: Get the argument list of the method call.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.8692126274108887
*Get the first argument of the method call.* 匹配到的元操作或API：
logic: Get the first argument of the method call.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8929160833358765
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803799152374268
*Get the second argument of the method call.* 匹配到的元操作或API：
logic: Get the second argument of the method call.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8758881688117981
*Check whether the second argument is a variable.* 匹配到的元操作或API：
query: Check whether the second argument is a variable.
most similar API: Check whether is reference to var
cosine Similarity: 0.8047316074371338
=========================logics=========================
1. Get all method calls within the class.
2. For each method call, get the name of called method.
3. Check whether the called method is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
4. Get the number of arguments of called method.
5. If the number of arguments is 1, proceed. If not, ignore this method call since the rule pertains to non-overloaded versions which expect a single argument.
6. Get the first argument of the method call.
7. Check whether the first argument is a string literal.
8. If the first argument is not a string literal, check if it is null.
9. If the argument is neither a string literal nor null, this does not violate the specified rule. If it is a string literal or null, it adheres to the rule by positioning the literal or null-check first to avoid NullPointerExceptions.

Given the test case does not directly make a string comparison but instead appears to call a method `equalsIgnoreCase` with a `BigDecimal` object, it does not directly apply or violate the described rule because it does not match the pattern of comparing a string to a literal or null directly. Thus, the number of violations for this specific rule in the given test case is correctly identified as 0.
*Get all method calls within the class.* 匹配到的元操作或API：
query: Get all method calls within the class.
most similar API: get method name of method call
cosine Similarity: 0.8104215264320374
*For each method call, get the name of called method.* 匹配到的元操作或API：
logic: For each method call, get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9387874007225037
*Check whether the called method is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.* 匹配到的元操作或API：
query: Check whether the called method is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
most similar API: Check whether the method call equals
cosine Similarity: 0.8578868508338928
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*If the number of arguments is 1, proceed. If not, ignore this method call since the rule pertains to non-overloaded versions which expect a single argument.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of the method call.* 匹配到的元操作或API：
logic: Get the first argument of the method call.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8929160833358765
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803799152374268
*If the first argument is not a string literal, check if it is null.* 匹配到的元操作或API：
query: If the first argument is not a string literal, check if it is null.
most similar API: Check whether the string literal is null literal
cosine Similarity: 0.8932130336761475
*If the argument is neither a string literal nor null, this does not violate the specified rule. If it is a string literal or null, it adheres to the rule by positioning the literal or null-check first to avoid NullPointerExceptions.* 匹配到的元操作或API：
query: If the argument is neither a string literal nor null, this does not violate the specified rule. If it is a string literal or null, it adheres to the rule by positioning the literal or null-check first to avoid NullPointerExceptions.
most similar API: Check whether the string literal is null literal
cosine Similarity: 0.8157132863998413
=========================logics=========================
1. Get the method name of called method.
2. Check whether the method is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
3. Get the arguments of the called method.
4. Check whether the first argument is a literal.
5. Check whether the second argument is null.

If the called method is a string comparison method, the first argument is not a literal, and the second argument is not null, then this test case does not violate the rule.
*Get the method name of called method.* 匹配到的元操作或API：
logic: Get the method name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9715963006019592
*Check whether the method is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.* 匹配到的元操作或API：
query: Check whether the method is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
most similar API: Check whether is equals method
cosine Similarity: 0.8396687507629395
*Get the arguments of the called method.* 匹配到的元操作或API：
logic: Get the arguments of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9324952960014343
*Check whether the first argument is a literal.* 匹配到的元操作或API：
query: Check whether the first argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8155131936073303
*Check whether the second argument is null.* 匹配到的元操作或API：
query: Check whether the second argument is null.
most similar API: Check whether is null check
cosine Similarity: 0.8355706930160522
111
94
=========================logics=========================
1. Get the name of called method.
2. Check whether the name is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
3. Get the first argument of the called method.
4. Check whether the first argument is a string literal.
5. Get the second argument of the called method.
6. Check whether the second argument is a variable.
If the first argument of the method call is a string literal and the second argument is a variable, then this test case adheres to the rule and does not violate it.
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376136779785
*Check whether the name is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of the called method.* 匹配到的元操作或API：
logic: Get the first argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9071929454803467
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803799152374268
*Get the second argument of the called method.* 匹配到的元操作或API：
logic: Get the second argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8917081952095032
*Check whether the second argument is a variable.* 匹配到的元操作或API：
query: Check whether the second argument is a variable.
most similar API: Check whether is reference to var
cosine Similarity: 0.8047316074371338
=========================logics=========================
1. Get the name of called method.
2. Check whether the name is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
3. Get the number of arguments of called method.
4. Check whether the number of arguments is 1.
5. Get the first argument of called method.
6. Check whether the first argument is a string literal.
7. Get the method caller.
8. Check whether the method caller is a string type.

If the called method is one of the specified string comparison methods, has one argument, and the first argument is not a string literal (and the method caller is a string), then this test case violates the rule.
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376136779785
*Check whether the name is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of called method.* 匹配到的元操作或API：
logic: Get the first argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9160764813423157
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803799152374268
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796931147575378
*Check whether the method caller is a string type.* 匹配到的元操作或API：
logic: Check whether the method caller is a string type.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.9876718521118164
=========================logics=========================
1. Get the name of called method.
2. Check whether the name of the called method is one of equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, or contentEquals.
3. Get the argument list of the method call.
4. Get the size of the argument list.
5. Check whether the first argument in the list is a string literal.
6. Check whether the second argument (if exists) is not null.

Given the description and the provided test case code snippet, no explicit string comparison method is called directly within the `bar` method. The call to `compareTo` does not provide enough context to determine if it violates the rule, as it depends on the implementation of `compareTo` method in the class `Foo` or its ancestors, and whether it is a comparison with a string literal positioned correctly.

Therefore, based on the provided operations and the test case, we cannot directly apply these checks to conclude if the rule is violated. The description of the test case indicates it's okay, and the number of violations is 0, which aligns with our analysis that no direct violation checks can be performed with the information given in the snippet.
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376136779785
*Check whether the name of the called method is one of equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, or contentEquals.* 匹配到的元操作或API：
query: Check whether the name of the called method is one of equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, or contentEquals.
most similar API: Check whether the method call equals
cosine Similarity: 0.8506113886833191
*Get the argument list of the method call.* 匹配到的元操作或API：
logic: Get the argument list of the method call.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.8692126274108887
*Get the size of the argument list.* 匹配到的元操作或API：
query: Get the size of the argument list.
most similar API: size of argument list
cosine Similarity: 0.9323437809944153
*Check whether the first argument in the list is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument in the list is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8568921089172363
*Check whether the second argument (if exists) is not null.* 匹配到的元操作或API：
query: Check whether the second argument (if exists) is not null.
most similar API: Check whether is null check
cosine Similarity: 0.8106982111930847
=========================logics=========================
1. Get all methods declared in class.
2. Get the name of method.
3. Check whether the method name is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
4. Get all method call expressions within the method body.
5. Get the name of called method.
6. Check whether the called method name is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
7. Get the arguments of the called method.
8. Check whether the first argument of the called method is a string literal.
9. Get the second argument of the called method.
10. Check whether the second argument of the called method is a variable or a literal.

For each method call that matches the names in step 3, if the first argument is a literal and the second argument is a variable or null, then the test case adheres to the rule. If the first argument is not a literal or the second argument is not a variable or null, then it might violate the rule. However, in the provided test case, the literal "2" comes first in the `compareToIgnoreCase` method call, which adheres to the rule. Therefore, the number of violations in this test case is 0.
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366355895996094
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.* 匹配到的元操作或API：
query: Check whether the method name is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
most similar API: Check whether the method equals
cosine Similarity: 0.8276054859161377
*Get all method call expressions within the method body.* 匹配到的元操作或API：
query: Get all method call expressions within the method body.
most similar API: get text of method call
cosine Similarity: 0.8106042146682739
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376136779785
*Check whether the called method name is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.* 匹配到的元操作或API：
query: Check whether the called method name is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
most similar API: Check whether the method call equals
cosine Similarity: 0.8443799018859863
*Get the arguments of the called method.* 匹配到的元操作或API：
logic: Get the arguments of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9324952960014343
*Check whether the first argument of the called method is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument of the called method is a string literal.
most similar meta operation: Check whether the return type of called method is string
cosine Similarity: 0.8524708151817322
*Get the second argument of the called method.* 匹配到的元操作或API：
logic: Get the second argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8917081952095032
*Check whether the second argument of the called method is a variable or a literal.* 匹配到的元操作或API：
未匹配成功元操作或API
=========================logics=========================
1. Get all methods declared in class.
2. Get the name of method.
3. Get all method calls within the method.
4. Get the name of called method.
5. Check whether the called method is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
6. Get the number of arguments of called method.
7. Check whether the number of arguments is 1.
8. Get the first argument of called method.
9. Check whether the first argument is a string literal.
10. Check whether the method caller is a string type or variable.

If the called method is one of the specified string comparison methods, and the first argument is not a string literal (indicating the literal does not come first), then this test case violates the rule.

*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366355895996094
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get all method calls within the method.* 匹配到的元操作或API：
query: Get all method calls within the method.
most similar API: get method name of method call
cosine Similarity: 0.8215441703796387
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376136779785
*Check whether the called method is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.* 匹配到的元操作或API：
query: Check whether the called method is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
most similar API: Check whether the method call equals
cosine Similarity: 0.8578868508338928
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of called method.* 匹配到的元操作或API：
logic: Get the first argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9160764813423157
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803799152374268
*Check whether the method caller is a string type or variable.* 匹配到的元操作或API：
logic: Check whether the method caller is a string type or variable.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.950462818145752
=========================logics=========================
1. Get the name of called method.
2. Check whether the called method is one of: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
3. Get the arguments of the called method.
4. Check whether the first argument is a string literal.
5. Check whether the second argument is null.

If the method is one of the specified comparison methods and the first argument is not a string literal, and the second argument is not null, then it does not violate the rule. Since the test case does not show the method being called with the string literal first or null as the second argument, there is no violation according to the rule description provided.
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376136779785
*Check whether the called method is one of: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.* 匹配到的元操作或API：
query: Check whether the called method is one of: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
most similar API: Check whether the method call equals
cosine Similarity: 0.8580822348594666
*Get the arguments of the called method.* 匹配到的元操作或API：
logic: Get the arguments of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9324952960014343
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803799152374268
*Check whether the second argument is null.* 匹配到的元操作或API：
query: Check whether the second argument is null.
most similar API: Check whether is null check
cosine Similarity: 0.8355706930160522
=========================logics=========================
1. Get all methods declared in class.
2. Get the name of method.
3. Check whether the method is boolean equals(Object o), equalsIgnoreCase, compareTo, compareToIgnoreCase or contentEquals.
4. Get the body of method.
5. Find all method calls within the body.
6. Get the name of called method.
7. Check whether the name of the called method matches one of the mentioned comparison methods.
8. Get the argument list of method call.
9. Check whether the number of arguments is 2.
10. Get the first argument of method call.
11. Check whether the first argument is a string literal.
12. Get the second argument of method call.
13. Check whether the second argument is a variable (not a literal).

If all steps are passed for each method call, this means that we have a literal first in the comparison and the test case adheres to the rule. Since the description states "ok, literal comes first" and the number of violations is "0", we can conclude that the test case does not violate the rule.

*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366355895996094
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is boolean equals(Object o), equalsIgnoreCase, compareTo, compareToIgnoreCase or contentEquals.* 匹配到的元操作或API：
query: Check whether the method is boolean equals(Object o), equalsIgnoreCase, compareTo, compareToIgnoreCase or contentEquals.
most similar API: Check whether is equals method
cosine Similarity: 0.8362883925437927
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752806425094604
*Find all method calls within the body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376136779785
*Check whether the name of the called method matches one of the mentioned comparison methods.* 匹配到的元操作或API：
query: Check whether the name of the called method matches one of the mentioned comparison methods.
most similar API: Check whether the method call equals
cosine Similarity: 0.8510164618492126
*Get the argument list of method call.* 匹配到的元操作或API：
logic: Get the argument list of method call.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8785549402236938
*Check whether the number of arguments is 2.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of method call.* 匹配到的元操作或API：
logic: Get the first argument of method call.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9015621542930603
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803799152374268
*Get the second argument of method call.* 匹配到的元操作或API：
logic: Get the second argument of method call.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8847955465316772
*Check whether the second argument is a variable (not a literal).* 匹配到的元操作或API：
未匹配成功元操作或API
=========================logics=========================
1. Get the name of method.
2. Check whether the method is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
3. Get the argument list of method.
4. Get the size of argument list.
5. Check whether the size of argument list is 1.
6. Get the first argument of the method call.
7. Check whether the first argument is a string literal.
8. Check whether the method caller is a local variable, formal parameter, or field.

In the provided test case, we need to check if the string literal `"2"` comes first in the comparison. Since `x` is the method caller, and it is compared to a string literal using `contentEquals`, this violates the rule as the literal does not come first. There is one violation in this test case.
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.* 匹配到的元操作或API：
query: Check whether the method is one of the following: equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals.
most similar API: Check whether is equals method
cosine Similarity: 0.8396687507629395
*Get the argument list of method.* 匹配到的元操作或API：
logic: Get the argument list of method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8603730201721191
*Get the size of argument list.* 匹配到的元操作或API：
query: Get the size of argument list.
most similar API: size of argument list
cosine Similarity: 0.9362417459487915
*Check whether the size of argument list is 1.* 匹配到的元操作或API：
query: Check whether the size of argument list is 1.
most similar API: size of argument list
cosine Similarity: 0.8567352890968323
*Get the first argument of the method call.* 匹配到的元操作或API：
logic: Get the first argument of the method call.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8929160833358765
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803799152374268
*Check whether the method caller is a local variable, formal parameter, or field.* 匹配到的元操作或API：
query: Check whether the method caller is a local variable, formal parameter, or field.
most similar API: Check whether the method call is expression
cosine Similarity: 0.814143717288971
=========================logics=========================
1. Get the name of the method.
2. Check whether the method is equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, or contentEquals.
3. Get the number of arguments of called method.
4. Check whether the number of arguments is 1 or 2 (since equals can be overridden with one argument and the rest typically have one argument).
5. Get an argument of called method.
6. Check whether the argument is a string literal.
7. Check whether the argument is the first argument of the method call.

If the method name is one of the specified String comparison methods, the number of arguments is correct, and the first argument is not a string literal, then this test case would violate the rule. However, if the first argument is a string literal or the method is not one of the specified String comparison methods, then the test case does not violate the rule. In this test case, since "contentEquals" is called with a string literal as the first argument, it does not violate the rule.
*Get the name of the method.* 匹配到的元操作或API：
logic: Get the name of the method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9713992476463318
*Check whether the method is equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, or contentEquals.* 匹配到的元操作或API：
query: Check whether the method is equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, or contentEquals.
most similar API: Check whether is equals method
cosine Similarity: 0.8528470396995544
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1 or 2 (since equals can be overridden with one argument and the rest typically have one argument).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.907717227935791
*Check whether the argument is the first argument of the method call.* 匹配到的元操作或API：
query: Check whether the argument is the first argument of the method call.
most similar API: Check whether the method call equals
cosine Similarity: 0.8097406625747681
116
101
=========================logics=========================
1. Get the name of called method.
2. Check whether the name is equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, or contentEquals.
3. Get the argument list of method.
4. Check whether the size of argument list is 1.
5. Get the first argument of method.
6. Check whether the first argument is a string literal.
7. Get the method caller.
8. Check whether the type of method caller is String type.
9. Check whether the method caller is null.

If the called method is one of the specified string comparison methods and the first argument is not a string literal, and the method caller is a String or potentially null (i.e., not a literal), then this test case violates the rule.
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376136779785
*Check whether the name is equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, or contentEquals.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the argument list of method.* 匹配到的元操作或API：
logic: Get the argument list of method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8603730201721191
*Check whether the size of argument list is 1.* 匹配到的元操作或API：
query: Check whether the size of argument list is 1.
most similar API: size of argument list
cosine Similarity: 0.8567352890968323
*Get the first argument of method.* 匹配到的元操作或API：
logic: Get the first argument of method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8751165866851807
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803799152374268
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796931147575378
*Check whether the type of method caller is String type.* 匹配到的元操作或API：
logic: Check whether the type of method caller is String type.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.9830986261367798
*Check whether the method caller is null.* 匹配到的元操作或API：
query: Check whether the method caller is null.
most similar API: Check whether is null check
cosine Similarity: 0.8236193656921387
==========================第1轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;

The following are the test cases of the rule:
1. This is a positive test case
```java
// ok, literal comes first in .equals comparison
public class Foo {
    boolean bar(String x) {
        return "2".equals(x);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'equals')
            ――ASTStringLiteral
            ――ASTArgumentList (size = 1)
              ――ASTVariableAccess (referenced variable name = 'x')

2. This is a negative test case
```java
// bad, literal comes last in .equals comparison
public class Foo {
    boolean bar(String x) {
        return x.equals("2");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'equals')
            ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

3. This is a negative test case
```java
// ok, empty literal in .equals comparison
public class Foo {
    void bar(String str) {
        if ((str == null) || (str.equals(""))) {
            str = "snafu";
        }
        if (str == null || str.equals("")) {
            str = "snafu";
        }
        if ((str != null) && (str.equals(""))) {
            str = "snafu";
        }
        if (str != null && str.equals("")) {
            str = "snafu";
        }
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral

4. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug(Number number)
    {
        if (number.equals(new BigDecimal("123"))) {}
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bug')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'number')
      ――ASTBlock
        ――ASTIfStatement
          ――ASTMethodCall (called method name = 'equals')
            ――ASTVariableAccess (referenced variable name = 'number')
            ――ASTArgumentList (size = 1)
              ――ASTConstructorCall
                ――ASTClassOrInterfaceType (this is a class type)
                ――ASTArgumentList (size = 1)
                  ――ASTStringLiteral
          ――ASTBlock

5. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (str.equals(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'testMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTIfStatement
          ――ASTMethodCall (called method name = 'equals')
            ――ASTVariableAccess (referenced variable name = 'str')
            ――ASTArgumentList (size = 1)
              ――ASTMethodCall (called method name = 'getAnotherString')
                ――ASTArgumentList (size = 1)
                  ――ASTStringLiteral
          ――ASTBlock
    ――ASTMethodDeclaration (method name = 'getAnotherString')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'String')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTStringLiteral

6. This is a positive test case
```java
// #1256 PositionLiteralsFirstInComparisons .equals false positive with Characters
public class LiteralTest {
    protected final boolean check;
    public LiteralTest(Character c) {
        check = c.equals('x');
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'LiteralTest')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTPrimitiveType (this is a primitive type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'check')
    ――ASTConstructorDeclaration
      ――ASTModifierList
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'c')
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTAssignmentExpression
            ――ASTVariableAccess (referenced variable name = 'check')
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'c')
              ――ASTArgumentList (size = 1)
                ――ASTCharLiteral

7. This is a positive test case
```java
// ok, literal comes first in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".equalsIgnoreCase(x);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'equalsIgnoreCase')
            ――ASTStringLiteral
            ――ASTArgumentList (size = 1)
              ――ASTVariableAccess (referenced variable name = 'x')

8. This is a negative test case
```java
// bad, literal comes last in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'equalsIgnoreCase')
            ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

9. This is a positive test case
```java
// ok, testing .equalsIgnoreCase false positive
public class Foo {
    void bar() {
        if ((str == null) || (equalsIgnoreCase(""))) {
            str = "snafu";
        }
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equalsIgnoreCase')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral

10. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug()
    {
        if (equalsIgnoreCase(new BigDecimal("123"))) {}
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bug')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTIfStatement
          ――ASTMethodCall (called method name = 'equalsIgnoreCase')
            ――ASTArgumentList (size = 1)
              ――ASTConstructorCall
                ――ASTClassOrInterfaceType (this is a class type)
                ――ASTArgumentList (size = 1)
                  ――ASTStringLiteral
          ――ASTBlock

11. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (equalsIgnoreCase(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'testMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTIfStatement
          ――ASTMethodCall (called method name = 'equalsIgnoreCase')
            ――ASTArgumentList (size = 1)
              ――ASTMethodCall (called method name = 'getAnotherString')
                ――ASTArgumentList (size = 1)
                  ――ASTStringLiteral
          ――ASTBlock
    ――ASTMethodDeclaration (method name = 'getAnotherString')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'String')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTStringLiteral

12. This is a positive test case
```java
// ok, literal comes first in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareTo(x) < 0;
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTInfixExpression
            ――ASTMethodCall (called method name = 'compareTo')
              ――ASTStringLiteral
              ――ASTArgumentList (size = 1)
                ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTNumericLiteral

13. This is a negative test case
```java
// bad, literal comes last in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return x.compareTo("2") > 0;
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTInfixExpression
            ――ASTMethodCall (called method name = 'compareTo')
              ――ASTVariableAccess (referenced variable name = 'x')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
            ――ASTNumericLiteral

14. This is a positive test case
```java
// ok, testing for .compareTo false positive
public class Foo {
    boolean bar() {
        return compareTo("randomStringArg");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'compareTo')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

15. This is a positive test case
```java
// ok, literal comes first in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareToIgnoreCase(x) < 0;
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTInfixExpression
            ――ASTMethodCall (called method name = 'compareToIgnoreCase')
              ――ASTStringLiteral
              ――ASTArgumentList (size = 1)
                ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTNumericLiteral

16. This is a negative test case
```java
// bad, literal comes last in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.compareToIgnoreCase("2") > 0;
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTInfixExpression
            ――ASTMethodCall (called method name = 'compareToIgnoreCase')
              ――ASTVariableAccess (referenced variable name = 'x')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
            ――ASTNumericLiteral

17. This is a positive test case
```java
// ok, testing ,compareToIgnoreCase false positive
public class Foo {
    String bar() {
        return compareToIgnoreCase("randomStringArg");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'String')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'compareToIgnoreCase')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

18. This is a positive test case
```java
// ok, literal comes first in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return "2".contentEquals(x);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'contentEquals')
            ――ASTStringLiteral
            ――ASTArgumentList (size = 1)
              ――ASTVariableAccess (referenced variable name = 'x')

19. This is a negative test case
```java
// bad, literal comes last in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return x.contentEquals("2");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'contentEquals')
            ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

20. This is a positive test case
```java
// ok, testing .contentEquals false positive
public class Foo {
    boolean bar(String x) {
        return contentEquals("2");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'contentEquals')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral



The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:
1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isSyntacticallyAbstract()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isVarargs(), //Returns true if this node's last formal parameter is varargs.
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()
7. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullCheck(net.sourceforge.pmd.lang.java.ast.ASTExpression, net.sourceforge.pmd.lang.java.rule.internal.StablePathMatcher)
8. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isBooleanLiteral(net.sourceforge.pmd.lang.java.ast.JavaNode), //Returns true if the node is a boolean literal with any value.
9. net.sourceforge.pmd.lang.java.ast.ASTCharLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
10. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
11. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
12. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
13. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
14. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean equals(java.lang.Object)
15. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isReferenceToVar(net.sourceforge.pmd.lang.java.ast.ASTExpression, java.util.Set), //Returns true if the expression is a {@link ASTNamedReferenceExpr} that references any of the symbol in the set.
16. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isNullLiteral(), //Returns true if this is the {@linkplain ASTNullLiteral null literal}.
17. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isEqualsMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
18. net.sourceforge.pmd.lang.java.ast.ASTArgumentList: public int size(), //Returns the number of nodes in this list. This must be the number of nodes yielded by the {@link #iterator()}.
19. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
20. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.document.Chars getText()

1.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
3.  //Check whether the method caller is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallerStringType(ASTMethodCall node){
    return TypeTestUtil.isA(String.class, node.getQualifier());
}
```
4.  //Get the type of argument
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getMethodCallArgumentType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror();
}
```
5.  //Check whether the return type of called method is string
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.JMethodSig;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnStringType(ASTMethodCall call) {
    JMethodSig m = call.getMethodType();
    return TypeTestUtil.isA(String.class, m.getReturnType());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:
1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


出现语法错误，这一轮舍弃，直接重新生成
==========================第2轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;

The following are the test cases of the rule:
1. This is a positive test case
```java
// ok, literal comes first in .equals comparison
public class Foo {
    boolean bar(String x) {
        return "2".equals(x);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'equals')
            ――ASTStringLiteral
            ――ASTArgumentList (size = 1)
              ――ASTVariableAccess (referenced variable name = 'x')

2. This is a negative test case
```java
// bad, literal comes last in .equals comparison
public class Foo {
    boolean bar(String x) {
        return x.equals("2");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'equals')
            ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

3. This is a negative test case
```java
// ok, empty literal in .equals comparison
public class Foo {
    void bar(String str) {
        if ((str == null) || (str.equals(""))) {
            str = "snafu";
        }
        if (str == null || str.equals("")) {
            str = "snafu";
        }
        if ((str != null) && (str.equals(""))) {
            str = "snafu";
        }
        if (str != null && str.equals("")) {
            str = "snafu";
        }
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral

4. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug(Number number)
    {
        if (number.equals(new BigDecimal("123"))) {}
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bug')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'number')
      ――ASTBlock
        ――ASTIfStatement
          ――ASTMethodCall (called method name = 'equals')
            ――ASTVariableAccess (referenced variable name = 'number')
            ――ASTArgumentList (size = 1)
              ――ASTConstructorCall
                ――ASTClassOrInterfaceType (this is a class type)
                ――ASTArgumentList (size = 1)
                  ――ASTStringLiteral
          ――ASTBlock

5. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (str.equals(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'testMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTIfStatement
          ――ASTMethodCall (called method name = 'equals')
            ――ASTVariableAccess (referenced variable name = 'str')
            ――ASTArgumentList (size = 1)
              ――ASTMethodCall (called method name = 'getAnotherString')
                ――ASTArgumentList (size = 1)
                  ――ASTStringLiteral
          ――ASTBlock
    ――ASTMethodDeclaration (method name = 'getAnotherString')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'String')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTStringLiteral

6. This is a positive test case
```java
// #1256 PositionLiteralsFirstInComparisons .equals false positive with Characters
public class LiteralTest {
    protected final boolean check;
    public LiteralTest(Character c) {
        check = c.equals('x');
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'LiteralTest')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTPrimitiveType (this is a primitive type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'check')
    ――ASTConstructorDeclaration
      ――ASTModifierList
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'c')
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTAssignmentExpression
            ――ASTVariableAccess (referenced variable name = 'check')
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'c')
              ――ASTArgumentList (size = 1)
                ――ASTCharLiteral

7. This is a positive test case
```java
// ok, literal comes first in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".equalsIgnoreCase(x);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'equalsIgnoreCase')
            ――ASTStringLiteral
            ――ASTArgumentList (size = 1)
              ――ASTVariableAccess (referenced variable name = 'x')

8. This is a negative test case
```java
// bad, literal comes last in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'equalsIgnoreCase')
            ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

9. This is a positive test case
```java
// ok, testing .equalsIgnoreCase false positive
public class Foo {
    void bar() {
        if ((str == null) || (equalsIgnoreCase(""))) {
            str = "snafu";
        }
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equalsIgnoreCase')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral

10. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug()
    {
        if (equalsIgnoreCase(new BigDecimal("123"))) {}
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bug')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTIfStatement
          ――ASTMethodCall (called method name = 'equalsIgnoreCase')
            ――ASTArgumentList (size = 1)
              ――ASTConstructorCall
                ――ASTClassOrInterfaceType (this is a class type)
                ――ASTArgumentList (size = 1)
                  ――ASTStringLiteral
          ――ASTBlock

11. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (equalsIgnoreCase(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'testMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTIfStatement
          ――ASTMethodCall (called method name = 'equalsIgnoreCase')
            ――ASTArgumentList (size = 1)
              ――ASTMethodCall (called method name = 'getAnotherString')
                ――ASTArgumentList (size = 1)
                  ――ASTStringLiteral
          ――ASTBlock
    ――ASTMethodDeclaration (method name = 'getAnotherString')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'String')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTStringLiteral

12. This is a positive test case
```java
// ok, literal comes first in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareTo(x) < 0;
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTInfixExpression
            ――ASTMethodCall (called method name = 'compareTo')
              ――ASTStringLiteral
              ――ASTArgumentList (size = 1)
                ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTNumericLiteral

13. This is a negative test case
```java
// bad, literal comes last in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return x.compareTo("2") > 0;
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTInfixExpression
            ――ASTMethodCall (called method name = 'compareTo')
              ――ASTVariableAccess (referenced variable name = 'x')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
            ――ASTNumericLiteral

14. This is a positive test case
```java
// ok, testing for .compareTo false positive
public class Foo {
    boolean bar() {
        return compareTo("randomStringArg");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'compareTo')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

15. This is a positive test case
```java
// ok, literal comes first in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareToIgnoreCase(x) < 0;
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTInfixExpression
            ――ASTMethodCall (called method name = 'compareToIgnoreCase')
              ――ASTStringLiteral
              ――ASTArgumentList (size = 1)
                ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTNumericLiteral

16. This is a negative test case
```java
// bad, literal comes last in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.compareToIgnoreCase("2") > 0;
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTInfixExpression
            ――ASTMethodCall (called method name = 'compareToIgnoreCase')
              ――ASTVariableAccess (referenced variable name = 'x')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
            ――ASTNumericLiteral

17. This is a positive test case
```java
// ok, testing ,compareToIgnoreCase false positive
public class Foo {
    String bar() {
        return compareToIgnoreCase("randomStringArg");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'String')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'compareToIgnoreCase')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

18. This is a positive test case
```java
// ok, literal comes first in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return "2".contentEquals(x);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'contentEquals')
            ――ASTStringLiteral
            ――ASTArgumentList (size = 1)
              ――ASTVariableAccess (referenced variable name = 'x')

19. This is a negative test case
```java
// bad, literal comes last in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return x.contentEquals("2");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'contentEquals')
            ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

20. This is a positive test case
```java
// ok, testing .contentEquals false positive
public class Foo {
    boolean bar(String x) {
        return contentEquals("2");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'contentEquals')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral



The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:
1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isSyntacticallyAbstract()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isVarargs(), //Returns true if this node's last formal parameter is varargs.
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()
7. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullCheck(net.sourceforge.pmd.lang.java.ast.ASTExpression, net.sourceforge.pmd.lang.java.rule.internal.StablePathMatcher)
8. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isBooleanLiteral(net.sourceforge.pmd.lang.java.ast.JavaNode), //Returns true if the node is a boolean literal with any value.
9. net.sourceforge.pmd.lang.java.ast.ASTCharLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
10. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
11. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
12. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
13. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
14. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean equals(java.lang.Object)
15. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isReferenceToVar(net.sourceforge.pmd.lang.java.ast.ASTExpression, java.util.Set), //Returns true if the expression is a {@link ASTNamedReferenceExpr} that references any of the symbol in the set.
16. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isNullLiteral(), //Returns true if this is the {@linkplain ASTNullLiteral null literal}.
17. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isEqualsMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
18. net.sourceforge.pmd.lang.java.ast.ASTArgumentList: public int size(), //Returns the number of nodes in this list. This must be the number of nodes yielded by the {@link #iterator()}.
19. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
20. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.document.Chars getText()

1.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
3.  //Check whether the method caller is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallerStringType(ASTMethodCall node){
    return TypeTestUtil.isA(String.class, node.getQualifier());
}
```
4.  //Get the type of argument
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getMethodCallArgumentType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror();
}
```
5.  //Check whether the return type of called method is string
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.JMethodSig;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnStringType(ASTMethodCall call) {
    JMethodSig m = call.getMethodType();
    return TypeTestUtil.isA(String.class, m.getReturnType());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:
1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


出现语法错误，这一轮舍弃，直接重新生成
==========================第3轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;

The following are the test cases of the rule:
1. This is a positive test case
```java
// ok, literal comes first in .equals comparison
public class Foo {
    boolean bar(String x) {
        return "2".equals(x);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'equals')
            ――ASTStringLiteral
            ――ASTArgumentList (size = 1)
              ――ASTVariableAccess (referenced variable name = 'x')

2. This is a negative test case
```java
// bad, literal comes last in .equals comparison
public class Foo {
    boolean bar(String x) {
        return x.equals("2");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'equals')
            ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

3. This is a negative test case
```java
// ok, empty literal in .equals comparison
public class Foo {
    void bar(String str) {
        if ((str == null) || (str.equals(""))) {
            str = "snafu";
        }
        if (str == null || str.equals("")) {
            str = "snafu";
        }
        if ((str != null) && (str.equals(""))) {
            str = "snafu";
        }
        if (str != null && str.equals("")) {
            str = "snafu";
        }
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral

4. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug(Number number)
    {
        if (number.equals(new BigDecimal("123"))) {}
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bug')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'number')
      ――ASTBlock
        ――ASTIfStatement
          ――ASTMethodCall (called method name = 'equals')
            ――ASTVariableAccess (referenced variable name = 'number')
            ――ASTArgumentList (size = 1)
              ――ASTConstructorCall
                ――ASTClassOrInterfaceType (this is a class type)
                ――ASTArgumentList (size = 1)
                  ――ASTStringLiteral
          ――ASTBlock

5. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (str.equals(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'testMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTIfStatement
          ――ASTMethodCall (called method name = 'equals')
            ――ASTVariableAccess (referenced variable name = 'str')
            ――ASTArgumentList (size = 1)
              ――ASTMethodCall (called method name = 'getAnotherString')
                ――ASTArgumentList (size = 1)
                  ――ASTStringLiteral
          ――ASTBlock
    ――ASTMethodDeclaration (method name = 'getAnotherString')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'String')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTStringLiteral

6. This is a positive test case
```java
// #1256 PositionLiteralsFirstInComparisons .equals false positive with Characters
public class LiteralTest {
    protected final boolean check;
    public LiteralTest(Character c) {
        check = c.equals('x');
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'LiteralTest')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTPrimitiveType (this is a primitive type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'check')
    ――ASTConstructorDeclaration
      ――ASTModifierList
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'c')
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTAssignmentExpression
            ――ASTVariableAccess (referenced variable name = 'check')
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'c')
              ――ASTArgumentList (size = 1)
                ――ASTCharLiteral

7. This is a positive test case
```java
// ok, literal comes first in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".equalsIgnoreCase(x);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'equalsIgnoreCase')
            ――ASTStringLiteral
            ――ASTArgumentList (size = 1)
              ――ASTVariableAccess (referenced variable name = 'x')

8. This is a negative test case
```java
// bad, literal comes last in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'equalsIgnoreCase')
            ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

9. This is a positive test case
```java
// ok, testing .equalsIgnoreCase false positive
public class Foo {
    void bar() {
        if ((str == null) || (equalsIgnoreCase(""))) {
            str = "snafu";
        }
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equalsIgnoreCase')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral

10. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug()
    {
        if (equalsIgnoreCase(new BigDecimal("123"))) {}
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bug')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTIfStatement
          ――ASTMethodCall (called method name = 'equalsIgnoreCase')
            ――ASTArgumentList (size = 1)
              ――ASTConstructorCall
                ――ASTClassOrInterfaceType (this is a class type)
                ――ASTArgumentList (size = 1)
                  ――ASTStringLiteral
          ――ASTBlock

11. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (equalsIgnoreCase(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'testMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTIfStatement
          ――ASTMethodCall (called method name = 'equalsIgnoreCase')
            ――ASTArgumentList (size = 1)
              ――ASTMethodCall (called method name = 'getAnotherString')
                ――ASTArgumentList (size = 1)
                  ――ASTStringLiteral
          ――ASTBlock
    ――ASTMethodDeclaration (method name = 'getAnotherString')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'String')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTStringLiteral

12. This is a positive test case
```java
// ok, literal comes first in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareTo(x) < 0;
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTInfixExpression
            ――ASTMethodCall (called method name = 'compareTo')
              ――ASTStringLiteral
              ――ASTArgumentList (size = 1)
                ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTNumericLiteral

13. This is a negative test case
```java
// bad, literal comes last in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return x.compareTo("2") > 0;
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTInfixExpression
            ――ASTMethodCall (called method name = 'compareTo')
              ――ASTVariableAccess (referenced variable name = 'x')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
            ――ASTNumericLiteral

14. This is a positive test case
```java
// ok, testing for .compareTo false positive
public class Foo {
    boolean bar() {
        return compareTo("randomStringArg");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'compareTo')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

15. This is a positive test case
```java
// ok, literal comes first in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareToIgnoreCase(x) < 0;
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTInfixExpression
            ――ASTMethodCall (called method name = 'compareToIgnoreCase')
              ――ASTStringLiteral
              ――ASTArgumentList (size = 1)
                ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTNumericLiteral

16. This is a negative test case
```java
// bad, literal comes last in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.compareToIgnoreCase("2") > 0;
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTInfixExpression
            ――ASTMethodCall (called method name = 'compareToIgnoreCase')
              ――ASTVariableAccess (referenced variable name = 'x')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
            ――ASTNumericLiteral

17. This is a positive test case
```java
// ok, testing ,compareToIgnoreCase false positive
public class Foo {
    String bar() {
        return compareToIgnoreCase("randomStringArg");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'String')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'compareToIgnoreCase')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

18. This is a positive test case
```java
// ok, literal comes first in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return "2".contentEquals(x);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'contentEquals')
            ――ASTStringLiteral
            ――ASTArgumentList (size = 1)
              ――ASTVariableAccess (referenced variable name = 'x')

19. This is a negative test case
```java
// bad, literal comes last in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return x.contentEquals("2");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'contentEquals')
            ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

20. This is a positive test case
```java
// ok, testing .contentEquals false positive
public class Foo {
    boolean bar(String x) {
        return contentEquals("2");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'contentEquals')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral



The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:
1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isSyntacticallyAbstract()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isVarargs(), //Returns true if this node's last formal parameter is varargs.
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()
7. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullCheck(net.sourceforge.pmd.lang.java.ast.ASTExpression, net.sourceforge.pmd.lang.java.rule.internal.StablePathMatcher)
8. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isBooleanLiteral(net.sourceforge.pmd.lang.java.ast.JavaNode), //Returns true if the node is a boolean literal with any value.
9. net.sourceforge.pmd.lang.java.ast.ASTCharLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
10. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
11. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
12. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
13. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
14. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean equals(java.lang.Object)
15. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isReferenceToVar(net.sourceforge.pmd.lang.java.ast.ASTExpression, java.util.Set), //Returns true if the expression is a {@link ASTNamedReferenceExpr} that references any of the symbol in the set.
16. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isNullLiteral(), //Returns true if this is the {@linkplain ASTNullLiteral null literal}.
17. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isEqualsMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
18. net.sourceforge.pmd.lang.java.ast.ASTArgumentList: public int size(), //Returns the number of nodes in this list. This must be the number of nodes yielded by the {@link #iterator()}.
19. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
20. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.document.Chars getText()

1.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
3.  //Check whether the method caller is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallerStringType(ASTMethodCall node){
    return TypeTestUtil.isA(String.class, node.getQualifier());
}
```
4.  //Get the type of argument
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getMethodCallArgumentType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror();
}
```
5.  //Check whether the return type of called method is string
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.JMethodSig;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnStringType(ASTMethodCall call) {
    JMethodSig m = call.getMethodType();
    return TypeTestUtil.isA(String.class, m.getReturnType());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:
1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


出现语法错误，这一轮舍弃，直接重新生成
==========================第4轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;

The following are the test cases of the rule:
1. This is a positive test case
```java
// ok, literal comes first in .equals comparison
public class Foo {
    boolean bar(String x) {
        return "2".equals(x);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'equals')
            ――ASTStringLiteral
            ――ASTArgumentList (size = 1)
              ――ASTVariableAccess (referenced variable name = 'x')

2. This is a negative test case
```java
// bad, literal comes last in .equals comparison
public class Foo {
    boolean bar(String x) {
        return x.equals("2");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'equals')
            ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

3. This is a negative test case
```java
// ok, empty literal in .equals comparison
public class Foo {
    void bar(String str) {
        if ((str == null) || (str.equals(""))) {
            str = "snafu";
        }
        if (str == null || str.equals("")) {
            str = "snafu";
        }
        if ((str != null) && (str.equals(""))) {
            str = "snafu";
        }
        if (str != null && str.equals("")) {
            str = "snafu";
        }
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral

4. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug(Number number)
    {
        if (number.equals(new BigDecimal("123"))) {}
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bug')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'number')
      ――ASTBlock
        ――ASTIfStatement
          ――ASTMethodCall (called method name = 'equals')
            ――ASTVariableAccess (referenced variable name = 'number')
            ――ASTArgumentList (size = 1)
              ――ASTConstructorCall
                ――ASTClassOrInterfaceType (this is a class type)
                ――ASTArgumentList (size = 1)
                  ――ASTStringLiteral
          ――ASTBlock

5. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (str.equals(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'testMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTIfStatement
          ――ASTMethodCall (called method name = 'equals')
            ――ASTVariableAccess (referenced variable name = 'str')
            ――ASTArgumentList (size = 1)
              ――ASTMethodCall (called method name = 'getAnotherString')
                ――ASTArgumentList (size = 1)
                  ――ASTStringLiteral
          ――ASTBlock
    ――ASTMethodDeclaration (method name = 'getAnotherString')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'String')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTStringLiteral

6. This is a positive test case
```java
// #1256 PositionLiteralsFirstInComparisons .equals false positive with Characters
public class LiteralTest {
    protected final boolean check;
    public LiteralTest(Character c) {
        check = c.equals('x');
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'LiteralTest')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTPrimitiveType (this is a primitive type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'check')
    ――ASTConstructorDeclaration
      ――ASTModifierList
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'c')
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTAssignmentExpression
            ――ASTVariableAccess (referenced variable name = 'check')
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'c')
              ――ASTArgumentList (size = 1)
                ――ASTCharLiteral

7. This is a positive test case
```java
// ok, literal comes first in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".equalsIgnoreCase(x);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'equalsIgnoreCase')
            ――ASTStringLiteral
            ――ASTArgumentList (size = 1)
              ――ASTVariableAccess (referenced variable name = 'x')

8. This is a negative test case
```java
// bad, literal comes last in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'equalsIgnoreCase')
            ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

9. This is a positive test case
```java
// ok, testing .equalsIgnoreCase false positive
public class Foo {
    void bar() {
        if ((str == null) || (equalsIgnoreCase(""))) {
            str = "snafu";
        }
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equalsIgnoreCase')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral

10. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug()
    {
        if (equalsIgnoreCase(new BigDecimal("123"))) {}
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bug')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTIfStatement
          ――ASTMethodCall (called method name = 'equalsIgnoreCase')
            ――ASTArgumentList (size = 1)
              ――ASTConstructorCall
                ――ASTClassOrInterfaceType (this is a class type)
                ――ASTArgumentList (size = 1)
                  ――ASTStringLiteral
          ――ASTBlock

11. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (equalsIgnoreCase(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'testMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTIfStatement
          ――ASTMethodCall (called method name = 'equalsIgnoreCase')
            ――ASTArgumentList (size = 1)
              ――ASTMethodCall (called method name = 'getAnotherString')
                ――ASTArgumentList (size = 1)
                  ――ASTStringLiteral
          ――ASTBlock
    ――ASTMethodDeclaration (method name = 'getAnotherString')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'String')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTStringLiteral

12. This is a positive test case
```java
// ok, literal comes first in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareTo(x) < 0;
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTInfixExpression
            ――ASTMethodCall (called method name = 'compareTo')
              ――ASTStringLiteral
              ――ASTArgumentList (size = 1)
                ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTNumericLiteral

13. This is a negative test case
```java
// bad, literal comes last in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return x.compareTo("2") > 0;
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTInfixExpression
            ――ASTMethodCall (called method name = 'compareTo')
              ――ASTVariableAccess (referenced variable name = 'x')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
            ――ASTNumericLiteral

14. This is a positive test case
```java
// ok, testing for .compareTo false positive
public class Foo {
    boolean bar() {
        return compareTo("randomStringArg");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'compareTo')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

15. This is a positive test case
```java
// ok, literal comes first in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareToIgnoreCase(x) < 0;
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTInfixExpression
            ――ASTMethodCall (called method name = 'compareToIgnoreCase')
              ――ASTStringLiteral
              ――ASTArgumentList (size = 1)
                ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTNumericLiteral

16. This is a negative test case
```java
// bad, literal comes last in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.compareToIgnoreCase("2") > 0;
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTInfixExpression
            ――ASTMethodCall (called method name = 'compareToIgnoreCase')
              ――ASTVariableAccess (referenced variable name = 'x')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
            ――ASTNumericLiteral

17. This is a positive test case
```java
// ok, testing ,compareToIgnoreCase false positive
public class Foo {
    String bar() {
        return compareToIgnoreCase("randomStringArg");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'String')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'compareToIgnoreCase')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

18. This is a positive test case
```java
// ok, literal comes first in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return "2".contentEquals(x);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'contentEquals')
            ――ASTStringLiteral
            ――ASTArgumentList (size = 1)
              ――ASTVariableAccess (referenced variable name = 'x')

19. This is a negative test case
```java
// bad, literal comes last in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return x.contentEquals("2");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'contentEquals')
            ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

20. This is a positive test case
```java
// ok, testing .contentEquals false positive
public class Foo {
    boolean bar(String x) {
        return contentEquals("2");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'contentEquals')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral



The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:
1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isSyntacticallyAbstract()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isVarargs(), //Returns true if this node's last formal parameter is varargs.
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()
7. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullCheck(net.sourceforge.pmd.lang.java.ast.ASTExpression, net.sourceforge.pmd.lang.java.rule.internal.StablePathMatcher)
8. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isBooleanLiteral(net.sourceforge.pmd.lang.java.ast.JavaNode), //Returns true if the node is a boolean literal with any value.
9. net.sourceforge.pmd.lang.java.ast.ASTCharLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
10. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
11. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
12. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
13. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
14. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean equals(java.lang.Object)
15. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isReferenceToVar(net.sourceforge.pmd.lang.java.ast.ASTExpression, java.util.Set), //Returns true if the expression is a {@link ASTNamedReferenceExpr} that references any of the symbol in the set.
16. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isNullLiteral(), //Returns true if this is the {@linkplain ASTNullLiteral null literal}.
17. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isEqualsMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
18. net.sourceforge.pmd.lang.java.ast.ASTArgumentList: public int size(), //Returns the number of nodes in this list. This must be the number of nodes yielded by the {@link #iterator()}.
19. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
20. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.document.Chars getText()

1.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
3.  //Check whether the method caller is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallerStringType(ASTMethodCall node){
    return TypeTestUtil.isA(String.class, node.getQualifier());
}
```
4.  //Get the type of argument
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getMethodCallArgumentType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror();
}
```
5.  //Check whether the return type of called method is string
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.JMethodSig;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnStringType(ASTMethodCall call) {
    JMethodSig m = call.getMethodType();
    return TypeTestUtil.isA(String.class, m.getReturnType());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:
1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


出现语法错误，这一轮舍弃，直接重新生成
==========================第5轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;

The following are the test cases of the rule:
1. This is a positive test case
```java
// ok, literal comes first in .equals comparison
public class Foo {
    boolean bar(String x) {
        return "2".equals(x);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'equals')
            ――ASTStringLiteral
            ――ASTArgumentList (size = 1)
              ――ASTVariableAccess (referenced variable name = 'x')

2. This is a negative test case
```java
// bad, literal comes last in .equals comparison
public class Foo {
    boolean bar(String x) {
        return x.equals("2");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'equals')
            ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

3. This is a negative test case
```java
// ok, empty literal in .equals comparison
public class Foo {
    void bar(String str) {
        if ((str == null) || (str.equals(""))) {
            str = "snafu";
        }
        if (str == null || str.equals("")) {
            str = "snafu";
        }
        if ((str != null) && (str.equals(""))) {
            str = "snafu";
        }
        if (str != null && str.equals("")) {
            str = "snafu";
        }
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral

4. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug(Number number)
    {
        if (number.equals(new BigDecimal("123"))) {}
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bug')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'number')
      ――ASTBlock
        ――ASTIfStatement
          ――ASTMethodCall (called method name = 'equals')
            ――ASTVariableAccess (referenced variable name = 'number')
            ――ASTArgumentList (size = 1)
              ――ASTConstructorCall
                ――ASTClassOrInterfaceType (this is a class type)
                ――ASTArgumentList (size = 1)
                  ――ASTStringLiteral
          ――ASTBlock

5. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (str.equals(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'testMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTIfStatement
          ――ASTMethodCall (called method name = 'equals')
            ――ASTVariableAccess (referenced variable name = 'str')
            ――ASTArgumentList (size = 1)
              ――ASTMethodCall (called method name = 'getAnotherString')
                ――ASTArgumentList (size = 1)
                  ――ASTStringLiteral
          ――ASTBlock
    ――ASTMethodDeclaration (method name = 'getAnotherString')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'String')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTStringLiteral

6. This is a positive test case
```java
// #1256 PositionLiteralsFirstInComparisons .equals false positive with Characters
public class LiteralTest {
    protected final boolean check;
    public LiteralTest(Character c) {
        check = c.equals('x');
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'LiteralTest')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTPrimitiveType (this is a primitive type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'check')
    ――ASTConstructorDeclaration
      ――ASTModifierList
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'c')
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTAssignmentExpression
            ――ASTVariableAccess (referenced variable name = 'check')
            ――ASTMethodCall (called method name = 'equals')
              ――ASTVariableAccess (referenced variable name = 'c')
              ――ASTArgumentList (size = 1)
                ――ASTCharLiteral

7. This is a positive test case
```java
// ok, literal comes first in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".equalsIgnoreCase(x);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'equalsIgnoreCase')
            ――ASTStringLiteral
            ――ASTArgumentList (size = 1)
              ――ASTVariableAccess (referenced variable name = 'x')

8. This is a negative test case
```java
// bad, literal comes last in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'equalsIgnoreCase')
            ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

9. This is a positive test case
```java
// ok, testing .equalsIgnoreCase false positive
public class Foo {
    void bar() {
        if ((str == null) || (equalsIgnoreCase(""))) {
            str = "snafu";
        }
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTIfStatement
          ――ASTInfixExpression
            ――ASTInfixExpression
              ――ASTVariableAccess (referenced variable name = 'str')
              ――ASTNullLiteral
            ――ASTMethodCall (called method name = 'equalsIgnoreCase')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
          ――ASTBlock
            ――ASTExpressionStatement
              ――ASTAssignmentExpression
                ――ASTVariableAccess (referenced variable name = 'str')
                ――ASTStringLiteral

10. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug()
    {
        if (equalsIgnoreCase(new BigDecimal("123"))) {}
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTImportDeclaration
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bug')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTIfStatement
          ――ASTMethodCall (called method name = 'equalsIgnoreCase')
            ――ASTArgumentList (size = 1)
              ――ASTConstructorCall
                ――ASTClassOrInterfaceType (this is a class type)
                ――ASTArgumentList (size = 1)
                  ――ASTStringLiteral
          ――ASTBlock

11. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (equalsIgnoreCase(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'testMethod')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTIfStatement
          ――ASTMethodCall (called method name = 'equalsIgnoreCase')
            ――ASTArgumentList (size = 1)
              ――ASTMethodCall (called method name = 'getAnotherString')
                ――ASTArgumentList (size = 1)
                  ――ASTStringLiteral
          ――ASTBlock
    ――ASTMethodDeclaration (method name = 'getAnotherString')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'String')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTStringLiteral

12. This is a positive test case
```java
// ok, literal comes first in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareTo(x) < 0;
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTInfixExpression
            ――ASTMethodCall (called method name = 'compareTo')
              ――ASTStringLiteral
              ――ASTArgumentList (size = 1)
                ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTNumericLiteral

13. This is a negative test case
```java
// bad, literal comes last in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return x.compareTo("2") > 0;
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTInfixExpression
            ――ASTMethodCall (called method name = 'compareTo')
              ――ASTVariableAccess (referenced variable name = 'x')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
            ――ASTNumericLiteral

14. This is a positive test case
```java
// ok, testing for .compareTo false positive
public class Foo {
    boolean bar() {
        return compareTo("randomStringArg");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'compareTo')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

15. This is a positive test case
```java
// ok, literal comes first in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareToIgnoreCase(x) < 0;
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTInfixExpression
            ――ASTMethodCall (called method name = 'compareToIgnoreCase')
              ――ASTStringLiteral
              ――ASTArgumentList (size = 1)
                ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTNumericLiteral

16. This is a negative test case
```java
// bad, literal comes last in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.compareToIgnoreCase("2") > 0;
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTInfixExpression
            ――ASTMethodCall (called method name = 'compareToIgnoreCase')
              ――ASTVariableAccess (referenced variable name = 'x')
              ――ASTArgumentList (size = 1)
                ――ASTStringLiteral
            ――ASTNumericLiteral

17. This is a positive test case
```java
// ok, testing ,compareToIgnoreCase false positive
public class Foo {
    String bar() {
        return compareToIgnoreCase("randomStringArg");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTClassOrInterfaceType (method return type = 'String')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'compareToIgnoreCase')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

18. This is a positive test case
```java
// ok, literal comes first in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return "2".contentEquals(x);
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'contentEquals')
            ――ASTStringLiteral
            ――ASTArgumentList (size = 1)
              ――ASTVariableAccess (referenced variable name = 'x')

19. This is a negative test case
```java
// bad, literal comes last in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return x.contentEquals("2");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'contentEquals')
            ――ASTVariableAccess (referenced variable name = 'x')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral

20. This is a positive test case
```java
// ok, testing .contentEquals false positive
public class Foo {
    boolean bar(String x) {
        return contentEquals("2");
    }
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTPrimitiveType (method return type = 'boolean')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock
        ――ASTReturnStatement
          ――ASTMethodCall (called method name = 'contentEquals')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral



The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:
1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isSyntacticallyAbstract()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isVarargs(), //Returns true if this node's last formal parameter is varargs.
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()
7. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullCheck(net.sourceforge.pmd.lang.java.ast.ASTExpression, net.sourceforge.pmd.lang.java.rule.internal.StablePathMatcher)
8. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isBooleanLiteral(net.sourceforge.pmd.lang.java.ast.JavaNode), //Returns true if the node is a boolean literal with any value.
9. net.sourceforge.pmd.lang.java.ast.ASTCharLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
10. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
11. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
12. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
13. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
14. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean equals(java.lang.Object)
15. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isReferenceToVar(net.sourceforge.pmd.lang.java.ast.ASTExpression, java.util.Set), //Returns true if the expression is a {@link ASTNamedReferenceExpr} that references any of the symbol in the set.
16. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isNullLiteral(), //Returns true if this is the {@linkplain ASTNullLiteral null literal}.
17. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isEqualsMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
18. net.sourceforge.pmd.lang.java.ast.ASTArgumentList: public int size(), //Returns the number of nodes in this list. This must be the number of nodes yielded by the {@link #iterator()}.
19. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
20. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.document.Chars getText()

1.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
3.  //Check whether the method caller is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallerStringType(ASTMethodCall node){
    return TypeTestUtil.isA(String.class, node.getQualifier());
}
```
4.  //Get the type of argument
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getMethodCallArgumentType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror();
}
```
5.  //Check whether the return type of called method is string
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.JMethodSig;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnStringType(ASTMethodCall call) {
    JMethodSig m = call.getMethodType();
    return TypeTestUtil.isA(String.class, m.getReturnType());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:
1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


出现语法错误，这一轮舍弃，直接重新生成
5轮生成失败
结束

规则执行完毕，时间总花销： 1478.2474060058594 秒
