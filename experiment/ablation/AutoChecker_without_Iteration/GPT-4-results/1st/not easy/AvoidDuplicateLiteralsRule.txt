开始

========================================== Rule AvoidDuplicateLiteralsRule ===========================================
一共 11 个测试用例
正例 3 个
反例 8 个
94
78
144
127
12
9
157
137
23
19
114
98
107
91
10
8
38
34
40
37
11
9
15
13
11
8
85
71
96
81
19
14
149
133
97
91
12
10
9
7
12
10
92
78
9
7
85
71
96
79
27
17
77
63
12
10
119
103
97
81
30
28
90
76
=========================logics=========================
1. Get all string literals in the class.
2. Check whether the length of string literals is greater than or equal to 3.
3. Count occurrences of each string literal within the class.
4. Check whether any string literal occurs at least 4 times.

If there is a string literal with a length of 3 or more that occurs 4 or more times in the class, then this test case violates the rule.
*Get all string literals in the class.* 匹配到的元操作或API：
query: Get all string literals in the class.
most similar API: get class of string literal
cosine Similarity: 0.8472424149513245
*Check whether the length of string literals is greater than or equal to 3.* 匹配到的元操作或API：
query: Check whether the length of string literals is greater than or equal to 3.
most similar API: Check whether the string literal is long literal
cosine Similarity: 0.8359821438789368
*Count occurrences of each string literal within the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs at least 4 times.* 匹配到的元操作或API：
query: Check whether any string literal occurs at least 4 times.
most similar API: Check whether the string literal is double literal
cosine Similarity: 0.8010060787200928
111
94
99
82
=========================logics=========================
1. Get all string literals in the code.
2. Get the length of each string literal.
3. Filter out string literals with length less than 3.
4. Count occurrences of each string literal.
5. Check whether any string literal occurs 4 or more times.

Since the provided test case does not contain any string literals, it does not violate the rule regarding duplicate string literals with a threshold of 4. The number of violations is 0.
*Get all string literals in the code.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the length of each string literal.* 匹配到的元操作或API：
logic: Get the length of each string literal.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.9603046178817749
*Filter out string literals with length less than 3.* 匹配到的元操作或API：
未匹配成功元操作或API
*Count occurrences of each string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
94
78
97
81
87
72
83
69
117
102
93
78
=========================logics=========================
1. Get all fields declared in the class.
2. For each field, check whether the field is of array type.
3. If the field is an array, get the dimension of the array.
4. If the dimension is 1, get the one-dimensional array length.
5. For each element in the array, check if it is a string literal.
6. If it is a string literal, get the length of the string literal.
7. For each string literal with length >= 3, count occurrences in the array.
8. If any string literal occurs 4 or more times, note it as a violation.
9. Count the number of distinct string literals that violate the rule.
10. If the count of violating literals is at least 1, then the test case violates the rule exactly once.

*Get all fields declared in the class.* 匹配到的元操作或API：
query: Get all fields declared in the class.
most similar API: get declared annotations of field
cosine Similarity: 0.8222576975822449
*For each field, check whether the field is of array type.* 匹配到的元操作或API：
logic: For each field, check whether the field is of array type.
most similar meta operation: Check whether the field is array type
cosine Similarity: 0.9558621048927307
*If the field is an array, get the dimension of the array.* 匹配到的元操作或API：
logic: If the field is an array, get the dimension of the array.
most similar meta operation: Get the dimension of array
cosine Similarity: 0.8896278142929077
*If the dimension is 1, get the one-dimensional array length.* 匹配到的元操作或API：
logic: If the dimension is 1, get the one-dimensional array length.
most similar meta operation: Get the length of one dimension array
cosine Similarity: 0.9498072862625122
*For each element in the array, check if it is a string literal.* 匹配到的元操作或API：
query: For each element in the array, check if it is a string literal.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8905943632125854
*If it is a string literal, get the length of the string literal.* 匹配到的元操作或API：
logic: If it is a string literal, get the length of the string literal.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.9653066396713257
*For each string literal with length >= 3, count occurrences in the array.* 匹配到的元操作或API：
未匹配成功元操作或API
*If any string literal occurs 4 or more times, note it as a violation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Count the number of distinct string literals that violate the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the count of violating literals is at least 1, then the test case violates the rule exactly once.* 匹配到的元操作或API：
未匹配成功元操作或API
96
80
81
67
99
82
=========================logics=========================
1. Get all declared annotations in the class.
2. For each annotation, get its argument values.
3. Count occurrences of each string literal argument.
4. Filter out string literals with length less than 3.
5. Check whether any string literal occurs 4 or more times.
If a string literal with length 3 or more occurs 4 or more times in annotations, this test case violates the rule.
*Get all declared annotations in the class.* 匹配到的元操作或API：
logic: Get all declared annotations in the class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.8903629779815674
*For each annotation, get its argument values.* 匹配到的元操作或API：
query: For each annotation, get its argument values.
most similar API: for each of annotation
cosine Similarity: 0.8417031764984131
*Count occurrences of each string literal argument.* 匹配到的元操作或API：
未匹配成功元操作或API
*Filter out string literals with length less than 3.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
=========================logics=========================
1. Get all string literals in class.
2. Get the value of each string literal.
3. Get the length of string literal.
4. Check whether the length of string literal is greater or equal to 3.
5. Count occurrences of each string literal value in the class that have a length greater or equal to 3.
6. Check whether any string literal occurs 4 or more times.

If there's a string literal with a length of 3 or more that occurs 4 or more times, then the code violates the rule. However, since the given string "Howdy" occurs only twice, the number of violations is 0.
*Get all string literals in class.* 匹配到的元操作或API：
query: Get all string literals in class.
most similar API: get class of string literal
cosine Similarity: 0.8552722334861755
*Get the value of each string literal.* 匹配到的元操作或API：
logic: Get the value of each string literal.
most similar meta operation: Get the value of string literal
cosine Similarity: 0.9335806965827942
*Get the length of string literal.* 匹配到的元操作或API：
logic: Get the length of string literal.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.9875898957252502
*Check whether the length of string literal is greater or equal to 3.* 匹配到的元操作或API：
query: Check whether the length of string literal is greater or equal to 3.
most similar API: length of string literal
cosine Similarity: 0.8342752456665039
*Count occurrences of each string literal value in the class that have a length greater or equal to 3.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
=========================logics=========================
1. Get all string literals in the class.
2. Get the value of each string literal.
3. Check the length of each string literal.
4. If the length of the string literal is greater than or equal to 3, count its occurrences within the class.
5. If any string literal with a length of 3 or more occurs 4 or more times, it violates the rule.

To determine if the provided test case adheres to the rule, we will perform these checks on the given code segment:
```java
// exception list property
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
    }
    private void buz(String x) {}
}
```

Performing the checks:
1. "Howdy" and "foo" are the string literals in the class.
2. The values of the string literals are "Howdy" and "foo".
3. The length of "Howdy" is 5, which is greater than 3. The length of "foo" is also greater than 3.
4. The string "Howdy" occurs 4 times and the string "foo" also occurs 4 times.
5. Both strings violate the rule because they are longer than 3 characters and each occurs 4 times.

Based on the checks, there are indeed 2 instances where the rule is violated in the test case, matching the provided description.
*Get all string literals in the class.* 匹配到的元操作或API：
query: Get all string literals in the class.
most similar API: get class of string literal
cosine Similarity: 0.8472424149513245
*Get the value of each string literal.* 匹配到的元操作或API：
logic: Get the value of each string literal.
most similar meta operation: Get the value of string literal
cosine Similarity: 0.9335806965827942
*Check the length of each string literal.* 匹配到的元操作或API：
logic: Check the length of each string literal.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.9169607758522034
*If the length of the string literal is greater than or equal to 3, count its occurrences within the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*If any string literal with a length of 3 or more occurs 4 or more times, it violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*"Howdy" and "foo" are the string literals in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*The values of the string literals are "Howdy" and "foo".* 匹配到的元操作或API：
未匹配成功元操作或API
*The length of "Howdy" is 5, which is greater than 3. The length of "foo" is also greater than 3.* 匹配到的元操作或API：
未匹配成功元操作或API
*The string "Howdy" occurs 4 times and the string "foo" also occurs 4 times.* 匹配到的元操作或API：
未匹配成功元操作或API
*Both strings violate the rule because they are longer than 3 characters and each occurs 4 times.* 匹配到的元操作或API：
未匹配成功元操作或API
=========================logics=========================
1. Get all string literals in the class.
2. Filter out string literals with a length less than 3.
3. Count the occurrences of each string literal.
4. Check whether any string literal occurs 4 or more times.

If no string literal with a length of 3 or more occurs at least 4 times, then the number of violations of the rule in this test case is 0.
*Get all string literals in the class.* 匹配到的元操作或API：
query: Get all string literals in the class.
most similar API: get class of string literal
cosine Similarity: 0.8472424149513245
*Filter out string literals with a length less than 3.* 匹配到的元操作或API：
未匹配成功元操作或API
*Count the occurrences of each string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
=========================logics=========================
1. Get all string literals in the class.
2. Filter out string literals with length less than 3.
3. Count the occurrences of each string literal.
4. Check whether any string literal appears 4 or more times.

If any string literal with a length of 3 or more appears 4 or more times in the code, this test case violates the rule.
*Get all string literals in the class.* 匹配到的元操作或API：
query: Get all string literals in the class.
most similar API: get class of string literal
cosine Similarity: 0.8472424149513245
*Filter out string literals with length less than 3.* 匹配到的元操作或API：
未匹配成功元操作或API
*Count the occurrences of each string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal appears 4 or more times.* 匹配到的元操作或API：
query: Check whether any string literal appears 4 or more times.
most similar API: Check whether the string literal is double literal
cosine Similarity: 0.8034984469413757
=========================logics=========================
1. Get all string literals in the class.
2. Check whether the string literal length is greater than or equal to 3.
3. Count occurrences of each string literal that meets the length condition.
4. Check whether any string literal occurs 4 or more times.
If there is a string literal with a length of 3 or more that occurs at least 4 times, then this test case violates the rule. The number of violations is the count of distinct string literals that meet these conditions.
*Get all string literals in the class.* 匹配到的元操作或API：
query: Get all string literals in the class.
most similar API: get class of string literal
cosine Similarity: 0.8472424149513245
*Check whether the string literal length is greater than or equal to 3.* 匹配到的元操作或API：
query: Check whether the string literal length is greater than or equal to 3.
most similar API: Check whether the string literal is long literal
cosine Similarity: 0.8259308934211731
*Count occurrences of each string literal that meets the length condition.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
107
91
=========================logics=========================
1. Get all string literals in the class.
2. Filter out string literals with length less than 3.
3. Count occurrences of each string literal.
4. Check whether any string literal occurs 4 or more times.

If there is at least one string literal with a length of 3 or more that occurs 4 or more times in the class, then this test case violates the rule.
*Get all string literals in the class.* 匹配到的元操作或API：
query: Get all string literals in the class.
most similar API: get class of string literal
cosine Similarity: 0.8472424149513245
*Filter out string literals with length less than 3.* 匹配到的元操作或API：
未匹配成功元操作或API
*Count occurrences of each string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
=========================logics=========================
1. Get all declared annotations in the code.
2. For each annotation, get its parameters.
3. For each parameter, if it is a string literal, get the value of the string literal.
4. Get the length of each string literal value.
5. Omit string literals with length less than 3.
6. Count the occurrences of each string literal.
7. Check whether any string literal occurs 4 or more times.
If any string literal with a length of 3 or more occurs at least 4 times, then this test case violates the rule.
*Get all declared annotations in the code.* 匹配到的元操作或API：
logic: Get all declared annotations in the code.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.8584292531013489
*For each annotation, get its parameters.* 匹配到的元操作或API：
query: For each annotation, get its parameters.
most similar API: for each of annotation
cosine Similarity: 0.852763295173645
*For each parameter, if it is a string literal, get the value of the string literal.* 匹配到的元操作或API：
logic: For each parameter, if it is a string literal, get the value of the string literal.
most similar meta operation: Get the value of string literal
cosine Similarity: 0.891254186630249
*Get the length of each string literal value.* 匹配到的元操作或API：
logic: Get the length of each string literal value.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.9474939703941345
*Omit string literals with length less than 3.* 匹配到的元操作或API：
未匹配成功元操作或API
*Count the occurrences of each string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
==========================第1轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// duplicate literals in argument list
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

2. This is a positive test case
```java
// literal int argument, ok for now
public class Foo {
    private void bar() {
        buz(2);
    }
    private void buz(int x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTNumericLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTPrimitiveType (this is a primitive type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

3. This is a negative test case
```java
// duplicate literals in field decl
public class Foo {
    String[] FOO = {"foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"};
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTArrayType (this is a primitive type)
        ――ASTClassOrInterfaceType (this is a class type)
        ――ASTArrayDimensions
          ――ASTArrayTypeDim
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'FOO')
        ――ASTArrayInitializer
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral

4. This is a negative test case
```java
// duplicate literals in annotations, default case
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
  ――ASTClassOrInterfaceBody

5. This is a positive test case
```java
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

6. This is a negative test case
```java
// exception list property
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

7. This is a positive test case
```java
// exception list with escape
public class Foo {
    private void bar() {
        buz("Howdy,foo");
        buz("Howdy,foo");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

8. This is a negative test case
```java
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

9. This is a negative test case
```java
// minimum length property, default value
public class Foo {
    private void bar() {
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
        buz("fo"); buz("fo"); buz("fo"); buz("fo");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

10. This is a negative test case
```java
// #1425 Invalid XML Characters in Output
public class Duplicate {
    String s1 = "Tokenizer \ud801\udc1ctest";
    String s2 = "Tokenizer \ud801\udc1ctest";
    String s3 = "Tokenizer \ud801\udc1ctest";
    String s4 = "Tokenizer \ud801\udc1ctest";
    char c = '\uffef';
    char c\u0030 = 'a';
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Duplicate')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 's1')
        ――ASTStringLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 's2')
        ――ASTStringLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 's3')
        ――ASTStringLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 's4')
        ――ASTStringLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTPrimitiveType (this is a primitive type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'c')
        ――ASTCharLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTPrimitiveType (this is a primitive type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'c0')
        ――ASTCharLiteral

11. This is a negative test case
```java
// Duplicated string literals as annotation parameter
public class AnnotationParams {
    public static void foo(@SuppressWarnings("unused") Object str,
                           @SuppressWarnings("unused") String str2,
                           @SuppressWarnings("unused") String str3,
                           @SuppressWarnings("unused") String str4) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'AnnotationParams')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 4)
        ――ASTFormalParameter
          ――ASTModifierList
            ――ASTAnnotation
              ――ASTClassOrInterfaceType (this is a class type)
              ――ASTAnnotationMemberList
                ――ASTMemberValuePair
                  ――ASTStringLiteral
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
        ――ASTFormalParameter
          ――ASTModifierList
            ――ASTAnnotation
              ――ASTClassOrInterfaceType (this is a class type)
              ――ASTAnnotationMemberList
                ――ASTMemberValuePair
                  ――ASTStringLiteral
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str2')
        ――ASTFormalParameter
          ――ASTModifierList
            ――ASTAnnotation
              ――ASTClassOrInterfaceType (this is a class type)
              ――ASTAnnotationMemberList
                ――ASTMemberValuePair
                  ――ASTStringLiteral
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str3')
        ――ASTFormalParameter
          ――ASTModifierList
            ――ASTAnnotation
              ――ASTClassOrInterfaceType (this is a class type)
              ――ASTAnnotationMemberList
                ――ASTMemberValuePair
                  ――ASTStringLiteral
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str4')
      ――ASTBlock



The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:
1. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.Class<Class<?> getClass()
2. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isLongLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral long integer literal}.
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isDoubleLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral double literal}.
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length()
5. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
8. net.sourceforge.pmd.lang.java.ast.ASTAnnotation: public void forEach(java.util.function.Consumer)
9. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.String getConstValue()
10. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length(), //Length of the constant value in characters.

1.  //Check whether the field is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isFieldArrayType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```
2.  //Get the dimension of array
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimensions;
public int getArrayDimension(ASTVariableDeclaratorId varId) {
    int dimension = 0;
    if(varId.getType().isArray()){
        ASTArrayType arrayType = (ASTArrayType)varId.getTypeNode();
        ASTArrayDimensions arrayTypeDimensions = arrayType.getDimensions();
        dimension = arrayTypeDimensions.size();
    }
    return dimension;
}
```
3.  //Get the length of one dimension array
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimensions;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimExpr;
import net.sourceforge.pmd.lang.java.ast.ASTArrayAllocation;
import net.sourceforge.pmd.lang.java.ast.ASTArrayInitializer;
import net.sourceforge.pmd.lang.java.ast.ASTNumericLiteral;
public int getLengthOfOneDimensionArray(ASTVariableDeclaratorId varId) {
    int arrayLen = 0;
    int dimension;
    if (varId.getType().isArray()) {
        ASTArrayType arrayType = (ASTArrayType) varId.getTypeNode();
        ASTArrayDimensions arrayTypeDimensions = arrayType.getDimensions();
        dimension = arrayTypeDimensions.size();
        if (dimension == 1) {
            ASTArrayAllocation arrayAllocation = varId.getParent().firstChild(ASTArrayAllocation.class);
            if (arrayAllocation != null) {
                ASTArrayInitializer arrayInitializer = arrayAllocation.firstChild(ASTArrayInitializer.class);
                if (arrayInitializer != null) {
                    arrayLen = arrayInitializer.length();
                } else {
                    ASTArrayDimensions astArrayTypeDims = arrayAllocation.descendants(ASTArrayDimensions.class).first();
                    ASTArrayDimExpr arrayDimExpr = (ASTArrayDimExpr) astArrayTypeDims.get(0);
                    if (arrayDimExpr.getLengthExpression() instanceof ASTNumericLiteral) {
                        arrayLen = ((ASTNumericLiteral) arrayDimExpr.getLengthExpression()).getValueAsInt();
                    }
                }
            }
        }
    }
    return arrayLen;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:
1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


出现语法错误，这一轮舍弃，直接重新生成
==========================第2轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// duplicate literals in argument list
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

2. This is a positive test case
```java
// literal int argument, ok for now
public class Foo {
    private void bar() {
        buz(2);
    }
    private void buz(int x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTNumericLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTPrimitiveType (this is a primitive type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

3. This is a negative test case
```java
// duplicate literals in field decl
public class Foo {
    String[] FOO = {"foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"};
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTArrayType (this is a primitive type)
        ――ASTClassOrInterfaceType (this is a class type)
        ――ASTArrayDimensions
          ――ASTArrayTypeDim
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'FOO')
        ――ASTArrayInitializer
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral

4. This is a negative test case
```java
// duplicate literals in annotations, default case
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
  ――ASTClassOrInterfaceBody

5. This is a positive test case
```java
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

6. This is a negative test case
```java
// exception list property
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

7. This is a positive test case
```java
// exception list with escape
public class Foo {
    private void bar() {
        buz("Howdy,foo");
        buz("Howdy,foo");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

8. This is a negative test case
```java
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

9. This is a negative test case
```java
// minimum length property, default value
public class Foo {
    private void bar() {
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
        buz("fo"); buz("fo"); buz("fo"); buz("fo");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

10. This is a negative test case
```java
// #1425 Invalid XML Characters in Output
public class Duplicate {
    String s1 = "Tokenizer \ud801\udc1ctest";
    String s2 = "Tokenizer \ud801\udc1ctest";
    String s3 = "Tokenizer \ud801\udc1ctest";
    String s4 = "Tokenizer \ud801\udc1ctest";
    char c = '\uffef';
    char c\u0030 = 'a';
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Duplicate')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 's1')
        ――ASTStringLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 's2')
        ――ASTStringLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 's3')
        ――ASTStringLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 's4')
        ――ASTStringLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTPrimitiveType (this is a primitive type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'c')
        ――ASTCharLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTPrimitiveType (this is a primitive type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'c0')
        ――ASTCharLiteral

11. This is a negative test case
```java
// Duplicated string literals as annotation parameter
public class AnnotationParams {
    public static void foo(@SuppressWarnings("unused") Object str,
                           @SuppressWarnings("unused") String str2,
                           @SuppressWarnings("unused") String str3,
                           @SuppressWarnings("unused") String str4) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'AnnotationParams')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 4)
        ――ASTFormalParameter
          ――ASTModifierList
            ――ASTAnnotation
              ――ASTClassOrInterfaceType (this is a class type)
              ――ASTAnnotationMemberList
                ――ASTMemberValuePair
                  ――ASTStringLiteral
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
        ――ASTFormalParameter
          ――ASTModifierList
            ――ASTAnnotation
              ――ASTClassOrInterfaceType (this is a class type)
              ――ASTAnnotationMemberList
                ――ASTMemberValuePair
                  ――ASTStringLiteral
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str2')
        ――ASTFormalParameter
          ――ASTModifierList
            ――ASTAnnotation
              ――ASTClassOrInterfaceType (this is a class type)
              ――ASTAnnotationMemberList
                ――ASTMemberValuePair
                  ――ASTStringLiteral
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str3')
        ――ASTFormalParameter
          ――ASTModifierList
            ――ASTAnnotation
              ――ASTClassOrInterfaceType (this is a class type)
              ――ASTAnnotationMemberList
                ――ASTMemberValuePair
                  ――ASTStringLiteral
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str4')
      ――ASTBlock



The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:
1. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.Class<Class<?> getClass()
2. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isLongLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral long integer literal}.
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isDoubleLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral double literal}.
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length()
5. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
8. net.sourceforge.pmd.lang.java.ast.ASTAnnotation: public void forEach(java.util.function.Consumer)
9. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.String getConstValue()
10. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length(), //Length of the constant value in characters.

1.  //Check whether the field is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isFieldArrayType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```
2.  //Get the dimension of array
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimensions;
public int getArrayDimension(ASTVariableDeclaratorId varId) {
    int dimension = 0;
    if(varId.getType().isArray()){
        ASTArrayType arrayType = (ASTArrayType)varId.getTypeNode();
        ASTArrayDimensions arrayTypeDimensions = arrayType.getDimensions();
        dimension = arrayTypeDimensions.size();
    }
    return dimension;
}
```
3.  //Get the length of one dimension array
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimensions;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimExpr;
import net.sourceforge.pmd.lang.java.ast.ASTArrayAllocation;
import net.sourceforge.pmd.lang.java.ast.ASTArrayInitializer;
import net.sourceforge.pmd.lang.java.ast.ASTNumericLiteral;
public int getLengthOfOneDimensionArray(ASTVariableDeclaratorId varId) {
    int arrayLen = 0;
    int dimension;
    if (varId.getType().isArray()) {
        ASTArrayType arrayType = (ASTArrayType) varId.getTypeNode();
        ASTArrayDimensions arrayTypeDimensions = arrayType.getDimensions();
        dimension = arrayTypeDimensions.size();
        if (dimension == 1) {
            ASTArrayAllocation arrayAllocation = varId.getParent().firstChild(ASTArrayAllocation.class);
            if (arrayAllocation != null) {
                ASTArrayInitializer arrayInitializer = arrayAllocation.firstChild(ASTArrayInitializer.class);
                if (arrayInitializer != null) {
                    arrayLen = arrayInitializer.length();
                } else {
                    ASTArrayDimensions astArrayTypeDims = arrayAllocation.descendants(ASTArrayDimensions.class).first();
                    ASTArrayDimExpr arrayDimExpr = (ASTArrayDimExpr) astArrayTypeDims.get(0);
                    if (arrayDimExpr.getLengthExpression() instanceof ASTNumericLiteral) {
                        arrayLen = ((ASTNumericLiteral) arrayDimExpr.getLengthExpression()).getValueAsInt();
                    }
                }
            }
        }
    }
    return arrayLen;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:
1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


出现语法错误，这一轮舍弃，直接重新生成
==========================第3轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// duplicate literals in argument list
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

2. This is a positive test case
```java
// literal int argument, ok for now
public class Foo {
    private void bar() {
        buz(2);
    }
    private void buz(int x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTNumericLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTPrimitiveType (this is a primitive type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

3. This is a negative test case
```java
// duplicate literals in field decl
public class Foo {
    String[] FOO = {"foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"};
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTArrayType (this is a primitive type)
        ――ASTClassOrInterfaceType (this is a class type)
        ――ASTArrayDimensions
          ――ASTArrayTypeDim
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'FOO')
        ――ASTArrayInitializer
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral

4. This is a negative test case
```java
// duplicate literals in annotations, default case
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
  ――ASTClassOrInterfaceBody

5. This is a positive test case
```java
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

6. This is a negative test case
```java
// exception list property
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

7. This is a positive test case
```java
// exception list with escape
public class Foo {
    private void bar() {
        buz("Howdy,foo");
        buz("Howdy,foo");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

8. This is a negative test case
```java
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

9. This is a negative test case
```java
// minimum length property, default value
public class Foo {
    private void bar() {
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
        buz("fo"); buz("fo"); buz("fo"); buz("fo");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

10. This is a negative test case
```java
// #1425 Invalid XML Characters in Output
public class Duplicate {
    String s1 = "Tokenizer \ud801\udc1ctest";
    String s2 = "Tokenizer \ud801\udc1ctest";
    String s3 = "Tokenizer \ud801\udc1ctest";
    String s4 = "Tokenizer \ud801\udc1ctest";
    char c = '\uffef';
    char c\u0030 = 'a';
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Duplicate')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 's1')
        ――ASTStringLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 's2')
        ――ASTStringLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 's3')
        ――ASTStringLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 's4')
        ――ASTStringLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTPrimitiveType (this is a primitive type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'c')
        ――ASTCharLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTPrimitiveType (this is a primitive type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'c0')
        ――ASTCharLiteral

11. This is a negative test case
```java
// Duplicated string literals as annotation parameter
public class AnnotationParams {
    public static void foo(@SuppressWarnings("unused") Object str,
                           @SuppressWarnings("unused") String str2,
                           @SuppressWarnings("unused") String str3,
                           @SuppressWarnings("unused") String str4) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'AnnotationParams')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 4)
        ――ASTFormalParameter
          ――ASTModifierList
            ――ASTAnnotation
              ――ASTClassOrInterfaceType (this is a class type)
              ――ASTAnnotationMemberList
                ――ASTMemberValuePair
                  ――ASTStringLiteral
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
        ――ASTFormalParameter
          ――ASTModifierList
            ――ASTAnnotation
              ――ASTClassOrInterfaceType (this is a class type)
              ――ASTAnnotationMemberList
                ――ASTMemberValuePair
                  ――ASTStringLiteral
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str2')
        ――ASTFormalParameter
          ――ASTModifierList
            ――ASTAnnotation
              ――ASTClassOrInterfaceType (this is a class type)
              ――ASTAnnotationMemberList
                ――ASTMemberValuePair
                  ――ASTStringLiteral
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str3')
        ――ASTFormalParameter
          ――ASTModifierList
            ――ASTAnnotation
              ――ASTClassOrInterfaceType (this is a class type)
              ――ASTAnnotationMemberList
                ――ASTMemberValuePair
                  ――ASTStringLiteral
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str4')
      ――ASTBlock



The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:
1. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.Class<Class<?> getClass()
2. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isLongLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral long integer literal}.
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isDoubleLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral double literal}.
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length()
5. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
8. net.sourceforge.pmd.lang.java.ast.ASTAnnotation: public void forEach(java.util.function.Consumer)
9. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.String getConstValue()
10. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length(), //Length of the constant value in characters.

1.  //Check whether the field is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isFieldArrayType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```
2.  //Get the dimension of array
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimensions;
public int getArrayDimension(ASTVariableDeclaratorId varId) {
    int dimension = 0;
    if(varId.getType().isArray()){
        ASTArrayType arrayType = (ASTArrayType)varId.getTypeNode();
        ASTArrayDimensions arrayTypeDimensions = arrayType.getDimensions();
        dimension = arrayTypeDimensions.size();
    }
    return dimension;
}
```
3.  //Get the length of one dimension array
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimensions;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimExpr;
import net.sourceforge.pmd.lang.java.ast.ASTArrayAllocation;
import net.sourceforge.pmd.lang.java.ast.ASTArrayInitializer;
import net.sourceforge.pmd.lang.java.ast.ASTNumericLiteral;
public int getLengthOfOneDimensionArray(ASTVariableDeclaratorId varId) {
    int arrayLen = 0;
    int dimension;
    if (varId.getType().isArray()) {
        ASTArrayType arrayType = (ASTArrayType) varId.getTypeNode();
        ASTArrayDimensions arrayTypeDimensions = arrayType.getDimensions();
        dimension = arrayTypeDimensions.size();
        if (dimension == 1) {
            ASTArrayAllocation arrayAllocation = varId.getParent().firstChild(ASTArrayAllocation.class);
            if (arrayAllocation != null) {
                ASTArrayInitializer arrayInitializer = arrayAllocation.firstChild(ASTArrayInitializer.class);
                if (arrayInitializer != null) {
                    arrayLen = arrayInitializer.length();
                } else {
                    ASTArrayDimensions astArrayTypeDims = arrayAllocation.descendants(ASTArrayDimensions.class).first();
                    ASTArrayDimExpr arrayDimExpr = (ASTArrayDimExpr) astArrayTypeDims.get(0);
                    if (arrayDimExpr.getLengthExpression() instanceof ASTNumericLiteral) {
                        arrayLen = ((ASTNumericLiteral) arrayDimExpr.getLengthExpression()).getValueAsInt();
                    }
                }
            }
        }
    }
    return arrayLen;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:
1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


出现语法错误，这一轮舍弃，直接重新生成
==========================第4轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// duplicate literals in argument list
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

2. This is a positive test case
```java
// literal int argument, ok for now
public class Foo {
    private void bar() {
        buz(2);
    }
    private void buz(int x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTNumericLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTPrimitiveType (this is a primitive type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

3. This is a negative test case
```java
// duplicate literals in field decl
public class Foo {
    String[] FOO = {"foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"};
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTArrayType (this is a primitive type)
        ――ASTClassOrInterfaceType (this is a class type)
        ――ASTArrayDimensions
          ――ASTArrayTypeDim
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'FOO')
        ――ASTArrayInitializer
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral

4. This is a negative test case
```java
// duplicate literals in annotations, default case
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
  ――ASTClassOrInterfaceBody

5. This is a positive test case
```java
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

6. This is a negative test case
```java
// exception list property
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

7. This is a positive test case
```java
// exception list with escape
public class Foo {
    private void bar() {
        buz("Howdy,foo");
        buz("Howdy,foo");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

8. This is a negative test case
```java
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

9. This is a negative test case
```java
// minimum length property, default value
public class Foo {
    private void bar() {
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
        buz("fo"); buz("fo"); buz("fo"); buz("fo");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

10. This is a negative test case
```java
// #1425 Invalid XML Characters in Output
public class Duplicate {
    String s1 = "Tokenizer \ud801\udc1ctest";
    String s2 = "Tokenizer \ud801\udc1ctest";
    String s3 = "Tokenizer \ud801\udc1ctest";
    String s4 = "Tokenizer \ud801\udc1ctest";
    char c = '\uffef';
    char c\u0030 = 'a';
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Duplicate')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 's1')
        ――ASTStringLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 's2')
        ――ASTStringLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 's3')
        ――ASTStringLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 's4')
        ――ASTStringLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTPrimitiveType (this is a primitive type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'c')
        ――ASTCharLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTPrimitiveType (this is a primitive type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'c0')
        ――ASTCharLiteral

11. This is a negative test case
```java
// Duplicated string literals as annotation parameter
public class AnnotationParams {
    public static void foo(@SuppressWarnings("unused") Object str,
                           @SuppressWarnings("unused") String str2,
                           @SuppressWarnings("unused") String str3,
                           @SuppressWarnings("unused") String str4) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'AnnotationParams')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 4)
        ――ASTFormalParameter
          ――ASTModifierList
            ――ASTAnnotation
              ――ASTClassOrInterfaceType (this is a class type)
              ――ASTAnnotationMemberList
                ――ASTMemberValuePair
                  ――ASTStringLiteral
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
        ――ASTFormalParameter
          ――ASTModifierList
            ――ASTAnnotation
              ――ASTClassOrInterfaceType (this is a class type)
              ――ASTAnnotationMemberList
                ――ASTMemberValuePair
                  ――ASTStringLiteral
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str2')
        ――ASTFormalParameter
          ――ASTModifierList
            ――ASTAnnotation
              ――ASTClassOrInterfaceType (this is a class type)
              ――ASTAnnotationMemberList
                ――ASTMemberValuePair
                  ――ASTStringLiteral
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str3')
        ――ASTFormalParameter
          ――ASTModifierList
            ――ASTAnnotation
              ――ASTClassOrInterfaceType (this is a class type)
              ――ASTAnnotationMemberList
                ――ASTMemberValuePair
                  ――ASTStringLiteral
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str4')
      ――ASTBlock



The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:
1. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.Class<Class<?> getClass()
2. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isLongLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral long integer literal}.
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isDoubleLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral double literal}.
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length()
5. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
8. net.sourceforge.pmd.lang.java.ast.ASTAnnotation: public void forEach(java.util.function.Consumer)
9. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.String getConstValue()
10. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length(), //Length of the constant value in characters.

1.  //Check whether the field is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isFieldArrayType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```
2.  //Get the dimension of array
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimensions;
public int getArrayDimension(ASTVariableDeclaratorId varId) {
    int dimension = 0;
    if(varId.getType().isArray()){
        ASTArrayType arrayType = (ASTArrayType)varId.getTypeNode();
        ASTArrayDimensions arrayTypeDimensions = arrayType.getDimensions();
        dimension = arrayTypeDimensions.size();
    }
    return dimension;
}
```
3.  //Get the length of one dimension array
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimensions;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimExpr;
import net.sourceforge.pmd.lang.java.ast.ASTArrayAllocation;
import net.sourceforge.pmd.lang.java.ast.ASTArrayInitializer;
import net.sourceforge.pmd.lang.java.ast.ASTNumericLiteral;
public int getLengthOfOneDimensionArray(ASTVariableDeclaratorId varId) {
    int arrayLen = 0;
    int dimension;
    if (varId.getType().isArray()) {
        ASTArrayType arrayType = (ASTArrayType) varId.getTypeNode();
        ASTArrayDimensions arrayTypeDimensions = arrayType.getDimensions();
        dimension = arrayTypeDimensions.size();
        if (dimension == 1) {
            ASTArrayAllocation arrayAllocation = varId.getParent().firstChild(ASTArrayAllocation.class);
            if (arrayAllocation != null) {
                ASTArrayInitializer arrayInitializer = arrayAllocation.firstChild(ASTArrayInitializer.class);
                if (arrayInitializer != null) {
                    arrayLen = arrayInitializer.length();
                } else {
                    ASTArrayDimensions astArrayTypeDims = arrayAllocation.descendants(ASTArrayDimensions.class).first();
                    ASTArrayDimExpr arrayDimExpr = (ASTArrayDimExpr) astArrayTypeDims.get(0);
                    if (arrayDimExpr.getLengthExpression() instanceof ASTNumericLiteral) {
                        arrayLen = ((ASTNumericLiteral) arrayDimExpr.getLengthExpression()).getValueAsInt();
                    }
                }
            }
        }
    }
    return arrayLen;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:
1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;


import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {

    private static final IntegerProperty LITERAL_LENGTH_THRESHOLD = new IntegerProperty(
            "minimumLength",
            "Minimum length of strings to be considered",
            3,
            100,
            3,
            1.0f
    );

    private static final IntegerProperty DUPLICATE_THRESHOLD = new IntegerProperty(
            "threshold",
            "Minimum number of duplicates to trigger a violation",
            1,
            100,
            4,
            1.0f
    );

    private Map<String, Integer> stringLiterals = new HashMap<>();

    public AvoidDuplicateLiteralsRule() {
        super(ASTCompilationUnit.class);
        definePropertyDescriptor(LITERAL_LENGTH_THRESHOLD);
        definePropertyDescriptor(DUPLICATE_THRESHOLD);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        stringLiterals.clear();
        super.visit(node, data);
        int threshold = getProperty(DUPLICATE_THRESHOLD);
        stringLiterals.entrySet().stream()
                .filter(entry -> entry.getValue() >= threshold)
                .forEach(entry -> addViolation(data, node, new Object[]{entry.getKey()}));
        return data;
    }

    @Override
    public Object visit(ASTStringLiteral node, Object data) {
        String literal = node.getImage();
        if (literal != null) {
            int minLength = getProperty(LITERAL_LENGTH_THRESHOLD);
            if (literal.length() >= minLength) {
                stringLiterals.put(literal, stringLiterals.getOrDefault(literal, 0) + 1);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
=======================第一个测试用例生成的checker repair_compile_error_query======================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
Here is a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {

    private static final IntegerProperty LITERAL_LENGTH_THRESHOLD = new IntegerProperty(
            "minimumLength",
            "Minimum length of strings to be considered",
            3,
            100,
            3,
            1.0f
    );

    private static final IntegerProperty DUPLICATE_THRESHOLD = new IntegerProperty(
            "threshold",
            "Minimum number of duplicates to trigger a violation",
            1,
            100,
            4,
            1.0f
    );

    private Map<String, Integer> stringLiterals = new HashMap<>();

    public AvoidDuplicateLiteralsRule() {
        super(ASTCompilationUnit.class);
        definePropertyDescriptor(LITERAL_LENGTH_THRESHOLD);
        definePropertyDescriptor(DUPLICATE_THRESHOLD);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        stringLiterals.clear();
        super.visit(node, data);
        int threshold = getProperty(DUPLICATE_THRESHOLD);
        stringLiterals.entrySet().stream()
                .filter(entry -> entry.getValue() >= threshold)
                .forEach(entry -> addViolation(data, node, new Object[]{entry.getKey()}));
        return data;
    }

    @Override
    public Object visit(ASTStringLiteral node, Object data) {
        String literal = node.getImage();
        if (literal != null) {
            int minLength = getProperty(LITERAL_LENGTH_THRESHOLD);
            if (literal.length() >= minLength) {
                stringLiterals.put(literal, stringLiterals.getOrDefault(literal, 0) + 1);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker is compiled failed, and the failure info is:
IntegerProperty class is not correctly imported

Please help me repair this checker and give me repaired complete checker code.
You should keep code that is unrelated to failure info unchanged. 

第 2轮修复编译错误的结果
==========修复编译错误后的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {

    private static final IntegerProperty LITERAL_LENGTH_THRESHOLD = new IntegerProperty(
            "minimumLength",
            "Minimum length of strings to be considered",
            3,
            100,
            3,
            1.0f
    );

    private static final IntegerProperty DUPLICATE_THRESHOLD = new IntegerProperty(
            "threshold",
            "Minimum number of duplicates to trigger a violation",
            1,
            100,
            4,
            1.0f
    );

    private Map<String, Integer> stringLiterals = new HashMap<>();

    public AvoidDuplicateLiteralsRule() {
        super(ASTCompilationUnit.class);
        definePropertyDescriptor(LITERAL_LENGTH_THRESHOLD);
        definePropertyDescriptor(DUPLICATE_THRESHOLD);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        stringLiterals.clear();
        super.visit(node, data);
        int threshold = getProperty(DUPLICATE_THRESHOLD);
        stringLiterals.entrySet().stream()
                .filter(entry -> entry.getValue() >= threshold)
                .forEach(entry -> addViolation(data, node, new Object[]{entry.getKey()}));
        return data;
    }

    @Override
    public Object visit(ASTStringLiteral node, Object data) {
        String literal = node.getImage();
        if (literal != null) {
            int minLength = getProperty(LITERAL_LENGTH_THRESHOLD);
            if (literal.length() >= minLength) {
                stringLiterals.put(literal, stringLiterals.getOrDefault(literal, 0) + 1);
            }
        }
        return super.visit(node, data);
    }
}
编译错误
=======================第一个测试用例生成的checker repair_compile_error_query======================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
Here is a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {

    private static final IntegerProperty LITERAL_LENGTH_THRESHOLD = new IntegerProperty(
            "minimumLength",
            "Minimum length of strings to be considered",
            3,
            100,
            3,
            1.0f
    );

    private static final IntegerProperty DUPLICATE_THRESHOLD = new IntegerProperty(
            "threshold",
            "Minimum number of duplicates to trigger a violation",
            1,
            100,
            4,
            1.0f
    );

    private Map<String, Integer> stringLiterals = new HashMap<>();

    public AvoidDuplicateLiteralsRule() {
        super(ASTCompilationUnit.class);
        definePropertyDescriptor(LITERAL_LENGTH_THRESHOLD);
        definePropertyDescriptor(DUPLICATE_THRESHOLD);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        stringLiterals.clear();
        super.visit(node, data);
        int threshold = getProperty(DUPLICATE_THRESHOLD);
        stringLiterals.entrySet().stream()
                .filter(entry -> entry.getValue() >= threshold)
                .forEach(entry -> addViolation(data, node, new Object[]{entry.getKey()}));
        return data;
    }

    @Override
    public Object visit(ASTStringLiteral node, Object data) {
        String literal = node.getImage();
        if (literal != null) {
            int minLength = getProperty(LITERAL_LENGTH_THRESHOLD);
            if (literal.length() >= minLength) {
                stringLiterals.put(literal, stringLiterals.getOrDefault(literal, 0) + 1);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker is compiled failed, and the failure info is:
IntegerProperty class is not correctly imported

Please help me repair this checker and give me repaired complete checker code.
You should keep code that is unrelated to failure info unchanged. 

第 3轮修复编译错误的结果
==========修复编译错误后的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {

    private static final IntegerProperty LITERAL_LENGTH_THRESHOLD = new IntegerProperty(
            "minimumLength",
            "Minimum length of strings to be considered",
            3,
            100,
            3,
            1.0f
    );

    private static final IntegerProperty DUPLICATE_THRESHOLD = new IntegerProperty(
            "threshold",
            "Minimum number of duplicates to trigger a violation",
            1,
            100,
            4,
            1.0f
    );

    private Map<String, Integer> stringLiterals = new HashMap<>();

    public AvoidDuplicateLiteralsRule() {
        super(ASTCompilationUnit.class);
        definePropertyDescriptor(LITERAL_LENGTH_THRESHOLD);
        definePropertyDescriptor(DUPLICATE_THRESHOLD);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        stringLiterals.clear();
        super.visit(node, data);
        int threshold = getProperty(DUPLICATE_THRESHOLD);
        stringLiterals.entrySet().stream()
                .filter(entry -> entry.getValue() >= threshold)
                .forEach(entry -> addViolation(data, node, new Object[]{entry.getKey()}));
        return data;
    }

    @Override
    public Object visit(ASTStringLiteral node, Object data) {
        String literal = node.getImage();
        if (literal != null) {
            int minLength = getProperty(LITERAL_LENGTH_THRESHOLD);
            if (literal.length() >= minLength) {
                stringLiterals.put(literal, stringLiterals.getOrDefault(literal, 0) + 1);
            }
        }
        return super.visit(node, data);
    }
}
编译错误
 ======================第一个测试用例生成的checker 2轮 内编译修复不成功，重新来一轮生成checker============
==========================第5轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// duplicate literals in argument list
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

2. This is a positive test case
```java
// literal int argument, ok for now
public class Foo {
    private void bar() {
        buz(2);
    }
    private void buz(int x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTNumericLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTPrimitiveType (this is a primitive type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

3. This is a negative test case
```java
// duplicate literals in field decl
public class Foo {
    String[] FOO = {"foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"};
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTArrayType (this is a primitive type)
        ――ASTClassOrInterfaceType (this is a class type)
        ――ASTArrayDimensions
          ――ASTArrayTypeDim
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'FOO')
        ――ASTArrayInitializer
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral
          ――ASTStringLiteral

4. This is a negative test case
```java
// duplicate literals in annotations, default case
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
    ――ASTAnnotation
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTAnnotationMemberList
        ――ASTMemberValuePair
          ――ASTStringLiteral
  ――ASTClassOrInterfaceBody

5. This is a positive test case
```java
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

6. This is a negative test case
```java
// exception list property
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

7. This is a positive test case
```java
// exception list with escape
public class Foo {
    private void bar() {
        buz("Howdy,foo");
        buz("Howdy,foo");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

8. This is a negative test case
```java
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

9. This is a negative test case
```java
// minimum length property, default value
public class Foo {
    private void bar() {
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
        buz("fo"); buz("fo"); buz("fo"); buz("fo");
    }
    private void buz(String x) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'bar')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 0)
      ――ASTBlock
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
        ――ASTExpressionStatement
          ――ASTMethodCall (called method name = 'buz')
            ――ASTArgumentList (size = 1)
              ――ASTStringLiteral
    ――ASTMethodDeclaration (method name = 'buz')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 1)
        ――ASTFormalParameter
          ――ASTModifierList
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'x')
      ――ASTBlock

10. This is a negative test case
```java
// #1425 Invalid XML Characters in Output
public class Duplicate {
    String s1 = "Tokenizer \ud801\udc1ctest";
    String s2 = "Tokenizer \ud801\udc1ctest";
    String s3 = "Tokenizer \ud801\udc1ctest";
    String s4 = "Tokenizer \ud801\udc1ctest";
    char c = '\uffef';
    char c\u0030 = 'a';
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'Duplicate')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 's1')
        ――ASTStringLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 's2')
        ――ASTStringLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 's3')
        ――ASTStringLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTClassOrInterfaceType (this is a class type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 's4')
        ――ASTStringLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTPrimitiveType (this is a primitive type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'c')
        ――ASTCharLiteral
    ――ASTFieldDeclaration
      ――ASTModifierList
      ――ASTPrimitiveType (this is a primitive type)
      ――ASTVariableDeclarator
        ――ASTVariableDeclaratorId (declared variable name = 'c0')
        ――ASTCharLiteral

11. This is a negative test case
```java
// Duplicated string literals as annotation parameter
public class AnnotationParams {
    public static void foo(@SuppressWarnings("unused") Object str,
                           @SuppressWarnings("unused") String str2,
                           @SuppressWarnings("unused") String str3,
                           @SuppressWarnings("unused") String str4) {}
}
```
Its abstract syntax tree is:
ASTCompilationUnit
――ASTClassOrInterfaceDeclaration (class name = 'AnnotationParams')
  ――ASTModifierList
  ――ASTClassOrInterfaceBody
    ――ASTMethodDeclaration (method name = 'foo')
      ――ASTModifierList
      ――ASTVoidType (method return type = 'void')
      ――ASTFormalParameters (size = 4)
        ――ASTFormalParameter
          ――ASTModifierList
            ――ASTAnnotation
              ――ASTClassOrInterfaceType (this is a class type)
              ――ASTAnnotationMemberList
                ――ASTMemberValuePair
                  ――ASTStringLiteral
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str')
        ――ASTFormalParameter
          ――ASTModifierList
            ――ASTAnnotation
              ――ASTClassOrInterfaceType (this is a class type)
              ――ASTAnnotationMemberList
                ――ASTMemberValuePair
                  ――ASTStringLiteral
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str2')
        ――ASTFormalParameter
          ――ASTModifierList
            ――ASTAnnotation
              ――ASTClassOrInterfaceType (this is a class type)
              ――ASTAnnotationMemberList
                ――ASTMemberValuePair
                  ――ASTStringLiteral
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str3')
        ――ASTFormalParameter
          ――ASTModifierList
            ――ASTAnnotation
              ――ASTClassOrInterfaceType (this is a class type)
              ――ASTAnnotationMemberList
                ――ASTMemberValuePair
                  ――ASTStringLiteral
          ――ASTClassOrInterfaceType (this is a class type)
          ――ASTVariableDeclaratorId (declared variable name = 'str4')
      ――ASTBlock



The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:
1. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.Class<Class<?> getClass()
2. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isLongLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral long integer literal}.
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isDoubleLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral double literal}.
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length()
5. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
8. net.sourceforge.pmd.lang.java.ast.ASTAnnotation: public void forEach(java.util.function.Consumer)
9. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.String getConstValue()
10. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length(), //Length of the constant value in characters.

1.  //Check whether the field is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isFieldArrayType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```
2.  //Get the dimension of array
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimensions;
public int getArrayDimension(ASTVariableDeclaratorId varId) {
    int dimension = 0;
    if(varId.getType().isArray()){
        ASTArrayType arrayType = (ASTArrayType)varId.getTypeNode();
        ASTArrayDimensions arrayTypeDimensions = arrayType.getDimensions();
        dimension = arrayTypeDimensions.size();
    }
    return dimension;
}
```
3.  //Get the length of one dimension array
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimensions;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimExpr;
import net.sourceforge.pmd.lang.java.ast.ASTArrayAllocation;
import net.sourceforge.pmd.lang.java.ast.ASTArrayInitializer;
import net.sourceforge.pmd.lang.java.ast.ASTNumericLiteral;
public int getLengthOfOneDimensionArray(ASTVariableDeclaratorId varId) {
    int arrayLen = 0;
    int dimension;
    if (varId.getType().isArray()) {
        ASTArrayType arrayType = (ASTArrayType) varId.getTypeNode();
        ASTArrayDimensions arrayTypeDimensions = arrayType.getDimensions();
        dimension = arrayTypeDimensions.size();
        if (dimension == 1) {
            ASTArrayAllocation arrayAllocation = varId.getParent().firstChild(ASTArrayAllocation.class);
            if (arrayAllocation != null) {
                ASTArrayInitializer arrayInitializer = arrayAllocation.firstChild(ASTArrayInitializer.class);
                if (arrayInitializer != null) {
                    arrayLen = arrayInitializer.length();
                } else {
                    ASTArrayDimensions astArrayTypeDims = arrayAllocation.descendants(ASTArrayDimensions.class).first();
                    ASTArrayDimExpr arrayDimExpr = (ASTArrayDimExpr) astArrayTypeDims.get(0);
                    if (arrayDimExpr.getLengthExpression() instanceof ASTNumericLiteral) {
                        arrayLen = ((ASTNumericLiteral) arrayDimExpr.getLengthExpression()).getValueAsInt();
                    }
                }
            }
        }
    }
    return arrayLen;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:
1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


出现语法错误，这一轮舍弃，直接重新生成
5轮生成失败
结束

规则执行完毕，时间总花销： 1225.3364412784576 秒
