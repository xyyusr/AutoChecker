开始

========================================== Rule MethodNamingConventionsRule ===========================================
一共 12 个测试用例
正例 5 个
反例 7 个
1233
939
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method is public.
4. Check whether the method is a JUnit method.
5. Get the signature of method.
6. Check whether the method name matches the regex for the specific kind.
   - If the method is not static, not public, and not a JUnit method, check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
   - If the method is a static method, check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
   - If the method is a public static method and a JUnit method (either JUnit 3, 4, or 5), check whether the method name matches the corresponding regex.
   
In your test case:

1. Get the name of method: The method name is "Bar".
2. Check whether the method is static: The method is not static.
3. Check whether the method is public: The method is not public.
4. Check whether the method is a JUnit method: The method is not a JUnit method.
5. Since the method is neither static, public, nor a JUnit method, it falls under the default rule for instance method names.
6. Check whether the method name matches the regex for the specific kind: The method name "Bar" does not match the regex "[a-z][a-zA-Z0-9]*" for instance method names.

Since the method name "Bar" does not match the required regex, this test case violates the rule.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is public.', 'Check whether the method is a JUnit method.', 'Get the signature of method.', 'Check whether the method name matches the regex for the specific kind.', 'Get the name of method: The method name is "Bar".', 'Check whether the method is static: The method is not static.', 'Check whether the method is public: The method is not public.', 'Check whether the method is a JUnit method: The method is not a JUnit method.', 'Since the method is neither static, public, nor a JUnit method, it falls under the default rule for instance method names.', 'Check whether the method name matches the regex for the specific kind: The method name "Bar" does not match the regex "[a-z][a-zA-Z0-9]*" for instance method names.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Check whether the method is public.* 匹配到的元操作或API：
logic: Check whether the method is public.
most similar meta operation: Check whether the method is public
cosine Similarity: 0.9820576906204224
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827433228492737
*Check whether the method name matches the regex for the specific kind.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: The method name is "Bar".* 匹配到的元操作或API：
logic: Get the name of method: The method name is "Bar".
most similar meta operation: Get the name of method
cosine Similarity: 0.8984189033508301
*Check whether the method is static: The method is not static.* 匹配到的元操作或API：
logic: Check whether the method is static: The method is not static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9339491128921509
*Check whether the method is public: The method is not public.* 匹配到的元操作或API：
logic: Check whether the method is public: The method is not public.
most similar meta operation: Check whether the method is public
cosine Similarity: 0.9289852380752563
*Check whether the method is a JUnit method: The method is not a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method: The method is not a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9249879121780396
*Since the method is neither static, public, nor a JUnit method, it falls under the default rule for instance method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for the specific kind: The method name "Bar" does not match the regex "[a-z][a-zA-Z0-9]*" for instance method names.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should start with lowercase character
public class Foo {
    void Bar() {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'Bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPublic()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;
import java.util.regex.Matcher;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (TestFrameworksUtil.isJUnitMethod(node)) {
            // Assuming JUnit 5 by default if framework version cannot be determined
            Matcher matcher = JUNIT5_METHOD_PATTERN.matcher(methodName);
            if (!matcher.matches()) {
                addViolation(data, node);
            }
        } else if (node.isNative()) {
            Matcher matcher = NATIVE_METHOD_PATTERN.matcher(methodName);
            if (!matcher.matches()) {
                addViolation(data, node);
            }
        } else if (node.isStatic()) {
            Matcher matcher = STATIC_METHOD_PATTERN.matcher(methodName);
            if (!matcher.matches()) {
                addViolation(data, node);
            }
        } else {
            Matcher matcher = INSTANCE_METHOD_PATTERN.matcher(methodName);
            if (!matcher.matches()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
        2. Check whether the method is an instance method.
        3. Check whether the method is a static method.
        4. Check whether the method is a native method.
        5. Check whether the method is a junit method.
        6. Get the regex for instance method names.
        7. Check whether the method name matches the instance method name regex.
        8. Get the regex for static method names.
        9. Check whether the method name matches the static method name regex.
        10. Get the regex for native method names.
        11. Check whether the method name matches the native method name regex.
        12. Get the regex for JUnit 3 test method names.
        13. Check whether the method name matches the JUnit 3 test method name regex.
        14. Get the regex for JUnit 4 test method names.
        15. Check whether the method name matches the JUnit 4 test method name regex.
        16. Get the regex for JUnit 5 test method names.
        17. Check whether the method name matches the JUnit 5 test method name regex.
        18. Count the number of violations.

In this test case:
1. The name of the method is "Bar".
2. The method is an instance method.
3. The method is not a static method.
4. The method is not a native method.
5. The method is not a JUnit method.
6. The regex for instance method names is "[a-z][a-zA-Z0-9]*".
7. The method name "Bar" does not match the instance method name regex.
8. The regex for static method names is "[a-z][a-zA-Z0-9]*".
9. The method name "Bar" does not match the static method name regex.
10. The regex for native method names is "[a-z][a-zA-Z0-9]*".
11. The method name "Bar" does not match the native method name regex.
12. The regex for JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*".
13. The method name "Bar" does not match the JUnit 3 test method name regex.
14. The regex for JUnit 4 test method names is "[a-z][a-zA-Z0-9]*".
15. The method name "Bar" does not match the JUnit 4 test method name regex.
16. The regex for JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".
17. The method name "Bar" does not match the JUnit 5 test method name regex.
18. The number of violations is 1.

Thus, the test case `void Bar() {}` violates the rule because the method name does not start with a lowercase character as per the regex "[a-z][a-zA-Z0-9]*".
['Get the name of method.', 'Check whether the method is an instance method.', 'Check whether the method is a static method.', 'Check whether the method is a native method.', 'Check whether the method is a junit method.', 'Get the regex for instance method names.', 'Check whether the method name matches the instance method name regex.', 'Get the regex for static method names.', 'Check whether the method name matches the static method name regex.', 'Get the regex for native method names.', 'Check whether the method name matches the native method name regex.', 'Get the regex for JUnit 3 test method names.', 'Check whether the method name matches the JUnit 3 test method name regex.', 'Get the regex for JUnit 4 test method names.', 'Check whether the method name matches the JUnit 4 test method name regex.', 'Get the regex for JUnit 5 test method names.', 'Check whether the method name matches the JUnit 5 test method name regex.', 'Count the number of violations.', 'The name of the method is "Bar".', 'The method is an instance method.', 'The method is not a static method.', 'The method is not a native method.', 'The method is not a JUnit method.', 'The regex for instance method names is "[a-z][a-zA-Z0-9]*".', 'The method name "Bar" does not match the instance method name regex.', 'The regex for static method names is "[a-z][a-zA-Z0-9]*".', 'The method name "Bar" does not match the static method name regex.', 'The regex for native method names is "[a-z][a-zA-Z0-9]*".', 'The method name "Bar" does not match the native method name regex.', 'The regex for JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*".', 'The method name "Bar" does not match the JUnit 3 test method name regex.', 'The regex for JUnit 4 test method names is "[a-z][a-zA-Z0-9]*".', 'The method name "Bar" does not match the JUnit 4 test method name regex.', 'The regex for JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".', 'The method name "Bar" does not match the JUnit 5 test method name regex.', 'The number of violations is 1.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is an instance method.* 匹配到的元操作或API：
query: Check whether the method is an instance method.
most similar API: Check whether is test method
cosine Similarity: 0.8555020093917847
*Check whether the method is a static method.* 匹配到的元操作或API：
logic: Check whether the method is a static method.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9595943093299866
*Check whether the method is a native method.* 匹配到的元操作或API：
logic: Check whether the method is a native method.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9731004238128662
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Get the regex for instance method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the instance method name regex.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the regex for static method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the static method name regex.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the regex for native method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the native method name regex.* 匹配到的元操作或API：
query: Check whether the method name matches the native method name regex.
most similar API: Check whether the method is native
cosine Similarity: 0.8008258938789368
*Get the regex for JUnit 3 test method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the JUnit 3 test method name regex.* 匹配到的元操作或API：
query: Check whether the method name matches the JUnit 3 test method name regex.
most similar API: Check whether is junit3 method
cosine Similarity: 0.8509576916694641
*Get the regex for JUnit 4 test method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the JUnit 4 test method name regex.* 匹配到的元操作或API：
query: Check whether the method name matches the JUnit 4 test method name regex.
most similar API: Check whether is junit4 method
cosine Similarity: 0.8362696170806885
*Get the regex for JUnit 5 test method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the JUnit 5 test method name regex.* 匹配到的元操作或API：
query: Check whether the method name matches the JUnit 5 test method name regex.
most similar API: Check whether is junit5 method
cosine Similarity: 0.8429640531539917
*Count the number of violations.* 匹配到的元操作或API：
未匹配成功元操作或API
*The name of the method is "Bar".* 匹配到的元操作或API：
未匹配成功元操作或API
*The method is an instance method.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method is not a static method.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method is not a native method.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method is not a JUnit method.* 匹配到的元操作或API：
未匹配成功元操作或API
*The regex for instance method names is "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*The method name "Bar" does not match the instance method name regex.* 匹配到的元操作或API：
未匹配成功元操作或API
*The regex for static method names is "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*The method name "Bar" does not match the static method name regex.* 匹配到的元操作或API：
未匹配成功元操作或API
*The regex for native method names is "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*The method name "Bar" does not match the native method name regex.* 匹配到的元操作或API：
未匹配成功元操作或API
*The regex for JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*The method name "Bar" does not match the JUnit 3 test method name regex.* 匹配到的元操作或API：
未匹配成功元操作或API
*The regex for JUnit 4 test method names is "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*The method name "Bar" does not match the JUnit 4 test method name regex.* 匹配到的元操作或API：
未匹配成功元操作或API
*The regex for JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*The method name "Bar" does not match the JUnit 5 test method name regex.* 匹配到的元操作或API：
未匹配成功元操作或API
*The number of violations is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should start with lowercase character
public class Foo {
    void Bar() {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'Bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
7. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit4Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
8. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit5Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (TestFrameworksUtil.isJUnit3Method(node)) {
            if (!JUNIT3_TEST_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (TestFrameworksUtil.isJUnitMethod(node)) {
            if (!JUNIT4_TEST_METHOD_PATTERN.matcher(methodName).matches() && !JUNIT5_TEST_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (node.isNative()) {
            if (!NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (node.isStatic()) {
            if (!STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else {
            if (!INSTANCE_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is a junit method.
3. Get the signature of method.
4. Check whether the method is static.
5. Check whether the method is native.
6. Check whether the method name matches regex "[a-z][a-zA-Z0-9]*".

In this specific test case:
- The method name is "Bar".
- Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
- Since "Bar" does not start with a lowercase character, it does not match the default camel case regex for method names.
- The number of violating the rule in this test case is: 1
- The description of this test case is: bad 1

This confirms that the test case violates the rule as the method name does not adhere to the specified regex for instance methods.
['Get the name of method.', 'Check whether the method is a junit method.', 'Get the signature of method.', 'Check whether the method is static.', 'Check whether the method is native.', 'Check whether the method name matches regex "[a-z][a-zA-Z0-9]*".']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827433228492737
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124157905579
*Check whether the method name matches regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should start with lowercase character
public class Foo {
    void Bar() {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'Bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    // Assuming JUnit 3 is the only one with different pattern for demonstration
    private static final Pattern JUNIT3_METHOD_PATTERN = Pattern.compile("test[A-Z][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (TestFrameworksUtil.isJUnit3Method(node)) {
            if (!JUNIT3_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (TestFrameworksUtil.isJUnit4Method(node) || TestFrameworksUtil.isJUnit5Method(node)) {
            if (!INSTANCE_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (!INSTANCE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method is a JUnit method.
4. Get the signature of method.
5. Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".

If the method is not static, not a JUnit method, and its name does not match the regex for instance method names "[a-z][a-zA-Z0-9]*", then this test case violates the rule.
In this specific test case:

1. Get the name of method: Bar
2. Check whether the method is static: false
3. Check whether the method is a JUnit method: false
4. Get the signature of method: void Bar()
5. Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": false

The test case violates the rule because the method name "Bar" does not start with a lowercase character.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is a JUnit method.', 'Get the signature of method.', 'Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".', 'Get the name of method: Bar', 'Check whether the method is static: false', 'Check whether the method is a JUnit method: false', 'Get the signature of method: void Bar()', 'Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": false']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827433228492737
*Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: Bar* 匹配到的元操作或API：
logic: Get the name of method: Bar
most similar meta operation: Get the name of method
cosine Similarity: 0.8775445818901062
*Check whether the method is static: false* 匹配到的元操作或API：
logic: Check whether the method is static: false
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9611486792564392
*Check whether the method is a JUnit method: false* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method: false
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9644191861152649
*Get the signature of method: void Bar()* 匹配到的元操作或API：
logic: Get the signature of method: void Bar()
most similar meta operation: Get the signature of method
cosine Similarity: 0.8906004428863525
*Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": false* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should start with lowercase character
public class Foo {
    void Bar() {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'Bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (TestFrameworksUtil.isJUnitMethod(node)) {
            // Assuming JUnit 4 and 5 methods follow the same pattern as instance methods
            if (!INSTANCE_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (node.isNative()) {
            if (!NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (node.isStatic()) {
            if (!STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else {
            if (!INSTANCE_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method is a JUnit method.
4. Check whether the method is native.
5. Check whether the method name matches the regex for instance methods.

Given the test case:

1. Get the name of method. // The name of method is Bar
2. Check whether the method is static. // The method is not static
3. Check whether the method is a JUnit method. // The method is not a JUnit method
4. Check whether the method is native. // The method is not native
5. Check whether the method name matches the regex for instance methods. // The method name "Bar" does not match the regex "[a-z][a-zA-Z0-9]*" because it starts with an uppercase character.

Since the method name "Bar" does not match the expected regex for instance method names, this test case violates the rule.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is a JUnit method.', 'Check whether the method is native.', 'Check whether the method name matches the regex for instance methods.', 'Get the name of method. // The name of method is Bar', 'Check whether the method is static. // The method is not static', 'Check whether the method is a JUnit method. // The method is not a JUnit method', 'Check whether the method is native. // The method is not native', 'Check whether the method name matches the regex for instance methods. // The method name "Bar" does not match the regex "[a-z][a-zA-Z0-9]*" because it starts with an uppercase character.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124157905579
*Check whether the method name matches the regex for instance methods.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. // The name of method is Bar* 匹配到的元操作或API：
logic: Get the name of method. // The name of method is Bar
most similar meta operation: Get the name of method
cosine Similarity: 0.8849252462387085
*Check whether the method is static. // The method is not static* 匹配到的元操作或API：
logic: Check whether the method is static. // The method is not static
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9446521401405334
*Check whether the method is a JUnit method. // The method is not a JUnit method* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method. // The method is not a JUnit method
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9359540939331055
*Check whether the method is native. // The method is not native* 匹配到的元操作或API：
logic: Check whether the method is native. // The method is not native
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9647301435470581
*Check whether the method name matches the regex for instance methods. // The method name "Bar" does not match the regex "[a-z][a-zA-Z0-9]*" because it starts with an uppercase character.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should start with lowercase character
public class Foo {
    void Bar() {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'Bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        boolean isJUnitMethod = TestFrameworksUtil.isJUnitMethod(node);
        boolean isNativeMethod = node.isNative();
        boolean isStaticMethod = node.isStatic();
        String regex;

        if (isJUnitMethod) {
            regex = "test[A-Z0-9][a-zA-Z0-9]*";
        } else if (isNativeMethod) {
            regex = "[a-z][a-zA-Z0-9]*";
        } else {
            regex = "[a-z][a-zA-Z0-9]*";
        }

        if (!methodName.matches(regex)) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 1
1233
939
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method is JUnit method.
4. Get the regex for method name based on its kind.
5. Check whether the method name matches the regex.

For the provided test case:
1. Get the name of method: bar_foo
2. Check whether the method is static: false
3. Check whether the method is JUnit method: false (assuming it is not annotated with @Test)
4. Get the regex for method name based on its kind: [a-z][a-zA-Z0-9]*
5. Check whether the method name matches the regex: false (since "bar_foo" contains an underscore)

Since the method name does not match the regex for a standard instance method name, this test case violates the rule.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is JUnit method.', 'Get the regex for method name based on its kind.', 'Check whether the method name matches the regex.', 'Get the name of method: bar_foo', 'Check whether the method is static: false', 'Check whether the method is JUnit method: false (assuming it is not annotated with @Test)', 'Get the regex for method name based on its kind: [a-z][a-zA-Z0-9]*', 'Check whether the method name matches the regex: false (since "bar_foo" contains an underscore)']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Check whether the method is JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9728522300720215
*Get the regex for method name based on its kind.* 匹配到的元操作或API：
query: Get the regex for method name based on its kind.
most similar API: get method name of method
cosine Similarity: 0.8072101473808289
*Check whether the method name matches the regex.* 匹配到的元操作或API：
query: Check whether the method name matches the regex.
most similar API: Check whether the method equals
cosine Similarity: 0.8188823461532593
*Get the name of method: bar_foo* 匹配到的元操作或API：
logic: Get the name of method: bar_foo
most similar meta operation: Get the name of method
cosine Similarity: 0.8694788217544556
*Check whether the method is static: false* 匹配到的元操作或API：
logic: Check whether the method is static: false
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9611486792564392
*Check whether the method is JUnit method: false (assuming it is not annotated with @Test)* 匹配到的元操作或API：
logic: Check whether the method is JUnit method: false (assuming it is not annotated with @Test)
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9090739488601685
*Get the regex for method name based on its kind: [a-z][a-zA-Z0-9]** 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex: false (since "bar_foo" contains an underscore)* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should not contain underscores
public class Foo {
    void bar_foo() {}
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar_foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getMethodName(), //Returns the simple name of the method. @deprecated Use {@link #getName()}
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean equals(java.lang.Object)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (methodName.contains("_")) {
            if (!TestFrameworksUtil.isJUnitMethod(node)) {
                addViolation(data, node);
            } else {
                if (!methodName.matches("test[A-Z0-9][a-zA-Z0-9]*")) {
                    addViolation(data, node);
                }
            }
        } else {
            if (node.isStatic() && !methodName.matches("[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            } else if (!node.isStatic() && !methodName.matches("[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Get the signature of method.
3. Check whether the method is public.
4. Check whether the method is static.
5. Check whether the method is native.
6. Check whether the method is a junit method.
7. Get the name of class.
8. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

If the method name does not match the regex "[a-z][a-zA-Z0-9]*", then this test case violates the rule. In this case, the method name "bar_foo" contains an underscore, which causes it to violate the rule.
['Get the name of method.', 'Get the signature of method.', 'Check whether the method is public.', 'Check whether the method is static.', 'Check whether the method is native.', 'Check whether the method is a junit method.', 'Get the name of class.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827433228492737
*Check whether the method is public.* 匹配到的元操作或API：
logic: Check whether the method is public.
most similar meta operation: Check whether the method is public
cosine Similarity: 0.9820576906204224
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124157905579
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should not contain underscores
public class Foo {
    void bar_foo() {}
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar_foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPublic()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private final Pattern instanceMethodPattern = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private final Pattern staticMethodPattern = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private final Pattern nativeMethodPattern = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private final Pattern junit3MethodPattern = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private final Pattern junit4MethodPattern = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private final Pattern junit5MethodPattern = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isNative()) {
            if (!nativeMethodPattern.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (node.isStatic()) {
            if (!staticMethodPattern.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (TestFrameworksUtil.isJUnitMethod(node)) {
            if (!junit3MethodPattern.matcher(methodName).matches() && 
                !junit4MethodPattern.matcher(methodName).matches() && 
                !junit5MethodPattern.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else {
            if (!instanceMethodPattern.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method is a JUnit method.
4. Get the regex which applies to the method name.
5. Check whether the method name matches the regex.

For the given test case:
1. Get the name of method -> bar_foo
2. Check whether the method is static -> false
3. Check whether the method is a JUnit method -> false
4. Get the regex which applies to the method name -> [a-z][a-zA-Z0-9]*
5. Check whether the method name matches the regex -> false (Because "bar_foo" contains an underscore which does not match the "[a-z][a-zA-Z0-9]*" regex)

Since the method name `bar_foo` does not match the expected regex `[a-z][a-zA-Z0-9]*`, it violates the rule.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is a JUnit method.', 'Get the regex which applies to the method name.', 'Check whether the method name matches the regex.', 'Get the name of method -> bar_foo', 'Check whether the method is static -> false', 'Check whether the method is a JUnit method -> false', 'Get the regex which applies to the method name -> [a-z][a-zA-Z0-9]*', 'Check whether the method name matches the regex -> false (Because "bar_foo" contains an underscore which does not match the "[a-z][a-zA-Z0-9]*" regex)']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Get the regex which applies to the method name.* 匹配到的元操作或API：
query: Get the regex which applies to the method name.
most similar API: get method name of method
cosine Similarity: 0.8124148845672607
*Check whether the method name matches the regex.* 匹配到的元操作或API：
query: Check whether the method name matches the regex.
most similar API: Check whether the method equals
cosine Similarity: 0.8188823461532593
*Get the name of method -> bar_foo* 匹配到的元操作或API：
logic: Get the name of method -> bar_foo
most similar meta operation: Get the name of method
cosine Similarity: 0.8796032071113586
*Check whether the method is static -> false* 匹配到的元操作或API：
logic: Check whether the method is static -> false
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9584747552871704
*Check whether the method is a JUnit method -> false* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method -> false
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9753814935684204
*Get the regex which applies to the method name -> [a-z][a-zA-Z0-9]** 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex -> false (Because "bar_foo" contains an underscore which does not match the "[a-z][a-zA-Z0-9]*" regex)* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should not contain underscores
public class Foo {
    void bar_foo() {}
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar_foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getMethodName(), //Returns the simple name of the method. @deprecated Use {@link #getName()}
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean equals(java.lang.Object)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (!isJUnitMethod(node) && !methodName.matches("[a-z][a-zA-Z0-9]*")) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    private boolean isJUnitMethod(ASTMethodDeclaration node) {
        return TestFrameworksUtil.isJUnitMethod(node);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method is a junit method.
4. Get the regex for the specific kind of method.
5. Check whether the method name matches the regex for instance methods.
6. Check whether the method name matches the regex for JUnit 3 test methods.
7. Check whether the method name matches the regex for JUnit 4 test methods.
8. Check whether the method name matches the regex for JUnit 5 test methods.
9. Check whether the method name matches the regex for native methods.

If the method name does not match the regex for instance methods and it is not a static, native, or JUnit method, then this test case violates the rule.

In this specific case:
1. Get the name of method: The name of the method is `bar_foo`.
2. Check whether the method is static: The method is not static.
3. Check whether the method is a junit method: The method is not a JUnit method.
4. Get the regex for the specific kind of method: The regex for instance methods is `[a-z][a-zA-Z0-9]*`.
5. Check whether the method name matches the regex for instance methods: The method name `bar_foo` does not match the regex `[a-z][a-zA-Z0-9]*` because it contains an underscore.
6. Check whether the method name matches the regex for JUnit 3 test methods: This regex is `[a-z][a-zA-Z0-9]*` and the method name does not start with `test[A-Z0-9]`, so it does not match.
7. Check whether the method name matches the regex for JUnit 4 test methods: The regex for JUnit 4 test methods is `[a-z][a-zA-Z0-9]*` and the method name does not match because it contains an underscore.
8. Check whether the method name matches the regex for JUnit 5 test methods: The regex for JUnit 5 test methods is `[a-z][a-zA-Z0-9]*` and the method name does not match because it contains an underscore.
9. Check whether the method name matches the regex for native methods: This regex is `[a-z][a-zA-Z0-9]*`, and the method name does not match because it contains an underscore.

Since the method name `bar_foo` does not match the regex for instance methods and it is not a static, native, or JUnit method, this test case violates the rule.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is a junit method.', 'Get the regex for the specific kind of method.', 'Check whether the method name matches the regex for instance methods.', 'Check whether the method name matches the regex for JUnit 3 test methods.', 'Check whether the method name matches the regex for JUnit 4 test methods.', 'Check whether the method name matches the regex for JUnit 5 test methods.', 'Check whether the method name matches the regex for native methods.', 'Get the name of method: The name of the method is `bar_foo`.', 'Check whether the method is static: The method is not static.', 'Check whether the method is a junit method: The method is not a JUnit method.', 'Get the regex for the specific kind of method: The regex for instance methods is `[a-z][a-zA-Z0-9]*`.', 'Check whether the method name matches the regex for instance methods: The method name `bar_foo` does not match the regex `[a-z][a-zA-Z0-9]*` because it contains an underscore.', 'Check whether the method name matches the regex for JUnit 3 test methods: This regex is `[a-z][a-zA-Z0-9]*` and the method name does not start with `test[A-Z0-9]`, so it does not match.', 'Check whether the method name matches the regex for JUnit 4 test methods: The regex for JUnit 4 test methods is `[a-z][a-zA-Z0-9]*` and the method name does not match because it contains an underscore.', 'Check whether the method name matches the regex for JUnit 5 test methods: The regex for JUnit 5 test methods is `[a-z][a-zA-Z0-9]*` and the method name does not match because it contains an underscore.', 'Check whether the method name matches the regex for native methods: This regex is `[a-z][a-zA-Z0-9]*`, and the method name does not match because it contains an underscore.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Get the regex for the specific kind of method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for instance methods.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 3 test methods.* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test methods.
most similar API: Check whether is junit3 method
cosine Similarity: 0.856862485408783
*Check whether the method name matches the regex for JUnit 4 test methods.* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 4 test methods.
most similar API: Check whether is junit4 method
cosine Similarity: 0.8437420725822449
*Check whether the method name matches the regex for JUnit 5 test methods.* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 5 test methods.
most similar API: Check whether is junit5 method
cosine Similarity: 0.8510193228721619
*Check whether the method name matches the regex for native methods.* 匹配到的元操作或API：
query: Check whether the method name matches the regex for native methods.
most similar API: Check whether the method is native
cosine Similarity: 0.8243709802627563
*Get the name of method: The name of the method is `bar_foo`.* 匹配到的元操作或API：
logic: Get the name of method: The name of the method is `bar_foo`.
most similar meta operation: Get the name of method
cosine Similarity: 0.8830094933509827
*Check whether the method is static: The method is not static.* 匹配到的元操作或API：
logic: Check whether the method is static: The method is not static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9339491128921509
*Check whether the method is a junit method: The method is not a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method: The method is not a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9249879121780396
*Get the regex for the specific kind of method: The regex for instance methods is `[a-z][a-zA-Z0-9]*`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for instance methods: The method name `bar_foo` does not match the regex `[a-z][a-zA-Z0-9]*` because it contains an underscore.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 3 test methods: This regex is `[a-z][a-zA-Z0-9]*` and the method name does not start with `test[A-Z0-9]`, so it does not match.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 4 test methods: The regex for JUnit 4 test methods is `[a-z][a-zA-Z0-9]*` and the method name does not match because it contains an underscore.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 5 test methods: The regex for JUnit 5 test methods is `[a-z][a-zA-Z0-9]*` and the method name does not match because it contains an underscore.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for native methods: This regex is `[a-z][a-zA-Z0-9]*`, and the method name does not match because it contains an underscore.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should not contain underscores
public class Foo {
    void bar_foo() {}
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar_foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit4Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit5Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (TestFrameworksUtil.isJUnit3Method(node)) {
            if (!methodName.matches("test[A-Z0-9][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        } else if (TestFrameworksUtil.isJUnitMethod(node)) {
            if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        } else if (node.isNative()) {
            if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        } else if (node.isStatic()) {
            if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        } else {
            if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is a junit method.
3. Check whether the method is static.
4. Check whether the method name matches the regex for instance method names: "[a-z][a-zA-Z0-9]*".
5. Check whether the method name matches the regex for static method names: "[a-z][a-zA-Z0-9]*".
6. Check whether the method name matches the regex for native method names: "[a-z][a-zA-Z0-9]*".
7. Check whether the method name matches the regex for JUnit 3 test method names: "test[A-Z0-9][a-zA-Z0-9]*".
8. Check whether the method name matches the regex for JUnit 4 test method names: "[a-z][a-zA-Z0-9]*".
9. Check whether the method name matches the regex for JUnit 5 test method names: "[a-z][a-zA-Z0-9]*".
10. If the method is not a JUnit method and the method name does not match the regex for instance or static method names, then this test case violates the rule.
11. If the method is a JUnit method and the method name does not match the regex for JUnit 3, JUnit 4, or JUnit 5 test method names, then this test case violates the rule.
12. If the method is a native method and the method name does not match the regex for native method names, then this test case violates the rule.

In this specific test case:
1. The name of the method is `bar_foo`.
2. The method is not a JUnit method.
3. The method is not static.
4. The method name does not match the regex for instance method names: "[a-z][a-zA-Z0-9]*".

Since the method name `bar_foo` contains an underscore, it violates the rule for instance method names.
            
['Get the name of method.', 'Check whether the method is a junit method.', 'Check whether the method is static.', 'Check whether the method name matches the regex for instance method names: "[a-z][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for static method names: "[a-z][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for native method names: "[a-z][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for JUnit 3 test method names: "test[A-Z0-9][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for JUnit 4 test method names: "[a-z][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for JUnit 5 test method names: "[a-z][a-zA-Z0-9]*".', 'If the method is not a JUnit method and the method name does not match the regex for instance or static method names, then this test case violates the rule.', 'If the method is a JUnit method and the method name does not match the regex for JUnit 3, JUnit 4, or JUnit 5 test method names, then this test case violates the rule.', 'If the method is a native method and the method name does not match the regex for native method names, then this test case violates the rule.', 'The name of the method is `bar_foo`.', 'The method is not a JUnit method.', 'The method is not static.', 'The method name does not match the regex for instance method names: "[a-z][a-zA-Z0-9]*".']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Check whether the method name matches the regex for instance method names: "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for static method names: "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for native method names: "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 3 test method names: "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names: "test[A-Z0-9][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method
cosine Similarity: 0.8054032325744629
*Check whether the method name matches the regex for JUnit 4 test method names: "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 4 test method names: "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit4 method
cosine Similarity: 0.8008409142494202
*Check whether the method name matches the regex for JUnit 5 test method names: "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 5 test method names: "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit5 method
cosine Similarity: 0.8076136112213135
*If the method is not a JUnit method and the method name does not match the regex for instance or static method names, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the method is a JUnit method and the method name does not match the regex for JUnit 3, JUnit 4, or JUnit 5 test method names, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the method is a native method and the method name does not match the regex for native method names, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*The name of the method is `bar_foo`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method is not a JUnit method.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method is not static.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method name does not match the regex for instance method names: "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should not contain underscores
public class Foo {
    void bar_foo() {}
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar_foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit4Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit5Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (!methodName.matches("[a-z][a-zA-Z0-9]*") && !TestFrameworksUtil.isJUnitMethod(node)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 2
1233
939
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method
2. Check whether the method is static
3. Check whether the name of the method matches the regex "[a-z][a-zA-Z0-9]*"

Let's go through each method in the `Foo` class:

For the method `foo`:
1. Get the name of method -> Name is "foo"
2. Check whether the method is static -> Yes, it is static
3. Check whether the name of the method matches the regex "[a-z][a-zA-Z0-9]*" -> Yes, it matches

For the method `st_whatever`:
1. Get the name of method -> Name is "st_whatever"
2. Check whether the method is static -> Yes, it is static
3. Check whether the name of the method matches the regex "[a-z][a-zA-Z0-9]*" -> Yes, it matches

For the method `bar`:
1. Get the name of method -> Name is "bar"
2. Check whether the method is static -> No, it is not static
3. Check whether the name of the method matches the regex "[a-z][a-zA-Z0-9]*" -> Yes, it matches

Based on the provided rule description and the test case, there are no issues with the method names matching their respective regex patterns. The description "bad 3" and "1 violating the rule" seem to be incorrect based on the given rule and test case. If the rule description intended to report a different issue, please provide more details or clarify the rule.
['Get the name of method', 'Check whether the method is static', 'Check whether the name of the method matches the regex "[a-z][a-zA-Z0-9]*"', 'Get the name of method -> Name is "foo"', 'Check whether the method is static -> Yes, it is static', 'Check whether the name of the method matches the regex "[a-z][a-zA-Z0-9]*" -> Yes, it matches', 'Get the name of method -> Name is "st_whatever"', 'Check whether the method is static -> Yes, it is static', 'Check whether the name of the method matches the regex "[a-z][a-zA-Z0-9]*" -> Yes, it matches', 'Get the name of method -> Name is "bar"', 'Check whether the method is static -> No, it is not static', 'Check whether the name of the method matches the regex "[a-z][a-zA-Z0-9]*" -> Yes, it matches']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method* 匹配到的元操作或API：
logic: Get the name of method
most similar meta operation: Get the name of method
cosine Similarity: 1.0
*Check whether the method is static* 匹配到的元操作或API：
logic: Check whether the method is static
most similar meta operation: Check whether the method is static
cosine Similarity: 1.0
*Check whether the name of the method matches the regex "[a-z][a-zA-Z0-9]*"* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method -> Name is "foo"* 匹配到的元操作或API：
logic: Get the name of method -> Name is "foo"
most similar meta operation: Get the name of method
cosine Similarity: 0.9123207330703735
*Check whether the method is static -> Yes, it is static* 匹配到的元操作或API：
logic: Check whether the method is static -> Yes, it is static
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9720317125320435
*Check whether the name of the method matches the regex "[a-z][a-zA-Z0-9]*" -> Yes, it matches* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method -> Name is "st_whatever"* 匹配到的元操作或API：
logic: Get the name of method -> Name is "st_whatever"
most similar meta operation: Get the name of method
cosine Similarity: 0.8780691623687744
*Check whether the method is static -> Yes, it is static* 匹配到的元操作或API：
logic: Check whether the method is static -> Yes, it is static
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9720317125320435
*Check whether the name of the method matches the regex "[a-z][a-zA-Z0-9]*" -> Yes, it matches* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method -> Name is "bar"* 匹配到的元操作或API：
logic: Get the name of method -> Name is "bar"
most similar meta operation: Get the name of method
cosine Similarity: 0.9021895527839661
*Check whether the method is static -> No, it is not static* 匹配到的元操作或API：
logic: Check whether the method is static -> No, it is not static
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9505069255828857
*Check whether the name of the method matches the regex "[a-z][a-zA-Z0-9]*" -> Yes, it matches* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// Static method pattern
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'st_whatever')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        for (ASTMethodDeclaration method : node.getDeclaredMethods()) {
            if (method.isStatic()) {
                if (!Pattern.matches("[a-z][a-zA-Z0-9]*", method.getName())) {
                    addViolation(data, method);
                }
            } else {
                // Add logic for non-static methods if needed
                // For now, we only check static methods as per the original logic
            }
        }
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        // No need to implement this as the logic is handled in visit(ASTClassOrInterfaceDeclaration, Object)
        return data;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
4. Get the name of method.
5. Check whether the method is static.
6. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
7. Get the name of method.
8. Check whether the method is static.
9. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

For the given test case:
1. Get the name of method: foo
2. Check whether the method is static: true
3. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": true (no violation)
4. Get the name of method: st_whatever
5. Check whether the method is static: true
6. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": true (no violation)
7. Get the name of method: bar
8. Check whether the method is static: false (skip the regex check for this method as per the provided description)

However, based on the description provided ("bad 3" and "number of violating the rule in this test case is: 1"), it seems there might be a misunderstanding or additional context that is not mentioned in the method names alone. Let's assume there is a JUnit 3 test method in the class that does not follow the pattern.

Revised test case:
```java
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    void bar() {
    }

    void test1() { // JUnit 3 test method that does not follow the pattern
    }
}
```

Revised granular checks:
1. Get the name of method: foo
2. Check whether the method is static: true
3. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": true (no violation)
4. Get the name of method: st_whatever
5. Check whether the method is static: true
6. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": true (no violation)
7. Get the name of method: bar
8. Check whether the method is static: false (skip the regex check for this method as per the provided description)
9. Get the name of method: test1
10. Check whether the method is a junit method.
11. Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*".

For method `test1`:
9. Get the name of method: test1
10. Check whether the method is a junit method: true (assuming the presence of JUnit 3 annotations or naming conventions)
11. Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*": false (violation)

Based on the above checks, method `test1` violates the rule for JUnit 3 test method names.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is static.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is static.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method: foo', 'Check whether the method is static: true', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": true (no violation)', 'Get the name of method: st_whatever', 'Check whether the method is static: true', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": true (no violation)', 'Get the name of method: bar', 'Check whether the method is static: false (skip the regex check for this method as per the provided description)', 'Get the name of method: foo', 'Check whether the method is static: true', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": true (no violation)', 'Get the name of method: st_whatever', 'Check whether the method is static: true', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": true (no violation)', 'Get the name of method: bar', 'Check whether the method is static: false (skip the regex check for this method as per the provided description)', 'Get the name of method: test1', 'Check whether the method is a junit method.', 'Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*".', 'Get the name of method: test1', 'Check whether the method is a junit method: true (assuming the presence of JUnit 3 annotations or naming conventions)', 'Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*": false (violation)']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: foo* 匹配到的元操作或API：
logic: Get the name of method: foo
most similar meta operation: Get the name of method
cosine Similarity: 0.9303618669509888
*Check whether the method is static: true* 匹配到的元操作或API：
logic: Check whether the method is static: true
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9727094173431396
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": true (no violation)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: st_whatever* 匹配到的元操作或API：
query: Get the name of method: st_whatever
most similar API: get name of method
cosine Similarity: 0.838805615901947
*Check whether the method is static: true* 匹配到的元操作或API：
logic: Check whether the method is static: true
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9727094173431396
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": true (no violation)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: bar* 匹配到的元操作或API：
logic: Get the name of method: bar
most similar meta operation: Get the name of method
cosine Similarity: 0.8775445818901062
*Check whether the method is static: false (skip the regex check for this method as per the provided description)* 匹配到的元操作或API：
logic: Check whether the method is static: false (skip the regex check for this method as per the provided description)
most similar meta operation: Check whether the method is static
cosine Similarity: 0.8919609189033508
*Get the name of method: foo* 匹配到的元操作或API：
logic: Get the name of method: foo
most similar meta operation: Get the name of method
cosine Similarity: 0.9303618669509888
*Check whether the method is static: true* 匹配到的元操作或API：
logic: Check whether the method is static: true
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9727094173431396
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": true (no violation)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: st_whatever* 匹配到的元操作或API：
query: Get the name of method: st_whatever
most similar API: get name of method
cosine Similarity: 0.838805615901947
*Check whether the method is static: true* 匹配到的元操作或API：
logic: Check whether the method is static: true
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9727094173431396
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": true (no violation)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: bar* 匹配到的元操作或API：
logic: Get the name of method: bar
most similar meta operation: Get the name of method
cosine Similarity: 0.8775445818901062
*Check whether the method is static: false (skip the regex check for this method as per the provided description)* 匹配到的元操作或API：
logic: Check whether the method is static: false (skip the regex check for this method as per the provided description)
most similar meta operation: Check whether the method is static
cosine Similarity: 0.8919609189033508
*Get the name of method: test1* 匹配到的元操作或API：
logic: Get the name of method: test1
most similar meta operation: Get the name of method
cosine Similarity: 0.8887240886688232
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: test1* 匹配到的元操作或API：
logic: Get the name of method: test1
most similar meta operation: Get the name of method
cosine Similarity: 0.8887240886688232
*Check whether the method is a junit method: true (assuming the presence of JUnit 3 annotations or naming conventions)* 匹配到的元操作或API：
logic: Check whether the method is a junit method: true (assuming the presence of JUnit 3 annotations or naming conventions)
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9281072616577148
*Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*": false (violation)* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// Static method pattern
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'st_whatever')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName(), //Returns the simple name of the method.
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_METHOD_PATTERN = Pattern.compile("test[A-Z][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (TestFrameworksUtil.isJUnit3Method(node)) {
            if (!JUNIT3_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (TestFrameworksUtil.isJUnit4Method(node) || TestFrameworksUtil.isJUnit5Method(node)) {
            if (!JUNIT4_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (node.isStatic()) {
            if (!STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else {
            if (!INSTANCE_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

Let's perform the checks for each method:

### Method `foo`
1. Get the name of method. // Method name is `foo`
2. Check whether the method is static. // `foo` is static
3. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // `foo` matches the regex

### Method `st_whatever`
1. Get the name of method. // Method name is `st_whatever`
2. Check whether the method is static. // `st_whatever` is static
3. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // `st_whatever` matches the regex

### Method `bar`
1. Get the name of method. // Method name is `bar`
2. Check whether the method is static. // `bar` is not static
3. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // `bar` matches the regex

### JUnit 3 Test Method (Assuming `foo` or `st_whatever` are JUnit 3 test methods)
Since the test case description indicates there is a violation, let's assume one of these methods is intended to be a JUnit 3 test method and check for that pattern.

#### Assuming `foo` is a JUnit 3 test method:
1. Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*". // `foo` does not match the regex

#### Assuming `st_whatever` is a JUnit 3 test method:
1. Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*". // `st_whatever` does not match the regex

Based on the test case description, we need to identify the specific method that should be a JUnit 3 test method but does not match the pattern. Since `st_whatever` is mentioned as the violating method:

### Method `st_whatever` (Assumed as JUnit 3 test method)
1. Get the name of method. // Method name is `st_whatever`
2. Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*". // `st_whatever` does not match the regex

This indicates that `st_whatever` is the method violating the rule under the assumption that it is intended to be a JUnit 3 test method. If it's not a JUnit test method, there is no violation in this specific test case based on the provided regex patterns.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method. // Method name is `foo`', 'Check whether the method is static. // `foo` is static', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // `foo` matches the regex', 'Get the name of method. // Method name is `st_whatever`', 'Check whether the method is static. // `st_whatever` is static', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // `st_whatever` matches the regex', 'Get the name of method. // Method name is `bar`', 'Check whether the method is static. // `bar` is not static', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // `bar` matches the regex', 'Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*". // `foo` does not match the regex', 'Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*". // `st_whatever` does not match the regex', 'Get the name of method. // Method name is `st_whatever`', 'Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*". // `st_whatever` does not match the regex']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. // Method name is `foo`* 匹配到的元操作或API：
logic: Get the name of method. // Method name is `foo`
most similar meta operation: Get the name of method
cosine Similarity: 0.9083741903305054
*Check whether the method is static. // `foo` is static* 匹配到的元操作或API：
logic: Check whether the method is static. // `foo` is static
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9182592630386353
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // `foo` matches the regex* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. // Method name is `st_whatever`* 匹配到的元操作或API：
logic: Get the name of method. // Method name is `st_whatever`
most similar meta operation: Get the name of method
cosine Similarity: 0.869015097618103
*Check whether the method is static. // `st_whatever` is static* 匹配到的元操作或API：
logic: Check whether the method is static. // `st_whatever` is static
most similar meta operation: Check whether the method is static
cosine Similarity: 0.8715233206748962
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // `st_whatever` matches the regex* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. // Method name is `bar`* 匹配到的元操作或API：
logic: Get the name of method. // Method name is `bar`
most similar meta operation: Get the name of method
cosine Similarity: 0.8847513794898987
*Check whether the method is static. // `bar` is not static* 匹配到的元操作或API：
logic: Check whether the method is static. // `bar` is not static
most similar meta operation: Check whether the method is static
cosine Similarity: 0.8826452493667603
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // `bar` matches the regex* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*". // `foo` does not match the regex* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*". // `st_whatever` does not match the regex* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. // Method name is `st_whatever`* 匹配到的元操作或API：
logic: Get the name of method. // Method name is `st_whatever`
most similar meta operation: Get the name of method
cosine Similarity: 0.869015097618103
*Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*". // `st_whatever` does not match the regex* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// Static method pattern
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'st_whatever')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Visit each method declaration within the class or interface
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        // Check if the method is static and does not match the naming pattern
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
True
此测试用例生成了first checker: bad 3


======================接下来开始迭代=====================
[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method is native.
3. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
4. Get the name of method.
5. Check whether the method is native.
6. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
7. Get the name of method.
8. Check whether the method is native.
9. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

The first method, `foo()`, is native and its name matches the regex "[a-z][a-zA-Z0-9]*", so it does not violate the rule.

The second method, `nt_whatever()`, is native, but its name does not match the regex "[a-z][a-zA-Z0-9]*" because it contains an underscore. Therefore, it violates the rule.

The third method, `bar()`, is not a native method, so the regex for native methods does not apply, and it does not violate the rule.

The number of violating the rule in this test case is 1.
['Get the name of method.', 'Check whether the method is native.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is native.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is native.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124157905579
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124157905579
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124157905579
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Visit each method declaration within the class or interface
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        // Check if the method is static and does not match the naming pattern
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// Native method pattern
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'nt_whatever')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (isJUnitTestMethod(node) && !JUNIT3_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (!node.isStatic() && !node.isNative() && !isJUnitTestMethod(node) && !INSTANCE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }

    private boolean isJUnitTestMethod(ASTMethodDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.annotations();
        return annotations.anyMatch(annotation -> isJUnitTestAnnotation(annotation));
    }

    private boolean isJUnitTestAnnotation(ASTAnnotation annotation) {
        TypeSystem ts = annotation.getTypeSystem();
        JAnnotation jAnnotation = annotation.getAnnotation();
        return jAnnotation != null && (ts.findClass("org.junit.Test").isPresent() && jAnnotation.getType().equals(ts.findClass("org.junit.Test").get().getType()));
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of method.
2. Get the signature of method.
3. Check whether the method is native.
4. Get the name of method.
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for a native method.
6. Repeat steps 1 to 5 for each method in the class.

For the given test case:
1. Get the name of method: `foo`
2. Get the signature of method: `native void foo()`
3. Check whether the method is native: true
4. Get the name of method: `foo`
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for a native method: true (since `foo` matches the regex)

1. Get the name of method: `nt_whatever`
2. Get the signature of method: `native void nt_whatever()`
3. Check whether the method is native: true
4. Get the name of method: `nt_whatever`
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for a native method: true (since `nt_whatever` matches the regex)

1. Get the name of method: `bar`
2. Get the signature of method: `void bar()`
3. Check whether the method is native: false
4. (Since it's not native, this method does not need to be checked against the native method regex)

The number of violating the rule in this test case is: 0 (as per the provided test case, all native methods match the required regex). However, if the intention was to show a violating case, let's assume the method names were different:

```java
class Foo {
    native void Foo() {
    }

    native void NT_Whatever() {
    }

    // not reported
    void bar() {
    }
}
```

For this modified test case:
1. Get the name of method: `Foo`
2. Get the signature of method: `native void Foo()`
3. Check whether the method is native: true
4. Get the name of method: `Foo`
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for a native method: false (since `Foo` does not match the regex)

1. Get the name of method: `NT_Whatever`
2. Get the signature of method: `native void NT_Whatever()`
3. Check whether the method is native: true
4. Get the name of method: `NT_Whatever`
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for a native method: false (since `NT_Whatever` does not match the regex)

In this modified test case, the number of violating the rule is: 2
['Get the name of method.', 'Get the signature of method.', 'Check whether the method is native.', 'Get the name of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for a native method.', 'Repeat steps 1 to 5 for each method in the class.', 'Get the name of method: `foo`', 'Get the signature of method: `native void foo()`', 'Check whether the method is native: true', 'Get the name of method: `foo`', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for a native method: true (since `foo` matches the regex)', 'Get the name of method: `nt_whatever`', 'Get the signature of method: `native void nt_whatever()`', 'Check whether the method is native: true', 'Get the name of method: `nt_whatever`', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for a native method: true (since `nt_whatever` matches the regex)', 'Get the name of method: `bar`', 'Get the signature of method: `void bar()`', 'Check whether the method is native: false', "(Since it's not native, this method does not need to be checked against the native method regex)", 'Get the name of method: `Foo`', 'Get the signature of method: `native void Foo()`', 'Check whether the method is native: true', 'Get the name of method: `Foo`', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for a native method: false (since `Foo` does not match the regex)', 'Get the name of method: `NT_Whatever`', 'Get the signature of method: `native void NT_Whatever()`', 'Check whether the method is native: true', 'Get the name of method: `NT_Whatever`', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for a native method: false (since `NT_Whatever` does not match the regex)']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827433228492737
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124157905579
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for a native method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 1 to 5 for each method in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: `foo`* 匹配到的元操作或API：
logic: Get the name of method: `foo`
most similar meta operation: Get the name of method
cosine Similarity: 0.9086973667144775
*Get the signature of method: `native void foo()`* 匹配到的元操作或API：
logic: Get the signature of method: `native void foo()`
most similar meta operation: Get the signature of method
cosine Similarity: 0.8719401359558105
*Check whether the method is native: true* 匹配到的元操作或API：
logic: Check whether the method is native: true
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9691004753112793
*Get the name of method: `foo`* 匹配到的元操作或API：
logic: Get the name of method: `foo`
most similar meta operation: Get the name of method
cosine Similarity: 0.9086973667144775
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for a native method: true (since `foo` matches the regex)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: `nt_whatever`* 匹配到的元操作或API：
query: Get the name of method: `nt_whatever`
most similar API: get name of method
cosine Similarity: 0.822588324546814
*Get the signature of method: `native void nt_whatever()`* 匹配到的元操作或API：
query: Get the signature of method: `native void nt_whatever()`
most similar API: get generic signature of method
cosine Similarity: 0.8301761746406555
*Check whether the method is native: true* 匹配到的元操作或API：
logic: Check whether the method is native: true
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9691004753112793
*Get the name of method: `nt_whatever`* 匹配到的元操作或API：
query: Get the name of method: `nt_whatever`
most similar API: get name of method
cosine Similarity: 0.822588324546814
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for a native method: true (since `nt_whatever` matches the regex)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: `bar`* 匹配到的元操作或API：
logic: Get the name of method: `bar`
most similar meta operation: Get the name of method
cosine Similarity: 0.8704965114593506
*Get the signature of method: `void bar()`* 匹配到的元操作或API：
logic: Get the signature of method: `void bar()`
most similar meta operation: Get the signature of method
cosine Similarity: 0.8893685340881348
*Check whether the method is native: false* 匹配到的元操作或API：
logic: Check whether the method is native: false
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9489175081253052
*(Since it's not native, this method does not need to be checked against the native method regex)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: `Foo`* 匹配到的元操作或API：
logic: Get the name of method: `Foo`
most similar meta operation: Get the name of method
cosine Similarity: 0.9086973667144775
*Get the signature of method: `native void Foo()`* 匹配到的元操作或API：
logic: Get the signature of method: `native void Foo()`
most similar meta operation: Get the signature of method
cosine Similarity: 0.8719401359558105
*Check whether the method is native: true* 匹配到的元操作或API：
logic: Check whether the method is native: true
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9691004753112793
*Get the name of method: `Foo`* 匹配到的元操作或API：
logic: Get the name of method: `Foo`
most similar meta operation: Get the name of method
cosine Similarity: 0.9086973667144775
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for a native method: false (since `Foo` does not match the regex)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: `NT_Whatever`* 匹配到的元操作或API：
query: Get the name of method: `NT_Whatever`
most similar API: get name of method
cosine Similarity: 0.822588324546814
*Get the signature of method: `native void NT_Whatever()`* 匹配到的元操作或API：
query: Get the signature of method: `native void NT_Whatever()`
most similar API: get generic signature of method
cosine Similarity: 0.8301761746406555
*Check whether the method is native: true* 匹配到的元操作或API：
logic: Check whether the method is native: true
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9691004753112793
*Get the name of method: `NT_Whatever`* 匹配到的元操作或API：
query: Get the name of method: `NT_Whatever`
most similar API: get name of method
cosine Similarity: 0.822588324546814
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for a native method: false (since `NT_Whatever` does not match the regex)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Visit each method declaration within the class or interface
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        // Check if the method is static and does not match the naming pattern
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// Native method pattern
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'nt_whatever')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName(), //Returns the simple name of the method.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
94
78
84
70
107
91
=========================error_testcase_logics=========================
To analyze the given test case and check its adherence to the rule, let's break it down step-by-step:

1. Get the name of class.
2. Check whether the class extends TestCase.
3. Get the methods declared in class.
4. Check whether the method is public.
5. Check whether the method is a junit method.
6. Get the name of method.
7. Check whether the method name matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".

Let's go through these steps for each method in the `TournamentTest` class:

### For method `testGetBestTeam`
4. Check whether the method is public.
   - This method is public.
5. Check whether the method is a junit method.
   - Since the class extends `TestCase`, this method is a JUnit 3 test method.
6. Get the name of method.
   - The name of the method is `testGetBestTeam`.
7. Check whether the method name matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".
   - The method name `testGetBestTeam` matches the regex "test[A-Z0-9][a-zA-Z0-9]*" as it starts with `test` followed by an uppercase letter `G`.

### For method `test_getBestTeam`
4. Check whether the method is public.
   - This method is public.
5. Check whether the method is a junit method.
   - Since the class extends `TestCase`, this method is a JUnit 3 test method.
6. Get the name of method.
   - The name of the method is `test_getBestTeam`.
7. Check whether the method name matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".
   - The method name `test_getBestTeam` does not match the regex "test[A-Z0-9][a-zA-Z0-9]*" as it contains an underscore `_` after `test` which is not allowed by the regex.

Based on the above granular checks, the method `test_getBestTeam` violates the rule for JUnit 3 test method names as it does not comply with the specified regex. The number of violations in this test case is: 1.
['Get the name of class.', 'Check whether the class extends TestCase.', 'Get the methods declared in class.', 'Check whether the method is public.', 'Check whether the method is a junit method.', 'Get the name of method.', 'Check whether the method name matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".', 'Check whether the method is public.', 'Check whether the method is a junit method.', 'Get the name of method.', 'Check whether the method name matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".', 'Check whether the method is public.', 'Check whether the method is a junit method.', 'Get the name of method.', 'Check whether the method name matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'ASTImportDeclaration', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class extends TestCase.* 匹配到的元操作或API：
query: Check whether the class extends TestCase.
most similar API: Check whether is test class
cosine Similarity: 0.8235635757446289
*Get the methods declared in class.* 匹配到的元操作或API：
logic: Get the methods declared in class.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.850942075252533
*Check whether the method is public.* 匹配到的元操作或API：
logic: Check whether the method is public.
most similar meta operation: Check whether the method is public
cosine Similarity: 0.9820576906204224
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method
cosine Similarity: 0.8015708923339844
*Check whether the method is public.* 匹配到的元操作或API：
logic: Check whether the method is public.
most similar meta operation: Check whether the method is public
cosine Similarity: 0.9820576906204224
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method
cosine Similarity: 0.8015708923339844
*Check whether the method is public.* 匹配到的元操作或API：
logic: Check whether the method is public.
most similar meta operation: Check whether the method is public
cosine Similarity: 0.9820576906204224
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method
cosine Similarity: 0.8015708923339844
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 3 test detection
import junit.framework.Assert;
import junit.framework.TestCase;

public class TournamentTest extends TestCase {

    public void testGetBestTeam() {
    }

    // this is ok tho
    public void test_getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testGetBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'test_getBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestClass(net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPublic()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnit3Method(node) && !JUNIT3_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To check the adherence of the test case to the rule, we need to perform the following granular checks on each method:

1. Get the name of method.
2. Check whether the method is a JUnit method.
3. Get the name of the package where the class is located.
4. Check whether the package includes "junit.framework" or "org.junit".
5. Get the name of the class.
6. Check whether the class extends TestCase.
7. If the method is a JUnit method and the class extends TestCase, check whether the method name matches the JUnit 3 test method name regex.
8. If the method is not a JUnit method (or the class does not extend TestCase), check whether the method name matches the instance/static method name regex for non-JUnit methods.

Let's apply these checks to each method in the `TournamentTest` class:

### Method: `testGetBestTeam()`

1. Get the name of method: `testGetBestTeam`
2. Check whether the method is a JUnit method: This method is a JUnit method because it is in a class that extends `TestCase` and has a name starting with `test`.
3. Get the name of the package where the class is located: Not explicitly provided in the snippet, but it must include the JUnit 3 package as `TestCase` is imported from `junit.framework.TestCase`.
4. Check whether the package includes "junit.framework" or "org.junit": It includes "junit.framework".
5. Get the name of the class: `TournamentTest`
6. Check whether the class extends TestCase: Yes, it extends `TestCase`.
7. Check whether the method name matches the JUnit 3 test method name regex: The name `testGetBestTeam` matches the regex `test[A-Z0-9][a-zA-Z0-9]*`.

### Method: `test_getBestTeam()`

1. Get the name of method: `test_getBestTeam`
2. Check whether the method is a JUnit method: This method is a JUnit method because it is in a class that extends `TestCase` and has a name starting with `test`.
3. Get the name of the package where the class is located: Not explicitly provided in the snippet, but it must include the JUnit 3 package as `TestCase` is imported from `junit.framework.TestCase`.
4. Check whether the package includes "junit.framework" or "org.junit": It includes "junit.framework".
5. Get the name of the class: `TournamentTest`
6. Check whether the class extends TestCase: Yes, it extends `TestCase`.
7. Check whether the method name matches the JUnit 3 test method name regex: The name `test_getBestTeam` does not match the regex `test[A-Z0-9][a-zA-Z0-9]*` because the second character in the method name after `test` is an underscore (`_`).

Based on the above granular checks, the method `test_getBestTeam()` does not adhere to the rule for JUnit 3 test method names, as it does not match the specified regex. Therefore, this test case violates the rule.
['Get the name of method.', 'Check whether the method is a JUnit method.', 'Get the name of the package where the class is located.', 'Check whether the package includes "junit.framework" or "org.junit".', 'Get the name of the class.', 'Check whether the class extends TestCase.', 'If the method is a JUnit method and the class extends TestCase, check whether the method name matches the JUnit 3 test method name regex.', 'If the method is not a JUnit method (or the class does not extend TestCase), check whether the method name matches the instance/static method name regex for non-JUnit methods.', 'Get the name of method: `testGetBestTeam`', 'Check whether the method is a JUnit method: This method is a JUnit method because it is in a class that extends `TestCase` and has a name starting with `test`.', 'Get the name of the package where the class is located: Not explicitly provided in the snippet, but it must include the JUnit 3 package as `TestCase` is imported from `junit.framework.TestCase`.', 'Check whether the package includes "junit.framework" or "org.junit": It includes "junit.framework".', 'Get the name of the class: `TournamentTest`', 'Check whether the class extends TestCase: Yes, it extends `TestCase`.', 'Check whether the method name matches the JUnit 3 test method name regex: The name `testGetBestTeam` matches the regex `test[A-Z0-9][a-zA-Z0-9]*`.', 'Get the name of method: `test_getBestTeam`', 'Check whether the method is a JUnit method: This method is a JUnit method because it is in a class that extends `TestCase` and has a name starting with `test`.', 'Get the name of the package where the class is located: Not explicitly provided in the snippet, but it must include the JUnit 3 package as `TestCase` is imported from `junit.framework.TestCase`.', 'Check whether the package includes "junit.framework" or "org.junit": It includes "junit.framework".', 'Get the name of the class: `TournamentTest`', 'Check whether the class extends TestCase: Yes, it extends `TestCase`.', 'Check whether the method name matches the JUnit 3 test method name regex: The name `test_getBestTeam` does not match the regex `test[A-Z0-9][a-zA-Z0-9]*` because the second character in the method name after `test` is an underscore (`_`).']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'ASTImportDeclaration', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the package includes "junit.framework" or "org.junit".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the class.* 匹配到的元操作或API：
logic: Get the name of the class.
most similar meta operation: Get the name of class
cosine Similarity: 0.968898594379425
*Check whether the class extends TestCase.* 匹配到的元操作或API：
query: Check whether the class extends TestCase.
most similar API: Check whether is test class
cosine Similarity: 0.8235635757446289
*If the method is a JUnit method and the class extends TestCase, check whether the method name matches the JUnit 3 test method name regex.* 匹配到的元操作或API：
query: If the method is a JUnit method and the class extends TestCase, check whether the method name matches the JUnit 3 test method name regex.
most similar API: Check whether is junit3 method
cosine Similarity: 0.8457494974136353
*If the method is not a JUnit method (or the class does not extend TestCase), check whether the method name matches the instance/static method name regex for non-JUnit methods.* 匹配到的元操作或API：
query: If the method is not a JUnit method (or the class does not extend TestCase), check whether the method name matches the instance/static method name regex for non-JUnit methods.
most similar API: Check whether is junit3 method
cosine Similarity: 0.8027670383453369
*Get the name of method: `testGetBestTeam`* 匹配到的元操作或API：
query: Get the name of method: `testGetBestTeam`
most similar API: get name of method
cosine Similarity: 0.8321921825408936
*Check whether the method is a JUnit method: This method is a JUnit method because it is in a class that extends `TestCase` and has a name starting with `test`.* 匹配到的元操作或API：
query: Check whether the method is a JUnit method: This method is a JUnit method because it is in a class that extends `TestCase` and has a name starting with `test`.
most similar API: Check whether is junit method
cosine Similarity: 0.8565417528152466
*Get the name of the package where the class is located: Not explicitly provided in the snippet, but it must include the JUnit 3 package as `TestCase` is imported from `junit.framework.TestCase`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the package includes "junit.framework" or "org.junit": It includes "junit.framework".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the class: `TournamentTest`* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class extends TestCase: Yes, it extends `TestCase`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the JUnit 3 test method name regex: The name `testGetBestTeam` matches the regex `test[A-Z0-9][a-zA-Z0-9]*`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: `test_getBestTeam`* 匹配到的元操作或API：
query: Get the name of method: `test_getBestTeam`
most similar API: get name of method
cosine Similarity: 0.8398772478103638
*Check whether the method is a JUnit method: This method is a JUnit method because it is in a class that extends `TestCase` and has a name starting with `test`.* 匹配到的元操作或API：
query: Check whether the method is a JUnit method: This method is a JUnit method because it is in a class that extends `TestCase` and has a name starting with `test`.
most similar API: Check whether is junit method
cosine Similarity: 0.8565417528152466
*Get the name of the package where the class is located: Not explicitly provided in the snippet, but it must include the JUnit 3 package as `TestCase` is imported from `junit.framework.TestCase`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the package includes "junit.framework" or "org.junit": It includes "junit.framework".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the class: `TournamentTest`* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class extends TestCase: Yes, it extends `TestCase`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the JUnit 3 test method name regex: The name `test_getBestTeam` does not match the regex `test[A-Z0-9][a-zA-Z0-9]*` because the second character in the method name after `test` is an underscore (`_`).* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 3 test detection
import junit.framework.Assert;
import junit.framework.TestCase;

public class TournamentTest extends TestCase {

    public void testGetBestTeam() {
    }

    // this is ok tho
    public void test_getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testGetBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'test_getBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestClass(net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration)
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName(), //Returns the simple name of the method.
8. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //True if this is a junit @Test method (or a junit 3 method).



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnit3Method(node) && !JUNIT3_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method is a junit method.
3. Check whether the class extends TestCase to determine if it is a JUnit 3 test.
4. Get the name of called method (to identify the test method).
5. Check whether the name of the called method matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".

For the first method:
1. Get the name of method: `testGetBestTeam`
2. Check whether the method is a junit method: Yes, it is a JUnit method.
3. Check whether the class extends TestCase to determine if it is a JUnit 3 test: Yes, it extends `TestCase`.
4. Get the name of called method: `testGetBestTeam`
5. Check whether the name of the called method matches the regex for JUnit 3 test method names: Yes, it matches the regex "test[A-Z0-9][a-zA-Z0-9]*".

For the second method:
1. Get the name of method: `test_getBestTeam`
2. Check whether the method is a junit method: Yes, it is a JUnit method.
3. Check whether the class extends TestCase to determine if it is a JUnit 3 test: Yes, it extends `TestCase`.
4. Get the name of called method: `test_getBestTeam`
5. Check whether the name of the called method matches the regex for JUnit 3 test method names: No, it does not match the regex "test[A-Z0-9][a-zA-Z0-9]*".

The number of violating the rule in this test case is: 1 (method `test_getBestTeam` does not match the JUnit 3 test method name regex).
['Get the name of method.', 'Check whether the method is a junit method.', 'Check whether the class extends TestCase to determine if it is a JUnit 3 test.', 'Get the name of called method (to identify the test method).', 'Check whether the name of the called method matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".', 'Get the name of method: `testGetBestTeam`', 'Check whether the method is a junit method: Yes, it is a JUnit method.', 'Check whether the class extends TestCase to determine if it is a JUnit 3 test: Yes, it extends `TestCase`.', 'Get the name of called method: `testGetBestTeam`', 'Check whether the name of the called method matches the regex for JUnit 3 test method names: Yes, it matches the regex "test[A-Z0-9][a-zA-Z0-9]*".', 'Get the name of method: `test_getBestTeam`', 'Check whether the method is a junit method: Yes, it is a JUnit method.', 'Check whether the class extends TestCase to determine if it is a JUnit 3 test: Yes, it extends `TestCase`.', 'Get the name of called method: `test_getBestTeam`', 'Check whether the name of the called method matches the regex for JUnit 3 test method names: No, it does not match the regex "test[A-Z0-9][a-zA-Z0-9]*".']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'ASTImportDeclaration', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Check whether the class extends TestCase to determine if it is a JUnit 3 test.* 匹配到的元操作或API：
query: Check whether the class extends TestCase to determine if it is a JUnit 3 test.
most similar API: Check whether is junit3 class: True if this is a {@code TestCase} class for Junit 3.
cosine Similarity: 0.906019389629364
*Get the name of called method (to identify the test method).* 匹配到的元操作或API：
logic: Get the name of called method (to identify the test method).
most similar meta operation: Get the name of called method
cosine Similarity: 0.9174394607543945
*Check whether the name of the called method matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: `testGetBestTeam`* 匹配到的元操作或API：
query: Get the name of method: `testGetBestTeam`
most similar API: get name of method
cosine Similarity: 0.8321921825408936
*Check whether the method is a junit method: Yes, it is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method: Yes, it is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9512014389038086
*Check whether the class extends TestCase to determine if it is a JUnit 3 test: Yes, it extends `TestCase`.* 匹配到的元操作或API：
query: Check whether the class extends TestCase to determine if it is a JUnit 3 test: Yes, it extends `TestCase`.
most similar API: Check whether is junit3 class: True if this is a {@code TestCase} class for Junit 3.
cosine Similarity: 0.9093939661979675
*Get the name of called method: `testGetBestTeam`* 匹配到的元操作或API：
logic: Get the name of called method: `testGetBestTeam`
most similar meta operation: Get the name of called method
cosine Similarity: 0.862537682056427
*Check whether the name of the called method matches the regex for JUnit 3 test method names: Yes, it matches the regex "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: `test_getBestTeam`* 匹配到的元操作或API：
query: Get the name of method: `test_getBestTeam`
most similar API: get name of method
cosine Similarity: 0.8398772478103638
*Check whether the method is a junit method: Yes, it is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method: Yes, it is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9512014389038086
*Check whether the class extends TestCase to determine if it is a JUnit 3 test: Yes, it extends `TestCase`.* 匹配到的元操作或API：
query: Check whether the class extends TestCase to determine if it is a JUnit 3 test: Yes, it extends `TestCase`.
most similar API: Check whether is junit3 class: True if this is a {@code TestCase} class for Junit 3.
cosine Similarity: 0.9093939661979675
*Get the name of called method: `test_getBestTeam`* 匹配到的元操作或API：
logic: Get the name of called method: `test_getBestTeam`
most similar meta operation: Get the name of called method
cosine Similarity: 0.8720545768737793
*Check whether the name of the called method matches the regex for JUnit 3 test method names: No, it does not match the regex "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 3 test detection
import junit.framework.Assert;
import junit.framework.TestCase;

public class TournamentTest extends TestCase {

    public void testGetBestTeam() {
    }

    // this is ok tho
    public void test_getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testGetBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'test_getBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Class(net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration), //True if this is a {@code TestCase} class for Junit 3.
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName(), //Returns the simple name of the method.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnit3Class(node) && !JUNIT3_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Check whether the class is a JUnit test class.
2. Get the name of the class.
3. Check whether the class extends `TestCase` (JUnit 3).
4. Get all methods declared in the class.
5. Get the name of method.
6. Check whether method is a JUnit 3 test method.
7. Get the signature of method.
8. Check whether the method is public.
9. Get the name of method.
10. Check whether the method name matches the regex for JUnit 3 test method names: "test[A-Z0-9][a-zA-Z0-9]*".

For the method `testGetBestTeam`:
11. Check whether the method name matches the regex for JUnit 3 test method names: "test[A-Z0-9][a-zA-Z0-9]*".

For the method `test_getBestTeam`:
12. Check whether the method name matches the regex for JUnit 3 test method names: "test[A-Z0-9][a-zA-Z0-9]*".

The method `test_getBestTeam` does not match the JUnit 3 test method name regex, hence it violates the rule. The method `testGetBestTeam` matches the regex and does not violate the rule.
['Check whether the class is a JUnit test class.', 'Get the name of the class.', 'Check whether the class extends `TestCase` (JUnit 3).', 'Get all methods declared in the class.', 'Get the name of method.', 'Check whether method is a JUnit 3 test method.', 'Get the signature of method.', 'Check whether the method is public.', 'Get the name of method.', 'Check whether the method name matches the regex for JUnit 3 test method names: "test[A-Z0-9][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for JUnit 3 test method names: "test[A-Z0-9][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for JUnit 3 test method names: "test[A-Z0-9][a-zA-Z0-9]*".']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'ASTImportDeclaration', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Check whether the class is a JUnit test class.* 匹配到的元操作或API：
logic: Check whether the class is a JUnit test class.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.8680211305618286
*Get the name of the class.* 匹配到的元操作或API：
logic: Get the name of the class.
most similar meta operation: Get the name of class
cosine Similarity: 0.968898594379425
*Check whether the class extends `TestCase` (JUnit 3).* 匹配到的元操作或API：
query: Check whether the class extends `TestCase` (JUnit 3).
most similar API: Check whether is junit3 class: True if this is a {@code TestCase} class for Junit 3.
cosine Similarity: 0.8742191195487976
*Get all methods declared in the class.* 匹配到的元操作或API：
query: Get all methods declared in the class.
most similar API: get declared annotations of method
cosine Similarity: 0.8373103141784668
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether method is a JUnit 3 test method.* 匹配到的元操作或API：
logic: Check whether method is a JUnit 3 test method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9197065234184265
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827433228492737
*Check whether the method is public.* 匹配到的元操作或API：
logic: Check whether the method is public.
most similar meta operation: Check whether the method is public
cosine Similarity: 0.9820576906204224
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex for JUnit 3 test method names: "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names: "test[A-Z0-9][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method
cosine Similarity: 0.8054032325744629
*Check whether the method name matches the regex for JUnit 3 test method names: "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names: "test[A-Z0-9][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method
cosine Similarity: 0.8054032325744629
*Check whether the method name matches the regex for JUnit 3 test method names: "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names: "test[A-Z0-9][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method
cosine Similarity: 0.8054032325744629
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 3 test detection
import junit.framework.Assert;
import junit.framework.TestCase;

public class TournamentTest extends TestCase {

    public void testGetBestTeam() {
    }

    // this is ok tho
    public void test_getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testGetBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'test_getBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Class(net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration), //True if this is a {@code TestCase} class for Junit 3.
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPublic()
8. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnit3Class(node) && TestFrameworksUtil.isJUnit3Method(node) && !JUNIT3_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Check whether the class extends TestCase.
2. Get the name of method.
3. Check whether the method is public.
4. Check whether the method is void.
5. Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").
6. Get the next method.
7. Repeat steps 2-5 for the next method.

In this specific test case:

1. Check whether the class extends TestCase. (True, class extends TestCase)
2. Get the name of method. (First method is `testGetBestTeam`)
3. Check whether the method is public. (True, method is public)
4. Check whether the method is void. (True, method is void)
5. Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*"). (True, method name matches the regex)
6. Get the next method. (Next method is `test_getBestTeam`)
7. Get the name of method. (Method name is `test_getBestTeam`)
8. Check whether the method is public. (True, method is public)
9. Check whether the method is void. (True, method is void)
10. Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*"). (False, method name does not match the regex)

In this test case, the method `test_getBestTeam` violates the rule because its name does not match the regex for JUnit 3 test method names. The method `testGetBestTeam` adheres to the rule. Therefore, the number of violations is 1.
['Check whether the class extends TestCase.', 'Get the name of method.', 'Check whether the method is public.', 'Check whether the method is void.', 'Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").', 'Get the next method.', 'Repeat steps 2-5 for the next method.', 'Check whether the class extends TestCase. (True, class extends TestCase)', 'Get the name of method. (First method is `testGetBestTeam`)', 'Check whether the method is public. (True, method is public)', 'Check whether the method is void. (True, method is void)', 'Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*"). (True, method name matches the regex)', 'Get the next method. (Next method is `test_getBestTeam`)', 'Get the name of method. (Method name is `test_getBestTeam`)', 'Check whether the method is public. (True, method is public)', 'Check whether the method is void. (True, method is void)', 'Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*"). (False, method name does not match the regex)']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'ASTImportDeclaration', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Check whether the class extends TestCase.* 匹配到的元操作或API：
query: Check whether the class extends TestCase.
most similar API: Check whether is test class
cosine Similarity: 0.8235635757446289
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is public.* 匹配到的元操作或API：
logic: Check whether the method is public.
most similar meta operation: Check whether the method is public
cosine Similarity: 0.9820576906204224
*Check whether the method is void.* 匹配到的元操作或API：
logic: Check whether the method is void.
most similar meta operation: Check whether the return type of method is void
cosine Similarity: 0.9163467884063721
*Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").
most similar API: Check whether is junit3 method
cosine Similarity: 0.8099059462547302
*Get the next method.* 匹配到的元操作或API：
query: Get the next method.
most similar API: get next sibling of method
cosine Similarity: 0.8609321117401123
*Repeat steps 2-5 for the next method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class extends TestCase. (True, class extends TestCase)* 匹配到的元操作或API：
query: Check whether the class extends TestCase. (True, class extends TestCase)
most similar API: Check whether is test class
cosine Similarity: 0.8205196261405945
*Get the name of method. (First method is `testGetBestTeam`)* 匹配到的元操作或API：
logic: Get the name of method. (First method is `testGetBestTeam`)
most similar meta operation: Get the name of method
cosine Similarity: 0.8851190805435181
*Check whether the method is public. (True, method is public)* 匹配到的元操作或API：
logic: Check whether the method is public. (True, method is public)
most similar meta operation: Check whether the method is public
cosine Similarity: 0.9626951813697815
*Check whether the method is void. (True, method is void)* 匹配到的元操作或API：
logic: Check whether the method is void. (True, method is void)
most similar meta operation: Check whether the return type of method is void
cosine Similarity: 0.9075636863708496
*Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*"). (True, method name matches the regex)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the next method. (Next method is `test_getBestTeam`)* 匹配到的元操作或API：
query: Get the next method. (Next method is `test_getBestTeam`)
most similar API: get next sibling of method
cosine Similarity: 0.8182570934295654
*Get the name of method. (Method name is `test_getBestTeam`)* 匹配到的元操作或API：
logic: Get the name of method. (Method name is `test_getBestTeam`)
most similar meta operation: Get the name of method
cosine Similarity: 0.8730040192604065
*Check whether the method is public. (True, method is public)* 匹配到的元操作或API：
logic: Check whether the method is public. (True, method is public)
most similar meta operation: Check whether the method is public
cosine Similarity: 0.9626951813697815
*Check whether the method is void. (True, method is void)* 匹配到的元操作或API：
logic: Check whether the method is void. (True, method is void)
most similar meta operation: Check whether the return type of method is void
cosine Similarity: 0.9075636863708496
*Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*"). (False, method name does not match the regex)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 3 test detection
import junit.framework.Assert;
import junit.framework.TestCase;

public class TournamentTest extends TestCase {

    public void testGetBestTeam() {
    }

    // this is ok tho
    public void test_getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testGetBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'test_getBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestClass(net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration)
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPublic()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isVoid()
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.Node getNextSibling()



出现了语法错误，重新修复测试修复错误

==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 5
[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
84
70
99
82
107
91
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether method has declared annotations.
3. Get a declared annotation of method.
4. Check whether the annotation is Test.
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
6. Get the name of method.
7. Check whether method has declared annotations.
8. Get a declared annotation of method.
9. Check whether the annotation is Test.
10. Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*".

For the first method `get_best_team`:
- 1. Get the name of method: `get_best_team`
- 2. Check whether method has declared annotations: true
- 3. Get a declared annotation of method: `@Test`
- 4. Check whether the annotation is Test: true
- 5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": false (because it contains an underscore)

For the second method `getBestTeam`:
- 6. Get the name of method: `getBestTeam`
- 7. Check whether method has declared annotations: true
- 8. Get a declared annotation of method: `@Test`
- 9. Check whether the annotation is Test: true
- 10. Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*": false (because it does not start with "test")

The first method `get_best_team` violates the rule because it is a JUnit 4 test method and its name does not match the regex "[a-z][a-zA-Z0-9]*". The second method does not violate the rule as per the provided regex, but the rule description mentioned it should match "test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3 test methods. However, since the context here is JUnit 4 and the second method name matches the regex "[a-z][a-zA-Z0-9]*", it is considered correct for JUnit 4.

Thus, the number of violating the rule in this test case is 1 for the method `get_best_team`.
['Get the name of method.', 'Check whether method has declared annotations.', 'Get a declared annotation of method.', 'Check whether the annotation is Test.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether method has declared annotations.', 'Get a declared annotation of method.', 'Check whether the annotation is Test.', 'Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*".']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTImportDeclaration', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'ASTAnnotation', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether method has declared annotations.* 匹配到的元操作或API：
logic: Check whether method has declared annotations.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9891548156738281
*Get a declared annotation of method.* 匹配到的元操作或API：
logic: Get a declared annotation of method.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9867770075798035
*Check whether the annotation is Test.* 匹配到的元操作或API：
query: Check whether the annotation is Test.
most similar API: Check whether is junit4 test annotation
cosine Similarity: 0.8442187309265137
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether method has declared annotations.* 匹配到的元操作或API：
logic: Check whether method has declared annotations.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9891548156738281
*Get a declared annotation of method.* 匹配到的元操作或API：
logic: Get a declared annotation of method.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9867770075798035
*Check whether the annotation is Test.* 匹配到的元操作或API：
query: Check whether the annotation is Test.
most similar API: Check whether is junit4 test annotation
cosine Similarity: 0.8442187309265137
*Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 4 test detection without proper auxclasspath
import org.junit.Test; // note: test case uses "useAuxClasspath=false"!!

public class TournamentTest {

    // wrong test name pattern
    @Test
    public void get_best_team() {
    }

    // this is ok
    @Test
    public void getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'get_best_team')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'getBestTeam')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJunit4TestAnnotation(net.sourceforge.pmd.lang.java.ast.ASTAnnotation)

1.  //Check whether method has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTMethodDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (isJunit4TestMethod(node) && !JUNIT4_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }

    private boolean isJunit4TestMethod(ASTMethodDeclaration node) {
        return node.getDeclaredAnnotations().anyMatch(annotation -> TestFrameworksUtil.isJunit4TestAnnotation(annotation));
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class has declared annotations.
3. Get a declared annotation of class.
4. Check whether the class has `Test` annotation.
5. Get all methods declared in class.
6. Check whether method has declared annotations.
7. Get a declared annotation of method.
8. Check whether the method has `Test` annotation.
9. Get the name of method.
10. Check whether the method name matches the regex for JUnit 4 test method names.
11. If the method has a `Test` annotation, check whether it is an instance method.
12. If the method is an instance method and has a `Test` annotation, check whether its name matches the regex "[a-z][a-zA-Z0-9]*".
13. Check whether the method name matches the regex for JUnit 5 test method names.
14. If the method name does not match the regex for JUnit 4 or JUnit 5 test method names, and the method has a `Test` annotation, then this method violates the rule.

For the specific test case provided:

1. Get the name of class. // Name is TournamentTest
2. Check whether the class has declared annotations. // No annotations declared on the class
3. Get all methods declared in class. // Methods are get_best_team and getBestTeam
4. For the method `get_best_team`:
   6. Check whether the method has declared annotations. // `get_best_team` has a `Test` annotation
   7. Get a declared annotation of method. // Annotation is `Test`
   8. Check whether the method has `Test` annotation. // Confirmed to have `Test` annotation
   9. Get the name of method. // Name is get_best_team
   10. Check whether the method name matches the regex for JUnit 4 test method names. // get_best_team does not match "[a-z][a-zA-Z0-9]*"
   11. Check whether the method is an instance method. // `get_best_team` is an instance method
   12. Check whether its name matches the regex "[a-z][a-zA-Z0-9]*". // get_best_team does not match
   14. Check whether the method name matches the regex for JUnit 5 test method names. // get_best_team matches "[a-z][a-zA-Z0-9]*", but the rule specifies JUnit 4 test method names should follow a specific pattern.
   
Since the method `get_best_team` has a `Test` annotation and its name does not match the specified regex for JUnit 4 test method names, it violates the rule.

For the method `getBestTeam`:
   6. Check whether the method has declared annotations. // `getBestTeam` has a `Test` annotation
   7. Get a declared annotation of method. // Annotation is `Test`
   8. Check whether the method has `Test` annotation. // Confirmed to have `Test` annotation
   9. Get the name of method. // Name is getBestTeam
   10. Check whether the method name matches the regex for JUnit 4 test method names. // getBestTeam matches "[a-z][a-zA-Z0-9]*"
   
Since the method `getBestTeam` has a `Test` annotation and its name matches the specified regex for JUnit 4 test method names, it does not violate the rule.

Therefore, the number of violations in this test case is 1, specifically for the method `get_best_team`.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the class has `Test` annotation.', 'Get all methods declared in class.', 'Check whether method has declared annotations.', 'Get a declared annotation of method.', 'Check whether the method has `Test` annotation.', 'Get the name of method.', 'Check whether the method name matches the regex for JUnit 4 test method names.', 'If the method has a `Test` annotation, check whether it is an instance method.', 'If the method is an instance method and has a `Test` annotation, check whether its name matches the regex "[a-z][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for JUnit 5 test method names.', 'If the method name does not match the regex for JUnit 4 or JUnit 5 test method names, and the method has a `Test` annotation, then this method violates the rule.', 'Get the name of class. // Name is TournamentTest', 'Check whether the class has declared annotations. // No annotations declared on the class', 'Get all methods declared in class. // Methods are get_best_team and getBestTeam', 'For the method `get_best_team`:', 'Check whether the method has declared annotations. // `get_best_team` has a `Test` annotation', 'Get a declared annotation of method. // Annotation is `Test`', 'Check whether the method has `Test` annotation. // Confirmed to have `Test` annotation', 'Get the name of method. // Name is get_best_team', 'Check whether the method name matches the regex for JUnit 4 test method names. // get_best_team does not match "[a-z][a-zA-Z0-9]*"', 'Check whether the method is an instance method. // `get_best_team` is an instance method', 'Check whether its name matches the regex "[a-z][a-zA-Z0-9]*". // get_best_team does not match', 'Check whether the method name matches the regex for JUnit 5 test method names. // get_best_team matches "[a-z][a-zA-Z0-9]*", but the rule specifies JUnit 4 test method names should follow a specific pattern.', 'Check whether the method has declared annotations. // `getBestTeam` has a `Test` annotation', 'Get a declared annotation of method. // Annotation is `Test`', 'Check whether the method has `Test` annotation. // Confirmed to have `Test` annotation', 'Get the name of method. // Name is getBestTeam', 'Check whether the method name matches the regex for JUnit 4 test method names. // getBestTeam matches "[a-z][a-zA-Z0-9]*"']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTImportDeclaration', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'ASTAnnotation', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9878389835357666
*Check whether the class has `Test` annotation.* 匹配到的元操作或API：
logic: Check whether the class has `Test` annotation.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.860659658908844
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366355895996094
*Check whether method has declared annotations.* 匹配到的元操作或API：
logic: Check whether method has declared annotations.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9891548156738281
*Get a declared annotation of method.* 匹配到的元操作或API：
logic: Get a declared annotation of method.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9867770075798035
*Check whether the method has `Test` annotation.* 匹配到的元操作或API：
logic: Check whether the method has `Test` annotation.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.8676824569702148
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex for JUnit 4 test method names.* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 4 test method names.
most similar API: Check whether is junit4 method
cosine Similarity: 0.831702470779419
*If the method has a `Test` annotation, check whether it is an instance method.* 匹配到的元操作或API：
query: If the method has a `Test` annotation, check whether it is an instance method.
most similar API: Check whether is test method
cosine Similarity: 0.8602263927459717
*If the method is an instance method and has a `Test` annotation, check whether its name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: If the method is an instance method and has a `Test` annotation, check whether its name matches the regex "[a-z][a-zA-Z0-9]*".
most similar API: Check whether the method is any annotation present
cosine Similarity: 0.8075345754623413
*Check whether the method name matches the regex for JUnit 5 test method names.* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 5 test method names.
most similar API: Check whether is junit5 method
cosine Similarity: 0.8380169868469238
*If the method name does not match the regex for JUnit 4 or JUnit 5 test method names, and the method has a `Test` annotation, then this method violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class. // Name is TournamentTest* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has declared annotations. // No annotations declared on the class* 匹配到的元操作或API：
logic: Check whether the class has declared annotations. // No annotations declared on the class
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9486607313156128
*Get all methods declared in class. // Methods are get_best_team and getBestTeam* 匹配到的元操作或API：
未匹配成功元操作或API
*For the method `get_best_team`:* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method has declared annotations. // `get_best_team` has a `Test` annotation* 匹配到的元操作或API：
logic: Check whether the method has declared annotations. // `get_best_team` has a `Test` annotation
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.8585034608840942
*Get a declared annotation of method. // Annotation is `Test`* 匹配到的元操作或API：
logic: Get a declared annotation of method. // Annotation is `Test`
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9258067011833191
*Check whether the method has `Test` annotation. // Confirmed to have `Test` annotation* 匹配到的元操作或API：
query: Check whether the method has `Test` annotation. // Confirmed to have `Test` annotation
most similar API: Check whether the method is any annotation present
cosine Similarity: 0.8458964824676514
*Get the name of method. // Name is get_best_team* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 4 test method names. // get_best_team does not match "[a-z][a-zA-Z0-9]*"* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is an instance method. // `get_best_team` is an instance method* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether its name matches the regex "[a-z][a-zA-Z0-9]*". // get_best_team does not match* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 5 test method names. // get_best_team matches "[a-z][a-zA-Z0-9]*", but the rule specifies JUnit 4 test method names should follow a specific pattern.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method has declared annotations. // `getBestTeam` has a `Test` annotation* 匹配到的元操作或API：
logic: Check whether the method has declared annotations. // `getBestTeam` has a `Test` annotation
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.8994799852371216
*Get a declared annotation of method. // Annotation is `Test`* 匹配到的元操作或API：
logic: Get a declared annotation of method. // Annotation is `Test`
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9258067011833191
*Check whether the method has `Test` annotation. // Confirmed to have `Test` annotation* 匹配到的元操作或API：
query: Check whether the method has `Test` annotation. // Confirmed to have `Test` annotation
most similar API: Check whether the method is any annotation present
cosine Similarity: 0.8458964824676514
*Get the name of method. // Name is getBestTeam* 匹配到的元操作或API：
logic: Get the name of method. // Name is getBestTeam
most similar meta operation: Get the name of method
cosine Similarity: 0.8787223100662231
*Check whether the method name matches the regex for JUnit 4 test method names. // getBestTeam matches "[a-z][a-zA-Z0-9]*"* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 4 test detection without proper auxclasspath
import org.junit.Test; // note: test case uses "useAuxClasspath=false"!!

public class TournamentTest {

    // wrong test name pattern
    @Test
    public void get_best_team() {
    }

    // this is ok
    @Test
    public void getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'get_best_team')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'getBestTeam')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit4Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection), //Checks whether any annotation is present on this node. @param binaryNames            Collection that contains binary names of annotations.            Note: for now, canonical names are tolerated, this may be changed in PMD 7. @return <code>true</code> if any annotation is present on this node, else <code>false</code>
8. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit5Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether method has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTMethodDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();

        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnit4Method(node) && !JUNIT4_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnit5Method(node) && !JUNIT5_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }

        return data;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class has declared annotations.
3. Get a declared annotation of class.
4. Check whether the class has Test annotation.
5. Get all methods declared in class.
6. Check whether method has declared annotations.
7. Get a declared annotation of method.
8. Check whether the method has Test annotation.
9. Get the name of method.
10. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
11. Check whether the method is static.
12. Get the name of method.
13. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
14. Check whether the method is static.

In this case, it's important to focus on the methods that have the Test annotation.

1. Get the name of method (for the first method).
2. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
3. Get the name of method (for the second method).
4. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

The first method `get_best_team` does not match the regex "[a-z][a-zA-Z0-9]*" because it contains underscores.

The second method `getBestTeam` matches the regex "[a-z][a-zA-Z0-9]*" and thus adheres to the rule.

Therefore, the number of violating the rule in this test case is 1.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the class has Test annotation.', 'Get all methods declared in class.', 'Check whether method has declared annotations.', 'Get a declared annotation of method.', 'Check whether the method has Test annotation.', 'Get the name of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Check whether the method is static.', 'Get the name of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Check whether the method is static.', 'Get the name of method (for the first method).', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method (for the second method).', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTImportDeclaration', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'ASTAnnotation', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9878389835357666
*Check whether the class has Test annotation.* 匹配到的元操作或API：
logic: Check whether the class has Test annotation.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.8742661476135254
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366355895996094
*Check whether method has declared annotations.* 匹配到的元操作或API：
logic: Check whether method has declared annotations.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9891548156738281
*Get a declared annotation of method.* 匹配到的元操作或API：
logic: Get a declared annotation of method.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9867770075798035
*Check whether the method has Test annotation.* 匹配到的元操作或API：
logic: Check whether the method has Test annotation.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.8841648101806641
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Get the name of method (for the first method).* 匹配到的元操作或API：
logic: Get the name of method (for the first method).
most similar meta operation: Get the name of method
cosine Similarity: 0.910377025604248
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method (for the second method).* 匹配到的元操作或API：
logic: Get the name of method (for the second method).
most similar meta operation: Get the name of method
cosine Similarity: 0.9097568988800049
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 4 test detection without proper auxclasspath
import org.junit.Test; // note: test case uses "useAuxClasspath=false"!!

public class TournamentTest {

    // wrong test name pattern
    @Test
    public void get_best_team() {
    }

    // this is ok
    @Test
    public void getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'get_best_team')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'getBestTeam')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether method has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTMethodDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (isJUnit4TestMethod(node) && !JUNIT4_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }

    private boolean isJUnit4TestMethod(ASTMethodDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.anyMatch(annotation -> {
            ASTClassOrInterfaceType type = annotation.getType();
            return type != null && "Test".equals(type.getSimpleName()) && "org.junit".equals(type.getPackageName());
        });
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method is a junit method.
3. Get the name of called method for the annotation.
4. Check whether the called method name is Test.
5. Get the name of method.
6. Get the signature of method.
7. Check whether the method signature throws any Exception.
8. Get a declared annotation of method.
9. Check whether the method has Test annotation.
10. Get the name of method.
11. Check whether the method name matches the regex pattern "[a-z][a-zA-Z0-9]*".
12. Get the name of method.
13. Check whether the method name matches the JUnit 4 test method name regex pattern "[a-z][a-zA-Z0-9]*".

Since the test case specifies that the detection for JUnit 4 test methods does not use the proper auxclasspath, let's assume the rule checker takes the presence of the `@Test` annotation as a heuristic to identify JUnit test methods.

The second method `getBestTeam` matches the JUnit 4 test method name regex pattern, so it is not a violation.

For the first method `get_best_team`:
1. Get the name of method (get_best_team).
2. Check whether the method is a junit method (true, because it has a @Test annotation).
3. Get the name of called method for the annotation (Test).
4. Check whether the called method name is Test (true).
5. Get the name of method (get_best_team).
6. Get the signature of method (public void get_best_team()).
7. Check whether the method signature throws any Exception (false).
8. Get a declared annotation of method (@Test).
9. Check whether the method has Test annotation (true).
10. Get the name of method (get_best_team).
11. Check whether the method name matches the regex pattern "[a-z][a-zA-Z0-9]*" (false, because it contains an underscore).
12. Get the name of method (get_best_team).
13. Check whether the method name matches the JUnit 4 test method name regex pattern "[a-z][a-zA-Z0-9]*" (false, because it contains an underscore).

Since the method `get_best_team` does not match the JUnit 4 test method name regex pattern, it violates the rule.
['Get the name of method.', 'Check whether the method is a junit method.', 'Get the name of called method for the annotation.', 'Check whether the called method name is Test.', 'Get the name of method.', 'Get the signature of method.', 'Check whether the method signature throws any Exception.', 'Get a declared annotation of method.', 'Check whether the method has Test annotation.', 'Get the name of method.', 'Check whether the method name matches the regex pattern "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method name matches the JUnit 4 test method name regex pattern "[a-z][a-zA-Z0-9]*".', 'Get the name of method (get_best_team).', 'Check whether the method is a junit method (true, because it has a @Test annotation).', 'Get the name of called method for the annotation (Test).', 'Check whether the called method name is Test (true).', 'Get the name of method (get_best_team).', 'Get the signature of method (public void get_best_team()).', 'Check whether the method signature throws any Exception (false).', 'Get a declared annotation of method (@Test).', 'Check whether the method has Test annotation (true).', 'Get the name of method (get_best_team).', 'Check whether the method name matches the regex pattern "[a-z][a-zA-Z0-9]*" (false, because it contains an underscore).', 'Get the name of method (get_best_team).', 'Check whether the method name matches the JUnit 4 test method name regex pattern "[a-z][a-zA-Z0-9]*" (false, because it contains an underscore).']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTImportDeclaration', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'ASTAnnotation', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Get the name of called method for the annotation.* 匹配到的元操作或API：
logic: Get the name of called method for the annotation.
most similar meta operation: Get the name of called method
cosine Similarity: 0.926863431930542
*Check whether the called method name is Test.* 匹配到的元操作或API：
query: Check whether the called method name is Test.
most similar API: Check whether is test method
cosine Similarity: 0.8869897127151489
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827433228492737
*Check whether the method signature throws any Exception.* 匹配到的元操作或API：
logic: Check whether the method signature throws any Exception.
most similar meta operation: Check whether the method signature throws x Exception
cosine Similarity: 0.9251600503921509
*Get a declared annotation of method.* 匹配到的元操作或API：
logic: Get a declared annotation of method.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9867770075798035
*Check whether the method has Test annotation.* 匹配到的元操作或API：
logic: Check whether the method has Test annotation.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.8841648101806641
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex pattern "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the JUnit 4 test method name regex pattern "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the JUnit 4 test method name regex pattern "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit4 method
cosine Similarity: 0.8199860453605652
*Get the name of method (get_best_team).* 匹配到的元操作或API：
query: Get the name of method (get_best_team).
most similar API: get name of method
cosine Similarity: 0.8094407320022583
*Check whether the method is a junit method (true, because it has a @Test annotation).* 匹配到的元操作或API：
logic: Check whether the method is a junit method (true, because it has a @Test annotation).
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9384229779243469
*Get the name of called method for the annotation (Test).* 匹配到的元操作或API：
logic: Get the name of called method for the annotation (Test).
most similar meta operation: Get the name of called method
cosine Similarity: 0.8824434280395508
*Check whether the called method name is Test (true).* 匹配到的元操作或API：
query: Check whether the called method name is Test (true).
most similar API: Check whether is test method
cosine Similarity: 0.8627369999885559
*Get the name of method (get_best_team).* 匹配到的元操作或API：
query: Get the name of method (get_best_team).
most similar API: get name of method
cosine Similarity: 0.8094407320022583
*Get the signature of method (public void get_best_team()).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method signature throws any Exception (false).* 匹配到的元操作或API：
logic: Check whether the method signature throws any Exception (false).
most similar meta operation: Check whether the method signature throws x Exception
cosine Similarity: 0.8998376131057739
*Get a declared annotation of method (@Test).* 匹配到的元操作或API：
logic: Get a declared annotation of method (@Test).
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9266241192817688
*Check whether the method has Test annotation (true).* 匹配到的元操作或API：
logic: Check whether the method has Test annotation (true).
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.8684337139129639
*Get the name of method (get_best_team).* 匹配到的元操作或API：
query: Get the name of method (get_best_team).
most similar API: get name of method
cosine Similarity: 0.8094407320022583
*Check whether the method name matches the regex pattern "[a-z][a-zA-Z0-9]*" (false, because it contains an underscore).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method (get_best_team).* 匹配到的元操作或API：
query: Get the name of method (get_best_team).
most similar API: get name of method
cosine Similarity: 0.8094407320022583
*Check whether the method name matches the JUnit 4 test method name regex pattern "[a-z][a-zA-Z0-9]*" (false, because it contains an underscore).* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 4 test detection without proper auxclasspath
import org.junit.Test; // note: test case uses "useAuxClasspath=false"!!

public class TournamentTest {

    // wrong test name pattern
    @Test
    public void get_best_team() {
    }

    // this is ok
    @Test
    public void getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'get_best_team')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'getBestTeam')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
7. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit4Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
8. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName(), //Returns the simple name of the method.

1.  //Check whether the method signature throws x Exception
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean throwsSpecificException(ASTMethodDeclaration node){
    ASTThrowsList list = node.getThrowsList();
    if(list == null){
        return false;
    }else{
        for(ASTClassOrInterfaceType classOrInterfaceType : list){
            if(TypeTestUtil.isA(x.class, classOrInterfaceType)){
                return true;
            }
        }
    }
    return false;
}
```
2.  //Check whether method has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTMethodDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnit3Method(node) && !JUNIT3_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnit4Method(node) && !JUNIT4_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnit5Method(node) && !JUNIT5_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method has the @Test annotation.
3. Get the name of method for the first method (get_best_team).
4. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for JUnit 4 test methods.
5. Get the name of method for the second method (getBestTeam).
6. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for JUnit 4 test methods.
7. Check whether the method is a JUnit method without using the auxclasspath for the first method.
8. Check whether the method is a JUnit method without using the auxclasspath for the second method.

If the method has the @Test annotation and does not match the expected regex pattern, it violates the rule. In this test case, the first method `get_best_team` does not match the regex "[a-z][a-zA-Z0-9]*" because it contains an underscore, so it violates the rule. The second method `getBestTeam` matches the regex and does not violate the rule.
['Get the name of method.', 'Check whether the method has the @Test annotation.', 'Get the name of method for the first method (get_best_team).', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for JUnit 4 test methods.', 'Get the name of method for the second method (getBestTeam).', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for JUnit 4 test methods.', 'Check whether the method is a JUnit method without using the auxclasspath for the first method.', 'Check whether the method is a JUnit method without using the auxclasspath for the second method.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTImportDeclaration', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'ASTAnnotation', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method has the @Test annotation.* 匹配到的元操作或API：
query: Check whether the method has the @Test annotation.
most similar API: Check whether the method is annotation present
cosine Similarity: 0.8465763330459595
*Get the name of method for the first method (get_best_team).* 匹配到的元操作或API：
query: Get the name of method for the first method (get_best_team).
most similar API: get name of method: Returns the simple name of the method.
cosine Similarity: 0.8060116171836853
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for JUnit 4 test methods.* 匹配到的元操作或API：
query: Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for JUnit 4 test methods.
most similar API: Check whether is junit4 method
cosine Similarity: 0.8186453580856323
*Get the name of method for the second method (getBestTeam).* 匹配到的元操作或API：
logic: Get the name of method for the second method (getBestTeam).
most similar meta operation: Get the name of method
cosine Similarity: 0.862165629863739
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for JUnit 4 test methods.* 匹配到的元操作或API：
query: Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for JUnit 4 test methods.
most similar API: Check whether is junit4 method
cosine Similarity: 0.8186453580856323
*Check whether the method is a JUnit method without using the auxclasspath for the first method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method without using the auxclasspath for the first method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.8800845146179199
*Check whether the method is a JUnit method without using the auxclasspath for the second method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method without using the auxclasspath for the second method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.8751400113105774
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 4 test detection without proper auxclasspath
import org.junit.Test; // note: test case uses "useAuxClasspath=false"!!

public class TournamentTest {

    // wrong test name pattern
    @Test
    public void get_best_team() {
    }

    // this is ok
    @Test
    public void getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'get_best_team')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'getBestTeam')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAnnotationPresent(java.lang.Class), //Returns true if an annotation with the given type is applied to this node.
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName(), //Returns the simple name of the method.
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit4Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnit4Method(node) && !JUNIT4_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 6
[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method is native.
4. Check whether the method is a JUnit 3 method.
5. Check whether the method is a JUnit 4 method.
6. Check whether the method is a JUnit 5 method.
7. Check whether the method name matches the regex pattern for instance methods: "[a-z][a-zA-Z0-9]*".

Let's perform the checks for each method:

For `fooBar` method:
1. Get the name of method: fooBar
2. Check whether the method is static: False
3. Check whether the method is native: False
4. Check whether the method is a JUnit 3 method: False
5. Check whether the method is a JUnit 4 method: False
6. Check whether the method is a JUnit 5 method: False
7. Check whether the method name matches the regex pattern for instance methods: True (fooBar matches the pattern)

For `m_fooBar` method:
1. Get the name of method: m_fooBar
2. Check whether the method is static: False
3. Check whether the method is native: False
4. Check whether the method is a JUnit 3 method: False
5. Check whether the method is a JUnit 4 method: False
6. Check whether the method is a JUnit 5 method: False
7. Check whether the method name matches the regex pattern for instance methods: False (m_fooBar does not match the pattern)

Based on these checks, the `m_fooBar` method violates the rule as its name does not match the regex pattern for instance methods.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is native.', 'Check whether the method is a JUnit 3 method.', 'Check whether the method is a JUnit 4 method.', 'Check whether the method is a JUnit 5 method.', 'Check whether the method name matches the regex pattern for instance methods: "[a-z][a-zA-Z0-9]*".', 'Get the name of method: fooBar', 'Check whether the method is static: False', 'Check whether the method is native: False', 'Check whether the method is a JUnit 3 method: False', 'Check whether the method is a JUnit 4 method: False', 'Check whether the method is a JUnit 5 method: False', 'Check whether the method name matches the regex pattern for instance methods: True (fooBar matches the pattern)', 'Get the name of method: m_fooBar', 'Check whether the method is static: False', 'Check whether the method is native: False', 'Check whether the method is a JUnit 3 method: False', 'Check whether the method is a JUnit 4 method: False', 'Check whether the method is a JUnit 5 method: False', 'Check whether the method name matches the regex pattern for instance methods: False (m_fooBar does not match the pattern)']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124157905579
*Check whether the method is a JUnit 3 method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit 3 method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9112962484359741
*Check whether the method is a JUnit 4 method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit 4 method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.8955751657485962
*Check whether the method is a JUnit 5 method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit 5 method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9123812913894653
*Check whether the method name matches the regex pattern for instance methods: "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: fooBar* 匹配到的元操作或API：
logic: Get the name of method: fooBar
most similar meta operation: Get the name of method
cosine Similarity: 0.8897057175636292
*Check whether the method is static: False* 匹配到的元操作或API：
logic: Check whether the method is static: False
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9611486792564392
*Check whether the method is native: False* 匹配到的元操作或API：
logic: Check whether the method is native: False
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9489175081253052
*Check whether the method is a JUnit 3 method: False* 匹配到的元操作或API：
logic: Check whether the method is a JUnit 3 method: False
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9174875020980835
*Check whether the method is a JUnit 4 method: False* 匹配到的元操作或API：
logic: Check whether the method is a JUnit 4 method: False
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9035330414772034
*Check whether the method is a JUnit 5 method: False* 匹配到的元操作或API：
logic: Check whether the method is a JUnit 5 method: False
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.915166437625885
*Check whether the method name matches the regex pattern for instance methods: True (fooBar matches the pattern)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: m_fooBar* 匹配到的元操作或API：
logic: Get the name of method: m_fooBar
most similar meta operation: Get the name of method
cosine Similarity: 0.8615140914916992
*Check whether the method is static: False* 匹配到的元操作或API：
logic: Check whether the method is static: False
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9611486792564392
*Check whether the method is native: False* 匹配到的元操作或API：
logic: Check whether the method is native: False
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9489175081253052
*Check whether the method is a JUnit 3 method: False* 匹配到的元操作或API：
logic: Check whether the method is a JUnit 3 method: False
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9174875020980835
*Check whether the method is a JUnit 4 method: False* 匹配到的元操作或API：
logic: Check whether the method is a JUnit 4 method: False
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9035330414772034
*Check whether the method is a JUnit 5 method: False* 匹配到的元操作或API：
logic: Check whether the method is a JUnit 5 method: False
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.915166437625885
*Check whether the method name matches the regex pattern for instance methods: False (m_fooBar does not match the pattern)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// Instance method custom convention
public class Foo {

    public void fooBar() {
    }

    public void m_fooBar() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'm_fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (TestFrameworksUtil.isJUnitMethod(node)) {
            if (!JUNIT3_METHOD_PATTERN.matcher(node.getName()).matches() &&
                !JUNIT4_METHOD_PATTERN.matcher(node.getName()).matches() &&
                !JUNIT5_METHOD_PATTERN.matcher(node.getName()).matches()) {
                addViolation(data, node);
            }
        } else if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (!node.isStatic() && !node.isNative() && !INSTANCE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method is a junit method.
4. Get the regex for instance method names.
5. Check whether the method name matches the regex for instance method names.
6. Get the regex for static method names.
7. Check whether the method name matches the regex for static method names.
8. Get the regex for native method names.
9. Check whether the method name matches the regex for native method names.
10. Get the regex for JUnit 3 test method names.
11. Check whether the method name matches the regex for JUnit 3 test method names.
12. Get the regex for JUnit 4 test method names.
13. Check whether the method name matches the regex for JUnit 4 test method names.
14. Get the regex for JUnit 5 test method names.
15. Check whether the method name matches the regex for JUnit 5 test method names.

For the method `fooBar`:
16. Get the name of method.
    - Method name is `fooBar`.
17. Check whether the method is static.
    - Method is not static.
18. Check whether the method is a junit method.
    - Method is not a JUnit method.
19. Get the regex for instance method names.
    - Regex is "[a-z][a-zA-Z0-9]*".
20. Check whether the method name matches the regex for instance method names.
    - `fooBar` matches the regex.

For the method `m_fooBar`:
21. Get the name of method.
    - Method name is `m_fooBar`.
22. Check whether the method is static.
    - Method is not static.
23. Check whether the method is a junit method.
    - Method is not a JUnit method.
24. Get the regex for instance method names.
    - Regex is "[a-z][a-zA-Z0-9]*".
25. Check whether the method name matches the regex for instance method names.
    - `m_fooBar` does not match the regex.

Since `m_fooBar` does not match the regex for instance method names, it violates the rule.
The number of violating the rule in this test case is: 1
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is a junit method.', 'Get the regex for instance method names.', 'Check whether the method name matches the regex for instance method names.', 'Get the regex for static method names.', 'Check whether the method name matches the regex for static method names.', 'Get the regex for native method names.', 'Check whether the method name matches the regex for native method names.', 'Get the regex for JUnit 3 test method names.', 'Check whether the method name matches the regex for JUnit 3 test method names.', 'Get the regex for JUnit 4 test method names.', 'Check whether the method name matches the regex for JUnit 4 test method names.', 'Get the regex for JUnit 5 test method names.', 'Check whether the method name matches the regex for JUnit 5 test method names.', 'Get the name of method.', 'Check whether the method is static.', 'Check whether the method is a junit method.', 'Get the regex for instance method names.', 'Check whether the method name matches the regex for instance method names.', 'Get the name of method.', 'Check whether the method is static.', 'Check whether the method is a junit method.', 'Get the regex for instance method names.', 'Check whether the method name matches the regex for instance method names.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Get the regex for instance method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for instance method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the regex for static method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for static method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the regex for native method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for native method names.* 匹配到的元操作或API：
query: Check whether the method name matches the regex for native method names.
most similar API: Check whether the method is native
cosine Similarity: 0.8058079481124878
*Get the regex for JUnit 3 test method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 3 test method names.* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names.
most similar API: Check whether is junit3 method
cosine Similarity: 0.8450577259063721
*Get the regex for JUnit 4 test method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 4 test method names.* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 4 test method names.
most similar API: Check whether is junit4 method
cosine Similarity: 0.831702470779419
*Get the regex for JUnit 5 test method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 5 test method names.* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 5 test method names.
most similar API: Check whether is junit5 method
cosine Similarity: 0.8380169868469238
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Get the regex for instance method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for instance method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Get the regex for instance method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for instance method names.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// Instance method custom convention
public class Foo {

    public void fooBar() {
    }

    public void m_fooBar() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'm_fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit4Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
7. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit5Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (TestFrameworksUtil.isJUnit3Method(node) && !JUNIT3_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (TestFrameworksUtil.isJUnit4Method(node) && !JUNIT4_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (TestFrameworksUtil.isJUnit5Method(node) && !JUNIT5_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (!node.isStatic() && !node.isNative() && !INSTANCE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To ascertain the adherence of the test case to the rule, we need to perform granular checks on each method declared in the class `Foo`.

1. Get the name of method.
2. Check whether the method is an instance method.
3. Check whether the name matches the regex "[a-z][a-zA-Z0-9]*" for instance methods.

Repeat the above checks for each method:

- For the method `fooBar`:
    1. Get the name of method. // `fooBar`
    2. Check whether the method is an instance method. // true
    3. Check whether the name matches the regex "[a-z][a-zA-Z0-9]*" for instance methods. // true (matches)

- For the method `m_fooBar`:
    1. Get the name of method. // `m_fooBar`
    2. Check whether the method is an instance method. // true
    3. Check whether the name matches the regex "[a-z][a-zA-Z0-9]*" for instance methods. // false (does not match)

Based on the above checks, the method `m_fooBar` violates the rule as its name does not match the regex pattern for instance methods.

Therefore, the number of methods violating the rule in this test case is: 1.
['Get the name of method.', 'Check whether the method is an instance method.', 'Check whether the name matches the regex "[a-z][a-zA-Z0-9]*" for instance methods.', 'Get the name of method. // `fooBar`', 'Check whether the method is an instance method. // true', 'Check whether the name matches the regex "[a-z][a-zA-Z0-9]*" for instance methods. // true (matches)', 'Get the name of method. // `m_fooBar`', 'Check whether the method is an instance method. // true', 'Check whether the name matches the regex "[a-z][a-zA-Z0-9]*" for instance methods. // false (does not match)']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is an instance method.* 匹配到的元操作或API：
query: Check whether the method is an instance method.
most similar API: Check whether is test method
cosine Similarity: 0.8555020093917847
*Check whether the name matches the regex "[a-z][a-zA-Z0-9]*" for instance methods.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. // `fooBar`* 匹配到的元操作或API：
logic: Get the name of method. // `fooBar`
most similar meta operation: Get the name of method
cosine Similarity: 0.891360878944397
*Check whether the method is an instance method. // true* 匹配到的元操作或API：
query: Check whether the method is an instance method. // true
most similar API: Check whether is test method
cosine Similarity: 0.8239220380783081
*Check whether the name matches the regex "[a-z][a-zA-Z0-9]*" for instance methods. // true (matches)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. // `m_fooBar`* 匹配到的元操作或API：
logic: Get the name of method. // `m_fooBar`
most similar meta operation: Get the name of method
cosine Similarity: 0.8708948493003845
*Check whether the method is an instance method. // true* 匹配到的元操作或API：
query: Check whether the method is an instance method. // true
most similar API: Check whether is test method
cosine Similarity: 0.8239220380783081
*Check whether the name matches the regex "[a-z][a-zA-Z0-9]*" for instance methods. // false (does not match)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// Instance method custom convention
public class Foo {

    public void fooBar() {
    }

    public void m_fooBar() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'm_fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (TestFrameworksUtil.isTestMethod(node)) {
            if (!JUNIT3_TEST_METHOD_PATTERN.matcher(node.getName()).matches() &&
                !JUNIT4_TEST_METHOD_PATTERN.matcher(node.getName()).matches() &&
                !JUNIT5_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
                addViolation(data, node);
            }
        } else if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (!node.isStatic() && !node.isNative() && !INSTANCE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method is native.
4. Check whether the method is a junit method.
5. Get the signature of method.
6. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
7. Get the name of method.
8. Check whether the method is static.
9. Check whether the method is native.
10. Check whether the method is a junit method.
11. Get the signature of method.
12. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

For method `fooBar`:
- 1. Get the name of method: fooBar
- 2. Check whether the method is static: false
- 3. Check whether the method is native: false
- 4. Check whether the method is a junit method: false
- 6. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": true (This method does not violate the rule)

For method `m_fooBar`:
- 7. Get the name of method: m_fooBar
- 8. Check whether the method is static: false
- 9. Check whether the method is native: false
- 10. Check whether the method is a junit method: false
- 12. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": false (This method violates the rule)

The number of methods violating the rule in this test case is: 1
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is native.', 'Check whether the method is a junit method.', 'Get the signature of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is static.', 'Check whether the method is native.', 'Check whether the method is a junit method.', 'Get the signature of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124157905579
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827433228492737
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124157905579
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827433228492737
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// Instance method custom convention
public class Foo {

    public void fooBar() {
    }

    public void m_fooBar() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'm_fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (TestFrameworksUtil.isJUnitMethod(node)) {
            if (!JUNIT3_TEST_METHOD_PATTERN.matcher(node.getName()).matches() &&
                !JUNIT4_TEST_METHOD_PATTERN.matcher(node.getName()).matches() &&
                !JUNIT5_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
                addViolation(data, node);
            }
        } else if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (!node.isStatic() && !node.isNative() && !INSTANCE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method is native.
4. Check whether the method is a junit method.
5. Get the signature of method.
6. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
7. Repeat steps 1-6 for each method in the class.

For the given test case:
1. Get the name of method: fooBar.
2. Check whether the method is static: false.
3. Check whether the method is native: false.
4. Check whether the method is a junit method: false.
5. Get the signature of method: public void fooBar().
6. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": true (but this is an instance method and the name does not follow the camel case convention for instance methods, which should start with a lowercase letter).

Next method:
1. Get the name of method: m_fooBar.
2. Check whether the method is static: false.
3. Check whether the method is native: false.
4. Check whether the method is a junit method: false.
5. Get the signature of method: public void m_fooBar().
6. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": false (this method name does not match the standard camel case convention for instance method names).

The number of violating the rule in this test case is: 1

The method `m_fooBar` violates the rule because its name does not match the regex "[a-z][a-zA-Z0-9]*" which applies to instance method names.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is native.', 'Check whether the method is a junit method.', 'Get the signature of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Repeat steps 1-6 for each method in the class.', 'Get the name of method: fooBar.', 'Check whether the method is static: false.', 'Check whether the method is native: false.', 'Check whether the method is a junit method: false.', 'Get the signature of method: public void fooBar().', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": true (but this is an instance method and the name does not follow the camel case convention for instance methods, which should start with a lowercase letter).', 'Get the name of method: m_fooBar.', 'Check whether the method is static: false.', 'Check whether the method is native: false.', 'Check whether the method is a junit method: false.', 'Get the signature of method: public void m_fooBar().', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": false (this method name does not match the standard camel case convention for instance method names).']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812489748001099
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124157905579
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799771308898926
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827433228492737
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 1-6 for each method in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: fooBar.* 匹配到的元操作或API：
logic: Get the name of method: fooBar.
most similar meta operation: Get the name of method
cosine Similarity: 0.8815590143203735
*Check whether the method is static: false.* 匹配到的元操作或API：
logic: Check whether the method is static: false.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9351266622543335
*Check whether the method is native: false.* 匹配到的元操作或API：
logic: Check whether the method is native: false.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9184080362319946
*Check whether the method is a junit method: false.* 匹配到的元操作或API：
logic: Check whether the method is a junit method: false.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9346438050270081
*Get the signature of method: public void fooBar().* 匹配到的元操作或API：
logic: Get the signature of method: public void fooBar().
most similar meta operation: Get the signature of method
cosine Similarity: 0.9087714552879333
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": true (but this is an instance method and the name does not follow the camel case convention for instance methods, which should start with a lowercase letter).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: m_fooBar.* 匹配到的元操作或API：
logic: Get the name of method: m_fooBar.
most similar meta operation: Get the name of method
cosine Similarity: 0.8562745451927185
*Check whether the method is static: false.* 匹配到的元操作或API：
logic: Check whether the method is static: false.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9351266622543335
*Check whether the method is native: false.* 匹配到的元操作或API：
logic: Check whether the method is native: false.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9184080362319946
*Check whether the method is a junit method: false.* 匹配到的元操作或API：
logic: Check whether the method is a junit method: false.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9346438050270081
*Get the signature of method: public void m_fooBar().* 匹配到的元操作或API：
logic: Get the signature of method: public void m_fooBar().
most similar meta operation: Get the signature of method
cosine Similarity: 0.8949941992759705
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": false (this method name does not match the standard camel case convention for instance method names).* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// Instance method custom convention
public class Foo {

    public void fooBar() {
    }

    public void m_fooBar() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'm_fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        node.children(ASTMethodDeclaration.class).forEach(method -> visit(method, data));
        return data;
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (TestFrameworksUtil.isJUnitMethod(node)) {
            if (!JUNIT3_TEST_METHOD_PATTERN.matcher(node.getName()).matches() &&
                !JUNIT4_TEST_METHOD_PATTERN.matcher(node.getName()).matches() &&
                !JUNIT5_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
                addViolation(data, node);
            }
        } else if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (!node.isStatic() && !node.isNative() && !INSTANCE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return data;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 7
测试用例全部通过
最终通过 7 个测试用例
正例 5 个
反例 2 个
输入token：452081
输出token：263634
结束

规则执行完毕，时间总花销： 2244.058676481247 秒
