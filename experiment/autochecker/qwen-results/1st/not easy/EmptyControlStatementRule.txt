开始

========================================== Rule EmptyControlStatementRule ===========================================
一共 31 个测试用例
正例 9 个
反例 22 个
2129
1700
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the body of try statement.
2. Check whether the body of try statement is empty.
3. Get the body of catch clause.
4. Check whether the body of catch clause is empty.
5. Get the body of finally clause (if present).
6. Check whether the body of finally clause is empty.
7. Get the body of switch statement (if present).
8. Check whether the body of switch statement is empty.
9. Get the body of synchronized statement (if present).
10. Check whether the body of synchronized statement is empty.
11. Get the body of if statement (if present).
12. Check whether the body of if statement is empty.
13. Get the body of else statement (if present).
14. Check whether the body of else statement is empty.
15. Get the body of while loop statement (if present).
16. Check whether the body of while loop statement is empty.
17. Get the body of for loop statement (if present).
18. Check whether the body of for loop statement is empty.
19. Get the body of do-while loop statement (if present).
20. Check whether the body of do-while loop statement is empty.
21. Get the body of initializers and blocks used as statements (if present).
22. Check whether the body of initializers and blocks used as statements is empty.

In this test case:

1. Get the body of try statement.
2. Check whether the body of try statement is empty.  // This check will return true as the try block is empty.
3. Get the body of catch clause.
4. Check whether the body of catch clause is empty.  // This check will return false as the catch block contains e.printStackTrace().
5. Get the body of finally clause (if present).
6. Check whether the body of finally clause is empty.  // This check is not applicable as there is no finally block.

Since the body of the try statement is empty, this test case violates the rule.
['Get the body of try statement.', 'Check whether the body of try statement is empty.', 'Get the body of catch clause.', 'Check whether the body of catch clause is empty.', 'Get the body of finally clause (if present).', 'Check whether the body of finally clause is empty.', 'Get the body of switch statement (if present).', 'Check whether the body of switch statement is empty.', 'Get the body of synchronized statement (if present).', 'Check whether the body of synchronized statement is empty.', 'Get the body of if statement (if present).', 'Check whether the body of if statement is empty.', 'Get the body of else statement (if present).', 'Check whether the body of else statement is empty.', 'Get the body of while loop statement (if present).', 'Check whether the body of while loop statement is empty.', 'Get the body of for loop statement (if present).', 'Check whether the body of for loop statement is empty.', 'Get the body of do-while loop statement (if present).', 'Check whether the body of do-while loop statement is empty.', 'Get the body of initializers and blocks used as statements (if present).', 'Check whether the body of initializers and blocks used as statements is empty.', 'Get the body of try statement.', 'Check whether the body of try statement is empty.  // This check will return true as the try block is empty.', 'Get the body of catch clause.', 'Check whether the body of catch clause is empty.  // This check will return false as the catch block contains e.printStackTrace().', 'Get the body of finally clause (if present).', 'Check whether the body of finally clause is empty.  // This check is not applicable as there is no finally block.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTExpressionStatement', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTCatchClause', 'ASTCatchParameter', 'ASTVariableDeclaratorId', 'ASTBlock', 'ASTVariableAccess', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the body of try statement.* 匹配到的元操作或API：
query: Get the body of try statement.
most similar API: get body of try statement
cosine Similarity: 0.9849938750267029
*Check whether the body of try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8571393489837646
*Get the body of catch clause.* 匹配到的元操作或API：
logic: Get the body of catch clause.
most similar meta operation: Get a parameter of catch clause
cosine Similarity: 0.8649000525474548
*Check whether the body of catch clause is empty.* 匹配到的元操作或API：
query: Check whether the body of catch clause is empty.
most similar API: get body of catch clause
cosine Similarity: 0.8372232913970947
*Get the body of finally clause (if present).* 匹配到的元操作或API：
query: Get the body of finally clause (if present).
most similar API: get finally clause of try statement
cosine Similarity: 0.8336633443832397
*Check whether the body of finally clause is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of switch statement (if present).* 匹配到的元操作或API：
logic: Get the body of switch statement (if present).
most similar meta operation: Get the condition of switch statement
cosine Similarity: 0.8504118919372559
*Check whether the body of switch statement is empty.* 匹配到的元操作或API：
query: Check whether the body of switch statement is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8093870282173157
*Get the body of synchronized statement (if present).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of synchronized statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of if statement (if present).* 匹配到的元操作或API：
query: Get the body of if statement (if present).
most similar API: get body of try statement
cosine Similarity: 0.8114956617355347
*Check whether the body of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8571334481239319
*Get the body of else statement (if present).* 匹配到的元操作或API：
logic: Get the body of else statement (if present).
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.8622741103172302
*Check whether the body of else statement is empty.* 匹配到的元操作或API：
query: Check whether the body of else statement is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8019800186157227
*Get the body of while loop statement (if present).* 匹配到的元操作或API：
query: Get the body of while loop statement (if present).
most similar API: get body of try statement
cosine Similarity: 0.8332709074020386
*Check whether the body of while loop statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of for loop statement (if present).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of for loop statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of do-while loop statement (if present).* 匹配到的元操作或API：
query: Get the body of do-while loop statement (if present).
most similar API: get body of try statement
cosine Similarity: 0.8214432001113892
*Check whether the body of do-while loop statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of initializers and blocks used as statements (if present).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of initializers and blocks used as statements is empty.* 匹配到的元操作或API：
query: Check whether the body of initializers and blocks used as statements is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.840742826461792
*Get the body of try statement.* 匹配到的元操作或API：
query: Get the body of try statement.
most similar API: get body of try statement
cosine Similarity: 0.9849938750267029
*Check whether the body of try statement is empty.  // This check will return true as the try block is empty.* 匹配到的元操作或API：
query: Check whether the body of try statement is empty.  // This check will return true as the try block is empty.
most similar API: get body of try statement
cosine Similarity: 0.8101565837860107
*Get the body of catch clause.* 匹配到的元操作或API：
logic: Get the body of catch clause.
most similar meta operation: Get a parameter of catch clause
cosine Similarity: 0.8649000525474548
*Check whether the body of catch clause is empty.  // This check will return false as the catch block contains e.printStackTrace().* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of finally clause (if present).* 匹配到的元操作或API：
query: Get the body of finally clause (if present).
most similar API: get finally clause of try statement
cosine Similarity: 0.8336633443832397
*Check whether the body of finally clause is empty.  // This check is not applicable as there is no finally block.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
The test case corresponding to the rule:
```
// pos, empty try block
public class EmptyTryBlock1 {
                public void foo() {
                    try {
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock1')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTExpressionStatement
                ——ASTMethodCall (called method name = 'printStackTrace')
                  ——ASTVariableAccess (referenced variable name = 'e')
                  ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
2. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTCatchParameter getParameter()
3. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this catch branch.
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause(), //Returns the {@code finally} clause of this try statement, if any. @return The finally statement, or null if there is none
5. net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getTestedExpression()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()
7. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
8. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch()
9. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBlock().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        if (node.getFirstChild().isEmpty()) {
            addViolation(data, node);
        }
        ASTStatement elseBranch = node.getElseBranch();
        if (elseBranch != null && elseBranch.isEmpty()) {
            addViolation(data, elseBranch);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTTryStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the body of try statement.
2. Check whether the body of try statement is empty.
3. Get the body of catch clause.
4. Check whether the body of catch clause is empty.
5. Get the body of finally clause of try statement.
6. Check whether the body of finally clause is empty.

If the body of the try statement is empty, then this test case violates the rule. In this specific test case, step 2 will confirm the violation.
['Get the body of try statement.', 'Check whether the body of try statement is empty.', 'Get the body of catch clause.', 'Check whether the body of catch clause is empty.', 'Get the body of finally clause of try statement.', 'Check whether the body of finally clause is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTExpressionStatement', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTCatchClause', 'ASTCatchParameter', 'ASTVariableDeclaratorId', 'ASTBlock', 'ASTVariableAccess', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the body of try statement.* 匹配到的元操作或API：
query: Get the body of try statement.
most similar API: get body of try statement
cosine Similarity: 0.9849938750267029
*Check whether the body of try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8571393489837646
*Get the body of catch clause.* 匹配到的元操作或API：
logic: Get the body of catch clause.
most similar meta operation: Get a parameter of catch clause
cosine Similarity: 0.8649000525474548
*Check whether the body of catch clause is empty.* 匹配到的元操作或API：
query: Check whether the body of catch clause is empty.
most similar API: get body of catch clause
cosine Similarity: 0.8372232913970947
*Get the body of finally clause of try statement.* 匹配到的元操作或API：
logic: Get the body of finally clause of try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.8654305338859558
*Check whether the body of finally clause is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
The test case corresponding to the rule:
```
// pos, empty try block
public class EmptyTryBlock1 {
                public void foo() {
                    try {
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock1')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTExpressionStatement
                ——ASTMethodCall (called method name = 'printStackTrace')
                  ——ASTVariableAccess (referenced variable name = 'e')
                  ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
2. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTCatchParameter getParameter()
3. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this catch branch.
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class);
    }
    
    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBlock().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTIfStatement node, Object data) {
        if (node.getFirstBranch().getBlock().isEmpty()) {
            addViolation(data, node.getFirstBranch());
        }
        ASTElseClause elseClause = node.getElseClause();
        if (elseClause != null && elseClause.getBlock().isEmpty()) {
            addViolation(data, elseClause);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        if (node.getBlock().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTForStatement node, Object data) {
        if (node.getBlock().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTDoStatement node, Object data) {
        if (node.getBlock().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTMethodDeclaration) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the body of try statement.
2. Check whether the body of try statement is empty.
3. Get the body of catch clause.
4. Check whether the body of catch clause is empty.
5. Get the body of finally clause of try statement.
6. Check whether the body of finally clause is empty.

Given the test case, the granular checks should be:

1. Get the body of try statement.
2. Check whether the body of try statement is empty. (This should report the violation as the body is empty.)

The catch and finally clauses in the test case are not empty, so they do not violate the rule. Therefore, the number of violations in this test case is 1, which aligns with the provided description.
['Get the body of try statement.', 'Check whether the body of try statement is empty.', 'Get the body of catch clause.', 'Check whether the body of catch clause is empty.', 'Get the body of finally clause of try statement.', 'Check whether the body of finally clause is empty.', 'Get the body of try statement.', 'Check whether the body of try statement is empty. (This should report the violation as the body is empty.)']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTExpressionStatement', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTCatchClause', 'ASTCatchParameter', 'ASTVariableDeclaratorId', 'ASTBlock', 'ASTVariableAccess', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the body of try statement.* 匹配到的元操作或API：
query: Get the body of try statement.
most similar API: get body of try statement
cosine Similarity: 0.9849938750267029
*Check whether the body of try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8571393489837646
*Get the body of catch clause.* 匹配到的元操作或API：
logic: Get the body of catch clause.
most similar meta operation: Get a parameter of catch clause
cosine Similarity: 0.8649000525474548
*Check whether the body of catch clause is empty.* 匹配到的元操作或API：
query: Check whether the body of catch clause is empty.
most similar API: get body of catch clause
cosine Similarity: 0.8372232913970947
*Get the body of finally clause of try statement.* 匹配到的元操作或API：
logic: Get the body of finally clause of try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.8654305338859558
*Check whether the body of finally clause is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of try statement.* 匹配到的元操作或API：
query: Get the body of try statement.
most similar API: get body of try statement
cosine Similarity: 0.9849938750267029
*Check whether the body of try statement is empty. (This should report the violation as the body is empty.)* 匹配到的元操作或API：
query: Check whether the body of try statement is empty. (This should report the violation as the body is empty.)
most similar API: get body of try statement
cosine Similarity: 0.8365203142166138
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
The test case corresponding to the rule:
```
// pos, empty try block
public class EmptyTryBlock1 {
                public void foo() {
                    try {
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock1')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTExpressionStatement
                ——ASTMethodCall (called method name = 'printStackTrace')
                  ——ASTVariableAccess (referenced variable name = 'e')
                  ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
2. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTCatchParameter getParameter()
3. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this catch branch.
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTCatchClause.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTClassOrInterfaceBodyDeclaration.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTCatchClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock thenBlock = node.getFirstChildOfType(ASTBlock.class);
        if (thenBlock != null && thenBlock.getNumChildren() == 0) {
            addViolation(data, thenBlock);
        }
        ASTBlock elseBlock = node.getElseClause();
        if (elseBlock != null && elseBlock.getNumChildren() == 0) {
            addViolation(data, elseBlock);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.getParent() instanceof ASTClassOrInterfaceBodyDeclaration && node.getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Get all method declarations in class.
3. Get the method name of each method declaration.
4. Check whether the method name is foo.
5. Get the body of method foo.
6. Get all statements in the body of method foo.
7. Check whether the statement is a try statement.
8. Get the try block of the try statement.
9. Check whether the try block is empty.

If the try block is empty, then this test case violates the rule. The number of violations is 1, as indicated.
['Get the name of class.', 'Get all method declarations in class.', 'Get the method name of each method declaration.', 'Check whether the method name is foo.', 'Get the body of method foo.', 'Get all statements in the body of method foo.', 'Check whether the statement is a try statement.', 'Get the try block of the try statement.', 'Check whether the try block is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTExpressionStatement', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTCatchClause', 'ASTCatchParameter', 'ASTVariableDeclaratorId', 'ASTBlock', 'ASTVariableAccess', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all method declarations in class.* 匹配到的元操作或API：
logic: Get all method declarations in class.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.8512491583824158
*Get the method name of each method declaration.* 匹配到的元操作或API：
logic: Get the method name of each method declaration.
most similar meta operation: Get the name of method
cosine Similarity: 0.8749961853027344
*Check whether the method name is foo.* 匹配到的元操作或API：
query: Check whether the method name is foo.
most similar API: Check whether the method equals
cosine Similarity: 0.8480665683746338
*Get the body of method foo.* 匹配到的元操作或API：
query: Get the body of method foo.
most similar API: get body of method
cosine Similarity: 0.9337469339370728
*Get all statements in the body of method foo.* 匹配到的元操作或API：
query: Get all statements in the body of method foo.
most similar API: get body of method
cosine Similarity: 0.8139541149139404
*Check whether the statement is a try statement.* 匹配到的元操作或API：
query: Check whether the statement is a try statement.
most similar API: Check whether the try statement equals
cosine Similarity: 0.9079430103302002
*Get the try block of the try statement.* 匹配到的元操作或API：
query: Get the try block of the try statement.
most similar API: get body of try statement
cosine Similarity: 0.8504365086555481
*Check whether the try block is empty.* 匹配到的元操作或API：
query: Check whether the try block is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8674914240837097
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
The test case corresponding to the rule:
```
// pos, empty try block
public class EmptyTryBlock1 {
                public void foo() {
                    try {
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock1')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTExpressionStatement
                ——ASTMethodCall (called method name = 'printStackTrace')
                  ——ASTVariableAccess (referenced variable name = 'e')
                  ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
5. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean equals(java.lang.Object)
6. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
7. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyBlock.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoWhileStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyBlock node, Object data) {
        if (node.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getNumChildren() == 0 && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    // Get method declaration from method call
    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method) {
        JMethodSymbol symbol = (JMethodSymbol) method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the body of the try statement.
2. Check whether the body of the try statement is empty.
3. Get the body of the catch clause.
4. Check whether the body of the catch clause is empty.
5. Get the body of the finally clause.
6. Check whether the body of the finally clause is empty.
7. Get the body of the if statement.
8. Check whether the body of the if statement is empty.
9. Get the body of the else statement.
10. Check whether the body of the else statement is empty.
11. Get the body of the for statement.
12. Check whether the body of the for statement is empty.
13. Get the body of the while statement.
14. Check whether the body of the while statement is empty.
15. Get the body of the do-while statement.
16. Check whether the body of the do-while statement is empty.
17. Get the body of the switch statement.
18. Check whether the body of the switch statement is empty.
19. Get the body of the synchronized statement.
20. Check whether the body of the synchronized statement is empty.
21. Get the body of the initializer block.
22. Check whether the body of the initializer block is empty.

In this test case:
1. Get the body of the try statement.
2. Check whether the body of the try statement is empty. (This will be true, indicating a violation of the rule)
3. Get the body of the catch clause.
4. Check whether the body of the catch clause is empty. (This will be false, no violation of the rule)
5. Get the body of the finally clause.
6. Check whether the body of the finally clause is empty. (This will be false, as there is no finally block)

Based on the above checks, the number of violating the rule in this test case is: 1
The description of this test case is: bad 1 (The try block body is empty)
['Get the body of the try statement.', 'Check whether the body of the try statement is empty.', 'Get the body of the catch clause.', 'Check whether the body of the catch clause is empty.', 'Get the body of the finally clause.', 'Check whether the body of the finally clause is empty.', 'Get the body of the if statement.', 'Check whether the body of the if statement is empty.', 'Get the body of the else statement.', 'Check whether the body of the else statement is empty.', 'Get the body of the for statement.', 'Check whether the body of the for statement is empty.', 'Get the body of the while statement.', 'Check whether the body of the while statement is empty.', 'Get the body of the do-while statement.', 'Check whether the body of the do-while statement is empty.', 'Get the body of the switch statement.', 'Check whether the body of the switch statement is empty.', 'Get the body of the synchronized statement.', 'Check whether the body of the synchronized statement is empty.', 'Get the body of the initializer block.', 'Check whether the body of the initializer block is empty.', 'Get the body of the try statement.', 'Check whether the body of the try statement is empty. (This will be true, indicating a violation of the rule)', 'Get the body of the catch clause.', 'Check whether the body of the catch clause is empty. (This will be false, no violation of the rule)', 'Get the body of the finally clause.', 'Check whether the body of the finally clause is empty. (This will be false, as there is no finally block)']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTExpressionStatement', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTCatchClause', 'ASTCatchParameter', 'ASTVariableDeclaratorId', 'ASTBlock', 'ASTVariableAccess', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the body of the try statement.* 匹配到的元操作或API：
query: Get the body of the try statement.
most similar API: get body of try statement
cosine Similarity: 0.9787790179252625
*Check whether the body of the try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8486955761909485
*Get the body of the catch clause.* 匹配到的元操作或API：
logic: Get the body of the catch clause.
most similar meta operation: Get a parameter of catch clause
cosine Similarity: 0.8557887077331543
*Check whether the body of the catch clause is empty.* 匹配到的元操作或API：
query: Check whether the body of the catch clause is empty.
most similar API: Check whether the catch clause equals
cosine Similarity: 0.8271185159683228
*Get the body of the finally clause.* 匹配到的元操作或API：
query: Get the body of the finally clause.
most similar API: get finally clause of try statement
cosine Similarity: 0.8548771739006042
*Check whether the body of the finally clause is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the if statement.* 匹配到的元操作或API：
query: Get the body of the if statement.
most similar API: get body of try statement
cosine Similarity: 0.845529317855835
*Check whether the body of the if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of the if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8603641390800476
*Get the body of the else statement.* 匹配到的元操作或API：
logic: Get the body of the else statement.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.8584789633750916
*Check whether the body of the else statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the for statement.* 匹配到的元操作或API：
query: Get the body of the for statement.
most similar API: get body of try statement: Returns the body of this try statement.
cosine Similarity: 0.802523136138916
*Check whether the body of the for statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the for statement is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8181268572807312
*Get the body of the while statement.* 匹配到的元操作或API：
query: Get the body of the while statement.
most similar API: get body of try statement
cosine Similarity: 0.8494767546653748
*Check whether the body of the while statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the do-while statement.* 匹配到的元操作或API：
query: Get the body of the do-while statement.
most similar API: get body of try statement
cosine Similarity: 0.8317021131515503
*Check whether the body of the do-while statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the switch statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the switch statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the switch statement is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8094785809516907
*Get the body of the synchronized statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the synchronized statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the initializer block.* 匹配到的元操作或API：
query: Get the body of the initializer block.
most similar API: get body of class or interface
cosine Similarity: 0.8090934753417969
*Check whether the body of the initializer block is empty.* 匹配到的元操作或API：
query: Check whether the body of the initializer block is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8630777597427368
*Get the body of the try statement.* 匹配到的元操作或API：
query: Get the body of the try statement.
most similar API: get body of try statement
cosine Similarity: 0.9787790179252625
*Check whether the body of the try statement is empty. (This will be true, indicating a violation of the rule)* 匹配到的元操作或API：
query: Check whether the body of the try statement is empty. (This will be true, indicating a violation of the rule)
most similar API: get body of try statement
cosine Similarity: 0.8151361346244812
*Get the body of the catch clause.* 匹配到的元操作或API：
logic: Get the body of the catch clause.
most similar meta operation: Get a parameter of catch clause
cosine Similarity: 0.8557887077331543
*Check whether the body of the catch clause is empty. (This will be false, no violation of the rule)* 匹配到的元操作或API：
query: Check whether the body of the catch clause is empty. (This will be false, no violation of the rule)
most similar API: Check whether the catch clause equals
cosine Similarity: 0.8332996964454651
*Get the body of the finally clause.* 匹配到的元操作或API：
query: Get the body of the finally clause.
most similar API: get finally clause of try statement
cosine Similarity: 0.8548771739006042
*Check whether the body of the finally clause is empty. (This will be false, as there is no finally block)* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
The test case corresponding to the rule:
```
// pos, empty try block
public class EmptyTryBlock1 {
                public void foo() {
                    try {
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock1')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTExpressionStatement
                ——ASTMethodCall (called method name = 'printStackTrace')
                  ——ASTVariableAccess (referenced variable name = 'e')
                  ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
2. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTCatchParameter getParameter()
3. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause(), //Returns the {@code finally} clause of this try statement, if any. @return The finally statement, or null if there is none
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
6. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTTypeBody getBody(), //Returns the body of this type declaration.



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoWhileStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getFirstChild() instanceof ASTBlock && ((ASTBlock) finallyClause.getFirstChild()).isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getFirstChild() instanceof ASTBlock && ((ASTBlock) node.getFirstChild()).isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getFirstChild() instanceof ASTBlock && ((ASTBlock) node.getFirstChild()).isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        if (node.getFirstChild() instanceof ASTBlock && ((ASTBlock) node.getFirstChild()).isEmpty()) {
            addViolation(data, node);
        }
        ASTStatement elseBranch = node.getElseBranch();
        if (elseBranch instanceof ASTBlock && ((ASTBlock) elseBranch).isEmpty()) {
            addViolation(data, elseBranch);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        if (node.getFirstChild() instanceof ASTBlock && ((ASTBlock) node.getFirstChild()).isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        if (node.getFirstChild() instanceof ASTBlock && ((ASTBlock) node.getFirstChild()).isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoWhileStatement node, Object data) {
        if (node.getFirstChild() instanceof ASTBlock && ((ASTBlock) node.getFirstChild()).isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTBlockStatement && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 1
1954
1552
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the method declaration from method call.
2. Get the body of the method.
3. Get the try statement from the method body.
4. Check whether the try block is empty.
5. Get the finally block from the try statement.
6. Check whether the finally block is empty.
7. Get the initializers and blocks used as statements from the method body.
8. Check whether any initializer or block is empty.

Based on the provided test case:
1. Get the method declaration from method call: `public void foo()`
2. Get the body of the method: 
    ```java
    try {
    } finally {
        int x = 5;
    }
    ```
3. Get the try statement from the method body: 
    ```java
    try {
    }
    ```
4. Check whether the try block is empty: **True**
5. Get the finally block from the try statement: 
    ```java
    finally {
        int x = 5;
    }
    ```
6. Check whether the finally block is empty: **False**
7. Get the initializers and blocks used as statements from the method body: **None**
8. Check whether any initializer or block is empty: **False**

The number of violating the rule in this test case is: 1 (the empty try block).
        The description of this test case is: bad 2
['Get the method declaration from method call.', 'Get the body of the method.', 'Get the try statement from the method body.', 'Check whether the try block is empty.', 'Get the finally block from the try statement.', 'Check whether the finally block is empty.', 'Get the initializers and blocks used as statements from the method body.', 'Check whether any initializer or block is empty.', 'Get the method declaration from method call: `public void foo()`', 'Get the body of the method:', 'Get the try statement from the method body:', 'Check whether the try block is empty: **True**', 'Get the finally block from the try statement:', 'Check whether the finally block is empty: **False**', 'Get the initializers and blocks used as statements from the method body: **None**', 'Check whether any initializer or block is empty: **False**']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTBlock', 'ASTFinallyClause', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'ASTVariableDeclarator', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTNumericLiteral']
*Get the method declaration from method call.* 匹配到的元操作或API：
logic: Get the method declaration from method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9787436127662659
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Get the try statement from the method body.* 匹配到的元操作或API：
query: Get the try statement from the method body.
most similar API: get body of try statement
cosine Similarity: 0.9219610691070557
*Check whether the try block is empty.* 匹配到的元操作或API：
query: Check whether the try block is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8674914240837097
*Get the finally block from the try statement.* 匹配到的元操作或API：
logic: Get the finally block from the try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9098196029663086
*Check whether the finally block is empty.* 匹配到的元操作或API：
query: Check whether the finally block is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8699493408203125
*Get the initializers and blocks used as statements from the method body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any initializer or block is empty.* 匹配到的元操作或API：
query: Check whether any initializer or block is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.882697343826294
*Get the method declaration from method call: `public void foo()`* 匹配到的元操作或API：
logic: Get the method declaration from method call: `public void foo()`
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9399864077568054
*Get the body of the method:* 匹配到的元操作或API：
query: Get the body of the method:
most similar API: get body of method
cosine Similarity: 0.9694322943687439
*Get the try statement from the method body:* 匹配到的元操作或API：
query: Get the try statement from the method body:
most similar API: get body of try statement
cosine Similarity: 0.9233849048614502
*Check whether the try block is empty: **True*** 匹配到的元操作或API：
query: Check whether the try block is empty: **True**
most similar API: Check whether the block is empty
cosine Similarity: 0.8611892461776733
*Get the finally block from the try statement:* 匹配到的元操作或API：
logic: Get the finally block from the try statement:
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9100555181503296
*Check whether the finally block is empty: **False*** 匹配到的元操作或API：
query: Check whether the finally block is empty: **False**
most similar API: Check whether the block is empty
cosine Similarity: 0.8519734740257263
*Get the initializers and blocks used as statements from the method body: **None*** 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any initializer or block is empty: **False*** 匹配到的元操作或API：
query: Check whether any initializer or block is empty: **False**
most similar API: Check whether the block is empty
cosine Similarity: 0.8700752258300781
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
The test case corresponding to the rule:
```
// pos, empty try block
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock2')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTFinallyClause
            ——ASTBlock
              ——ASTLocalVariableDeclaration
                ——ASTModifierList
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTVariableDeclarator
                  ——ASTVariableDeclaratorId (declared variable name = 'x')
                  ——ASTNumericLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
3. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileLoop.class, ASTForLoop.class, ASTDoWhileLoop.class, ASTInitializer.class, ASTBlock.class);
    }
    
    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, body);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getFirstChildOfType(ASTBlock.class).isEmpty()) {
            addViolation(data, finallyClause.getFirstChildOfType(ASTBlock.class));
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock thenBlock = node.getFirstChildOfType(ASTBlock.class);
        if (thenBlock != null && thenBlock.isEmpty()) {
            addViolation(data, thenBlock);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTWhileLoop node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTForLoop node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTDoWhileLoop node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.getParent() instanceof ASTMethodDeclaration && node.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the body of try statement.
2. Check whether the body of try statement is empty.
3. Get the finally branch of try statement.
4. Check whether the finally branch of try statement is empty.

For this test case:
1. The body of the try statement is empty.
2. The finally branch of the try statement is not empty.

Therefore, the test case violates the rule with 1 empty try block body.
['Get the body of try statement.', 'Check whether the body of try statement is empty.', 'Get the finally branch of try statement.', 'Check whether the finally branch of try statement is empty.', 'The body of the try statement is empty.', 'The finally branch of the try statement is not empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTBlock', 'ASTFinallyClause', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'ASTVariableDeclarator', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTNumericLiteral']
*Get the body of try statement.* 匹配到的元操作或API：
query: Get the body of try statement.
most similar API: get body of try statement
cosine Similarity: 0.9849938750267029
*Check whether the body of try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8571393489837646
*Get the finally branch of try statement.* 匹配到的元操作或API：
logic: Get the finally branch of try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9912987947463989
*Check whether the finally branch of try statement is empty.* 匹配到的元操作或API：
logic: Check whether the finally branch of try statement is empty.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.8797644376754761
*The body of the try statement is empty.* 匹配到的元操作或API：
query: The body of the try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8262755870819092
*The finally branch of the try statement is not empty.* 匹配到的元操作或API：
logic: The finally branch of the try statement is not empty.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.8824464678764343
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
The test case corresponding to the rule:
```
// pos, empty try block
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock2')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTFinallyClause
            ——ASTBlock
              ——ASTLocalVariableDeclaration
                ——ASTModifierList
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTVariableDeclarator
                  ——ASTVariableDeclaratorId (declared variable name = 'x')
                  ——ASTNumericLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedBlock.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, body);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getFirstChildOfType(ASTBlock.class).isEmpty()) {
            addViolation(data, finallyClause.getFirstChildOfType(ASTBlock.class));
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedBlock node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock thenBlock = node.getFirstChildOfType(ASTBlock.class);
        if (thenBlock != null && thenBlock.isEmpty()) {
            addViolation(data, thenBlock);
        }
        ASTBlock elseBlock = node.getFirstChildOfType(ASTBlock.class, 1);
        if (elseBlock != null && elseBlock.isEmpty()) {
            addViolation(data, elseBlock);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the control statements in the method body.
2. Check whether the control statement is a try statement.
3. Get the body of the try statement.
4. Check whether the body of the try statement is empty.
5. Get the finally branch of the try statement.
6. Check whether the finally branch of the try statement is empty.

This test case violates the rule as it has an empty try block. The finally block is not empty, so it does not violate the rule. Therefore, the number of violations is 1.
            
['Get the control statements in the method body.', 'Check whether the control statement is a try statement.', 'Get the body of the try statement.', 'Check whether the body of the try statement is empty.', 'Get the finally branch of the try statement.', 'Check whether the finally branch of the try statement is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTBlock', 'ASTFinallyClause', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'ASTVariableDeclarator', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTNumericLiteral']
*Get the control statements in the method body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is a try statement.* 匹配到的元操作或API：
query: Check whether the control statement is a try statement.
most similar API: Check whether the try statement equals
cosine Similarity: 0.8672434091567993
*Get the body of the try statement.* 匹配到的元操作或API：
query: Get the body of the try statement.
most similar API: get body of try statement
cosine Similarity: 0.9787790179252625
*Check whether the body of the try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8486955761909485
*Get the finally branch of the try statement.* 匹配到的元操作或API：
logic: Get the finally branch of the try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9862933158874512
*Check whether the finally branch of the try statement is empty.* 匹配到的元操作或API：
logic: Check whether the finally branch of the try statement is empty.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.8724913001060486
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
The test case corresponding to the rule:
```
// pos, empty try block
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock2')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTFinallyClause
            ——ASTBlock
              ——ASTLocalVariableDeclaration
                ——ASTModifierList
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTVariableDeclarator
                  ——ASTVariableDeclaratorId (declared variable name = 'x')
                  ——ASTNumericLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean equals(java.lang.Object)
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTLoopStatement.class, ASTVariableInitializer.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().getNumChildren() == 0) {
            addViolation(data, finallyClause.getBody());
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock thenBlock = node.getFirstChildOfType(ASTBlock.class);
        if (thenBlock != null && thenBlock.getNumChildren() == 0) {
            addViolation(data, thenBlock);
        }
        ASTBlock elseBlock = node.getFirstChildOfType(ASTBlock.class, 1);
        if (elseBlock != null && elseBlock.getNumChildren() == 0) {
            addViolation(data, elseBlock);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTLoopStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTVariableInitializer node, Object data) {
        if (node.hasDescendantMatching(ASTBlock.class) && node.getFirstChildOfType(ASTBlock.class).getNumChildren() == 0) {
            addViolation(data, node.getFirstChildOfType(ASTBlock.class));
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.getParent() instanceof ASTClassOrInterfaceBody || node.getParent() instanceof ASTMethodDeclaration) {
            return super.visit(node, data);
        }
        if (node.getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the method declaration from method call.
2. Get the body of the method.
3. Check whether the body of the method contains a try statement.
4. Get the try statement.
5. Check whether the body of the try statement is empty.
6. Get the finally block of the try statement.
7. Check whether the finally block of the try statement is empty.

In this test case, the try block is empty, which violates the rule. The finally block is not empty, so it does not violate the rule. Therefore, the number of violations is 1.
            
['Get the method declaration from method call.', 'Get the body of the method.', 'Check whether the body of the method contains a try statement.', 'Get the try statement.', 'Check whether the body of the try statement is empty.', 'Get the finally block of the try statement.', 'Check whether the finally block of the try statement is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTBlock', 'ASTFinallyClause', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'ASTVariableDeclarator', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTNumericLiteral']
*Get the method declaration from method call.* 匹配到的元操作或API：
logic: Get the method declaration from method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9787436127662659
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Check whether the body of the method contains a try statement.* 匹配到的元操作或API：
query: Check whether the body of the method contains a try statement.
most similar API: get body of try statement
cosine Similarity: 0.8458302021026611
*Get the try statement.* 匹配到的元操作或API：
logic: Get the try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8690330982208252
*Check whether the body of the try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8486955761909485
*Get the finally block of the try statement.* 匹配到的元操作或API：
logic: Get the finally block of the try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9133995175361633
*Check whether the finally block of the try statement is empty.* 匹配到的元操作或API：
query: Check whether the finally block of the try statement is empty.
most similar API: get finally clause of try statement
cosine Similarity: 0.830769956111908
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
The test case corresponding to the rule:
```
// pos, empty try block
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock2')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTFinallyClause
            ——ASTBlock
              ——ASTLocalVariableDeclaration
                ——ASTModifierList
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTVariableDeclarator
                  ——ASTVariableDeclaratorId (declared variable name = 'x')
                  ——ASTNumericLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()
5. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause(), //Returns the {@code finally} clause of this try statement, if any. @return The finally statement, or null if there is none

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class,
                ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class,
                ASTForStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().getNumChildren() == 0) {
            addViolation(data, finallyClause.getBody());
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock thenBlock = node.getThenBlock();
        if (thenBlock.getNumChildren() == 0) {
            addViolation(data, thenBlock);
        }
        ASTBlock elseBlock = node.getElseBlock();
        if (elseBlock != null && elseBlock.getNumChildren() == 0) {
            addViolation(data, elseBlock);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.getParent() instanceof ASTBlock && node.getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the method name within class.
2. Check whether the method name is foo.
3. Get the try statement within method foo.
4. Get the body of the try statement.
5. Check whether the body of the try statement is empty.
6. Get the finally statement within method foo.
7. Get the body of the finally statement.
8. Check whether the body of the finally statement is empty.

The number of violations in this test case is determined by the checks in steps 5 and 8. Since the try block body is empty and the finally block body is not empty, the test case violates the rule once according to the provided description.
['Get the method name within class.', 'Check whether the method name is foo.', 'Get the try statement within method foo.', 'Get the body of the try statement.', 'Check whether the body of the try statement is empty.', 'Get the finally statement within method foo.', 'Get the body of the finally statement.', 'Check whether the body of the finally statement is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTBlock', 'ASTFinallyClause', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'ASTVariableDeclarator', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTNumericLiteral']
*Get the method name within class.* 匹配到的元操作或API：
logic: Get the method name within class.
most similar meta operation: Get the name of method
cosine Similarity: 0.8987963795661926
*Check whether the method name is foo.* 匹配到的元操作或API：
query: Check whether the method name is foo.
most similar API: Check whether the method equals
cosine Similarity: 0.8480665683746338
*Get the try statement within method foo.* 匹配到的元操作或API：
logic: Get the try statement within method foo.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8587676286697388
*Get the body of the try statement.* 匹配到的元操作或API：
query: Get the body of the try statement.
most similar API: get body of try statement
cosine Similarity: 0.9787790179252625
*Check whether the body of the try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8486955761909485
*Get the finally statement within method foo.* 匹配到的元操作或API：
logic: Get the finally statement within method foo.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.853675365447998
*Get the body of the finally statement.* 匹配到的元操作或API：
query: Get the body of the finally statement.
most similar API: get body of finally clause
cosine Similarity: 0.9299283623695374
*Check whether the body of the finally statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the finally statement is empty.
most similar API: get body of finally clause
cosine Similarity: 0.836310088634491
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
The test case corresponding to the rule:
```
// pos, empty try block
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock2')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTFinallyClause
            ——ASTBlock
              ——ASTLocalVariableDeclaration
                ——ASTModifierList
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTVariableDeclarator
                  ——ASTVariableDeclaratorId (declared variable name = 'x')
                  ——ASTNumericLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
5. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()
6. net.sourceforge.pmd.lang.java.ast.ASTFinallyClause: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this finally clause.



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (node.getBody().getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.getNumChildren() == 0) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.getNumChildren() == 0) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
True
此测试用例生成了first checker: bad 2


======================接下来开始迭代=====================
[ERROR]   "ok 2" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
94
78
106
91
82
68
96
80
106
91
109
93
=========================error_testcase_logics=========================
1. Get the name of the class.
2. Get the method declaration from method call.
3. Get the signature of method.
4. Get the body of method.
5. Check whether the body of method contains a try statement.
6. Get the try statement from method body.
7. Check whether the try statement is a try-with-resources statement.
8. Get the initializer of try-with-resources statement.
9. Check whether the try-with-resources initializer is empty.
10. Check whether the try-with-resources statement has a catch clause.
11. Check whether the try-with-resources statement has a finally clause.
12. Check whether the finally clause is empty.
13. Check whether the try statement body is empty.
14. Check whether the method body contains a switch statement.
15. Check whether the switch statement body is empty.
16. Check whether the method body contains a synchronized statement.
17. Check whether the synchronized statement body is empty.
18. Check whether the method body contains an if statement.
19. Get the if statement from method body.
20. Check whether the if statement body is empty.
21. Check whether the if statement has an else branch.
22. Check whether the else branch of if statement is empty.
23. Check whether the method body contains a while loop.
24. Get the while loop from method body.
25. Check whether the while loop body is empty.
26. Check whether the method body contains a for loop.
27. Get the for loop from method body.
28. Check whether the for loop body is empty.
29. Check whether the method body contains a do-while loop.
30. Get the do-while loop from method body.
31. Check whether the do-while loop body is empty.
32. Check whether the method body contains any initializer blocks.
33. Check whether the initializer block is empty.
34. Check whether the method body contains any blocks used as statements.
35. Check whether the block used as statement is empty.

In this test case, the try-with-resources statement body is empty, but it is okay as the rule description specifies "ok with unused var name". Therefore, the test case does not violate the rule.
The number of violations in this test case is: 0
['Get the name of the class.', 'Get the method declaration from method call.', 'Get the signature of method.', 'Get the body of method.', 'Check whether the body of method contains a try statement.', 'Get the try statement from method body.', 'Check whether the try statement is a try-with-resources statement.', 'Get the initializer of try-with-resources statement.', 'Check whether the try-with-resources initializer is empty.', 'Check whether the try-with-resources statement has a catch clause.', 'Check whether the try-with-resources statement has a finally clause.', 'Check whether the finally clause is empty.', 'Check whether the try statement body is empty.', 'Check whether the method body contains a switch statement.', 'Check whether the switch statement body is empty.', 'Check whether the method body contains a synchronized statement.', 'Check whether the synchronized statement body is empty.', 'Check whether the method body contains an if statement.', 'Get the if statement from method body.', 'Check whether the if statement body is empty.', 'Check whether the if statement has an else branch.', 'Check whether the else branch of if statement is empty.', 'Check whether the method body contains a while loop.', 'Get the while loop from method body.', 'Check whether the while loop body is empty.', 'Check whether the method body contains a for loop.', 'Get the for loop from method body.', 'Check whether the for loop body is empty.', 'Check whether the method body contains a do-while loop.', 'Get the do-while loop from method body.', 'Check whether the do-while loop body is empty.', 'Check whether the method body contains any initializer blocks.', 'Check whether the initializer block is empty.', 'Check whether the method body contains any blocks used as statements.', 'Check whether the block used as statement is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTTryStatement', 'ASTLambdaParameterList', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTConstructorCall', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTResource', 'ASTVariableDeclaratorId', 'ASTResourceList', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTLambdaExpression', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTAmbiguousName', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the name of the class.* 匹配到的元操作或API：
logic: Get the name of the class.
most similar meta operation: Get the name of class
cosine Similarity: 0.968898594379425
*Get the method declaration from method call.* 匹配到的元操作或API：
logic: Get the method declaration from method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9787436127662659
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827433228492737
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752807021141052
*Check whether the body of method contains a try statement.* 匹配到的元操作或API：
query: Check whether the body of method contains a try statement.
most similar API: get body of try statement
cosine Similarity: 0.8438896536827087
*Get the try statement from method body.* 匹配到的元操作或API：
query: Get the try statement from method body.
most similar API: get body of try statement
cosine Similarity: 0.9264925718307495
*Check whether the try statement is a try-with-resources statement.* 匹配到的元操作或API：
query: Check whether the try statement is a try-with-resources statement.
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.9599140882492065
*Get the initializer of try-with-resources statement.* 匹配到的元操作或API：
query: Get the initializer of try-with-resources statement.
most similar API: get initializer of resource
cosine Similarity: 0.8588769435882568
*Check whether the try-with-resources initializer is empty.* 匹配到的元操作或API：
query: Check whether the try-with-resources initializer is empty.
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.8483747243881226
*Check whether the try-with-resources statement has a catch clause.* 匹配到的元操作或API：
query: Check whether the try-with-resources statement has a catch clause.
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.9018970131874084
*Check whether the try-with-resources statement has a finally clause.* 匹配到的元操作或API：
query: Check whether the try-with-resources statement has a finally clause.
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.8798208236694336
*Check whether the finally clause is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the try statement body is empty.* 匹配到的元操作或API：
query: Check whether the try statement body is empty.
most similar API: get body of try statement
cosine Similarity: 0.8382278680801392
*Check whether the method body contains a switch statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the switch statement body is empty.* 匹配到的元操作或API：
query: Check whether the switch statement body is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8133547902107239
*Check whether the method body contains a synchronized statement.* 匹配到的元操作或API：
logic: Check whether the method body contains a synchronized statement.
most similar meta operation: Check whether the method is synchronized
cosine Similarity: 0.8885620832443237
*Check whether the synchronized statement body is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method body contains an if statement.* 匹配到的元操作或API：
query: Check whether the method body contains an if statement.
most similar API: Check whether the method equals
cosine Similarity: 0.8234866857528687
*Get the if statement from method body.* 匹配到的元操作或API：
query: Get the if statement from method body.
most similar API: get body of method
cosine Similarity: 0.8187111020088196
*Check whether the if statement body is empty.* 匹配到的元操作或API：
logic: Check whether the if statement body is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8646794557571411
*Check whether the if statement has an else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9772751331329346
*Check whether the else branch of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the else branch of if statement is empty.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9108617901802063
*Check whether the method body contains a while loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the while loop from method body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the while loop body is empty.* 匹配到的元操作或API：
query: Check whether the while loop body is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8015036582946777
*Check whether the method body contains a for loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the for loop from method body.* 匹配到的元操作或API：
query: Get the for loop from method body.
most similar API: get body of method
cosine Similarity: 0.8137949109077454
*Check whether the for loop body is empty.* 匹配到的元操作或API：
query: Check whether the for loop body is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8158854246139526
*Check whether the method body contains a do-while loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the do-while loop from method body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the do-while loop body is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method body contains any initializer blocks.* 匹配到的元操作或API：
query: Check whether the method body contains any initializer blocks.
most similar API: Check whether the variable declarator has initializer
cosine Similarity: 0.8020039796829224
*Check whether the initializer block is empty.* 匹配到的元操作或API：
query: Check whether the initializer block is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8620045185089111
*Check whether the method body contains any blocks used as statements.* 匹配到的元操作或API：
query: Check whether the method body contains any blocks used as statements.
most similar API: Check whether the lambda expression is block body: Returns true if this lambda has a block for body.
cosine Similarity: 0.8290647268295288
*Check whether the block used as statement is empty.* 匹配到的元操作或API：
query: Check whether the block used as statement is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.9348034262657166
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (node.getBody().getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.getNumChildren() == 0) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.getNumChildren() == 0) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }


This checker is failed(false positive) on this positive test case:
```
// #432 empty try-with-resource - ok with unused var name
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'X')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'method')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTResourceList
            ——ASTResource
              ——ASTLocalVariableDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTVariableDeclarator
                  ——ASTVariableDeclaratorId (declared variable name = 'ignored')
                  ——ASTMethodCall (called method name = 'execute')
                    ——ASTArgumentList (size = 3)
                      ——ASTLambdaExpression
                        ——ASTLambdaParameterList
                        ——ASTMethodCall (called method name = 'delete')
                          ——ASTMethodCall (called method name = 'request')
                            ——ASTAmbiguousName (this is a primitive type)
                            ——ASTArgumentList (size = 1)
                              ——ASTVariableAccess (referenced variable name = 'mediaTypes')
                          ——ASTArgumentList (size = 0)
                      ——ASTVariableAccess (referenced variable name = 'DELETE')
                      ——ASTConstructorCall
                        ——ASTClassOrInterfaceType (this is a class type)
                        ——ASTArgumentList (size = 2)
                          ——ASTVariableAccess (referenced variable name = 'status')
                          ——ASTVariableAccess (referenced variable name = 'required')
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
5. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean isTryWithResources(), //Returns true if this node is a try-with-resources, in which case it has a ResourceSpecification child node.
6. net.sourceforge.pmd.lang.java.ast.ASTResource: public net.sourceforge.pmd.lang.java.ast.ASTExpression getInitializer(), //Returns the initializer of the expression. If this is a concise resource, then returns that expression. If this is a local variable declaration, returns the initializer of the variable.
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()
8. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isSynchronized()
9. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean equals(java.lang.Object)
10. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
11. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
12. net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator: public boolean hasInitializer(), //Returns true if the declared variable is initialized. Otherwise, {@link #getInitializer()} returns null.
13. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()
14. net.sourceforge.pmd.lang.java.ast.ASTLambdaExpression: public boolean isBlockBody(), //Returns true if this lambda has a block for body.

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
94
78
106
91
82
68
96
80
106
91
109
93
=========================error_testcase_logics=========================
1. Get the body of try statement.
2. Check whether the body of try statement is empty.
3. Check whether the try statement is a try-with-resources statement.
4. Get the resource list of try-with-resources statement.
5. Get the resource name from the resource list.
6. Check whether the resource name is "ignored".
        If the body of the try statement is empty and it is a try-with-resources statement and the resource name is not "ignored", then this test case violates the rule.

In this specific test case:
1. Get the body of try statement.
        -> The body contains comments, which are not considered code statements.
2. Check whether the body of try statement is empty.
        -> The body is considered empty in terms of code statements.
3. Check whether the try statement is a try-with-resources statement.
        -> Yes, it is a try-with-resources statement.
4. Get the resource list of try-with-resources statement.
        -> The resource list contains `ClientResponse response`.
5. Get the resource name from the resource list.
        -> The resource name is `response`.
6. Check whether the resource name is "ignored".
        -> No, the resource name is not "ignored".

Since the body of the try statement is empty (in terms of code statements) and it is a try-with-resources statement with a resource name other than "ignored", this test case violates the rule.
['Get the body of try statement.', 'Check whether the body of try statement is empty.', 'Check whether the try statement is a try-with-resources statement.', 'Get the resource list of try-with-resources statement.', 'Get the resource name from the resource list.', 'Check whether the resource name is "ignored".', 'Get the body of try statement.', 'Check whether the body of try statement is empty.', 'Check whether the try statement is a try-with-resources statement.', 'Get the resource list of try-with-resources statement.', 'Get the resource name from the resource list.', 'Check whether the resource name is "ignored".']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTTryStatement', 'ASTLambdaParameterList', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTConstructorCall', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTResource', 'ASTVariableDeclaratorId', 'ASTResourceList', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTLambdaExpression', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTAmbiguousName', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the body of try statement.* 匹配到的元操作或API：
query: Get the body of try statement.
most similar API: get body of try statement
cosine Similarity: 0.9849938750267029
*Check whether the body of try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8571393489837646
*Check whether the try statement is a try-with-resources statement.* 匹配到的元操作或API：
query: Check whether the try statement is a try-with-resources statement.
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.9599140882492065
*Get the resource list of try-with-resources statement.* 匹配到的元操作或API：
query: Get the resource list of try-with-resources statement.
most similar API: get resources of try statement: Returns the node for the resource list. This is null if this is not a try-with-resources.
cosine Similarity: 0.8681280612945557
*Get the resource name from the resource list.* 匹配到的元操作或API：
query: Get the resource name from the resource list.
most similar API: get text of resource list
cosine Similarity: 0.8472142815589905
*Check whether the resource name is "ignored".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of try statement.* 匹配到的元操作或API：
query: Get the body of try statement.
most similar API: get body of try statement
cosine Similarity: 0.9849938750267029
*Check whether the body of try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8571393489837646
*Check whether the try statement is a try-with-resources statement.* 匹配到的元操作或API：
query: Check whether the try statement is a try-with-resources statement.
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.9599140882492065
*Get the resource list of try-with-resources statement.* 匹配到的元操作或API：
query: Get the resource list of try-with-resources statement.
most similar API: get resources of try statement: Returns the node for the resource list. This is null if this is not a try-with-resources.
cosine Similarity: 0.8681280612945557
*Get the resource name from the resource list.* 匹配到的元操作或API：
query: Get the resource name from the resource list.
most similar API: get text of resource list
cosine Similarity: 0.8472142815589905
*Check whether the resource name is "ignored".* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'X')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'method')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTResourceList
            ——ASTResource
              ——ASTLocalVariableDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTVariableDeclarator
                  ——ASTVariableDeclaratorId (declared variable name = 'response')
                  ——ASTMethodCall (called method name = 'execute')
                    ——ASTArgumentList (size = 3)
                      ——ASTLambdaExpression
                        ——ASTLambdaParameterList
                        ——ASTMethodCall (called method name = 'delete')
                          ——ASTMethodCall (called method name = 'request')
                            ——ASTAmbiguousName (this is a primitive type)
                            ——ASTArgumentList (size = 1)
                              ——ASTVariableAccess (referenced variable name = 'mediaTypes')
                          ——ASTArgumentList (size = 0)
                      ——ASTVariableAccess (referenced variable name = 'DELETE')
                      ——ASTConstructorCall
                        ——ASTClassOrInterfaceType (this is a class type)
                        ——ASTArgumentList (size = 2)
                          ——ASTVariableAccess (referenced variable name = 'status')
                          ——ASTVariableAccess (referenced variable name = 'required')
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean isTryWithResources(), //Returns true if this node is a try-with-resources, in which case it has a ResourceSpecification child node.
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTResourceList getResources(), //Returns the node for the resource list. This is null if this is not a try-with-resources.
4. net.sourceforge.pmd.lang.java.ast.ASTResourceList: public net.sourceforge.pmd.lang.document.Chars getText()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        } else if (node.isTryWithResources() && node.getBody().isEmpty()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.getNumChildren() > 0) {
                boolean allIgnored = true;
                for (ASTResource resource : resources) {
                    ASTLocalVariableDeclaration decl = resource.getFirstChildOfType(ASTLocalVariableDeclaration.class);
                    if (decl != null) {
                        ASTVariableDeclaratorId id = decl.getFirstChildOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getName())) {
                            allIgnored = false;
                            break;
                        }
                    }
                }
                if (!allIgnored) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { 
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the body of try statement.
2. Check whether the body of try statement is empty.
3. Get the finally branch of try statement.
4. Check whether the finally branch of try statement is empty.
5. Get the body of switch statement.
6. Check whether the body of switch statement is empty.
7. Get the body of synchronized statement.
8. Check whether the body of synchronized statement is empty.
9. Get the body of if statement.
10. Check whether the body of if statement is empty.
11. Get the body of while loop.
12. Check whether the body of while loop is empty.
13. Get the body of for loop.
14. Check whether the body of for loop is empty.
15. Get the body of do-while loop.
16. Check whether the body of do-while loop is empty.
17. Get the initializer block.
18. Check whether the initializer block is empty.

Given the test case, we will perform the following checks:

1. Get the body of try statement. (The body contains comments and is not truly empty)
2. Check whether the body of try statement is empty. (False, as the body contains comments)
3. Get the finally branch of try statement. (There is no finally branch in the given code)
4. Get the body of switch statement. (There is no switch statement in the given code)
5. Get the body of synchronized statement. (There is no synchronized statement in the given code)
6. Get the body of if statement. (There is no if statement in the given code)
7. Get the body of while loop. (There is no while loop in the given code)
8. Get the body of for loop. (There is no for loop in the given code)
9. Get the body of do-while loop. (There is no do-while loop in the given code)
10. Get the initializer block. (There is no initializer block in the given code)

Based on these checks, the test case does not violate the rule as the body of the try statement is not truly empty (it contains comments), and there are no other empty control statements or blocks. The rule should be designed to ignore comments within the body to accurately determine if the body is empty.

If the rule should report try-with-resources blocks with no statements (excluding comments) in the body, then the check should be modified to consider the body without comments. However, based on the provided test case and the description, the rule correctly identifies that there is no violation.
['Get the body of try statement.', 'Check whether the body of try statement is empty.', 'Get the finally branch of try statement.', 'Check whether the finally branch of try statement is empty.', 'Get the body of switch statement.', 'Check whether the body of switch statement is empty.', 'Get the body of synchronized statement.', 'Check whether the body of synchronized statement is empty.', 'Get the body of if statement.', 'Check whether the body of if statement is empty.', 'Get the body of while loop.', 'Check whether the body of while loop is empty.', 'Get the body of for loop.', 'Check whether the body of for loop is empty.', 'Get the body of do-while loop.', 'Check whether the body of do-while loop is empty.', 'Get the initializer block.', 'Check whether the initializer block is empty.', 'Get the body of try statement. (The body contains comments and is not truly empty)', 'Check whether the body of try statement is empty. (False, as the body contains comments)', 'Get the finally branch of try statement. (There is no finally branch in the given code)', 'Get the body of switch statement. (There is no switch statement in the given code)', 'Get the body of synchronized statement. (There is no synchronized statement in the given code)', 'Get the body of if statement. (There is no if statement in the given code)', 'Get the body of while loop. (There is no while loop in the given code)', 'Get the body of for loop. (There is no for loop in the given code)', 'Get the body of do-while loop. (There is no do-while loop in the given code)', 'Get the initializer block. (There is no initializer block in the given code)']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTTryStatement', 'ASTLambdaParameterList', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTConstructorCall', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTResource', 'ASTVariableDeclaratorId', 'ASTResourceList', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTLambdaExpression', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTAmbiguousName', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the body of try statement.* 匹配到的元操作或API：
query: Get the body of try statement.
most similar API: get body of try statement
cosine Similarity: 0.9849938750267029
*Check whether the body of try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8571393489837646
*Get the finally branch of try statement.* 匹配到的元操作或API：
logic: Get the finally branch of try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9912987947463989
*Check whether the finally branch of try statement is empty.* 匹配到的元操作或API：
logic: Check whether the finally branch of try statement is empty.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.8797644376754761
*Get the body of switch statement.* 匹配到的元操作或API：
logic: Get the body of switch statement.
most similar meta operation: Get a branch of switch statement
cosine Similarity: 0.8521518707275391
*Check whether the body of switch statement is empty.* 匹配到的元操作或API：
query: Check whether the body of switch statement is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8093870282173157
*Get the body of synchronized statement.* 匹配到的元操作或API：
logic: Get the body of synchronized statement.
most similar meta operation: Get the lock of synchronized statement
cosine Similarity: 0.8570017218589783
*Check whether the body of synchronized statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of if statement.* 匹配到的元操作或API：
query: Get the body of if statement.
most similar API: get body of try statement
cosine Similarity: 0.845997154712677
*Check whether the body of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8571334481239319
*Get the body of while loop.* 匹配到的元操作或API：
query: Get the body of while loop.
most similar API: get body of try statement
cosine Similarity: 0.81794273853302
*Check whether the body of while loop is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of for loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of for loop is empty.* 匹配到的元操作或API：
query: Check whether the body of for loop is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8082364201545715
*Get the body of do-while loop.* 匹配到的元操作或API：
query: Get the body of do-while loop.
most similar API: get body of try statement
cosine Similarity: 0.8119039535522461
*Check whether the body of do-while loop is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the initializer block.* 匹配到的元操作或API：
query: Get the initializer block.
most similar API: get initializer of resource
cosine Similarity: 0.824134111404419
*Check whether the initializer block is empty.* 匹配到的元操作或API：
query: Check whether the initializer block is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8620045185089111
*Get the body of try statement. (The body contains comments and is not truly empty)* 匹配到的元操作或API：
query: Get the body of try statement. (The body contains comments and is not truly empty)
most similar API: get body of try statement
cosine Similarity: 0.9323099851608276
*Check whether the body of try statement is empty. (False, as the body contains comments)* 匹配到的元操作或API：
query: Check whether the body of try statement is empty. (False, as the body contains comments)
most similar API: get body of try statement
cosine Similarity: 0.8315435647964478
*Get the finally branch of try statement. (There is no finally branch in the given code)* 匹配到的元操作或API：
logic: Get the finally branch of try statement. (There is no finally branch in the given code)
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9549633264541626
*Get the body of switch statement. (There is no switch statement in the given code)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of synchronized statement. (There is no synchronized statement in the given code)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of if statement. (There is no if statement in the given code)* 匹配到的元操作或API：
query: Get the body of if statement. (There is no if statement in the given code)
most similar API: get body of try statement
cosine Similarity: 0.8132342100143433
*Get the body of while loop. (There is no while loop in the given code)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of for loop. (There is no for loop in the given code)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of do-while loop. (There is no do-while loop in the given code)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the initializer block. (There is no initializer block in the given code)* 匹配到的元操作或API：
query: Get the initializer block. (There is no initializer block in the given code)
most similar API: get initializer of variable declarator
cosine Similarity: 0.8005646467208862
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'X')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'method')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTResourceList
            ——ASTResource
              ——ASTLocalVariableDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTVariableDeclarator
                  ——ASTVariableDeclaratorId (declared variable name = 'response')
                  ——ASTMethodCall (called method name = 'execute')
                    ——ASTArgumentList (size = 3)
                      ——ASTLambdaExpression
                        ——ASTLambdaParameterList
                        ——ASTMethodCall (called method name = 'delete')
                          ——ASTMethodCall (called method name = 'request')
                            ——ASTAmbiguousName (this is a primitive type)
                            ——ASTArgumentList (size = 1)
                              ——ASTVariableAccess (referenced variable name = 'mediaTypes')
                          ——ASTArgumentList (size = 0)
                      ——ASTVariableAccess (referenced variable name = 'DELETE')
                      ——ASTConstructorCall
                        ——ASTClassOrInterfaceType (this is a class type)
                        ——ASTArgumentList (size = 2)
                          ——ASTVariableAccess (referenced variable name = 'status')
                          ——ASTVariableAccess (referenced variable name = 'required')
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()
3. net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTSwitchBranch> getBranches()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()
5. net.sourceforge.pmd.lang.java.ast.ASTSynchronizedStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLockExpression()
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
7. net.sourceforge.pmd.lang.java.ast.ASTResource: public net.sourceforge.pmd.lang.java.ast.ASTExpression getInitializer(), //Returns the initializer of the expression. If this is a concise resource, then returns that expression. If this is a local variable declaration, returns the initializer of the variable.
8. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()
9. net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator: public net.sourceforge.pmd.lang.java.ast.ASTExpression getInitializer(), //Returns the initializer, of the variable, or null if it doesn't exist.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        } else if (node.isTryWithResources() && !hasIgnoredResource(node) && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    private boolean hasIgnoredResource(ASTTryStatement node) {
        return node.getResourceList().findResources()
            .anyMatch(resource -> {
                ASTVariableDeclarator declarator = resource.getFirstChildOfType(ASTVariableDeclarator.class);
                if (declarator != null) {
                    ASTVariableDeclaratorId id = declarator.getFirstChildOfType(ASTVariableDeclaratorId.class);
                    return id != null && "ignored".equals(id.getImage());
                }
                return false;
            });
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        NodeStream<ASTBlock> switchBlocks = node.getBranches().map(branch -> branch.getFirstChildOfType(ASTBlock.class)).filter(block -> block != null && block.isEmpty());
        if (switchBlocks.count() == node.getBranches().count()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the body of the try statement.
2. Check whether the body of the try statement is empty.
3. If the body is not empty, check whether the body contains only comments.
4. Get the finally branch of the try statement.
5. Check whether the finally branch of the try statement is empty.
6. Check whether the try statement is a try-with-resources statement.
7. Get the resource list of the try-with-resources statement.
8. Get the name of the first resource in the list.
9. Check whether the name of the first resource is "ignored".
10. If the try statement is a try-with-resources statement and the body is empty and the resource name is not "ignored", report a violation.

In this test case:
- The try statement body is not empty (it contains comments).
- There is no finally branch.
- The try statement is a try-with-resources statement.
- The resource name is "response", not "ignored".
- The body contains comments, but is not considered empty according to the rule description provided.

However, the rule description mentions that the new rule will report empty try-with-resources blocks if the resource name is not "ignored". Assuming the tool strictly follows this rule and considers the presence of comments as non-empty, this would not be a violation. If the tool is configured to treat the presence of comments as an empty body (which seems unlikely given the comment in the code), then it would be a violation.

Given the test case and the provided rule description, it seems the tool is configured to treat the presence of comments as non-empty, and thus the number of violations is 0. However, if the tool is configured to report empty try-with-resources blocks regardless of comments, then the number of violations is 1, as the comment does not change the fact that the body is empty in terms of executable code.

Since the problem statement clearly says the number of violations is 1, we will consider the tool to be configured to report empty try-with-resources blocks regardless of comments.

Thus, the correct granular checks are:
1. Get the body of the try statement.
2. Check whether the body of the try statement contains only comments and no executable code.
3. Check whether the try statement is a try-with-resources statement.
4. Get the resource list of the try-with-resources statement.
5. Get the name of the first resource in the list.
6. Check whether the name of the first resource is "ignored".
7. If the try statement is a try-with-resources statement and the body contains only comments and no executable code and the resource name is not "ignored", report a violation.

In this case, steps 2, 3, 5, and 6 confirm the violation of the rule.
['Get the body of the try statement.', 'Check whether the body of the try statement is empty.', 'If the body is not empty, check whether the body contains only comments.', 'Get the finally branch of the try statement.', 'Check whether the finally branch of the try statement is empty.', 'Check whether the try statement is a try-with-resources statement.', 'Get the resource list of the try-with-resources statement.', 'Get the name of the first resource in the list.', 'Check whether the name of the first resource is "ignored".', 'If the try statement is a try-with-resources statement and the body is empty and the resource name is not "ignored", report a violation.', 'Get the body of the try statement.', 'Check whether the body of the try statement contains only comments and no executable code.', 'Check whether the try statement is a try-with-resources statement.', 'Get the resource list of the try-with-resources statement.', 'Get the name of the first resource in the list.', 'Check whether the name of the first resource is "ignored".', 'If the try statement is a try-with-resources statement and the body contains only comments and no executable code and the resource name is not "ignored", report a violation.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTTryStatement', 'ASTLambdaParameterList', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTConstructorCall', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTResource', 'ASTVariableDeclaratorId', 'ASTResourceList', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTLambdaExpression', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTAmbiguousName', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the body of the try statement.* 匹配到的元操作或API：
query: Get the body of the try statement.
most similar API: get body of try statement
cosine Similarity: 0.9787790179252625
*Check whether the body of the try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8486955761909485
*If the body is not empty, check whether the body contains only comments.* 匹配到的元操作或API：
query: If the body is not empty, check whether the body contains only comments.
most similar API: Check whether is comment
cosine Similarity: 0.8119484186172485
*Get the finally branch of the try statement.* 匹配到的元操作或API：
logic: Get the finally branch of the try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9862933158874512
*Check whether the finally branch of the try statement is empty.* 匹配到的元操作或API：
logic: Check whether the finally branch of the try statement is empty.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.8724913001060486
*Check whether the try statement is a try-with-resources statement.* 匹配到的元操作或API：
query: Check whether the try statement is a try-with-resources statement.
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.9599140882492065
*Get the resource list of the try-with-resources statement.* 匹配到的元操作或API：
query: Get the resource list of the try-with-resources statement.
most similar API: get resources of try statement: Returns the node for the resource list. This is null if this is not a try-with-resources.
cosine Similarity: 0.8625782132148743
*Get the name of the first resource in the list.* 匹配到的元操作或API：
query: Get the name of the first resource in the list.
most similar API: get first child of resource list
cosine Similarity: 0.8663253784179688
*Check whether the name of the first resource is "ignored".* 匹配到的元操作或API：
未匹配成功元操作或API
*If the try statement is a try-with-resources statement and the body is empty and the resource name is not "ignored", report a violation.* 匹配到的元操作或API：
query: If the try statement is a try-with-resources statement and the body is empty and the resource name is not "ignored", report a violation.
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.8138183355331421
*Get the body of the try statement.* 匹配到的元操作或API：
query: Get the body of the try statement.
most similar API: get body of try statement
cosine Similarity: 0.9787790179252625
*Check whether the body of the try statement contains only comments and no executable code.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the try statement is a try-with-resources statement.* 匹配到的元操作或API：
query: Check whether the try statement is a try-with-resources statement.
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.9599140882492065
*Get the resource list of the try-with-resources statement.* 匹配到的元操作或API：
query: Get the resource list of the try-with-resources statement.
most similar API: get resources of try statement: Returns the node for the resource list. This is null if this is not a try-with-resources.
cosine Similarity: 0.8625782132148743
*Get the name of the first resource in the list.* 匹配到的元操作或API：
query: Get the name of the first resource in the list.
most similar API: get first child of resource list
cosine Similarity: 0.8663253784179688
*Check whether the name of the first resource is "ignored".* 匹配到的元操作或API：
未匹配成功元操作或API
*If the try statement is a try-with-resources statement and the body contains only comments and no executable code and the resource name is not "ignored", report a violation.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'X')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'method')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTResourceList
            ——ASTResource
              ——ASTLocalVariableDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTVariableDeclarator
                  ——ASTVariableDeclaratorId (declared variable name = 'response')
                  ——ASTMethodCall (called method name = 'execute')
                    ——ASTArgumentList (size = 3)
                      ——ASTLambdaExpression
                        ——ASTLambdaParameterList
                        ——ASTMethodCall (called method name = 'delete')
                          ——ASTMethodCall (called method name = 'request')
                            ——ASTAmbiguousName (this is a primitive type)
                            ——ASTArgumentList (size = 1)
                              ——ASTVariableAccess (referenced variable name = 'mediaTypes')
                          ——ASTArgumentList (size = 0)
                      ——ASTVariableAccess (referenced variable name = 'DELETE')
                      ——ASTConstructorCall
                        ——ASTClassOrInterfaceType (this is a class type)
                        ——ASTArgumentList (size = 2)
                          ——ASTVariableAccess (referenced variable name = 'status')
                          ——ASTVariableAccess (referenced variable name = 'required')
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
2. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isComment(net.sourceforge.pmd.lang.ast.impl.javacc.JavaccToken), //Returns true if the given token is a Java comment.
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean isTryWithResources(), //Returns true if this node is a try-with-resources, in which case it has a ResourceSpecification child node.
5. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTResourceList getResources(), //Returns the node for the resource list. This is null if this is not a try-with-resources.
6. net.sourceforge.pmd.lang.java.ast.ASTResourceList: public net.sourceforge.pmd.lang.ast.Node getFirstChild()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        if (node.isTryWithResources() && node.getBody().isEmpty() && !isIgnoredResource(node.getResources())) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    private boolean isIgnoredResource(ASTResourceList resources) {
        ASTResource resource = (ASTResource) resources.getFirstChild();
        ASTLocalVariableDeclaration declaration = resource.getFirstChildOfType(ASTLocalVariableDeclaration.class);
        ASTVariableDeclaratorId id = declaration.getFirstChildOfType(ASTVariableDeclaratorId.class);
        return "ignored".equals(id.getImage());
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) {
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 5" failed'}, {'error_rules_info': '[ERROR]   "ok 2" failed'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 2" failed不通过
=========================error_testcase_logics=========================
1. Get the number of try statements in the method.
2. For each try statement, check whether the body of the try statement is empty.
3. For each try statement, check whether it has a finally clause.
4. For each try statement with a finally clause, check whether the body of the finally clause is empty.
5. Get the number of switch statements in the method.
6. For each switch statement, check whether the body of the switch statement is empty.
7. Get the number of synchronized statements in the method.
8. For each synchronized statement, check whether the body of the synchronized statement is empty.
9. Get the number of if statements in the method.
10. For each if statement, check whether the body of the if statement is empty.
11. Check whether the if statement has an else branch.
12. If the if statement has an else branch, check whether the body of the else branch is empty.
13. Get the number of while loop statements in the method.
14. For each while loop statement, check whether the body of the while loop statement is empty.
15. Get the number of for loop statements in the method.
16. For each for loop statement, check whether the body of the for loop statement is empty.
17. Get the number of do-while loop statements in the method.
18. For each do-while loop statement, check whether the body of the do-while loop statement is empty.
19. Get the number of initializers and blocks used as statements in the method.
20. For each initializer or block, check whether the body is empty.

In this specific test case:

21. Get the try statement in the method.
22. Check whether the body of the try statement is empty.
        - The body of the try statement contains comments, which are not considered empty. Therefore, this does not violate the rule.
23. Check whether the try statement has a finally clause.
        - The try statement does not have a finally clause.
24. Get the number of switch statements in the method.
        - There are no switch statements in the method.
25. Get the number of synchronized statements in the method.
        - There are no synchronized statements in the method.
26. Get the number of if statements in the method.
        - There are no if statements in the method.
27. Get the number of while loop statements in the method.
        - There are no while loop statements in the method.
28. Get the number of for loop statements in the method.
        - There are no for loop statements in the method.
29. Get the number of do-while loop statements in the method.
        - There are no do-while loop statements in the method.
30. Get the number of initializers and blocks used as statements in the method.
        - There are no initializers or blocks used as statements in the method.

Given these checks, the test case does not violate the rule as the try block contains comments and is not considered empty. Therefore, the number of violations should be 0, not 1. If the intention is to report empty try blocks without any comments or code, then the test case would need to be modified to reflect that.
['Get the number of try statements in the method.', 'For each try statement, check whether the body of the try statement is empty.', 'For each try statement, check whether it has a finally clause.', 'For each try statement with a finally clause, check whether the body of the finally clause is empty.', 'Get the number of switch statements in the method.', 'For each switch statement, check whether the body of the switch statement is empty.', 'Get the number of synchronized statements in the method.', 'For each synchronized statement, check whether the body of the synchronized statement is empty.', 'Get the number of if statements in the method.', 'For each if statement, check whether the body of the if statement is empty.', 'Check whether the if statement has an else branch.', 'If the if statement has an else branch, check whether the body of the else branch is empty.', 'Get the number of while loop statements in the method.', 'For each while loop statement, check whether the body of the while loop statement is empty.', 'Get the number of for loop statements in the method.', 'For each for loop statement, check whether the body of the for loop statement is empty.', 'Get the number of do-while loop statements in the method.', 'For each do-while loop statement, check whether the body of the do-while loop statement is empty.', 'Get the number of initializers and blocks used as statements in the method.', 'For each initializer or block, check whether the body is empty.', 'Get the try statement in the method.', 'Check whether the body of the try statement is empty.', 'Check whether the try statement has a finally clause.', 'Get the number of switch statements in the method.', 'Get the number of synchronized statements in the method.', 'Get the number of if statements in the method.', 'Get the number of while loop statements in the method.', 'Get the number of for loop statements in the method.', 'Get the number of do-while loop statements in the method.', 'Get the number of initializers and blocks used as statements in the method.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTTryStatement', 'ASTLambdaParameterList', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTConstructorCall', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTResource', 'ASTVariableDeclaratorId', 'ASTResourceList', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTLambdaExpression', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTAmbiguousName', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the number of try statements in the method.* 匹配到的元操作或API：
query: Get the number of try statements in the method.
most similar API: get num children of try statement
cosine Similarity: 0.834815502166748
*For each try statement, check whether the body of the try statement is empty.* 匹配到的元操作或API：
query: For each try statement, check whether the body of the try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8369017839431763
*For each try statement, check whether it has a finally clause.* 匹配到的元操作或API：
query: For each try statement, check whether it has a finally clause.
most similar API: get finally clause of try statement
cosine Similarity: 0.9013512134552002
*For each try statement with a finally clause, check whether the body of the finally clause is empty.* 匹配到的元操作或API：
query: For each try statement with a finally clause, check whether the body of the finally clause is empty.
most similar API: get finally clause of try statement
cosine Similarity: 0.847120463848114
*Get the number of switch statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each switch statement, check whether the body of the switch statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of synchronized statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each synchronized statement, check whether the body of the synchronized statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of if statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each if statement, check whether the body of the if statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the if statement has an else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9772751331329346
*If the if statement has an else branch, check whether the body of the else branch is empty.* 匹配到的元操作或API：
logic: If the if statement has an else branch, check whether the body of the else branch is empty.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.8954053521156311
*Get the number of while loop statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each while loop statement, check whether the body of the while loop statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of for loop statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each for loop statement, check whether the body of the for loop statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of do-while loop statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each do-while loop statement, check whether the body of the do-while loop statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of initializers and blocks used as statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each initializer or block, check whether the body is empty.* 匹配到的元操作或API：
query: For each initializer or block, check whether the body is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8511307239532471
*Get the try statement in the method.* 匹配到的元操作或API：
logic: Get the try statement in the method.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8530656099319458
*Check whether the body of the try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8486955761909485
*Check whether the try statement has a finally clause.* 匹配到的元操作或API：
query: Check whether the try statement has a finally clause.
most similar API: get finally clause of try statement
cosine Similarity: 0.9059703350067139
*Get the number of switch statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of synchronized statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of if statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of while loop statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of for loop statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of do-while loop statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of initializers and blocks used as statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'X')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'method')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTResourceList
            ——ASTResource
              ——ASTLocalVariableDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTVariableDeclarator
                  ——ASTVariableDeclaratorId (declared variable name = 'response')
                  ——ASTMethodCall (called method name = 'execute')
                    ——ASTArgumentList (size = 3)
                      ——ASTLambdaExpression
                        ——ASTLambdaParameterList
                        ——ASTMethodCall (called method name = 'delete')
                          ——ASTMethodCall (called method name = 'request')
                            ——ASTAmbiguousName (this is a primitive type)
                            ——ASTArgumentList (size = 1)
                              ——ASTVariableAccess (referenced variable name = 'mediaTypes')
                          ——ASTArgumentList (size = 0)
                      ——ASTVariableAccess (referenced variable name = 'DELETE')
                      ——ASTConstructorCall
                        ——ASTClassOrInterfaceType (this is a class type)
                        ——ASTArgumentList (size = 2)
                          ——ASTVariableAccess (referenced variable name = 'status')
                          ——ASTVariableAccess (referenced variable name = 'required')
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public int getNumChildren()
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause(), //Returns the {@code finally} clause of this try statement, if any. @return The finally statement, or null if there is none
4. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()
6. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        } else if (node.isTryWithResources() && node.getBody().isEmpty()) {
            if (!isIgnoredResource(node.getResourceList())) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    private boolean isIgnoredResource(ASTResourceList resourceList) {
        for (ASTResource resource : resourceList) {
            ASTVariableDeclaratorId declaratorId = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
            if (declaratorId != null && !declaratorId.getName().equals("ignored")) {
                return false;
            }
        }
        return true;
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { 
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the body of the try statement.
2. Check whether the body of the try statement is empty.
3. Get the finally branch of the try statement.
4. Check whether the finally branch of the try statement is empty.
5. Check whether the try statement is a try-with-resources statement.
6. Get the resources list of the try-with-resources statement.
7. Get a resource from the resources list.
8. Get the name of the resource.
9. Check whether the name of the resource is "ignored".

In this test case:
- The try statement is a try-with-resources statement (check 5).
- The body of the try statement is not empty (check 2), as it contains comments.
- The finally branch of the try statement is empty (check 4).
- The resource name is "response" (check 8), not "ignored" (check 9).

Thus, the number of violating the rule in this test case is 1 (the empty finally block).
['Get the body of the try statement.', 'Check whether the body of the try statement is empty.', 'Get the finally branch of the try statement.', 'Check whether the finally branch of the try statement is empty.', 'Check whether the try statement is a try-with-resources statement.', 'Get the resources list of the try-with-resources statement.', 'Get a resource from the resources list.', 'Get the name of the resource.', 'Check whether the name of the resource is "ignored".']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTTryStatement', 'ASTLambdaParameterList', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTConstructorCall', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTResource', 'ASTVariableDeclaratorId', 'ASTResourceList', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTLambdaExpression', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTAmbiguousName', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the body of the try statement.* 匹配到的元操作或API：
query: Get the body of the try statement.
most similar API: get body of try statement
cosine Similarity: 0.9787790179252625
*Check whether the body of the try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8486955761909485
*Get the finally branch of the try statement.* 匹配到的元操作或API：
logic: Get the finally branch of the try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9862933158874512
*Check whether the finally branch of the try statement is empty.* 匹配到的元操作或API：
logic: Check whether the finally branch of the try statement is empty.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.8724913001060486
*Check whether the try statement is a try-with-resources statement.* 匹配到的元操作或API：
query: Check whether the try statement is a try-with-resources statement.
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.9599140882492065
*Get the resources list of the try-with-resources statement.* 匹配到的元操作或API：
query: Get the resources list of the try-with-resources statement.
most similar API: get resources of try statement: Returns the node for the resource list. This is null if this is not a try-with-resources.
cosine Similarity: 0.8630044460296631
*Get a resource from the resources list.* 匹配到的元操作或API：
query: Get a resource from the resources list.
most similar API: get of resource list
cosine Similarity: 0.8885983228683472
*Get the name of the resource.* 匹配到的元操作或API：
query: Get the name of the resource.
most similar API: get text of resource
cosine Similarity: 0.8375747203826904
*Check whether the name of the resource is "ignored".* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'X')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'method')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTResourceList
            ——ASTResource
              ——ASTLocalVariableDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTVariableDeclarator
                  ——ASTVariableDeclaratorId (declared variable name = 'response')
                  ——ASTMethodCall (called method name = 'execute')
                    ——ASTArgumentList (size = 3)
                      ——ASTLambdaExpression
                        ——ASTLambdaParameterList
                        ——ASTMethodCall (called method name = 'delete')
                          ——ASTMethodCall (called method name = 'request')
                            ——ASTAmbiguousName (this is a primitive type)
                            ——ASTArgumentList (size = 1)
                              ——ASTVariableAccess (referenced variable name = 'mediaTypes')
                          ——ASTArgumentList (size = 0)
                      ——ASTVariableAccess (referenced variable name = 'DELETE')
                      ——ASTConstructorCall
                        ——ASTClassOrInterfaceType (this is a class type)
                        ——ASTArgumentList (size = 2)
                          ——ASTVariableAccess (referenced variable name = 'status')
                          ——ASTVariableAccess (referenced variable name = 'required')
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean isTryWithResources(), //Returns true if this node is a try-with-resources, in which case it has a ResourceSpecification child node.
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTResourceList getResources(), //Returns the node for the resource list. This is null if this is not a try-with-resources.
5. net.sourceforge.pmd.lang.java.ast.ASTResourceList: public N get(int), //@throws IndexOutOfBoundsException if not in range
6. net.sourceforge.pmd.lang.java.ast.ASTResource: public net.sourceforge.pmd.lang.document.Chars getText()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        } else if (node.isTryWithResources() && node.getBody().isEmpty()) {
            ASTResourceList resources = node.getResources();
            for (int i = 0; i < resources.size(); i++) {
                ASTResource resource = resources.get(i);
                Chars resourceName = resource.getText();
                if (!resourceName.equals("ignored")) {
                    addViolation(data, node);
                    break;
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) {
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 5
[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
84
70
82
68
96
80
119
103
=========================error_testcase_logics=========================
1. Get the method declaration from the method call.
        2. Get the body of the method.
        3. Check whether the method body contains a try statement.
        4. Check whether the try statement has a finally clause.
        5. Get the body of the try statement.
        6. Check whether the body of the try statement is empty.
        7. Get the body of the finally clause.
        8. Check whether the body of the finally clause is empty.

In this specific test case:
1. Get the method declaration from the method call (method(InputStream in)).
2. Get the body of the method (the content inside the method).
3. Check whether the method body contains a try statement (it does, `try (in) { ... }`).
4. Check whether the try statement has a finally clause (it does not have a finally clause in this case, but the try statement itself is empty).
5. Get the body of the try statement (the content inside the try statement, which is empty).
6. Check whether the body of the try statement is empty (it is empty, so this is a violation).

The test case provided does contain an empty try statement, which violates the rule. Therefore, the number of violations in this test case is indeed 1.
['Get the method declaration from the method call.', 'Get the body of the method.', 'Check whether the method body contains a try statement.', 'Check whether the try statement has a finally clause.', 'Get the body of the try statement.', 'Check whether the body of the try statement is empty.', 'Get the body of the finally clause.', 'Check whether the body of the finally clause is empty.', 'Get the method declaration from the method call (method(InputStream in)).', 'Get the body of the method (the content inside the method).', 'Check whether the method body contains a try statement (it does, `try (in) { ... }`).', 'Check whether the try statement has a finally clause (it does not have a finally clause in this case, but the try statement itself is empty).', 'Get the body of the try statement (the content inside the try statement, which is empty).', 'Check whether the body of the try statement is empty (it is empty, so this is a violation).']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTImportDeclaration', 'ASTFormalParameters', 'ASTResource', 'ASTVariableDeclaratorId', 'ASTResourceList', 'ASTVariableAccess', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the method declaration from the method call.* 匹配到的元操作或API：
logic: Get the method declaration from the method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9715674519538879
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Check whether the method body contains a try statement.* 匹配到的元操作或API：
query: Check whether the method body contains a try statement.
most similar API: get body of try statement
cosine Similarity: 0.8470126390457153
*Check whether the try statement has a finally clause.* 匹配到的元操作或API：
query: Check whether the try statement has a finally clause.
most similar API: get finally clause of try statement
cosine Similarity: 0.9059703350067139
*Get the body of the try statement.* 匹配到的元操作或API：
query: Get the body of the try statement.
most similar API: get body of try statement
cosine Similarity: 0.9787790179252625
*Check whether the body of the try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8486955761909485
*Get the body of the finally clause.* 匹配到的元操作或API：
query: Get the body of the finally clause.
most similar API: get finally clause of try statement
cosine Similarity: 0.8548771739006042
*Check whether the body of the finally clause is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the method declaration from the method call (method(InputStream in)).* 匹配到的元操作或API：
logic: Get the method declaration from the method call (method(InputStream in)).
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9059932231903076
*Get the body of the method (the content inside the method).* 匹配到的元操作或API：
query: Get the body of the method (the content inside the method).
most similar API: get body of method
cosine Similarity: 0.9348300099372864
*Check whether the method body contains a try statement (it does, `try (in) { ... }`).* 匹配到的元操作或API：
query: Check whether the method body contains a try statement (it does, `try (in) { ... }`).
most similar API: get body of try statement
cosine Similarity: 0.802700400352478
*Check whether the try statement has a finally clause (it does not have a finally clause in this case, but the try statement itself is empty).* 匹配到的元操作或API：
query: Check whether the try statement has a finally clause (it does not have a finally clause in this case, but the try statement itself is empty).
most similar API: get finally clause of try statement
cosine Similarity: 0.871977686882019
*Get the body of the try statement (the content inside the try statement, which is empty).* 匹配到的元操作或API：
query: Get the body of the try statement (the content inside the try statement, which is empty).
most similar API: get body of try statement: Returns the body of this try statement.
cosine Similarity: 0.9292416572570801
*Check whether the body of the try statement is empty (it is empty, so this is a violation).* 匹配到的元操作或API：
query: Check whether the body of the try statement is empty (it is empty, so this is a violation).
most similar API: get body of try statement
cosine Similarity: 0.823214590549469
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty concise try-with-resource - not ok
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'X')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'method')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'in')
      ——ASTBlock
        ——ASTTryStatement
          ——ASTResourceList
            ——ASTResource
              ——ASTVariableAccess (referenced variable name = 'in')
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause(), //Returns the {@code finally} clause of this try statement, if any. @return The finally statement, or null if there is none

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        } else if (node.isTryWithResources() && node.getResourceList().getResources().size() > 0 && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the type of the block (try-with-resources in this case).
2. Check whether the block is a try-with-resources block.
3. Get the body of the try-with-resources block.
4. Check whether the body of the try-with-resources block is empty.
5. Get the finally branch of try statement (if present).
6. Check whether the finally branch of the try statement is empty.
7. Get the body of the switch statement (if present).
8. Check whether the body of the switch statement is empty.
9. Get the body of the synchronized statement (if present).
10. Check whether the body of the synchronized statement is empty.
11. Get the condition of the if statement (if present).
12. Get the body of the if statement (if present).
13. Check whether the body of the if statement is empty.
14. Get the else branch of the if statement (if present).
15. Check whether the else branch of the if statement is empty.
16. Get the condition of the while statement (if present).
17. Get the body of the while statement (if present).
18. Check whether the body of the while statement is empty.
19. Get the condition of the do-while statement (if present).
20. Get the body of the do-while statement (if present).
21. Check whether the body of the do-while statement is empty.
22. Get the loop variable of the for loop (if present).
23. Get the body of the for loop (if present).
24. Check whether the body of the for loop is empty.
25. Get the loop variable of the enhanced for loop (if present).
26. Get the body of the enhanced for loop (if present).
27. Check whether the body of the enhanced for loop is empty.
28. Get the initializers and blocks used as statements (for scoping).
29. Check whether the body of these initializers and blocks is empty.

For the given test case:
1. Get the type of the block (try-with-resources in this case).
2. Check whether the block is a try-with-resources block. (True, it is a try-with-resources block)
3. Get the body of the try-with-resources block. (The body is empty)
4. Check whether the body of the try-with-resources block is empty. (True, the body is empty)

This indicates a violation of the rule. Therefore, the number of violations in this test case is 1.
['Get the type of the block (try-with-resources in this case).', 'Check whether the block is a try-with-resources block.', 'Get the body of the try-with-resources block.', 'Check whether the body of the try-with-resources block is empty.', 'Get the finally branch of try statement (if present).', 'Check whether the finally branch of the try statement is empty.', 'Get the body of the switch statement (if present).', 'Check whether the body of the switch statement is empty.', 'Get the body of the synchronized statement (if present).', 'Check whether the body of the synchronized statement is empty.', 'Get the condition of the if statement (if present).', 'Get the body of the if statement (if present).', 'Check whether the body of the if statement is empty.', 'Get the else branch of the if statement (if present).', 'Check whether the else branch of the if statement is empty.', 'Get the condition of the while statement (if present).', 'Get the body of the while statement (if present).', 'Check whether the body of the while statement is empty.', 'Get the condition of the do-while statement (if present).', 'Get the body of the do-while statement (if present).', 'Check whether the body of the do-while statement is empty.', 'Get the loop variable of the for loop (if present).', 'Get the body of the for loop (if present).', 'Check whether the body of the for loop is empty.', 'Get the loop variable of the enhanced for loop (if present).', 'Get the body of the enhanced for loop (if present).', 'Check whether the body of the enhanced for loop is empty.', 'Get the initializers and blocks used as statements (for scoping).', 'Check whether the body of these initializers and blocks is empty.', 'Get the type of the block (try-with-resources in this case).', 'Check whether the block is a try-with-resources block. (True, it is a try-with-resources block)', 'Get the body of the try-with-resources block. (The body is empty)', 'Check whether the body of the try-with-resources block is empty. (True, the body is empty)']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTImportDeclaration', 'ASTFormalParameters', 'ASTResource', 'ASTVariableDeclaratorId', 'ASTResourceList', 'ASTVariableAccess', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the type of the block (try-with-resources in this case).* 匹配到的元操作或API：
query: Get the type of the block (try-with-resources in this case).
most similar API: get type system of block
cosine Similarity: 0.8079856634140015
*Check whether the block is a try-with-resources block.* 匹配到的元操作或API：
query: Check whether the block is a try-with-resources block.
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.8888108730316162
*Get the body of the try-with-resources block.* 匹配到的元操作或API：
query: Get the body of the try-with-resources block.
most similar API: get resources of try statement
cosine Similarity: 0.8296367526054382
*Check whether the body of the try-with-resources block is empty.* 匹配到的元操作或API：
query: Check whether the body of the try-with-resources block is empty.
most similar API: Check whether the resource list is empty
cosine Similarity: 0.8546039462089539
*Get the finally branch of try statement (if present).* 匹配到的元操作或API：
logic: Get the finally branch of try statement (if present).
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.979672372341156
*Check whether the finally branch of the try statement is empty.* 匹配到的元操作或API：
logic: Check whether the finally branch of the try statement is empty.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.8724913001060486
*Get the body of the switch statement (if present).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the switch statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the switch statement is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8094785809516907
*Get the body of the synchronized statement (if present).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the synchronized statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the condition of the if statement (if present).* 匹配到的元操作或API：
logic: Get the condition of the if statement (if present).
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9369165301322937
*Get the body of the if statement (if present).* 匹配到的元操作或API：
query: Get the body of the if statement (if present).
most similar API: get body of try statement
cosine Similarity: 0.8131042122840881
*Check whether the body of the if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of the if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8603641390800476
*Get the else branch of the if statement (if present).* 匹配到的元操作或API：
logic: Get the else branch of the if statement (if present).
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.9649499654769897
*Check whether the else branch of the if statement is empty.* 匹配到的元操作或API：
logic: Check whether the else branch of the if statement is empty.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9060106873512268
*Get the condition of the while statement (if present).* 匹配到的元操作或API：
logic: Get the condition of the while statement (if present).
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.9546467065811157
*Get the body of the while statement (if present).* 匹配到的元操作或API：
query: Get the body of the while statement (if present).
most similar API: get body of try statement
cosine Similarity: 0.8376685976982117
*Check whether the body of the while statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the condition of the do-while statement (if present).* 匹配到的元操作或API：
logic: Get the condition of the do-while statement (if present).
most similar meta operation: Get the condition of do-while statement
cosine Similarity: 0.9635500907897949
*Get the body of the do-while statement (if present).* 匹配到的元操作或API：
query: Get the body of the do-while statement (if present).
most similar API: get body of try statement
cosine Similarity: 0.8222542405128479
*Check whether the body of the do-while statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop variable of the for loop (if present).* 匹配到的元操作或API：
logic: Get the loop variable of the for loop (if present).
most similar meta operation: Get a loop variable of for loop
cosine Similarity: 0.9495061039924622
*Get the body of the for loop (if present).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the for loop is empty.* 匹配到的元操作或API：
query: Check whether the body of the for loop is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8098466396331787
*Get the loop variable of the enhanced for loop (if present).* 匹配到的元操作或API：
logic: Get the loop variable of the enhanced for loop (if present).
most similar meta operation: Get a loop variable of for loop
cosine Similarity: 0.9061242341995239
*Get the body of the enhanced for loop (if present).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the enhanced for loop is empty.* 匹配到的元操作或API：
query: Check whether the body of the enhanced for loop is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8008933663368225
*Get the initializers and blocks used as statements (for scoping).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of these initializers and blocks is empty.* 匹配到的元操作或API：
query: Check whether the body of these initializers and blocks is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8582744002342224
*Get the type of the block (try-with-resources in this case).* 匹配到的元操作或API：
query: Get the type of the block (try-with-resources in this case).
most similar API: get type system of block
cosine Similarity: 0.8079856634140015
*Check whether the block is a try-with-resources block. (True, it is a try-with-resources block)* 匹配到的元操作或API：
query: Check whether the block is a try-with-resources block. (True, it is a try-with-resources block)
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.8885457515716553
*Get the body of the try-with-resources block. (The body is empty)* 匹配到的元操作或API：
query: Get the body of the try-with-resources block. (The body is empty)
most similar API: get resources of try statement
cosine Similarity: 0.8265013098716736
*Check whether the body of the try-with-resources block is empty. (True, the body is empty)* 匹配到的元操作或API：
query: Check whether the body of the try-with-resources block is empty. (True, the body is empty)
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.8373894095420837
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty concise try-with-resource - not ok
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'X')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'method')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'in')
      ——ASTBlock
        ——ASTTryStatement
          ——ASTResourceList
            ——ASTResource
              ——ASTVariableAccess (referenced variable name = 'in')
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTBlock: public net.sourceforge.pmd.lang.java.types.TypeSystem getTypeSystem()
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean isTryWithResources(), //Returns true if this node is a try-with-resources, in which case it has a ResourceSpecification child node.
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTResourceList getResources(), //Returns the node for the resource list. This is null if this is not a try-with-resources.
4. net.sourceforge.pmd.lang.java.ast.ASTResourceList: public boolean isEmpty()
5. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()
7. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
8. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
9. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
10. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch()
11. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
12. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
13. net.sourceforge.pmd.lang.java.ast.ASTDoStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody()
14. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public net.sourceforge.pmd.lang.ast.NodeStream<ASTVariableDeclaratorId> getLoopVariables(net.sourceforge.pmd.lang.java.ast.ASTForStatement)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        if (node.isTryWithResources() && node.getResources().isEmpty() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the body of the try statement.
2. Check whether the body of the try statement is empty.
3. Get the finally branch of the try statement.
4. Check whether the finally branch of the try statement is present.
5. If the finally branch is present, get the body of the finally branch.
6. Check whether the body of the finally branch is empty.
7. Get the initializer(s) of the try-with-resources statement.
8. Check whether the initializer(s) of the try-with-resources statement is empty.
9. Get the body of the try-with-resources statement.
10. Check whether the body of the try-with-resources statement is empty.

In this test case:
- The try-with-resources statement has an empty body (step 9 and 10).
- There is no finally block, so steps 3 and 6 are not applicable.
- The initializer of the try-with-resources statement is not empty (it initializes the `InputStream`), so step 8 is not a violation.

Therefore, the number of violations is 1 (the empty body of the try-with-resources statement).
['Get the body of the try statement.', 'Check whether the body of the try statement is empty.', 'Get the finally branch of the try statement.', 'Check whether the finally branch of the try statement is present.', 'If the finally branch is present, get the body of the finally branch.', 'Check whether the body of the finally branch is empty.', 'Get the initializer(s) of the try-with-resources statement.', 'Check whether the initializer(s) of the try-with-resources statement is empty.', 'Get the body of the try-with-resources statement.', 'Check whether the body of the try-with-resources statement is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTImportDeclaration', 'ASTFormalParameters', 'ASTResource', 'ASTVariableDeclaratorId', 'ASTResourceList', 'ASTVariableAccess', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the body of the try statement.* 匹配到的元操作或API：
query: Get the body of the try statement.
most similar API: get body of try statement
cosine Similarity: 0.9787790179252625
*Check whether the body of the try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8486955761909485
*Get the finally branch of the try statement.* 匹配到的元操作或API：
logic: Get the finally branch of the try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9862933158874512
*Check whether the finally branch of the try statement is present.* 匹配到的元操作或API：
logic: Check whether the finally branch of the try statement is present.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9147607088088989
*If the finally branch is present, get the body of the finally branch.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the finally branch is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the initializer(s) of the try-with-resources statement.* 匹配到的元操作或API：
query: Get the initializer(s) of the try-with-resources statement.
most similar API: get initializer of resource
cosine Similarity: 0.8502232432365417
*Check whether the initializer(s) of the try-with-resources statement is empty.* 匹配到的元操作或API：
query: Check whether the initializer(s) of the try-with-resources statement is empty.
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.8308669328689575
*Get the body of the try-with-resources statement.* 匹配到的元操作或API：
query: Get the body of the try-with-resources statement.
most similar API: get resources of try statement
cosine Similarity: 0.8845179677009583
*Check whether the body of the try-with-resources statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the try-with-resources statement is empty.
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.8632696866989136
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty concise try-with-resource - not ok
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'X')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'method')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'in')
      ——ASTBlock
        ——ASTTryStatement
          ——ASTResourceList
            ——ASTResource
              ——ASTVariableAccess (referenced variable name = 'in')
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()
3. net.sourceforge.pmd.lang.java.ast.ASTResource: public net.sourceforge.pmd.lang.java.ast.ASTExpression getInitializer(), //Returns the initializer of the expression. If this is a concise resource, then returns that expression. If this is a local variable declaration, returns the initializer of the variable.
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean isTryWithResources(), //Returns true if this node is a try-with-resources, in which case it has a ResourceSpecification child node.
5. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTResourceList getResources(), //Returns the node for the resource list. This is null if this is not a try-with-resources.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        } else if (node.isTryWithResources() && node.getBody().isEmpty()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.getNumChildren() > 0) {
                boolean allResourcesConcise = true;
                for (ASTResource resource : resources.getResources()) {
                    if (resource.getInitializer() == null) {
                        allResourcesConcise = false;
                        break;
                    }
                }
                if (allResourcesConcise) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the signature of the called method.
2. Check whether the method is a constructor call for try-with-resources.
3. Get the body of the try-with-resources statement.
4. Check whether the body is empty.
If the body of the try-with-resources statement is empty, then this test case violates the rule.

In this specific test case:
1. The method signature is not applicable as we are dealing with a try-with-resources statement.
2. The try-with-resources statement is using `in` as a resource, which is a constructor call for try-with-resources in the context of the rule.
3. The body of the try-with-resources statement is empty.
4. Since the body is empty, this test case violates the rule.
['Get the signature of the called method.', 'Check whether the method is a constructor call for try-with-resources.', 'Get the body of the try-with-resources statement.', 'Check whether the body is empty.', 'The method signature is not applicable as we are dealing with a try-with-resources statement.', 'The try-with-resources statement is using `in` as a resource, which is a constructor call for try-with-resources in the context of the rule.', 'The body of the try-with-resources statement is empty.', 'Since the body is empty, this test case violates the rule.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTImportDeclaration', 'ASTFormalParameters', 'ASTResource', 'ASTVariableDeclaratorId', 'ASTResourceList', 'ASTVariableAccess', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the signature of the called method.* 匹配到的元操作或API：
logic: Get the signature of the called method.
most similar meta operation: Get the signature of the called method
cosine Similarity: 0.9828985929489136
*Check whether the method is a constructor call for try-with-resources.* 匹配到的元操作或API：
query: Check whether the method is a constructor call for try-with-resources.
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.8370770215988159
*Get the body of the try-with-resources statement.* 匹配到的元操作或API：
query: Get the body of the try-with-resources statement.
most similar API: get resources of try statement
cosine Similarity: 0.8845179677009583
*Check whether the body is empty.* 匹配到的元操作或API：
query: Check whether the body is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8587327003479004
*The method signature is not applicable as we are dealing with a try-with-resources statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*The try-with-resources statement is using `in` as a resource, which is a constructor call for try-with-resources in the context of the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*The body of the try-with-resources statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Since the body is empty, this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty concise try-with-resource - not ok
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'X')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'method')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'in')
      ——ASTBlock
        ——ASTTryStatement
          ——ASTResourceList
            ——ASTResource
              ——ASTVariableAccess (referenced variable name = 'in')
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.types.JMethodSig getMethodType()
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean isTryWithResources(), //Returns true if this node is a try-with-resources, in which case it has a ResourceSpecification child node.
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTResourceList getResources(), //Returns the node for the resource list. This is null if this is not a try-with-resources.
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        } else if (node.isTryWithResources() && node.getResources() != null && node.getResources().isEmpty() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the body of the try statement.
2. Check whether the body of the try statement is empty.
3. Get the finally branch of the try statement.
4. Check whether the finally branch of the try statement is empty.
5. Get the body of the switch statement.
6. Check whether the body of the switch statement is empty.
7. Get the body of the synchronized statement.
8. Check whether the body of the synchronized statement is empty.
9. Get the body of the if statement.
10. Check whether the body of the if statement is empty.
11. Get the body of the for loop.
12. Check whether the body of the for loop is empty.
13. Get the body of the while loop.
14. Check whether the body of the while loop is empty.
15. Get the body of the do-while loop.
16. Check whether the body of the do-while loop is empty.
17. Get the body of the initializer block.
18. Check whether the body of the initializer block is empty.
19. Get the body of the block used as a statement.
20. Check whether the body of the block used as a statement is empty.

For the provided test case:
1. Get the body of the try statement.
2. Check whether the body of the try statement is empty.
   - The body of the try statement is empty, which violates the rule.
   
The other checks are not applicable to the given test case as there are no switch, synchronized, if, loop statements, initializers, or blocks used as statements in the provided code snippet. Thus, the number of violations in this test case is: 1.
['Get the body of the try statement.', 'Check whether the body of the try statement is empty.', 'Get the finally branch of the try statement.', 'Check whether the finally branch of the try statement is empty.', 'Get the body of the switch statement.', 'Check whether the body of the switch statement is empty.', 'Get the body of the synchronized statement.', 'Check whether the body of the synchronized statement is empty.', 'Get the body of the if statement.', 'Check whether the body of the if statement is empty.', 'Get the body of the for loop.', 'Check whether the body of the for loop is empty.', 'Get the body of the while loop.', 'Check whether the body of the while loop is empty.', 'Get the body of the do-while loop.', 'Check whether the body of the do-while loop is empty.', 'Get the body of the initializer block.', 'Check whether the body of the initializer block is empty.', 'Get the body of the block used as a statement.', 'Check whether the body of the block used as a statement is empty.', 'Get the body of the try statement.', 'Check whether the body of the try statement is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTImportDeclaration', 'ASTFormalParameters', 'ASTResource', 'ASTVariableDeclaratorId', 'ASTResourceList', 'ASTVariableAccess', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the body of the try statement.* 匹配到的元操作或API：
query: Get the body of the try statement.
most similar API: get body of try statement
cosine Similarity: 0.9787790179252625
*Check whether the body of the try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8486955761909485
*Get the finally branch of the try statement.* 匹配到的元操作或API：
logic: Get the finally branch of the try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9862933158874512
*Check whether the finally branch of the try statement is empty.* 匹配到的元操作或API：
logic: Check whether the finally branch of the try statement is empty.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.8724913001060486
*Get the body of the switch statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the switch statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the switch statement is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8094785809516907
*Get the body of the synchronized statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the synchronized statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the if statement.* 匹配到的元操作或API：
query: Get the body of the if statement.
most similar API: get body of try statement
cosine Similarity: 0.845529317855835
*Check whether the body of the if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of the if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8603641390800476
*Get the body of the for loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the for loop is empty.* 匹配到的元操作或API：
query: Check whether the body of the for loop is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8098466396331787
*Get the body of the while loop.* 匹配到的元操作或API：
query: Get the body of the while loop.
most similar API: get body of try statement
cosine Similarity: 0.8167150616645813
*Check whether the body of the while loop is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the do-while loop.* 匹配到的元操作或API：
query: Get the body of the do-while loop.
most similar API: get body of try statement
cosine Similarity: 0.8072477579116821
*Check whether the body of the do-while loop is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the initializer block.* 匹配到的元操作或API：
query: Get the body of the initializer block.
most similar API: get body of class or interface
cosine Similarity: 0.8090934753417969
*Check whether the body of the initializer block is empty.* 匹配到的元操作或API：
query: Check whether the body of the initializer block is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8630777597427368
*Get the body of the block used as a statement.* 匹配到的元操作或API：
query: Get the body of the block used as a statement.
most similar API: get text of block
cosine Similarity: 0.8125266432762146
*Check whether the body of the block used as a statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the block used as a statement is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8961539268493652
*Get the body of the try statement.* 匹配到的元操作或API：
query: Get the body of the try statement.
most similar API: get body of try statement
cosine Similarity: 0.9787790179252625
*Check whether the body of the try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8486955761909485
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty concise try-with-resource - not ok
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'X')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'method')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'in')
      ——ASTBlock
        ——ASTTryStatement
          ——ASTResourceList
            ——ASTResource
              ——ASTVariableAccess (referenced variable name = 'in')
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTTypeBody getBody(), //Returns the body of this type declaration.
6. net.sourceforge.pmd.lang.java.ast.ASTBlock: public net.sourceforge.pmd.lang.document.Chars getText()
7. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        } else if (node.isTryWithResources() && node.getResourceCount() == 1 && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 6
[ERROR]   "bad 8" failed不通过
90
76
=========================error_testcase_logics=========================
1. Get the name of method.
2. Get the body of method.
3. Get a control statement in the method body.
4. Get the name of the control statement.
5. Check whether the control statement is a switch statement.
6. Get the body of the switch statement.
7. Check whether the body of the switch statement is empty.
If the body of the switch statement is empty, then this test case violates the rule.
['Get the name of method.', 'Get the body of method.', 'Get a control statement in the method body.', 'Get the name of the control statement.', 'Check whether the control statement is a switch statement.', 'Get the body of the switch statement.', 'Check whether the body of the switch statement is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTMethodDeclaration', 'ASTSwitchStatement', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'ASTVariableDeclarator', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTNumericLiteral']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752807021141052
*Get a control statement in the method body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the control statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is a switch statement.* 匹配到的元操作或API：
query: Check whether the control statement is a switch statement.
most similar API: Check whether the switch statement equals
cosine Similarity: 0.8677688837051392
*Get the body of the switch statement.* 匹配到的元操作或API：
query: Get the body of the switch statement.
most similar API: get text of switch statement
cosine Similarity: 0.8815829753875732
*Check whether the body of the switch statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the switch statement is empty.
most similar API: Check whether the switch statement equals
cosine Similarity: 0.8138682246208191
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty switch stmt
public class EmptySwitchStmt1 {
                public void bar() {
                    int x = 2;
                    switch (x) {}
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptySwitchStmt1')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'x')
            ——ASTNumericLiteral
        ——ASTSwitchStatement
          ——ASTVariableAccess (referenced variable name = 'x')


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
3. net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement: public net.sourceforge.pmd.lang.document.Chars getText()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        if (node.getNumChildren() == 0) { // Switch statement with no body
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 8" failed'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 8" failed不通过
=========================error_testcase_logics=========================
1. Get the name of the method.
2. Get the body of the method.
3. Get all control statements in the method body.
4. Find the switch statement in the control statements.
5. Get the body of the switch statement.
6. Check whether the body of the switch statement is empty.

If the body of the switch statement is empty, then this test case violates the rule.
['Get the name of the method.', 'Get the body of the method.', 'Get all control statements in the method body.', 'Find the switch statement in the control statements.', 'Get the body of the switch statement.', 'Check whether the body of the switch statement is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTMethodDeclaration', 'ASTSwitchStatement', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'ASTVariableDeclarator', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTNumericLiteral']
*Get the name of the method.* 匹配到的元操作或API：
logic: Get the name of the method.
most similar meta operation: Get the name of method
cosine Similarity: 0.971399188041687
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Get all control statements in the method body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Find the switch statement in the control statements.* 匹配到的元操作或API：
query: Find the switch statement in the control statements.
most similar API: compare location of switch statement
cosine Similarity: 0.8326404094696045
*Get the body of the switch statement.* 匹配到的元操作或API：
query: Get the body of the switch statement.
most similar API: get text of switch statement
cosine Similarity: 0.8815829753875732
*Check whether the body of the switch statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the switch statement is empty.
most similar API: Check whether the switch statement equals
cosine Similarity: 0.8138682246208191
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty switch stmt
public class EmptySwitchStmt1 {
                public void bar() {
                    int x = 2;
                    switch (x) {}
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptySwitchStmt1')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'x')
            ——ASTNumericLiteral
        ——ASTSwitchStatement
          ——ASTVariableAccess (referenced variable name = 'x')


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
3. net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement: public int compareLocation(net.sourceforge.pmd.lang.ast.Node)
4. net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement: public net.sourceforge.pmd.lang.document.Chars getText()
5. net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        } else if (node.getNumChildren() == 0) { // Empty switch statement
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 8" failed'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 8" failed不通过
=========================error_testcase_logics=========================
1. Get the name of the method.
        2. Get the signature of the method.
        3. Get the body of the method.
        4. Get all switch statements in the body of the method.
        5. Get the number of switch statements found.
        6. Check whether the switch statement body is empty.
        If the switch statement body is empty, then this test case violates the rule.
        
Given the test case, let's perform the checks:

1. Get the name of the method.
   - The method name is `bar`.

2. Get the signature of the method.
   - The method signature is `public void bar()`.

3. Get the body of the method.
   - The body of the method is:
     ```java
     {
         int x = 2;
         switch (x) {}
     }
     ```

4. Get all switch statements in the body of the method.
   - There is one switch statement in the body: `switch (x) {}`.

5. Get the number of switch statements found.
   - The number of switch statements found is 1.

6. Check whether the switch statement body is empty.
   - The switch statement body `switch (x) {}` is indeed empty.

Since the switch statement body is empty, this test case violates the rule.
['Get the name of the method.', 'Get the signature of the method.', 'Get the body of the method.', 'Get all switch statements in the body of the method.', 'Get the number of switch statements found.', 'Check whether the switch statement body is empty.', 'Get the name of the method.', 'Get the signature of the method.', 'Get the body of the method.', 'Get all switch statements in the body of the method.', 'Get the number of switch statements found.', 'Check whether the switch statement body is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTMethodDeclaration', 'ASTSwitchStatement', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'ASTVariableDeclarator', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTNumericLiteral']
*Get the name of the method.* 匹配到的元操作或API：
logic: Get the name of the method.
most similar meta operation: Get the name of method
cosine Similarity: 0.971399188041687
*Get the signature of the method.* 匹配到的元操作或API：
logic: Get the signature of the method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9734324812889099
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Get all switch statements in the body of the method.* 匹配到的元操作或API：
query: Get all switch statements in the body of the method.
most similar API: get text of switch statement
cosine Similarity: 0.8164705634117126
*Get the number of switch statements found.* 匹配到的元操作或API：
query: Get the number of switch statements found.
most similar API: get num children of switch statement
cosine Similarity: 0.8410934209823608
*Check whether the switch statement body is empty.* 匹配到的元操作或API：
query: Check whether the switch statement body is empty.
most similar API: Check whether the switch statement equals
cosine Similarity: 0.8167762756347656
*Get the name of the method.* 匹配到的元操作或API：
logic: Get the name of the method.
most similar meta operation: Get the name of method
cosine Similarity: 0.971399188041687
*Get the signature of the method.* 匹配到的元操作或API：
logic: Get the signature of the method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9734324812889099
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Get all switch statements in the body of the method.* 匹配到的元操作或API：
query: Get all switch statements in the body of the method.
most similar API: get text of switch statement
cosine Similarity: 0.8164705634117126
*Get the number of switch statements found.* 匹配到的元操作或API：
query: Get the number of switch statements found.
most similar API: get num children of switch statement
cosine Similarity: 0.8410934209823608
*Check whether the switch statement body is empty.* 匹配到的元操作或API：
query: Check whether the switch statement body is empty.
most similar API: Check whether the switch statement equals
cosine Similarity: 0.8167762756347656
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty switch stmt
public class EmptySwitchStmt1 {
                public void bar() {
                    int x = 2;
                    switch (x) {}
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptySwitchStmt1')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'x')
            ——ASTNumericLiteral
        ——ASTSwitchStatement
          ——ASTVariableAccess (referenced variable name = 'x')


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
4. net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement: public net.sourceforge.pmd.lang.document.Chars getText()
5. net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement: public int getNumChildren()
6. net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        } else if (node.getNumChildren() == 0) { // Empty switch statement
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 8" failed'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 8" failed不通过
=========================error_testcase_logics=========================
1. Get the condition of switch statement.
        2. Check whether the switch statement has any branches.
        If the switch statement has no branches, then it violates the rule.
        
In this specific test case:
1. The condition of the switch statement is `x`.
2. Check whether the switch statement has any branches. It does not have any branches.
        
Since the switch statement has an empty body, it violates the rule.
['Get the condition of switch statement.', 'Check whether the switch statement has any branches.', 'The condition of the switch statement is `x`.', 'Check whether the switch statement has any branches. It does not have any branches.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTMethodDeclaration', 'ASTSwitchStatement', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'ASTVariableDeclarator', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTNumericLiteral']
*Get the condition of switch statement.* 匹配到的元操作或API：
logic: Get the condition of switch statement.
most similar meta operation: Get the condition of switch statement
cosine Similarity: 0.987187385559082
*Check whether the switch statement has any branches.* 匹配到的元操作或API：
logic: Check whether the switch statement has any branches.
most similar meta operation: Check whether the switch statement uses fallthrough branches
cosine Similarity: 0.8883507251739502
*The condition of the switch statement is `x`.* 匹配到的元操作或API：
logic: The condition of the switch statement is `x`.
most similar meta operation: Get the condition of switch statement
cosine Similarity: 0.8515939116477966
*Check whether the switch statement has any branches. It does not have any branches.* 匹配到的元操作或API：
logic: Check whether the switch statement has any branches. It does not have any branches.
most similar meta operation: Check whether the switch statement uses fallthrough branches
cosine Similarity: 0.8681252002716064
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty switch stmt
public class EmptySwitchStmt1 {
                public void bar() {
                    int x = 2;
                    switch (x) {}
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptySwitchStmt1')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'x')
            ——ASTNumericLiteral
        ——ASTSwitchStatement
          ——ASTVariableAccess (referenced variable name = 'x')


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getTestedExpression()
2. net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement: public boolean isFallthroughSwitch()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        if (node.getNumChildren() == 0) { // Switch statement with no body
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 8" failed'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 8" failed不通过
=========================error_testcase_logics=========================
1. Get the condition of switch statement.
        2. Get a branch of switch statement.
        3. Check whether the switch branch is default.
        4. Get the label of switch statement branch.
        5. Get the expression of switch label.
        6. Get the right-hand side of the switch statement arrow branch.
        7. Check whether the right-hand side of the switch statement arrow branch is empty.
        8. Check whether the switch statement is empty.
        
In this specific test case:
1. Get the condition of switch statement. // The condition is `x`
2. Get a branch of switch statement. // There are no branches in the switch statement.
3. The switch statement has no branches, so this check is not applicable.
4. Check whether the switch statement is empty. // The switch statement is indeed empty.

Since the switch statement is empty, this test case violates the rule.
['Get the condition of switch statement.', 'Get a branch of switch statement.', 'Check whether the switch branch is default.', 'Get the label of switch statement branch.', 'Get the expression of switch label.', 'Get the right-hand side of the switch statement arrow branch.', 'Check whether the right-hand side of the switch statement arrow branch is empty.', 'Check whether the switch statement is empty.', 'Get the condition of switch statement. // The condition is `x`', 'Get a branch of switch statement. // There are no branches in the switch statement.', 'The switch statement has no branches, so this check is not applicable.', 'Check whether the switch statement is empty. // The switch statement is indeed empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTMethodDeclaration', 'ASTSwitchStatement', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'ASTVariableDeclarator', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTNumericLiteral']
*Get the condition of switch statement.* 匹配到的元操作或API：
logic: Get the condition of switch statement.
most similar meta operation: Get the condition of switch statement
cosine Similarity: 0.987187385559082
*Get a branch of switch statement.* 匹配到的元操作或API：
logic: Get a branch of switch statement.
most similar meta operation: Get a branch of switch statement
cosine Similarity: 0.989242672920227
*Check whether the switch branch is default.* 匹配到的元操作或API：
logic: Check whether the switch branch is default.
most similar meta operation: Check whether the switch branch is default
cosine Similarity: 0.990627110004425
*Get the label of switch statement branch.* 匹配到的元操作或API：
logic: Get the label of switch statement branch.
most similar meta operation: Get the label of switch statement branch
cosine Similarity: 0.9913433790206909
*Get the expression of switch label.* 匹配到的元操作或API：
logic: Get the expression of switch label.
most similar meta operation: Get the expression of switch label
cosine Similarity: 0.9905807971954346
*Get the right-hand side of the switch statement arrow branch.* 匹配到的元操作或API：
logic: Get the right-hand side of the switch statement arrow branch.
most similar meta operation: Get the right hand side of the switch statement arrow branch
cosine Similarity: 0.9838226437568665
*Check whether the right-hand side of the switch statement arrow branch is empty.* 匹配到的元操作或API：
logic: Check whether the right-hand side of the switch statement arrow branch is empty.
most similar meta operation: Get the right hand side of the switch statement arrow branch
cosine Similarity: 0.8662875294685364
*Check whether the switch statement is empty.* 匹配到的元操作或API：
query: Check whether the switch statement is empty.
most similar API: Check whether the switch statement equals
cosine Similarity: 0.8563297390937805
*Get the condition of switch statement. // The condition is `x`* 匹配到的元操作或API：
logic: Get the condition of switch statement. // The condition is `x`
most similar meta operation: Get the condition of switch statement
cosine Similarity: 0.9313444495201111
*Get a branch of switch statement. // There are no branches in the switch statement.* 匹配到的元操作或API：
logic: Get a branch of switch statement. // There are no branches in the switch statement.
most similar meta operation: Get a branch of switch statement
cosine Similarity: 0.9027588963508606
*The switch statement has no branches, so this check is not applicable.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the switch statement is empty. // The switch statement is indeed empty.* 匹配到的元操作或API：
query: Check whether the switch statement is empty. // The switch statement is indeed empty.
most similar API: Check whether the switch statement equals
cosine Similarity: 0.8305903673171997
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty switch stmt
public class EmptySwitchStmt1 {
                public void bar() {
                    int x = 2;
                    switch (x) {}
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptySwitchStmt1')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'x')
            ——ASTNumericLiteral
        ——ASTSwitchStatement
          ——ASTVariableAccess (referenced variable name = 'x')


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getTestedExpression()
2. net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTSwitchBranch> getBranches()
3. net.sourceforge.pmd.lang.java.ast.ASTSwitchBranch: public boolean isDefault()
4. net.sourceforge.pmd.lang.java.ast.ASTSwitchBranch: public net.sourceforge.pmd.lang.java.ast.ASTSwitchLabel getLabel()
5. net.sourceforge.pmd.lang.java.ast.ASTSwitchLabel: public NodeStream<ASTExpression> getExprList()
6. net.sourceforge.pmd.lang.java.ast.ASTSwitchArrowBranch: public net.sourceforge.pmd.lang.java.ast.ASTSwitchArrowRHS getRightHandSide()
7. net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        } else {
            boolean hasDefault = false;
            boolean hasNonEmptyBranch = false;
            for (ASTSwitchBranch branch : branches) {
                if (branch.isDefault()) {
                    hasDefault = true;
                }
                if (branch instanceof ASTSwitchArrowBranch) {
                    ASTSwitchArrowBranch arrowBranch = (ASTSwitchArrowBranch) branch;
                    ASTSwitchArrowRHS rhs = arrowBranch.getRightHandSide();
                    if (!rhs.isEmpty()) {
                        hasNonEmptyBranch = true;
                    }
                } else if (!branch.isEmpty()) {
                    hasNonEmptyBranch = true;
                }
            }
            if (!hasNonEmptyBranch && !hasDefault) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 8
[ERROR]   "bad 9" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the body of the method.
2. Check whether the body contains an empty block.
3. If an empty block is found, check whether it is used as a statement (for scoping).

In this test case:
- The body of the method `bar` is checked.
- An empty block `{}` is found.
- The empty block is used as a statement (for scoping).

Therefore, this test case violates the rule once.
['Get the body of the method.', 'Check whether the body contains an empty block.', 'If an empty block is found, check whether it is used as a statement (for scoping).']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Check whether the body contains an empty block.* 匹配到的元操作或API：
query: Check whether the body contains an empty block.
most similar API: Check whether the block is empty
cosine Similarity: 0.8996580839157104
*If an empty block is found, check whether it is used as a statement (for scoping).* 匹配到的元操作或API：
query: If an empty block is found, check whether it is used as a statement (for scoping).
most similar API: Check whether the block is empty
cosine Similarity: 0.8705902099609375
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty block
public class Foo {
                public void bar() {
                    {}
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
2. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            node.isEmpty() && node.getParent() instanceof ASTMethodDeclaration) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 9" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 9" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Check whether the class is public.
2. Get the method located in the class.
3. Get the name of method.
4. Get the method body.
5. Check whether the method body contains an empty block.
If the method body contains an empty block, then this test case violates the rule.
            
['Check whether the class is public.', 'Get the method located in the class.', 'Get the name of method.', 'Get the method body.', 'Check whether the method body contains an empty block.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Get the method located in the class.* 匹配到的元操作或API：
logic: Get the method located in the class.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.8935988545417786
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the method body.* 匹配到的元操作或API：
query: Get the method body.
most similar API: get body of method
cosine Similarity: 0.9521394371986389
*Check whether the method body contains an empty block.* 匹配到的元操作或API：
query: Check whether the method body contains an empty block.
most similar API: Check whether the block is empty
cosine Similarity: 0.8801108002662659
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody)) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty block
public class Foo {
                public void bar() {
                    {}
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
5. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "bad 10" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
78
64
=========================error_testcase_logics=========================
1. Check whether the class has an initializer block.
2. Check whether the initializer block is empty.
If the initializer block is empty, then this test case violates the rule. 

In this specific test case:
1. The class `Foo` has an initializer block `{}`.
2. The initializer block is empty, which means it violates the rule.
['Check whether the class has an initializer block.', 'Check whether the initializer block is empty.', 'The class `Foo` has an initializer block `{}`.', 'The initializer block is empty, which means it violates the rule.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'ASTInitializer', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Check whether the class has an initializer block.* 匹配到的元操作或API：
query: Check whether the class has an initializer block.
most similar API: Check whether the initializer equals
cosine Similarity: 0.8732585310935974
*Check whether the initializer block is empty.* 匹配到的元操作或API：
query: Check whether the initializer block is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8620045185089111
*The class `Foo` has an initializer block `{}`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The initializer block is empty, which means it violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty initializer failure case (non static)
public class Foo {
                {}
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTInitializer: public boolean equals(java.lang.Object)
2. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 10" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 10" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get the number of initializers in class.
3. Check whether the initializer is static.
4. Check whether the body of the initializer is empty.
5. Get the number of blocks used as statements in class.
6. Check whether the body of the block used as a statement is empty.

In this test case:
7. The number of violating the rule in this test case is: 1.

The specific granular check for the violation is:
4. Check whether the body of the initializer is empty.
   This check will confirm that the body of the empty initializer is indeed empty, which violates the rule.
['Get the name of class.', 'Get the number of initializers in class.', 'Check whether the initializer is static.', 'Check whether the body of the initializer is empty.', 'Get the number of blocks used as statements in class.', 'Check whether the body of the block used as a statement is empty.', 'The number of violating the rule in this test case is: 1.', 'Check whether the body of the initializer is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'ASTInitializer', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the number of initializers in class.* 匹配到的元操作或API：
query: Get the number of initializers in class.
most similar API: get num children of initializer
cosine Similarity: 0.8755324482917786
*Check whether the initializer is static.* 匹配到的元操作或API：
query: Check whether the initializer is static.
most similar API: Check whether the initializer is static
cosine Similarity: 0.9883449077606201
*Check whether the body of the initializer is empty.* 匹配到的元操作或API：
query: Check whether the body of the initializer is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8785521984100342
*Get the number of blocks used as statements in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the block used as a statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the block used as a statement is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8961539268493652
*The number of violating the rule in this test case is: 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the initializer is empty.* 匹配到的元操作或API：
query: Check whether the body of the initializer is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8785521984100342
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty initializer failure case (non static)
public class Foo {
                {}
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTInitializer: public int getNumChildren()
3. net.sourceforge.pmd.lang.java.ast.ASTInitializer: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()
5. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 10" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 10" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class has blocks used as statements (for scoping).
3. Check whether the body of the block is empty.
4. If the body of the block is empty, it violates the rule.

In this test case:

1. Get the name of class: Foo
2. Check whether the class has blocks used as statements (for scoping): Yes
3. Check whether the body of the block is empty: Yes
4. Since the body of the block is empty, this test case violates the rule.
['Get the name of class.', 'Check whether the class has blocks used as statements (for scoping).', 'Check whether the body of the block is empty.', 'If the body of the block is empty, it violates the rule.', 'Get the name of class: Foo', 'Check whether the class has blocks used as statements (for scoping): Yes', 'Check whether the body of the block is empty: Yes', 'Since the body of the block is empty, this test case violates the rule.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'ASTInitializer', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has blocks used as statements (for scoping).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the block is empty.* 匹配到的元操作或API：
query: Check whether the body of the block is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.9294555187225342
*If the body of the block is empty, it violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: Foo* 匹配到的元操作或API：
logic: Get the name of class: Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9263079166412354
*Check whether the class has blocks used as statements (for scoping): Yes* 匹配到的元操作或API：
query: Check whether the class has blocks used as statements (for scoping): Yes
most similar API: Check whether the block equals
cosine Similarity: 0.8026329874992371
*Check whether the body of the block is empty: Yes* 匹配到的元操作或API：
query: Check whether the body of the block is empty: Yes
most similar API: Check whether the block is empty
cosine Similarity: 0.9151607751846313
*Since the body of the block is empty, this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty initializer failure case (non static)
public class Foo {
                {}
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()
3. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        for (ASTInitializer initializer : node.findDescendantsOfType(ASTInitializer.class)) {
            if (initializer.getBody().isEmpty()) {
                addViolation(data, initializer);
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 10" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 10" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Check whether the class has any initializers.
        2. Check whether the initializer is static.
        3. Check whether the body of the initializer is empty.
        If the class has an initializer that is not static and the body of that initializer is empty, then the test case violates the rule.
['Check whether the class has any initializers.', 'Check whether the initializer is static.', 'Check whether the body of the initializer is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'ASTInitializer', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Check whether the class has any initializers.* 匹配到的元操作或API：
query: Check whether the class has any initializers.
most similar API: Check whether the initializer equals
cosine Similarity: 0.8680279850959778
*Check whether the initializer is static.* 匹配到的元操作或API：
query: Check whether the initializer is static.
most similar API: Check whether the initializer is static
cosine Similarity: 0.9883449077606201
*Check whether the body of the initializer is empty.* 匹配到的元操作或API：
query: Check whether the body of the initializer is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8785521984100342
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty initializer failure case (non static)
public class Foo {
                {}
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTInitializer: public boolean equals(java.lang.Object)
2. net.sourceforge.pmd.lang.java.ast.ASTInitializer: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { 
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (!node.isStatic() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 10" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 10" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Check whether the class contains an initializer block.
        2. Check whether the initializer block is static.
        3. Check whether the initializer block is empty.

If the class contains a non-static initializer block and it is empty, then this test case violates the rule.
['Check whether the class contains an initializer block.', 'Check whether the initializer block is static.', 'Check whether the initializer block is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'ASTInitializer', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Check whether the class contains an initializer block.* 匹配到的元操作或API：
query: Check whether the class contains an initializer block.
most similar API: Check whether the initializer equals
cosine Similarity: 0.8774299621582031
*Check whether the initializer block is static.* 匹配到的元操作或API：
query: Check whether the initializer block is static.
most similar API: Check whether the initializer is static
cosine Similarity: 0.9568566083908081
*Check whether the initializer block is empty.* 匹配到的元操作或API：
query: Check whether the initializer block is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8620045185089111
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty initializer failure case (non static)
public class Foo {
                {}
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTInitializer: public boolean equals(java.lang.Object)
2. net.sourceforge.pmd.lang.java.ast.ASTInitializer: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 10" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 10" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 10
[ERROR]   "bad 11" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
78
64
=========================error_testcase_logics=========================
1. Get the name of the package where the class is located.
2. Get the name of class.
3. Check whether the class is static.
4. Get all initializers declared in class.
5. Check whether the initializer is static.
6. Check whether the static initializer is empty.
If the static initializer is empty, then this test case violates the rule.
        
['Get the name of the package where the class is located.', 'Get the name of class.', 'Check whether the class is static.', 'Get all initializers declared in class.', 'Check whether the initializer is static.', 'Check whether the static initializer is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'ASTInitializer', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520915031433
*Get all initializers declared in class.* 匹配到的元操作或API：
query: Get all initializers declared in class.
most similar API: get class of initializer
cosine Similarity: 0.8484858274459839
*Check whether the initializer is static.* 匹配到的元操作或API：
query: Check whether the initializer is static.
most similar API: Check whether the initializer is static
cosine Similarity: 0.9883449077606201
*Check whether the static initializer is empty.* 匹配到的元操作或API：
query: Check whether the static initializer is empty.
most similar API: Check whether the initializer is static
cosine Similarity: 0.9006942510604858
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty initializer failure case (static)
public class Foo {
                static {}
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTInitializer: public java.lang.Class<Class<?> getClass()
5. net.sourceforge.pmd.lang.java.ast.ASTInitializer: public boolean isStatic()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 11" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 11" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all initializers in class.
3. Check whether the initializer is static.
4. Check whether the body of the initializer is empty.
        If the initializer is static and its body is empty, then this test case violates the rule.
['Get the name of class.', 'Get all initializers in class.', 'Check whether the initializer is static.', 'Check whether the body of the initializer is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'ASTInitializer', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all initializers in class.* 匹配到的元操作或API：
query: Get all initializers in class.
most similar API: get class of initializer
cosine Similarity: 0.8503428101539612
*Check whether the initializer is static.* 匹配到的元操作或API：
query: Check whether the initializer is static.
most similar API: Check whether the initializer is static
cosine Similarity: 0.9883449077606201
*Check whether the body of the initializer is empty.* 匹配到的元操作或API：
query: Check whether the body of the initializer is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8785521984100342
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty initializer failure case (static)
public class Foo {
                static {}
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTInitializer: public java.lang.Class<Class<?> getClass()
3. net.sourceforge.pmd.lang.java.ast.ASTInitializer: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 11" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 11" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Get all initializers in class.
        3. Check whether the initializer is static.
        4. Check whether the body of the static initializer is empty.
        If the initializer is static and its body is empty, then this test case violates the rule.
        
Based on the provided test case, the checks would be:

1. Get the name of class.
        2. Get all initializers in class.
        3. Check whether the initializer is static.
        4. Check whether the body of the static initializer is empty.

This test case will fail the 4th check, confirming that there is one violation of the rule in the provided code snippet.
['Get the name of class.', 'Get all initializers in class.', 'Check whether the initializer is static.', 'Check whether the body of the static initializer is empty.', 'Get the name of class.', 'Get all initializers in class.', 'Check whether the initializer is static.', 'Check whether the body of the static initializer is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'ASTInitializer', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all initializers in class.* 匹配到的元操作或API：
query: Get all initializers in class.
most similar API: get class of initializer
cosine Similarity: 0.8503428101539612
*Check whether the initializer is static.* 匹配到的元操作或API：
query: Check whether the initializer is static.
most similar API: Check whether the initializer is static
cosine Similarity: 0.9883449077606201
*Check whether the body of the static initializer is empty.* 匹配到的元操作或API：
query: Check whether the body of the static initializer is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.875758945941925
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all initializers in class.* 匹配到的元操作或API：
query: Get all initializers in class.
most similar API: get class of initializer
cosine Similarity: 0.8503428101539612
*Check whether the initializer is static.* 匹配到的元操作或API：
query: Check whether the initializer is static.
most similar API: Check whether the initializer is static
cosine Similarity: 0.9883449077606201
*Check whether the body of the static initializer is empty.* 匹配到的元操作或API：
query: Check whether the body of the static initializer is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.875758945941925
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty initializer failure case (static)
public class Foo {
                static {}
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTInitializer: public java.lang.Class<Class<?> getClass()
3. net.sourceforge.pmd.lang.java.ast.ASTInitializer: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 11" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 11" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Check whether the class has initializers.
2. Get the initializer of the class.
3. Check whether the initializer is static.
4. Get the body of the static initializer.
5. Check whether the body of the static initializer is empty.

If the body of the static initializer is empty, then this test case violates the rule.
['Check whether the class has initializers.', 'Get the initializer of the class.', 'Check whether the initializer is static.', 'Get the body of the static initializer.', 'Check whether the body of the static initializer is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'ASTInitializer', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Check whether the class has initializers.* 匹配到的元操作或API：
query: Check whether the class has initializers.
most similar API: Check whether the initializer equals
cosine Similarity: 0.8778448700904846
*Get the initializer of the class.* 匹配到的元操作或API：
query: Get the initializer of the class.
most similar API: get class of initializer
cosine Similarity: 0.8967980146408081
*Check whether the initializer is static.* 匹配到的元操作或API：
query: Check whether the initializer is static.
most similar API: Check whether the initializer is static
cosine Similarity: 0.9883449077606201
*Get the body of the static initializer.* 匹配到的元操作或API：
query: Get the body of the static initializer.
most similar API: get body of initializer
cosine Similarity: 0.9304062128067017
*Check whether the body of the static initializer is empty.* 匹配到的元操作或API：
query: Check whether the body of the static initializer is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.875758945941925
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty initializer failure case (static)
public class Foo {
                static {}
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTInitializer: public boolean equals(java.lang.Object)
2. net.sourceforge.pmd.lang.java.ast.ASTInitializer: public java.lang.Class<Class<?> getClass()
3. net.sourceforge.pmd.lang.java.ast.ASTInitializer: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTInitializer: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this initializer.
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 11" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 11" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Check whether the class has static initializers.
2. Get the static initializer of the class.
3. Check whether the body of the static initializer is empty.
   
If the body of the static initializer is empty, then this test case violates the rule.
['Check whether the class has static initializers.', 'Get the static initializer of the class.', 'Check whether the body of the static initializer is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'ASTInitializer', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Check whether the class has static initializers.* 匹配到的元操作或API：
query: Check whether the class has static initializers.
most similar API: Check whether the initializer is static
cosine Similarity: 0.9332150220870972
*Get the static initializer of the class.* 匹配到的元操作或API：
query: Get the static initializer of the class.
most similar API: get class of initializer
cosine Similarity: 0.8464104533195496
*Check whether the body of the static initializer is empty.* 匹配到的元操作或API：
query: Check whether the body of the static initializer is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.875758945941925
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty initializer failure case (static)
public class Foo {
                static {}
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTInitializer: public boolean isStatic()
2. net.sourceforge.pmd.lang.java.ast.ASTInitializer: public java.lang.Class<Class<?> getClass()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 11" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 11" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 11
[ERROR]   "bad 15" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
82
68
96
80
84
70
96
79
95
78
119
103
=========================error_testcase_logics=========================
1. Get the loop variable of for-each loop.
        2. Get the condition of for-each loop.
        3. Check whether the body of for-each loop is empty.
        If the body of the for-each loop is empty, then this test case violates the rule.
        
In this specific test case, the first for-each loop will be the one that violates the rule because its body is empty.

Let's perform the checks for this test case:

1. Get the loop variable of for-each loop. (The loop variable is `i`)
2. Get the condition of for-each loop. (The condition is `int i : list`)
3. Check whether the body of for-each loop is empty. (The body is empty, so this test case violates the rule.)

The second for-each loop does not violate the rule because its body is not empty.
['Get the loop variable of for-each loop.', 'Get the condition of for-each loop.', 'Check whether the body of for-each loop is empty.', 'Get the loop variable of for-each loop. (The loop variable is `i`)', 'Get the condition of for-each loop. (The condition is `int i : list`)', 'Check whether the body of for-each loop is empty. (The body is empty, so this test case violates the rule.)']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTForeachStatement', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTExpressionStatement', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'ASTTypeArguments', 'TypeConversion', 'TestFrameworksUtil', 'ASTImportDeclaration', 'ASTTypeExpression', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'ASTFieldAccess', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9849275350570679
*Get the condition of for-each loop.* 匹配到的元操作或API：
logic: Get the condition of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.8536348938941956
*Check whether the body of for-each loop is empty.* 匹配到的元操作或API：
query: Check whether the body of for-each loop is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8055720329284668
*Get the loop variable of for-each loop. (The loop variable is `i`)* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop. (The loop variable is `i`)
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.945888340473175
*Get the condition of for-each loop. (The condition is `int i : list`)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of for-each loop is empty. (The body is empty, so this test case violates the rule.)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty foreach
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
            ——ASTTypeArguments
              ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'list')
      ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'i')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'i')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForeachStatement: public net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId getVarId()
2. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "ok 8" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
82
68
96
80
84
70
96
79
95
78
119
103
75
61
=========================error_testcase_logics=========================
To verify the adherence of the provided test case to the rule, we need to granularly check each control statement and its body. Here’s how we can perform these checks:

1. Get the body of the for-each loop.
    - For the first loop (`for (int ignored : list) { }`):
        2. Check whether the body is empty.
            - The body is indeed empty, but the loop contains an empty block `{}`, which is not strictly an empty statement.
    - For the second loop (`for (int ignored2 : list);`):
        2. Check whether the body is empty.
            - The body is empty, as there is no block or statement following the loop.
    - For the third loop (`for (int i : list) { System.out.println(i); }`):
        2. Check whether the body is empty.
            - The body is not empty, as it contains a `System.out.println(i);` statement.

Since the rule specifically mentions empty initializers and empty control statements, the second loop (`for (int ignored2 : list);`) violates the rule. Let’s break down the checks for clarity:

1. Get the body of the first for-each loop.
    - Check whether the body is empty.
        - The body is not empty because it contains an empty block `{}`.

2. Get the body of the second for-each loop.
    - Check whether the body is empty.
        - The body is empty because there is no block or statement following the loop.

3. Get the body of the third for-each loop.
    - Check whether the body is empty.
        - The body is not empty because it contains a `System.out.println(i);` statement.

Based on these checks, the number of violations in the test case is 1, as the second for-each loop has an empty body. Therefore, the provided test case does not fully adhere to the rule as stated.
['Get the body of the for-each loop.', 'Check whether the body is empty.', 'Check whether the body is empty.', 'Check whether the body is empty.', 'Get the body of the first for-each loop.', 'Get the body of the second for-each loop.', 'Get the body of the third for-each loop.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTForeachStatement', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTExpressionStatement', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'ASTTypeArguments', 'TypeConversion', 'TestFrameworksUtil', 'ASTImportDeclaration', 'ASTTypeExpression', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'ASTFieldAccess', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTEmptyStatement', 'ASTVariableDeclarator']
*Get the body of the for-each loop.* 匹配到的元操作或API：
query: Get the body of the for-each loop.
most similar API: get body of foreach statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8478144407272339
*Check whether the body is empty.* 匹配到的元操作或API：
query: Check whether the body is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8587327003479004
*Check whether the body is empty.* 匹配到的元操作或API：
query: Check whether the body is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8587327003479004
*Check whether the body is empty.* 匹配到的元操作或API：
query: Check whether the body is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8587327003479004
*Get the body of the first for-each loop.* 匹配到的元操作或API：
query: Get the body of the first for-each loop.
most similar API: get body of foreach statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8237614035606384
*Get the body of the second for-each loop.* 匹配到的元操作或API：
query: Get the body of the second for-each loop.
most similar API: get body of foreach statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8176917433738708
*Get the body of the third for-each loop.* 匹配到的元操作或API：
query: Get the body of the third for-each loop.
most similar API: get body of foreach statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8050045371055603
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }


This checker is failed(false positive) on this positive test case:
```
// neg, empty foreach with unused var name
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int ignored : list) {
                    }
                    for (int ignored2 : list) ;
                    for (int i : list) { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
            ——ASTTypeArguments
              ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'list')
      ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'ignored')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'ignored2')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTEmptyStatement
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'i')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForeachStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock && ((ASTBlock) body).isEmpty()) {
            addViolation(data, node);
        } else if (body instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 8" resulted in wrong number of failures, ==> expected: <0> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 8" resulted in wrong number of failures, ==> expected: <0> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the loop variable of for-each loop.
        2. Check whether the for-each loop has an empty body.
        3. Check whether the for-each loop has a body that is a single semicolon.
        4. Repeat steps 1-3 for each for-each loop in the method.

For the provided test case:

1. Get the loop variable of for-each loop (ignored).
        2. Check whether the for-each loop has an empty body (it does, as there are no statements within the curly braces).
        3. Check whether the for-each loop has a body that is a single semicolon (it does not, as it is enclosed in curly braces).
        4. Repeat steps 1-3 for the next for-each loop (ignored2).
        5. Get the loop variable of for-each loop (ignored2).
        6. Check whether the for-each loop has an empty body (it does, as it is terminated by a single semicolon).
        7. Check whether the for-each loop has a body that is a single semicolon (it does).
        8. Repeat steps 1-3 for the last for-each loop (i).
        9. Get the loop variable of for-each loop (i).
        10. Check whether the for-each loop has an empty body (it does not, as it contains a statement within the curly braces).

Based on these checks, the first and second for-each loops violate the rule, as they have empty bodies. However, the description specifies that the counterexample should not violate the rule, so the test case provided does not meet the expected criteria of having no violations. If the goal is to verify that the test case does not violate the rule, we should ensure that at least one of the for-each loops has a non-empty body, as shown in the last loop with `System.out.println(i);`. If the goal is to correctly identify violations, then the first and second for-each loops should be reported as violations.
['Get the loop variable of for-each loop.', 'Check whether the for-each loop has an empty body.', 'Check whether the for-each loop has a body that is a single semicolon.', 'Repeat steps 1-3 for each for-each loop in the method.', 'Get the loop variable of for-each loop (ignored).', 'Check whether the for-each loop has an empty body (it does, as there are no statements within the curly braces).', 'Check whether the for-each loop has a body that is a single semicolon (it does not, as it is enclosed in curly braces).', 'Repeat steps 1-3 for the next for-each loop (ignored2).', 'Get the loop variable of for-each loop (ignored2).', 'Check whether the for-each loop has an empty body (it does, as it is terminated by a single semicolon).', 'Check whether the for-each loop has a body that is a single semicolon (it does).', 'Repeat steps 1-3 for the last for-each loop (i).', 'Get the loop variable of for-each loop (i).', 'Check whether the for-each loop has an empty body (it does not, as it contains a statement within the curly braces).']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTForeachStatement', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTExpressionStatement', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'ASTTypeArguments', 'TypeConversion', 'TestFrameworksUtil', 'ASTImportDeclaration', 'ASTTypeExpression', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'ASTFieldAccess', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTEmptyStatement', 'ASTVariableDeclarator']
*Get the loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9849275350570679
*Check whether the for-each loop has an empty body.* 匹配到的元操作或API：
query: Check whether the for-each loop has an empty body.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8124945163726807
*Check whether the for-each loop has a body that is a single semicolon.* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 1-3 for each for-each loop in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop variable of for-each loop (ignored).* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop (ignored).
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9445540904998779
*Check whether the for-each loop has an empty body (it does, as there are no statements within the curly braces).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the for-each loop has a body that is a single semicolon (it does not, as it is enclosed in curly braces).* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 1-3 for the next for-each loop (ignored2).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop variable of for-each loop (ignored2).* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop (ignored2).
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9175460934638977
*Check whether the for-each loop has an empty body (it does, as it is terminated by a single semicolon).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the for-each loop has a body that is a single semicolon (it does).* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 1-3 for the last for-each loop (i).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop variable of for-each loop (i).* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop (i).
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9469204545021057
*Check whether the for-each loop has an empty body (it does not, as it contains a statement within the curly braces).* 匹配到的元操作或API：
query: Check whether the for-each loop has an empty body (it does not, as it contains a statement within the curly braces).
most similar API: Check whether the empty statement equals
cosine Similarity: 0.8164552450180054
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }


This checker is failed(false positive) on this positive test case:
```
// neg, empty foreach with unused var name
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int ignored : list) {
                    }
                    for (int ignored2 : list) ;
                    for (int i : list) { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
            ——ASTTypeArguments
              ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'list')
      ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'ignored')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'ignored2')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTEmptyStatement
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'i')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForeachStatement: public net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId getVarId()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()
3. net.sourceforge.pmd.lang.java.ast.ASTEmptyStatement: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        } else if (node.getChildren().length == 3 && node.getChild(2) instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the loop variable of for-each loop.
        2. Check whether the loop variable is ignored.
        3. Get the body of for-each loop.
        4. Check whether the body of for-each loop is empty.
        5. Get the loop variable of for-each loop.
        6. Check whether the loop variable is ignored2.
        7. Get the body of for-each loop.
        8. Check whether the body of for-each loop is empty.
        9. Get the loop variable of for-each loop.
        10. Check whether the loop variable is i.
        11. Get the body of for-each loop.
        12. Check whether the body of for-each loop is empty.

These steps will allow us to check:
- The first for-each loop has an empty block body and a loop variable named "ignored".
- The second for-each loop has an empty semicolon body and a loop variable named "ignored2".
- The third for-each loop has a non-empty block body and a loop variable named "i".

In this test case, there are two violations of the rule (the first and second for-each loops both have empty bodies). The third for-each loop does not violate the rule as its body is not empty.

Given the provided test case analysis, the number of violations is 2, not 0 as stated. Therefore, the correct number of violations is 2.
['Get the loop variable of for-each loop.', 'Check whether the loop variable is ignored.', 'Get the body of for-each loop.', 'Check whether the body of for-each loop is empty.', 'Get the loop variable of for-each loop.', 'Check whether the loop variable is ignored2.', 'Get the body of for-each loop.', 'Check whether the body of for-each loop is empty.', 'Get the loop variable of for-each loop.', 'Check whether the loop variable is i.', 'Get the body of for-each loop.', 'Check whether the body of for-each loop is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTForeachStatement', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTExpressionStatement', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'ASTTypeArguments', 'TypeConversion', 'TestFrameworksUtil', 'ASTImportDeclaration', 'ASTTypeExpression', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'ASTFieldAccess', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTEmptyStatement', 'ASTVariableDeclarator']
*Get the loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9849275350570679
*Check whether the loop variable is ignored.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of for-each loop.* 匹配到的元操作或API：
logic: Get the body of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.8503332138061523
*Check whether the body of for-each loop is empty.* 匹配到的元操作或API：
query: Check whether the body of for-each loop is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8055720329284668
*Get the loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9849275350570679
*Check whether the loop variable is ignored2.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of for-each loop.* 匹配到的元操作或API：
logic: Get the body of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.8503332138061523
*Check whether the body of for-each loop is empty.* 匹配到的元操作或API：
query: Check whether the body of for-each loop is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8055720329284668
*Get the loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9849275350570679
*Check whether the loop variable is i.* 匹配到的元操作或API：
query: Check whether the loop variable is i.
most similar API: Check whether the variable declarator id is for loop variable
cosine Similarity: 0.8088465929031372
*Get the body of for-each loop.* 匹配到的元操作或API：
logic: Get the body of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.8503332138061523
*Check whether the body of for-each loop is empty.* 匹配到的元操作或API：
query: Check whether the body of for-each loop is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8055720329284668
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }


This checker is failed(false positive) on this positive test case:
```
// neg, empty foreach with unused var name
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int ignored : list) {
                    }
                    for (int ignored2 : list) ;
                    for (int i : list) { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
            ——ASTTypeArguments
              ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'list')
      ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'ignored')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'ignored2')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTEmptyStatement
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'i')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForeachStatement: public net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId getVarId()
2. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()
3. net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId: public boolean isForLoopVariable(), //Returns true if this node is a variable declared in the init clause of a {@linkplain ASTForStatement for loop}.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        ASTEmptyStatement emptyStatement = node.getFirstChildOfType(ASTEmptyStatement.class);
        if (emptyStatement != null) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 8" resulted in wrong number of failures, ==> expected: <0> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 8" resulted in wrong number of failures, ==> expected: <0> but was: <2>不通过
=========================error_testcase_logics=========================
To check the adherence of the test case to the rule, we need to perform granular checks on the loop statements within the `bar` method.

1. Get the loop variable of for-each loop.
2. Check whether the for-each loop body is empty.
3. Get the loop variable of for-each loop.
4. Check whether the for-each loop body is empty.
5. Get the loop variable of for-each loop.
6. Check whether the for-each loop body is empty.

Let's execute these checks on the provided test case:

1. Get the loop variable of for-each loop.
   - The loop variable is `ignored`.
2. Check whether the for-each loop body is empty.
   - The body is `{}`, which is empty. This violates the rule.
3. Get the loop variable of for-each loop.
   - The loop variable is `ignored2`.
4. Check whether the for-each loop body is empty.
   - The body is `;`, which is empty. This violates the rule.
5. Get the loop variable of for-each loop.
   - The loop variable is `i`.
6. Check whether the for-each loop body is empty.
   - The body is `{ System.out.println(i); }`, which is not empty. This does not violate the rule.

Based on these checks, the number of violations in this test case is 2. The first two for-each loops have empty bodies.
['Get the loop variable of for-each loop.', 'Check whether the for-each loop body is empty.', 'Get the loop variable of for-each loop.', 'Check whether the for-each loop body is empty.', 'Get the loop variable of for-each loop.', 'Check whether the for-each loop body is empty.', 'Get the loop variable of for-each loop.', 'Check whether the for-each loop body is empty.', 'Get the loop variable of for-each loop.', 'Check whether the for-each loop body is empty.', 'Get the loop variable of for-each loop.', 'Check whether the for-each loop body is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTForeachStatement', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTExpressionStatement', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'ASTTypeArguments', 'TypeConversion', 'TestFrameworksUtil', 'ASTImportDeclaration', 'ASTTypeExpression', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'ASTFieldAccess', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTEmptyStatement', 'ASTVariableDeclarator']
*Get the loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9849275350570679
*Check whether the for-each loop body is empty.* 匹配到的元操作或API：
query: Check whether the for-each loop body is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8150264024734497
*Get the loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9849275350570679
*Check whether the for-each loop body is empty.* 匹配到的元操作或API：
query: Check whether the for-each loop body is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8150264024734497
*Get the loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9849275350570679
*Check whether the for-each loop body is empty.* 匹配到的元操作或API：
query: Check whether the for-each loop body is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8150264024734497
*Get the loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9849275350570679
*Check whether the for-each loop body is empty.* 匹配到的元操作或API：
query: Check whether the for-each loop body is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8150264024734497
*Get the loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9849275350570679
*Check whether the for-each loop body is empty.* 匹配到的元操作或API：
query: Check whether the for-each loop body is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8150264024734497
*Get the loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9849275350570679
*Check whether the for-each loop body is empty.* 匹配到的元操作或API：
query: Check whether the for-each loop body is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8150264024734497
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }


This checker is failed(false positive) on this positive test case:
```
// neg, empty foreach with unused var name
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int ignored : list) {
                    }
                    for (int ignored2 : list) ;
                    for (int i : list) { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
            ——ASTTypeArguments
              ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'list')
      ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'ignored')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'ignored2')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTEmptyStatement
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'i')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForeachStatement: public net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId getVarId()
2. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        ASTEmptyStatement emptyStatement = node.getFirstChildOfType(ASTEmptyStatement.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        } else if (emptyStatement != null) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 8" resulted in wrong number of failures, ==> expected: <0> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 8" resulted in wrong number of failures, ==> expected: <0> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get a loop variable of for-each loop.
2. Check whether the body of the first for-each loop is empty.
3. Check whether the body of the second for-each loop is empty.
4. Check whether the body of the third for-each loop is empty.

In this test case:
- The first for-each loop has an empty block `{}` as its body.
- The second for-each loop has an empty semicolon `;` immediately following the signature, which also counts as an empty body.
- The third for-each loop has a non-empty body `{ System.out.println(i); }`.

Therefore, there are two violations of the rule in this test case, not zero. The correct checks would identify the first and second for-each loops as having empty bodies, while the third does not.

Let's clarify the granular checks for each loop:
1. Get a loop variable of for-each loop.
2. Check whether the body of the first for-each loop is empty. (This should return true, indicating a violation.)
3. Check whether the body of the second for-each loop is empty. (This should also return true, indicating another violation.)
4. Check whether the body of the third for-each loop is empty. (This should return false, indicating no violation.)
['Get a loop variable of for-each loop.', 'Check whether the body of the first for-each loop is empty.', 'Check whether the body of the second for-each loop is empty.', 'Check whether the body of the third for-each loop is empty.', 'Get a loop variable of for-each loop.', 'Check whether the body of the first for-each loop is empty. (This should return true, indicating a violation.)', 'Check whether the body of the second for-each loop is empty. (This should also return true, indicating another violation.)', 'Check whether the body of the third for-each loop is empty. (This should return false, indicating no violation.)']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTForeachStatement', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTExpressionStatement', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'ASTTypeArguments', 'TypeConversion', 'TestFrameworksUtil', 'ASTImportDeclaration', 'ASTTypeExpression', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'ASTFieldAccess', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTEmptyStatement', 'ASTVariableDeclarator']
*Get a loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get a loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9762571454048157
*Check whether the body of the first for-each loop is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the second for-each loop is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the third for-each loop is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get a loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get a loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9762571454048157
*Check whether the body of the first for-each loop is empty. (This should return true, indicating a violation.)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the second for-each loop is empty. (This should also return true, indicating another violation.)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the third for-each loop is empty. (This should return false, indicating no violation.)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }


This checker is failed(false positive) on this positive test case:
```
// neg, empty foreach with unused var name
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int ignored : list) {
                    }
                    for (int ignored2 : list) ;
                    for (int i : list) { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
            ——ASTTypeArguments
              ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'list')
      ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'ignored')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'ignored2')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTEmptyStatement
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'i')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForeachStatement: public net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId getVarId()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        ASTEmptyStatement emptyStatement = node.getFirstChildOfType(ASTEmptyStatement.class);
        if ((block != null && block.isEmpty()) || emptyStatement != null) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 8" resulted in wrong number of failures, ==> expected: <0> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 8" resulted in wrong number of failures, ==> expected: <0> but was: <2>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 8
[ERROR]   "bad 17" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
79
65
107
91
75
61
=========================error_testcase_logics=========================
1. Get the condition of while statement.
2. Check whether the condition is true.
3. Get the body of while statement.
4. Check whether the body of while statement is empty.
If the condition of the while statement is true and the body of the while statement is empty, then this test case violates the rule.

In this specific test case:
1. The condition of the while statement is `true`.
2. The body of the while statement is `;`, which is empty.
Therefore, the test case violates the rule once.
['Get the condition of while statement.', 'Check whether the condition is true.', 'Get the body of while statement.', 'Check whether the body of while statement is empty.', 'The condition of the while statement is `true`.', 'The body of the while statement is `;`, which is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTWhileStatement', 'ASTBooleanLiteral', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTEmptyStatement']
*Get the condition of while statement.* 匹配到的元操作或API：
logic: Get the condition of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.9850378632545471
*Check whether the condition is true.* 匹配到的元操作或API：
query: Check whether the condition is true.
most similar API: Check whether is conditional
cosine Similarity: 0.8189276456832886
*Get the body of while statement.* 匹配到的元操作或API：
logic: Get the body of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.8570234179496765
*Check whether the body of while statement is empty.* 匹配到的元操作或API：
query: Check whether the body of while statement is empty.
most similar API: get body of while statement
cosine Similarity: 0.8571991324424744
*The condition of the while statement is `true`.* 匹配到的元操作或API：
query: The condition of the while statement is `true`.
most similar API: get condition of while statement
cosine Similarity: 0.8249168395996094
*The body of the while statement is `;`, which is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// while(true);
public class Foo {
                public void bar() {
                    while (true);
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTWhileStatement
          ——ASTBooleanLiteral
          ——ASTEmptyStatement


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isConditional(net.sourceforge.pmd.lang.java.ast.JavaNode)
3. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
4. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition(), //Returns the node that represents the guard of this loop. This may be any expression of type boolean.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "bad 19" resulted in wrong number of failures, ==> expected: <2> but was: <1>不通过
84
69
119
103
100
82
=========================error_testcase_logics=========================
1. Get the control statement of the method.
        2. Check whether the control statement is an if statement.
        3. Get the body of the if statement.
        4. Check whether the body of the if statement is empty.
        5. Check whether the if statement has an else branch.
        6. Get the else branch of the if statement.
        7. Check whether the else branch is empty.
        If the body of the if statement is empty, it violates the rule. If the else branch of the if statement is also empty, it violates the rule. Therefore, the number of violations in this test case is 2.
['Get the control statement of the method.', 'Check whether the control statement is an if statement.', 'Get the body of the if statement.', 'Check whether the body of the if statement is empty.', 'Check whether the if statement has an else branch.', 'Get the else branch of the if statement.', 'Check whether the else branch is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTIfStatement', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTInfixExpression', 'ASTNumericLiteral']
*Get the control statement of the method.* 匹配到的元操作或API：
query: Get the control statement of the method.
most similar API: get text of method
cosine Similarity: 0.8140272498130798
*Check whether the control statement is an if statement.* 匹配到的元操作或API：
query: Check whether the control statement is an if statement.
most similar API: Check whether the if statement equals
cosine Similarity: 0.8228201270103455
*Get the body of the if statement.* 匹配到的元操作或API：
query: Get the body of the if statement.
most similar API: get text of if statement
cosine Similarity: 0.8748297691345215
*Check whether the body of the if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of the if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8603641390800476
*Check whether the if statement has an else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9772751331329346
*Get the else branch of the if statement.* 匹配到的元操作或API：
logic: Get the else branch of the if statement.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.9849298000335693
*Check whether the else branch is empty.* 匹配到的元操作或API：
logic: Check whether the else branch is empty.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.8779308795928955
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty if with else statement
public class Foo {
    void bar(int x) {
        if (x > 2) {
        } else {
        }
    }
}
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.document.Chars getText()
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.document.Chars getText()
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
5. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
6. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.hasElse()) {
            ASTBlock elseBlock = node.getElseBranch().getFirstChildOfType(ASTBlock.class);
            if (elseBlock != null && elseBlock.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 19" resulted in wrong number of failures, ==> expected: <2> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 19" resulted in wrong number of failures, ==> expected: <2> but was: <1>不通过
=========================error_testcase_logics=========================
1. Check whether the if statement has an else branch.
        2. Get the condition of if statement.
        3. Check whether the body of if statement is empty.
        4. Get the else branch of if statement.
        5. Check whether the body of else statement is empty.
        If the body of if statement is empty and the body of else statement is empty, then this test case violates the rule twice. One for the if statement and one for the else statement.
['Check whether the if statement has an else branch.', 'Get the condition of if statement.', 'Check whether the body of if statement is empty.', 'Get the else branch of if statement.', 'Check whether the body of else statement is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTIfStatement', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTInfixExpression', 'ASTNumericLiteral']
*Check whether the if statement has an else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9772751331329346
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797652363777161
*Check whether the body of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8571334481239319
*Get the else branch of if statement.* 匹配到的元操作或API：
logic: Get the else branch of if statement.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.989610493183136
*Check whether the body of else statement is empty.* 匹配到的元操作或API：
query: Check whether the body of else statement is empty.
most similar API: Check whether the if statement has else
cosine Similarity: 0.8486195802688599
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) { // Switch block is the only child
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty if with else statement
public class Foo {
    void bar(int x) {
        if (x > 2) {
        } else {
        }
    }
}
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
4. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch()
5. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse(), //Returns true if this statement has an {@code else} clause.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) {
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.hasElse()) {
            ASTStatement elseBranch = node.getElseBranch();
            if (elseBranch instanceof ASTBlock && ((ASTBlock) elseBranch).isEmpty()) {
                addViolation(data, elseBranch);
            } else if (elseBranch instanceof ASTEmptyStatement) {
                addViolation(data, elseBranch);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "bad 21" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
84
69
119
103
75
61
100
82
=========================error_testcase_logics=========================
1. Get the condition of if statement.
2. Check whether the if statement has an else branch.
3. Get the body of if statement.
4. Check whether the body of if statement is empty.
5. Get the body of else branch if it exists.
6. Check whether the body of else branch is empty.

In this test case:
1. The condition of the if statement is `x > 2`.
2. The if statement does not have an else branch.
3. The body of the if statement is `;`, which is empty.

Thus, the test case violates the rule by having an empty body in the if statement. The number of violations in this test case is: 1.
['Get the condition of if statement.', 'Check whether the if statement has an else branch.', 'Get the body of if statement.', 'Check whether the body of if statement is empty.', 'Get the body of else branch if it exists.', 'Check whether the body of else branch is empty.', 'The condition of the if statement is `x > 2`.', 'The if statement does not have an else branch.', 'The body of the if statement is `;`, which is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTIfStatement', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTEmptyStatement', 'ASTInfixExpression', 'ASTNumericLiteral']
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797652363777161
*Check whether the if statement has an else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9772751331329346
*Get the body of if statement.* 匹配到的元操作或API：
query: Get the body of if statement.
most similar API: get text of if statement
cosine Similarity: 0.8786210417747498
*Check whether the body of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8571334481239319
*Get the body of else branch if it exists.* 匹配到的元操作或API：
query: Get the body of else branch if it exists.
most similar API: get else branch of if statement
cosine Similarity: 0.8343334794044495
*Check whether the body of else branch is empty.* 匹配到的元操作或API：
logic: Check whether the body of else branch is empty.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.8562631607055664
*The condition of the if statement is `x > 2`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The if statement does not have an else branch.* 匹配到的元操作或API：
query: The if statement does not have an else branch.
most similar API: get else branch of if statement
cosine Similarity: 0.8089737892150879
*The body of the if statement is `;`, which is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) {
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.hasElse()) {
            ASTStatement elseBranch = node.getElseBranch();
            if (elseBranch instanceof ASTBlock && ((ASTBlock) elseBranch).isEmpty()) {
                addViolation(data, elseBranch);
            } else if (elseBranch instanceof ASTEmptyStatement) {
                addViolation(data, elseBranch);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }
This checker has passed this negative testcase:
public class Foo {
    void bar(int x) {
        if (x > 2) {
        } else {
        }
    }
}


This checker is failed(false negative) on this negative test case:
```
// empty if statement
public class Foo {
    void bar(int x) {
        if (x > 2);
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTEmptyStatement


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
3. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.document.Chars getText()
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
5. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch(), //Returns the statement of the {@code else} clause, if any.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) {
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getNumChildren() == 1 && node.getChild(0) instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        if (node.hasElse()) {
            ASTStatement elseBranch = node.getElseBranch();
            if (elseBranch instanceof ASTBlock && ((ASTBlock) elseBranch).isEmpty()) {
                addViolation(data, elseBranch);
            } else if (elseBranch instanceof ASTEmptyStatement) {
                addViolation(data, elseBranch);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 21" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 21" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the control statement.
2. Check whether the control statement is an if statement.
3. Get the body of the if statement.
4. Check whether the body of the if statement is empty.

If the control statement is an if statement with an empty body, then this test case violates the rule. In this case, the test case has one violation.
['Get the control statement.', 'Check whether the control statement is an if statement.', 'Get the body of the if statement.', 'Check whether the body of the if statement is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTIfStatement', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTEmptyStatement', 'ASTInfixExpression', 'ASTNumericLiteral']
*Get the control statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is an if statement.* 匹配到的元操作或API：
query: Check whether the control statement is an if statement.
most similar API: Check whether the if statement equals
cosine Similarity: 0.8228201270103455
*Get the body of the if statement.* 匹配到的元操作或API：
query: Get the body of the if statement.
most similar API: get text of if statement
cosine Similarity: 0.8748297691345215
*Check whether the body of the if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of the if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8603641390800476
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) {
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.hasElse()) {
            ASTStatement elseBranch = node.getElseBranch();
            if (elseBranch instanceof ASTBlock && ((ASTBlock) elseBranch).isEmpty()) {
                addViolation(data, elseBranch);
            } else if (elseBranch instanceof ASTEmptyStatement) {
                addViolation(data, elseBranch);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }
This checker has passed this negative testcase:
public class Foo {
    void bar(int x) {
        if (x > 2) {
        } else {
        }
    }
}


This checker is failed(false negative) on this negative test case:
```
// empty if statement
public class Foo {
    void bar(int x) {
        if (x > 2);
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTEmptyStatement


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean equals(java.lang.Object)
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.document.Chars getText()
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) {
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        if (node.hasElse()) {
            ASTStatement elseBranch = node.getElseBranch();
            if (elseBranch instanceof ASTBlock && ((ASTBlock) elseBranch).isEmpty()) {
                addViolation(data, elseBranch);
            } else if (elseBranch instanceof ASTEmptyStatement) {
                addViolation(data, elseBranch);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the condition of if statement.
        2. Check whether the if statement has else branch.
        3. Get the body of if statement.
        4. Check whether the body of if statement is empty.
        5. Check whether the if statement is used as a single-line statement without braces.
        If the if statement is used as a single-line statement without braces and the body of the if statement is effectively empty, then this test case violates the rule.

In this specific test case:
1. Get the condition of if statement. (The condition is `x > 2`)
2. Check whether the if statement has else branch. (There is no else branch)
3. Get the body of if statement. (The body is represented by the semicolon `;`)
4. Check whether the body of if statement is empty. (The body is empty as it's just a semicolon)
5. Check whether the if statement is used as a single-line statement without braces. (Yes, it is used as a single-line statement without braces)

Since the if statement is used without braces and its body is empty (represented by the semicolon), the test case violates the rule.
['Get the condition of if statement.', 'Check whether the if statement has else branch.', 'Get the body of if statement.', 'Check whether the body of if statement is empty.', 'Check whether the if statement is used as a single-line statement without braces.', 'Get the condition of if statement. (The condition is `x > 2`)', 'Check whether the if statement has else branch. (There is no else branch)', 'Get the body of if statement. (The body is represented by the semicolon `;`)', "Check whether the body of if statement is empty. (The body is empty as it's just a semicolon)", 'Check whether the if statement is used as a single-line statement without braces. (Yes, it is used as a single-line statement without braces)']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTIfStatement', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTEmptyStatement', 'ASTInfixExpression', 'ASTNumericLiteral']
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797652363777161
*Check whether the if statement has else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9873021841049194
*Get the body of if statement.* 匹配到的元操作或API：
query: Get the body of if statement.
most similar API: get text of if statement
cosine Similarity: 0.8786210417747498
*Check whether the body of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8571334481239319
*Check whether the if statement is used as a single-line statement without braces.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the condition of if statement. (The condition is `x > 2`)* 匹配到的元操作或API：
logic: Get the condition of if statement. (The condition is `x > 2`)
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.8776893019676208
*Check whether the if statement has else branch. (There is no else branch)* 匹配到的元操作或API：
logic: Check whether the if statement has else branch. (There is no else branch)
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9728074669837952
*Get the body of if statement. (The body is represented by the semicolon `;`)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of if statement is empty. (The body is empty as it's just a semicolon)* 匹配到的元操作或API：
query: Check whether the body of if statement is empty. (The body is empty as it's just a semicolon)
most similar API: Check whether the empty statement equals
cosine Similarity: 0.8297614455223083
*Check whether the if statement is used as a single-line statement without braces. (Yes, it is used as a single-line statement without braces)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) {
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.hasElse()) {
            ASTStatement elseBranch = node.getElseBranch();
            if (elseBranch instanceof ASTBlock && ((ASTBlock) elseBranch).isEmpty()) {
                addViolation(data, elseBranch);
            } else if (elseBranch instanceof ASTEmptyStatement) {
                addViolation(data, elseBranch);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }
This checker has passed this negative testcase:
public class Foo {
    void bar(int x) {
        if (x > 2) {
        } else {
        }
    }
}


This checker is failed(false negative) on this negative test case:
```
// empty if statement
public class Foo {
    void bar(int x) {
        if (x > 2);
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTEmptyStatement


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
3. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.document.Chars getText()
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
5. net.sourceforge.pmd.lang.java.ast.ASTEmptyStatement: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) {
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        } else if (node.getFirstChild() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        if (node.hasElse()) {
            ASTStatement elseBranch = node.getElseBranch();
            if (elseBranch instanceof ASTBlock && ((ASTBlock) elseBranch).isEmpty()) {
                addViolation(data, elseBranch);
            } else if (elseBranch instanceof ASTEmptyStatement) {
                addViolation(data, elseBranch);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        } else if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        } else if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        } else if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        } else if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 21" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 21" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the body of the if statement.
        2. Check whether the body of the if statement is empty.
        If the body of the if statement is empty, then this test case adheres to the rule.

Based on the provided test case, the checks show that the body of the if statement is indeed empty, which means it does violate the rule as reported.

So, the number of constructs violating the rule in this test case is: 1

To ensure completeness, let's break it down:
1. Get the body of the if statement.
        2. Check whether the body of the if statement is empty.
        This check confirms that the body is empty (the semicolon after the condition indicates an empty statement, which is the body of the if statement).

The test case contains one empty body construct, specifically the body of the if statement.
['Get the body of the if statement.', 'Check whether the body of the if statement is empty.', 'Get the body of the if statement.', 'Check whether the body of the if statement is empty.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTIfStatement', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTEmptyStatement', 'ASTInfixExpression', 'ASTNumericLiteral']
*Get the body of the if statement.* 匹配到的元操作或API：
query: Get the body of the if statement.
most similar API: get text of if statement
cosine Similarity: 0.8748297691345215
*Check whether the body of the if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of the if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8603641390800476
*Get the body of the if statement.* 匹配到的元操作或API：
query: Get the body of the if statement.
most similar API: get text of if statement
cosine Similarity: 0.8748297691345215
*Check whether the body of the if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of the if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8603641390800476
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) {
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.hasElse()) {
            ASTStatement elseBranch = node.getElseBranch();
            if (elseBranch instanceof ASTBlock && ((ASTBlock) elseBranch).isEmpty()) {
                addViolation(data, elseBranch);
            } else if (elseBranch instanceof ASTEmptyStatement) {
                addViolation(data, elseBranch);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }
This checker has passed this negative testcase:
public class Foo {
    void bar(int x) {
        if (x > 2) {
        } else {
        }
    }
}


This checker is failed(false negative) on this negative test case:
```
// empty if statement
public class Foo {
    void bar(int x) {
        if (x > 2);
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTEmptyStatement


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.document.Chars getText()
2. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getNumChildren() == 1) {
            ASTBlock block = (ASTBlock) node.getChild(0);
            if (block.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.hasElse()) {
            ASTStatement elseBranch = node.getElseBranch();
            if (elseBranch instanceof ASTBlock && ((ASTBlock) elseBranch).isEmpty()) {
                addViolation(data, elseBranch);
            } else if (elseBranch instanceof ASTEmptyStatement) {
                addViolation(data, elseBranch);
            }
        }
        if (node.getThenBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if ((node.getParent() instanceof ASTInitializer) || 
            ((node.getParent() instanceof ASTBlock) && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) ||
            (node.getParent() instanceof ASTBlock && node.isEmpty())) {
            if (node.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
测试用例全部通过
最终通过 24 个测试用例
正例 8 个
反例 16 个
输入token：963012
输出token：649025
结束

规则执行完毕，时间总花销： 5667.817242860794 秒
