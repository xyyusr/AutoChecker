开始

========================================== Rule ClassWithOnlyPrivateConstructorsShouldBeFinalRule ===========================================
一共 22 个测试用例
正例 15 个
反例 7 个
1117
839
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
        2. Check whether the class is public.
        3. Get all constructors declared in class.
        4. Check whether each constructor is private.
        5. Check whether the class has any declared annotations.
        6. Get the super class of class.
        7. Check whether the super class is different from Object.
        8. Get all methods declared in class.
        9. Check whether any method is protected or public.
        10. Get all fields declared in class.
        11. Check whether any field is protected or public.

If the class is public, all its constructors are private, it does not have any declared annotations that might affect its extensibility, its super class is not different from Object, and it does not have any protected or public methods or fields that might suggest it is intended to be extended, then this test case violates the rule. In this specific test case:

1. Get the name of class. (Foo)
2. Check whether the class is public. (True)
3. Get all constructors declared in class. (private Foo() { })
4. Check whether each constructor is private. (True)
5. Check whether the class has any declared annotations. (False)
6. Get the super class of class. (Object)
7. Check whether the super class is different from Object. (False)
8. Get all methods declared in class. (None)
9. Check whether any method is protected or public. (False)
10. Get all fields declared in class. (int a, int b)
11. Check whether any field is protected or public. (False - both are default package-private)

Given these checks, the test case violates the rule because the class is public, all its constructors are private, and it does not have any protected or public methods or fields that suggest it is intended to be extended.
['Get the name of class.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether each constructor is private.', 'Check whether the class has any declared annotations.', 'Get the super class of class.', 'Check whether the super class is different from Object.', 'Get all methods declared in class.', 'Check whether any method is protected or public.', 'Get all fields declared in class.', 'Check whether any field is protected or public.', 'Get the name of class. (Foo)', 'Check whether the class is public. (True)', 'Get all constructors declared in class. (private Foo() { })', 'Check whether each constructor is private. (True)', 'Check whether the class has any declared annotations. (False)', 'Get the super class of class. (Object)', 'Check whether the super class is different from Object. (False)', 'Get all methods declared in class. (None)', 'Check whether any method is protected or public. (False)', 'Get all fields declared in class. (int a, int b)', 'Check whether any field is protected or public. (False - both are default package-private)']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether each constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442477226257324
*Check whether the class has any declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has any declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9707680940628052
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851945042610168
*Check whether the super class is different from Object.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8142817616462708
*Check whether any method is protected or public.* 匹配到的元操作或API：
logic: Check whether any method is protected or public.
most similar meta operation: Check whether the method is protected
cosine Similarity: 0.9235407114028931
*Get all fields declared in class.* 匹配到的元操作或API：
query: Get all fields declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8290460109710693
*Check whether any field is protected or public.* 匹配到的元操作或API：
logic: Check whether any field is protected or public.
most similar meta operation: Check whether the field is protected
cosine Similarity: 0.9120529890060425
*Get the name of class. (Foo)* 匹配到的元操作或API：
logic: Get the name of class. (Foo)
most similar meta operation: Get the name of class
cosine Similarity: 0.9297348856925964
*Check whether the class is public. (True)* 匹配到的元操作或API：
logic: Check whether the class is public. (True)
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9759844541549683
*Get all constructors declared in class. (private Foo() { })* 匹配到的元操作或API：
query: Get all constructors declared in class. (private Foo() { })
most similar API: get declared annotations of constructor
cosine Similarity: 0.8383116126060486
*Check whether each constructor is private. (True)* 匹配到的元操作或API：
logic: Check whether each constructor is private. (True)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9401436448097229
*Check whether the class has any declared annotations. (False)* 匹配到的元操作或API：
logic: Check whether the class has any declared annotations. (False)
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.954084038734436
*Get the super class of class. (Object)* 匹配到的元操作或API：
logic: Get the super class of class. (Object)
most similar meta operation: Get the super class of class
cosine Similarity: 0.9456301331520081
*Check whether the super class is different from Object. (False)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all methods declared in class. (None)* 匹配到的元操作或API：
query: Get all methods declared in class. (None)
most similar API: get declarations of class or interface
cosine Similarity: 0.8099513053894043
*Check whether any method is protected or public. (False)* 匹配到的元操作或API：
logic: Check whether any method is protected or public. (False)
most similar meta operation: Check whether the method is protected
cosine Similarity: 0.9136235117912292
*Get all fields declared in class. (int a, int b)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any field is protected or public. (False - both are default package-private)* 匹配到的元操作或API：
logic: Check whether any field is protected or public. (False - both are default package-private)
most similar meta operation: Check whether the field is default package-private
cosine Similarity: 0.8915926814079285
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Simple violation
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isProtected()
8. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isProtected()
9. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isPackagePrivate()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    // Check whether class has declared annotations
    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isPublic() && !hasAnnotations(node)) {
            NodeStream<ASTConstructorDeclaration> constructors = node.getDeclarations(ASTConstructorDeclaration.class);
            if (constructors.allMatch(ASTConstructorDeclaration::isPrivate) && !constructors.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
        2. Check whether the class is public.
        3. Get all constructors declared in class.
        4. Check whether the constructor is private.
        5. Count the number of public or protected constructors.

To ascertain adherence to the rule:

1. Get the name of class.
        2. Check whether the class is public.
        3. Get all constructors declared in class.
        4. Check whether the constructor is private.
        5. Count the number of public or protected constructors.
        6. Check whether the number of public or protected constructors is 0.

If the class is public and all its constructors are private, then it may be made final because it cannot be extended from outside its compilation unit. In the provided test case, the class `Foo` is public and has one constructor, which is private. Therefore, this test case violates the rule.

The description of this test case is: bad 1
The number of violating the rule in this test case is: 1
['Get the name of class.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Count the number of public or protected constructors.', 'Get the name of class.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Count the number of public or protected constructors.', 'Check whether the number of public or protected constructors is 0.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Count the number of public or protected constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Count the number of public or protected constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the number of public or protected constructors is 0.* 匹配到的元操作或API：
query: Check whether the number of public or protected constructors is 0.
most similar API: Check whether the constructor is protected
cosine Similarity: 0.8242388367652893
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Simple violation
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isProtected()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isPublic() && !node.isInterface()) {
            NodeStream<ASTConstructorDeclaration> constructors = node.children(ASTConstructorDeclaration.class);
            if (!constructors.isEmpty() && constructors.allMatch(ASTConstructorDeclaration::isPrivate)) {
                if (!node.isFinal()) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Check whether the class is public.
2. Get the constructors of class.
3. Check whether the constructor is private.
4. Check whether the class has any public or protected constructors.
5. Check whether the class has any non-private constructors.
6. Check whether the class has any declared subclasses.

If the class is public, it has only private constructors, and there are no declared subclasses, then this test case may violate the rule.

Based on the provided test case:
- 1. Check whether the class is public. (True, Foo is public)
- 2. Get the constructors of class. (Foo has one constructor)
- 3. Check whether the constructor is private. (True, the constructor is private)
- 4. Check whether the class has any public or protected constructors. (False, no public or protected constructors)
- 5. Check whether the class has any non-private constructors. (False, the constructor is private)
- 6. Check whether the class has any declared subclasses. (False, no subclasses are declared)

Since the class is public, has only private constructors, and there are no declared subclasses, it may violate the rule. Thus, the number of violations in this test case is 1.
['Check whether the class is public.', 'Get the constructors of class.', 'Check whether the constructor is private.', 'Check whether the class has any public or protected constructors.', 'Check whether the class has any non-private constructors.', 'Check whether the class has any declared subclasses.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Get the constructors of class.* 匹配到的元操作或API：
query: Get the constructors of class.
most similar API: get class of constructor
cosine Similarity: 0.8381322622299194
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class has any public or protected constructors.* 匹配到的元操作或API：
logic: Check whether the class has any public or protected constructors.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.8995598554611206
*Check whether the class has any non-private constructors.* 匹配到的元操作或API：
logic: Check whether the class has any non-private constructors.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.884695291519165
*Check whether the class has any declared subclasses.* 匹配到的元操作或API：
query: Check whether the class has any declared subclasses.
most similar API: Check whether is declared in class
cosine Similarity: 0.8270808458328247
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Simple violation
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isProtected()
5. net.sourceforge.pmd.lang.java.types.TypeTestUtil: static public boolean isDeclaredInClass(java.lang.Class, net.sourceforge.pmd.lang.java.types.JMethodSig), //Returns true if the signature is that of a method declared in the given class. @param klass Class @param sig   Method signature to test @throws NullPointerException If any argument is null



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


出现语法错误，这一轮舍弃，直接重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class is public.
3. Get all constructors declared in class.
4. Check whether the constructor is private.

For the provided test case:
1. Get the name of class. (The name is `Foo`)
2. Check whether the class is public. (Yes, it is public)
3. Get all constructors declared in class. (There is one constructor)
4. Check whether the constructor is private. (Yes, the constructor is private)

Since the class is public and all its constructors are private, it violates the rule. Therefore, the description of this test case is: bad 1, and the number of violating the rule in this test case is: 1.
['Get the name of class.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get the name of class. (The name is `Foo`)', 'Check whether the class is public. (Yes, it is public)', 'Get all constructors declared in class. (There is one constructor)', 'Check whether the constructor is private. (Yes, the constructor is private)']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Get the name of class. (The name is `Foo`)* 匹配到的元操作或API：
logic: Get the name of class. (The name is `Foo`)
most similar meta operation: Get the name of class
cosine Similarity: 0.9064808487892151
*Check whether the class is public. (Yes, it is public)* 匹配到的元操作或API：
logic: Check whether the class is public. (Yes, it is public)
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9705967903137207
*Get all constructors declared in class. (There is one constructor)* 匹配到的元操作或API：
query: Get all constructors declared in class. (There is one constructor)
most similar API: get declared annotations of constructor
cosine Similarity: 0.8316332697868347
*Check whether the constructor is private. (Yes, the constructor is private)* 匹配到的元操作或API：
logic: Check whether the constructor is private. (Yes, the constructor is private)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9774948358535767
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Simple violation
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {

    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if the class is public and all constructors are private
        if (node.isPublic() && node.getConstructors().allMatch(ASTConstructorDeclaration::isPrivate)) {
            // Ensure there are no protected constructors
            if (node.getConstructors().noneMatch(ASTConstructorDeclaration::isProtected)) {
                // Check if the class is not already final
                if (!node.isFinal()) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Check whether the class has declared annotations.
2. Get a declared annotation of class.
3. Check whether the class has x annotation.
4. Get the name of class.
5. Check whether the class is abstract.
6. Check whether the class is public.
7. Check whether the class is private.
8. Check whether the class is protected.
9. Check whether the class is default package-private.
10. Check whether the class is final.
11. Check whether the class is static.
12. Check whether the class is inner class.
13. Check whether the class is anonymous class.
14. Get all constructors declared in class.
15. Get the signature of constructor.
16. Get the javadoc comment of constructor.
17. Check whether the constructor is private.
18. Check whether the constructor is public.
19. Check whether the constructor is default package-private.
20. Check whether the constructor is protected.
21. Get a formal parameter of constructor.
22. Get the number of formal parameters of constructor.
23. Get a throw exception in constructor signature.
24. Check whether the constructor signature throws x Exception.
25. Check whether constructor has declared annotations.
26. Get a declared annotation of constructor.
27. Check whether the constructor has x annotation.

Given the test case:
```java
public class Foo {
    private Foo() { }
}
```

The granular checks would proceed as follows:

1. Check whether the class has declared annotations.
        - Result: No declared annotations.

2. Check whether the class is abstract.
        - Result: Not abstract.

3. Check whether the class is public.
        - Result: Yes, the class is public.

4. Check whether the class is private.
        - Result: No, the class is not private.

5. Check whether the class is protected.
        - Result: No, the class is not protected.

6. Check whether the class is default package-private.
        - Result: No, the class is not default package-private.

7. Check whether the class is final.
        - Result: No, the class is not final.

8. Check whether the class is static.
        - Result: No, the class is not static.

9. Check whether the class is inner class.
        - Result: No, the class is not an inner class.

10. Check whether the class is anonymous class.
        - Result: No, the class is not an anonymous class.

11. Get all constructors declared in class.
        - Result: One constructor, `private Foo() { }`.

12. Get the signature of constructor.
        - Result: `private Foo()`.

13. Check whether the constructor is private.
        - Result: Yes, the constructor is private.

Since the class `Foo` is public and all its constructors are private, the class cannot be extended from outside its compilation unit. However, the rule specifically mentions that the class should also contain at least one abstract method to report it as a violation. Given the test case, there are no abstract methods, so it does not strictly violate the rule as described.

To clarify, the number of violating the rule in this test case is: 0

If the rule is simplified to only check for the presence of private constructors in a public class, then the number of violating the rule in this test case is: 1

Given the original rule description, the test case does not fully meet the criteria to be reported as a violation.
['Check whether the class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the class has x annotation.', 'Get the name of class.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Check whether the class is inner class.', 'Check whether the class is anonymous class.', 'Get all constructors declared in class.', 'Get the signature of constructor.', 'Get the javadoc comment of constructor.', 'Check whether the constructor is private.', 'Check whether the constructor is public.', 'Check whether the constructor is default package-private.', 'Check whether the constructor is protected.', 'Get a formal parameter of constructor.', 'Get the number of formal parameters of constructor.', 'Get a throw exception in constructor signature.', 'Check whether the constructor signature throws x Exception.', 'Check whether constructor has declared annotations.', 'Get a declared annotation of constructor.', 'Check whether the constructor has x annotation.', 'Check whether the class has declared annotations.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Check whether the class is inner class.', 'Check whether the class is anonymous class.', 'Get all constructors declared in class.', 'Get the signature of constructor.', 'Check whether the constructor is private.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9878389835357666
*Check whether the class has x annotation.* 匹配到的元操作或API：
logic: Check whether the class has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9908235669136047
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853934049606323
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844119548797607
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887725114822388
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520915031433
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9875447154045105
*Check whether the class is anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9849607944488525
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828829765319824
*Get the javadoc comment of constructor.* 匹配到的元操作或API：
logic: Get the javadoc comment of constructor.
most similar meta operation: Get the javadoc comment of constructor
cosine Similarity: 0.990827739238739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Check whether the constructor is default package-private.* 匹配到的元操作或API：
logic: Check whether the constructor is default package-private.
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.961661159992218
*Check whether the constructor is protected.* 匹配到的元操作或API：
logic: Check whether the constructor is protected.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9850410223007202
*Get a formal parameter of constructor.* 匹配到的元操作或API：
logic: Get a formal parameter of constructor.
most similar meta operation: Get a formal parameter of constructor
cosine Similarity: 0.9820768237113953
*Get the number of formal parameters of constructor.* 匹配到的元操作或API：
logic: Get the number of formal parameters of constructor.
most similar meta operation: Get the number of formal parameters of constructor
cosine Similarity: 0.9865635633468628
*Get a throw exception in constructor signature.* 匹配到的元操作或API：
logic: Get a throw exception in constructor signature.
most similar meta operation: Get a throw exception in constructor signature
cosine Similarity: 0.9784085154533386
*Check whether the constructor signature throws x Exception.* 匹配到的元操作或API：
logic: Check whether the constructor signature throws x Exception.
most similar meta operation: Check whether the constructor signature throws x Exception
cosine Similarity: 0.992306113243103
*Check whether constructor has declared annotations.* 匹配到的元操作或API：
logic: Check whether constructor has declared annotations.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.9901278018951416
*Get a declared annotation of constructor.* 匹配到的元操作或API：
logic: Get a declared annotation of constructor.
most similar meta operation: Get a declared annotation of constructor
cosine Similarity: 0.9872555732727051
*Check whether the constructor has x annotation.* 匹配到的元操作或API：
logic: Check whether the constructor has x annotation.
most similar meta operation: Check whether the constructor has x annotation
cosine Similarity: 0.9916678667068481
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853934049606323
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844119548797607
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887725114822388
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520915031433
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9875447154045105
*Check whether the class is anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9849607944488525
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828829765319824
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Simple violation
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isProtected()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
11. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
12. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnonymous()
13. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
14. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
15. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
16. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
17. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()
18. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPackagePrivate()
19. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isProtected()
20. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTFormalParameters getFormalParameters()
21. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTThrowsList getThrowsList()
22. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Get the number of formal parameters of constructor
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTConstructorDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```
3.  //Check whether the constructor signature throws x Exception
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean throwsSpecificException(ASTConstructorDeclaration node){
    ASTThrowsList list = node.getThrowsList();
    if(list == null){
        return false;
    }else{
        for(ASTClassOrInterfaceType classOrInterfaceType : list){
            if(TypeTestUtil.isA(x.class, classOrInterfaceType)){
                return true;
            }
        }
    }
    return false;
}
```
4.  //Check whether constructor has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTConstructorDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {

    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isFinal() && node.isPublic() && !hasAnnotations(node)) {
            boolean allConstructorsPrivate = node.descendants(ASTConstructorDeclaration.class)
                .allMatch(ASTConstructorDeclaration::isPrivate);

            if (allConstructorsPrivate) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Check whether class has declared annotations
    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }

    // Get the number of formal parameters of constructor
    public int getFormalParametersNumber(ASTConstructorDeclaration node) {
        ASTFormalParameters formalParameters = node.getFormalParameters();
        return formalParameters.size();
    }

    // Check whether the constructor signature throws x Exception
    public boolean throwsSpecificException(ASTConstructorDeclaration node) {
        ASTThrowsList list = node.getThrowsList();
        if (list == null) {
            return false;
        } else {
            for (ASTClassOrInterfaceType classOrInterfaceType : list) {
                if (TypeTestUtil.isA(x.class, classOrInterfaceType)) {
                    return true;
                }
            }
        }
        return false;
    }

    // Check whether constructor has declared annotations
    public boolean hasAnnotation(ASTConstructorDeclaration node) {
        NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
        return declaredAnnotations.nonEmpty();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 1
1117
839
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
To perform the granular checks on the provided test case, we need to determine if the class `Foo` can be made final due to its private constructor, and whether it is abstract. Let's break down the checks:

1. Get the name of class.
2. Check whether class is abstract.
3. Check whether class is public.
4. Get all constructors declared in class.
5. Get the signature of constructor.
6. Check whether the constructor is private.
7. Check whether the class has declared annotations.
8. Get the number of constructors declared in class.
9. Check whether the number of constructors declared is 1.

Now, let's apply these checks to the provided test case:

1. Get the name of class.
   - Class name: Foo

2. Check whether class is abstract.
   - Class is not abstract.

3. Check whether class is public.
   - Class is public.

4. Get all constructors declared in class.
   - Constructors: Foo()

5. Get the signature of constructor.
   - Constructor signature: Foo()

6. Check whether the constructor is private.
   - Constructor is private.

7. Check whether the class has declared annotations.
   - Class does not have declared annotations.

8. Get the number of constructors declared in class.
   - Number of constructors: 1

9. Check whether the number of constructors declared is 1.
   - Number of constructors is 1.

Based on these checks, the test case does not violate the rule as described. The rule specifically reports classes that can be made final because all their constructors are private. However, the class `Foo` in the test case is not abstract, but it also does not have any abstract methods. The rule does not specify that the class must be abstract to be reported, so the violation might be misinterpreted.

If the rule is intended to report any class with a private constructor that could not be extended from outside its compilation unit, then `Foo` should indeed be reported as a violation. Here's the corrected interpretation:

1. Get the name of class.
   - Class name: Foo

2. Check whether class is abstract.
   - Class is not abstract.

3. Check whether class is public.
   - Class is public.

4. Get all constructors declared in class.
   - Constructors: Foo()

5. Get the signature of constructor.
   - Constructor signature: Foo()

6. Check whether the constructor is private.
   - Constructor is private.

7. Check whether the class has declared annotations.
   - Class does not have declared annotations.

8. Get the number of constructors declared in class.
   - Number of constructors: 1

9. Check whether the number of constructors declared is 1.
   - Number of constructors is 1.

10. Check whether the class has extended classes.
    - Since the constructor is private, the class cannot be extended from outside its compilation unit.

11. Check whether the class has abstract methods.
    - The class does not have abstract methods.

Since the class `Foo` is public, has a private constructor, and does not have any abstract methods, it should be reported as a potential violation of the rule. The description "bad 2" might be a misinterpretation, as it should be reported as a potential violation for being a public class with a private constructor that cannot be extended from outside its compilation unit.

The number of violations in this test case is: 1

However, the rule description seems to exclude abstract classes from the report, so if the class `Foo` were abstract, it would not be reported as a violation. In this specific case, since `Foo` is not abstract, it should be reported.
['Get the name of class.', 'Check whether class is abstract.', 'Check whether class is public.', 'Get all constructors declared in class.', 'Get the signature of constructor.', 'Check whether the constructor is private.', 'Check whether the class has declared annotations.', 'Get the number of constructors declared in class.', 'Check whether the number of constructors declared is 1.', 'Get the name of class.', 'Check whether class is abstract.', 'Check whether class is public.', 'Get all constructors declared in class.', 'Get the signature of constructor.', 'Check whether the constructor is private.', 'Check whether the class has declared annotations.', 'Get the number of constructors declared in class.', 'Check whether the number of constructors declared is 1.', 'Get the name of class.', 'Check whether class is abstract.', 'Check whether class is public.', 'Get all constructors declared in class.', 'Get the signature of constructor.', 'Check whether the constructor is private.', 'Check whether the class has declared annotations.', 'Get the number of constructors declared in class.', 'Check whether the number of constructors declared is 1.', 'Check whether the class has extended classes.', 'Check whether the class has abstract methods.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether class is abstract.* 匹配到的元操作或API：
logic: Check whether class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9810293316841125
*Check whether class is public.* 匹配到的元操作或API：
logic: Check whether class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9831418991088867
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828829765319824
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get the number of constructors declared in class.* 匹配到的元操作或API：
query: Get the number of constructors declared in class.
most similar API: get num children of constructor
cosine Similarity: 0.8205668330192566
*Check whether the number of constructors declared is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether class is abstract.* 匹配到的元操作或API：
logic: Check whether class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9810293316841125
*Check whether class is public.* 匹配到的元操作或API：
logic: Check whether class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9831418991088867
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828829765319824
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get the number of constructors declared in class.* 匹配到的元操作或API：
query: Get the number of constructors declared in class.
most similar API: get num children of constructor
cosine Similarity: 0.8205668330192566
*Check whether the number of constructors declared is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether class is abstract.* 匹配到的元操作或API：
logic: Check whether class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9810293316841125
*Check whether class is public.* 匹配到的元操作或API：
logic: Check whether class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9831418991088867
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828829765319824
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get the number of constructors declared in class.* 匹配到的元操作或API：
query: Get the number of constructors declared in class.
most similar API: get num children of constructor
cosine Similarity: 0.8205668330192566
*Check whether the number of constructors declared is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has extended classes.* 匹配到的元操作或API：
logic: Check whether the class has extended classes.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9224615097045898
*Check whether the class has abstract methods.* 匹配到的元操作或API：
logic: Check whether the class has abstract methods.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9266514778137207
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// violation for abstract class
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public int getNumChildren()
8. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {

    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isAbstract() && node.isPublic() && node.children(ASTConstructorDeclaration.class).allMatch(ASTConstructorDeclaration::isPrivate)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    // Check whether class has declared annotations
    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }

    // Check whether the class has extended a specific class
    public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node, Class<?> specificClass) {
        ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
        return TypeTestUtil.isA(specificClass, classOrInterfaceType);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Check whether the class is abstract.
2. Get all constructors declared in class.
3. Check whether the constructor is private.
4. If the class is not abstract and all its constructors are private, then this test case violates the rule.

Based on the provided test case:
1. Check whether the class is abstract.
   - Result: The class is not abstract (it is a public class).
2. Get all constructors declared in class.
   - Result: There is one constructor declared in the class.
3. Check whether the constructor is private.
   - Result: The constructor is private.
4. If the class is not abstract and all its constructors are private, then this test case violates the rule.
   - Result: The class is not abstract and it has a private constructor, so it violates the rule.

However, the description of the test case indicates it is a violation for an abstract class, which is a discrepancy. Let's correct the description and check:

```java
public abstract class Foo {
    private Foo() { }
}
```

1. Check whether the class is abstract.
   - Result: The class is abstract.
2. Get all constructors declared in class.
   - Result: There is one constructor declared in the class.
3. Check whether the constructor is private.
   - Result: The constructor is private.
4. If the class is not abstract and all its constructors are private, then this test case violates the rule.
   - Result: The class is abstract, so it does not violate the rule as per the given rule description.

Given the rule description and the provided test case, the correct description and check should be:

```java
public class Foo {
    private Foo() { }
}
```

1. Check whether the class is abstract.
   - Result: The class is not abstract.
2. Get all constructors declared in class.
   - Result: There is one constructor declared in the class.
3. Check whether the constructor is private.
   - Result: The constructor is private.
4. If the class is not abstract and all its constructors are private, then this test case violates the rule.
   - Result: The class is not abstract and it has a private constructor, so it violates the rule.

The description of the test case should be corrected to indicate that it is a violation for a non-abstract class with a private constructor. The number of violations in this test case is indeed 1.
['Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'If the class is not abstract and all its constructors are private, then this test case violates the rule.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'If the class is not abstract and all its constructors are private, then this test case violates the rule.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'If the class is not abstract and all its constructors are private, then this test case violates the rule.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'If the class is not abstract and all its constructors are private, then this test case violates the rule.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*If the class is not abstract and all its constructors are private, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*If the class is not abstract and all its constructors are private, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*If the class is not abstract and all its constructors are private, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*If the class is not abstract and all its constructors are private, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// violation for abstract class
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isAbstract()) {
            boolean onlyPrivateConstructors = node.descendants(ASTConstructorDeclaration.class)
                                                    .allMatch(ASTConstructorDeclaration::isPrivate);
            if (onlyPrivateConstructors && !node.isFinal()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class has declared annotations.
3. Get the javadoc comment of class.
4. Check whether the class is abstract.
5. Get all constructors declared in class.
6. Check whether the constructor is private.
7. Check whether the class is public.
8. Check whether the class is package-private.
9. Check whether the class has any non-private constructors.

Given the test case:

- 1. Get the name of class: `Foo`
- 2. Check whether the class has declared annotations: No annotations are declared.
- 3. Get the javadoc comment of class: No javadoc comment provided.
- 4. Check whether the class is abstract: The class is not abstract.
- 5. Get all constructors declared in class: There is one constructor.
- 6. Check whether the constructor is private: The constructor is private.
- 7. Check whether the class is public: The class is public.
- 8. Check whether the class is package-private: No, the class is not package-private.
- 9. Check whether the class has any non-private constructors: No, all constructors are private.

The original test case description seems to conflict with the provided code. The description mentions an abstract class, but the provided code is a non-abstract class. Additionally, the rule is about making classes final if all their constructors are private, which is true in this case.

To align with the rule and the provided code, the correct steps should be:

- 1. Get the name of class: `Foo`
- 2. Check whether the class has declared annotations: No annotations are declared.
- 3. Get the javadoc comment of class: No javadoc comment provided.
- 4. Check whether the class is abstract: The class is not abstract.
- 5. Get all constructors declared in class: There is one constructor.
- 6. Check whether the constructor is private: The constructor is private.
- 7. Check whether the class is public: The class is public.
- 8. Check whether the class is package-private: No, the class is not package-private.

Based on the above steps, the test case does violate the rule because the class `Foo` is public and its constructor is private, meaning it cannot be extended from outside its compilation unit. Therefore, the class should be made final.

The description of this test case should be: `good 0` if the class is made final, or `bad 1` if it is not. Since the class is not made final in the provided test case:

- The description of this test case is: `bad 1`
- The number of violating the rule in this test case is: `1`
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get the javadoc comment of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is public.', 'Check whether the class is package-private.', 'Check whether the class has any non-private constructors.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Check whether the class is package-private.* 匹配到的元操作或API：
logic: Check whether the class is package-private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.922559916973114
*Check whether the class has any non-private constructors.* 匹配到的元操作或API：
logic: Check whether the class has any non-private constructors.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.884695291519165
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// violation for abstract class
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isPublic() && !node.isAbstract() && !node.isInterface() && !hasAnnotations(node)) {
            NodeStream<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class);
            if (constructors.nonEmpty() && constructors.allMatch(ASTConstructorDeclaration::isPrivate)) {
                if (node.descendants(ASTConstructorDeclaration.class).count() == node.getNumChildrenWithType(ASTConstructorDeclaration.class)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    // Check whether class has declared annotations
    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class is abstract.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Check whether the class has declared annotations.
6. Get a declared annotation of class.
7. Check whether the class has x annotation.
8. Get the number of constructors declared in class.

Given the test case:

```java
public class Foo {
    private Foo() { }
}
```

Let's perform the checks:

1. Get the name of class.
   - The name of the class is `Foo`.

2. Check whether the class is abstract.
   - The class is not marked as abstract.

3. Get all constructors declared in class.
   - There is one constructor declared in the class.

4. Check whether the constructor is private.
   - The constructor is private.

5. Check whether the class has declared annotations.
   - The class does not have any declared annotations.

6. Get a declared annotation of class.
   - Not applicable since there are no declared annotations.

7. Check whether the class has x annotation.
   - Not applicable since there are no declared annotations.

8. Get the number of constructors declared in class.
   - There is 1 constructor declared in the class.

The test case does not violate the rule as described because the class is not abstract. The rule specifically mentions abstract classes as a violation case, and since `Foo` is not abstract, it does not fall into the scope of the rule.

If the intention was to check a non-abstract class with a private constructor, the test case would be correct, but it would not be a violation for an abstract class as per the rule description provided. If the rule description is meant to include non-abstract classes as well, then the test case is fine.

Let's rephrase the checks to ensure clarity:

1. Get the name of class.
   - The name of the class is `Foo`.

2. Check whether the class is abstract.
   - The class is not marked as abstract.

3. Get all constructors declared in class.
   - There is one constructor declared in the class.

4. Check whether the constructor is private.
   - The constructor is private.

5. Check whether the class has declared annotations.
   - The class does not have any declared annotations.

6. Get a declared annotation of class.
   - Not applicable since there are no declared annotations.

7. Check whether the class has x annotation.
   - Not applicable since there are no declared annotations.

8. Get the number of constructors declared in class.
   - There is 1 constructor declared in the class.

9. Check whether the class can be extended from outside its compilation unit.
   - Since the constructor is private, the class cannot be extended from outside its compilation unit.

If the class were abstract, this would be a violation. Since it is not, we need to adjust our understanding of the rule or the test case.

If the rule is meant to apply to both abstract and non-abstract classes, then we should include:

10. Check whether the class is final.
    - The class is not final.

Given the rule description and the test case provided, the test case does not violate the rule as it stands. If the rule is meant to apply to non-abstract classes as well, then the test case is fine, but the rule description should be clarified.

To clarify further:

- If the rule is meant for abstract classes only: The test case does not violate the rule because the class is not abstract.
- If the rule is meant for both abstract and non-abstract classes: The test case violates the rule because the class is non-abstract and has a private constructor, so it cannot be extended from outside its compilation unit, and it is not marked as final.

Let's assume the rule is for both abstract and non-abstract classes:

10. Check whether the class is final.
    - The class is not final.

Thus, the test case violates the rule if the class is non-abstract and has a private constructor.
['Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the class has x annotation.', 'Get the number of constructors declared in class.', 'Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the class has x annotation.', 'Get the number of constructors declared in class.', 'Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the class has x annotation.', 'Get the number of constructors declared in class.', 'Check whether the class can be extended from outside its compilation unit.', 'Check whether the class is final.', 'Check whether the class is final.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9878389835357666
*Check whether the class has x annotation.* 匹配到的元操作或API：
logic: Check whether the class has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9908235669136047
*Get the number of constructors declared in class.* 匹配到的元操作或API：
query: Get the number of constructors declared in class.
most similar API: get num children of constructor
cosine Similarity: 0.8205668330192566
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9878389835357666
*Check whether the class has x annotation.* 匹配到的元操作或API：
logic: Check whether the class has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9908235669136047
*Get the number of constructors declared in class.* 匹配到的元操作或API：
query: Get the number of constructors declared in class.
most similar API: get num children of constructor
cosine Similarity: 0.8205668330192566
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9878389835357666
*Check whether the class has x annotation.* 匹配到的元操作或API：
logic: Check whether the class has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9908235669136047
*Get the number of constructors declared in class.* 匹配到的元操作或API：
query: Get the number of constructors declared in class.
most similar API: get num children of constructor
cosine Similarity: 0.8205668330192566
*Check whether the class can be extended from outside its compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887725114822388
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887725114822388
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// violation for abstract class
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public int getNumChildren()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {

    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isFinal() && !node.isAbstract() && !hasAnnotations(node)) {
            NodeStream<ASTConstructorDeclaration> constructors = node.children(ASTConstructorDeclaration.class);
            if (constructors.allMatch(ASTConstructorDeclaration::isPrivate) && constructors.nonEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Check whether class has declared annotations
    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Check whether the class is public.
2. Check whether the class is abstract.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Check whether the class has more than one constructor.
6. Count the number of private constructors.
7. Check whether all constructors in the class are private.

Let's perform these checks on the provided test case:

1. Check whether the class is public.
   - The class `Foo` is public.

2. Check whether the class is abstract.
   - The class `Foo` is abstract.

3. Get all constructors declared in class.
   - There is one constructor declared in class `Foo`.

4. Check whether the constructor is private.
   - The constructor `Foo()` is private.

5. Check whether the class has more than one constructor.
   - The class `Foo` has only one constructor.

6. Count the number of private constructors.
   - There is one private constructor.

7. Check whether all constructors in the class are private.
   - All constructors in the class `Foo` are private.

Based on these checks, the class `Foo` is public and has a private constructor, which means it cannot be extended from outside its compilation unit. However, the class is abstract, which is a different condition and does not strictly adhere to the rule's requirement for being made final just because of the private constructor. Therefore, if the rule specifically requires non-abstract classes, this test case does not violate the rule. If the rule allows for abstract classes as well, then this test case would violate the rule because it is an abstract class with a private constructor and could be made final.

Given the description "bad 2" and the number of violations as 1, it seems the rule considers abstract classes with private constructors as violations. Therefore, the test case does violate the rule.
['Check whether the class is public.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has more than one constructor.', 'Count the number of private constructors.', 'Check whether all constructors in the class are private.', 'Check whether the class is public.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has more than one constructor.', 'Count the number of private constructors.', 'Check whether all constructors in the class are private.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class has more than one constructor.* 匹配到的元操作或API：
query: Check whether the class has more than one constructor.
most similar API: Check whether the constructor equals
cosine Similarity: 0.82514488697052
*Count the number of private constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether all constructors in the class are private.* 匹配到的元操作或API：
logic: Check whether all constructors in the class are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9279561042785645
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class has more than one constructor.* 匹配到的元操作或API：
query: Check whether the class has more than one constructor.
most similar API: Check whether the constructor equals
cosine Similarity: 0.82514488697052
*Count the number of private constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether all constructors in the class are private.* 匹配到的元操作或API：
logic: Check whether all constructors in the class are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9279561042785645
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// violation for abstract class
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean equals(java.lang.Object)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isPublic() && !node.isAbstract()) {
            NodeStream<ASTConstructorDeclaration> constructors = node.children(ASTConstructorDeclaration.class);
            if (constructors.allMatch(ASTConstructorDeclaration::isPrivate) && constructors.count() > 0) {
                if (!node.isFinal()) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 2
1484
1157
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class is an inner class.
3. Get all constructors declared in class.
4. Check whether each constructor is private.
5. Check whether the class is final.

Given the test case:

1. The name of the class is Main209 (outer class).
2. Check whether Main209 is an inner class. It is not.
3. Get all constructors declared in Main209. There are no constructors declared in Main209.
4. The name of the inner class is InputBits.
5. Check whether InputBits is an inner class. It is.
6. Get all constructors declared in InputBits. There is one constructor.
7. Check whether each constructor is private. The constructor is private.
8. Check whether the class InputBits is final. It is not.

Since InputBits is an inner class with only private constructors and it is not declared as final, it violates the rule. Therefore, the number of violations in this test case is 1.
['Get the name of class.', 'Check whether the class is an inner class.', 'Get all constructors declared in class.', 'Check whether each constructor is private.', 'Check whether the class is final.', 'The name of the class is Main209 (outer class).', 'Check whether Main209 is an inner class. It is not.', 'Get all constructors declared in Main209. There are no constructors declared in Main209.', 'The name of the inner class is InputBits.', 'Check whether InputBits is an inner class. It is.', 'Get all constructors declared in InputBits. There is one constructor.', 'Check whether each constructor is private. The constructor is private.', 'Check whether the class InputBits is final. It is not.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831406474113464
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether each constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442477226257324
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887725114822388
*The name of the class is Main209 (outer class).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether Main209 is an inner class. It is not.* 匹配到的元操作或API：
logic: Check whether Main209 is an inner class. It is not.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8716492056846619
*Get all constructors declared in Main209. There are no constructors declared in Main209.* 匹配到的元操作或API：
未匹配成功元操作或API
*The name of the inner class is InputBits.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether InputBits is an inner class. It is.* 匹配到的元操作或API：
logic: Check whether InputBits is an inner class. It is.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8586178421974182
*Get all constructors declared in InputBits. There is one constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each constructor is private. The constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private. The constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9496592283248901
*Check whether the class InputBits is final. It is not.* 匹配到的元操作或API：
logic: Check whether the class InputBits is final. It is not.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.8696523308753967
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// #2536 [java] ClassWithOnlyPrivateConstructorsShouldBeFinal can't detect inner class with only private constructor
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super();
        addRuleChainVisit(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            NodeStream<ASTConstructorDeclaration> constructors = node.children(ASTConstructorDeclaration.class);
            if (constructors.allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Get all constructors declared in class.
3. Check whether the constructor is private.
4. Check whether the class is declared inside another class (inner class).
5. Check whether the class has any declared annotations.
6. Check whether the class is public.
7. Check whether the class is abstract.
8. Check whether the class is final.

Perform the checks on the inner class `InputBits`:

1. Get the name of class (InputBits).
2. Get all constructors declared in class (InputBits).
   - Get the number of constructors in InputBits.
   - Check whether the constructor is private (private InputBits(int number) { }).

Since `InputBits` is an inner class, we also need to check if it can be extended from outside its compilation unit:

4. Check whether the class is declared inside another class (Main209).
   - Check whether the class is static (private static class InputBits).

5. Check whether the class has any declared annotations.
6. Check whether the class is public.
7. Check whether the class is abstract.
8. Check whether the class is final.

Given these checks:

1. The name of the class is `InputBits`.
2. There is one constructor in `InputBits`.
3. The constructor `InputBits(int number)` is private.
4. `InputBits` is an inner class of `Main209` and is declared as static.
5. There are no declared annotations on `InputBits`.
6. `InputBits` is not public.
7. `InputBits` is not abstract.
8. `InputBits` is not final.

Since `InputBits` is an inner class with a private constructor and it is not public, it cannot be extended from outside its compilation unit, and thus it should be final. However, based on the provided test case, the rule checker does not correctly identify this, leading to a violation count of 1.

To ensure adherence to the rule:
- If the inner class has only private constructors and is not public or abstract, it should be marked as final.
- In this case, `InputBits` should be marked as final to adhere to the rule.
['Get the name of class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is declared inside another class (inner class).', 'Check whether the class has any declared annotations.', 'Check whether the class is public.', 'Check whether the class is abstract.', 'Check whether the class is final.', 'Get the name of class (InputBits).', 'Get all constructors declared in class (InputBits).', 'Check whether the class is declared inside another class (Main209).', 'Check whether the class has any declared annotations.', 'Check whether the class is public.', 'Check whether the class is abstract.', 'Check whether the class is final.', 'The name of the class is `InputBits`.', 'There is one constructor in `InputBits`.', 'The constructor `InputBits(int number)` is private.', '`InputBits` is an inner class of `Main209` and is declared as static.', 'There are no declared annotations on `InputBits`.', '`InputBits` is not public.', '`InputBits` is not abstract.', '`InputBits` is not final.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class is declared inside another class (inner class).* 匹配到的元操作或API：
logic: Check whether the class is declared inside another class (inner class).
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.893820583820343
*Check whether the class has any declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has any declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9707680940628052
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887725114822388
*Get the name of class (InputBits).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors declared in class (InputBits).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is declared inside another class (Main209).* 匹配到的元操作或API：
query: Check whether the class is declared inside another class (Main209).
most similar API: Check whether is declared in class
cosine Similarity: 0.8715787529945374
*Check whether the class has any declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has any declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9707680940628052
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887725114822388
*The name of the class is `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
*There is one constructor in `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The constructor `InputBits(int number)` is private.* 匹配到的元操作或API：
未匹配成功元操作或API
*`InputBits` is an inner class of `Main209` and is declared as static.* 匹配到的元操作或API：
未匹配成功元操作或API
*There are no declared annotations on `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
*`InputBits` is not public.* 匹配到的元操作或API：
未匹配成功元操作或API
*`InputBits` is not abstract.* 匹配到的元操作或API：
未匹配成功元操作或API
*`InputBits` is not final.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// #2536 [java] ClassWithOnlyPrivateConstructorsShouldBeFinal can't detect inner class with only private constructor
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
8. net.sourceforge.pmd.lang.java.types.TypeTestUtil: static public boolean isDeclaredInClass(java.lang.Class, net.sourceforge.pmd.lang.java.types.JMethodSig), //Returns true if the signature is that of a method declared in the given class. @param klass Class @param sig   Method signature to test @throws NullPointerException If any argument is null

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isPublic() && !node.isAbstract() && !node.isFinal() && !hasAnnotations(node)) {
            NodeStream<ASTConstructorDeclaration> constructors = node.children(ASTConstructorDeclaration.class);
            if (constructors.nonEmpty() && constructors.all(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Check whether class has declared annotations
    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class is inner class.
3. Get all constructors of the class.
4. Check whether each constructor is private.
5. Check whether the class is final.
6. Get the package of the class.
7. Get the classes declared in the same compilation unit.
8. Check whether any class outside the compilation unit extends the class.

For the provided test case:

1. Get the name of class: Main209.
2. Check whether the class is inner class: No.
3. Get all constructors of the class: Main209 has no constructors declared, it uses the default constructor.
4. Check whether each constructor is private: Not applicable, as Main209 has no constructors.
5. Check whether the class is final: No.
6. Get the package of the class: No package specified, it is default package-private.
7. Get the classes declared in the same compilation unit: InputBits is declared in the same compilation unit.
8. Check whether any class outside the compilation unit extends the class: Not applicable, as there are no classes outside the compilation unit.

However, the rule is about the inner class `InputBits`:

1. Get the name of class: InputBits.
2. Check whether the class is inner class: Yes.
3. Get all constructors of the class: InputBits has one constructor.
4. Check whether each constructor is private: Yes, the constructor is private.
5. Check whether the class is final: No.
6. Get the package of the class: No package specified, it is default package-private.
7. Get the classes declared in the same compilation unit: Main209 and InputBits are declared in the same compilation unit.
8. Check whether any class outside the compilation unit extends the class: No, as there are no classes outside the compilation unit that extend InputBits.

Since `InputBits` is an inner class with only private constructors and is not final, it violates the rule.
['Get the name of class.', 'Check whether the class is inner class.', 'Get all constructors of the class.', 'Check whether each constructor is private.', 'Check whether the class is final.', 'Get the package of the class.', 'Get the classes declared in the same compilation unit.', 'Check whether any class outside the compilation unit extends the class.', 'Get the name of class: Main209.', 'Check whether the class is inner class: No.', 'Get all constructors of the class: Main209 has no constructors declared, it uses the default constructor.', 'Check whether each constructor is private: Not applicable, as Main209 has no constructors.', 'Check whether the class is final: No.', 'Get the package of the class: No package specified, it is default package-private.', 'Get the classes declared in the same compilation unit: InputBits is declared in the same compilation unit.', 'Check whether any class outside the compilation unit extends the class: Not applicable, as there are no classes outside the compilation unit.', 'Get the name of class: InputBits.', 'Check whether the class is inner class: Yes.', 'Get all constructors of the class: InputBits has one constructor.', 'Check whether each constructor is private: Yes, the constructor is private.', 'Check whether the class is final: No.', 'Get the package of the class: No package specified, it is default package-private.', 'Get the classes declared in the same compilation unit: Main209 and InputBits are declared in the same compilation unit.', 'Check whether any class outside the compilation unit extends the class: No, as there are no classes outside the compilation unit that extend InputBits.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9875447154045105
*Get all constructors of the class.* 匹配到的元操作或API：
query: Get all constructors of the class.
most similar API: get parents of type of constructor
cosine Similarity: 0.8007245063781738
*Check whether each constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442477226257324
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887725114822388
*Get the package of the class.* 匹配到的元操作或API：
query: Get the package of the class.
most similar API: get package name of class or interface
cosine Similarity: 0.8242604732513428
*Get the classes declared in the same compilation unit.* 匹配到的元操作或API：
query: Get the classes declared in the same compilation unit.
most similar API: get class of compilation unit
cosine Similarity: 0.8734896183013916
*Check whether any class outside the compilation unit extends the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: Main209.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is inner class: No.* 匹配到的元操作或API：
logic: Check whether the class is inner class: No.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9294240474700928
*Get all constructors of the class: Main209 has no constructors declared, it uses the default constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each constructor is private: Not applicable, as Main209 has no constructors.* 匹配到的元操作或API：
logic: Check whether each constructor is private: Not applicable, as Main209 has no constructors.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8849155306816101
*Check whether the class is final: No.* 匹配到的元操作或API：
logic: Check whether the class is final: No.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9460524320602417
*Get the package of the class: No package specified, it is default package-private.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the classes declared in the same compilation unit: InputBits is declared in the same compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any class outside the compilation unit extends the class: Not applicable, as there are no classes outside the compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: InputBits.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is inner class: Yes.* 匹配到的元操作或API：
logic: Check whether the class is inner class: Yes.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.943924605846405
*Get all constructors of the class: InputBits has one constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each constructor is private: Yes, the constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private: Yes, the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.943229615688324
*Check whether the class is final: No.* 匹配到的元操作或API：
logic: Check whether the class is final: No.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9460524320602417
*Get the package of the class: No package specified, it is default package-private.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the classes declared in the same compilation unit: Main209 and InputBits are declared in the same compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any class outside the compilation unit extends the class: No, as there are no classes outside the compilation unit that extend InputBits.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// #2536 [java] ClassWithOnlyPrivateConstructorsShouldBeFinal can't detect inner class with only private constructor
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.util.List<List<T> getParentsOfType(java.lang.Class)
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName(), //Returns the name of the package in which this class is declared.
7. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public java.lang.Class<Class<?> getClass()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {

    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested()) {
            NodeStream<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class);
            if (!constructors.isEmpty() && constructors.allMatch(ASTConstructorDeclaration::isPrivate)) {
                if (!node.isFinal()) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class is an inner class.
3. Get all constructors declared in class.
4. Check whether each constructor is private.
5. Check whether the class is final.

In this test case:
1. The name of the class is `Main209`.
2. The inner class `InputBits` is an inner class.
3. `InputBits` has one constructor declared in it.
4. The constructor of `InputBits` is private.
5. The inner class `InputBits` is not final.

Since `InputBits` is an inner class with only private constructors and it is not final, it violates the rule. The number of violating the rule in this test case is indeed 1.
['Get the name of class.', 'Check whether the class is an inner class.', 'Get all constructors declared in class.', 'Check whether each constructor is private.', 'Check whether the class is final.', 'The name of the class is `Main209`.', 'The inner class `InputBits` is an inner class.', '`InputBits` has one constructor declared in it.', 'The constructor of `InputBits` is private.', 'The inner class `InputBits` is not final.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831406474113464
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether each constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442477226257324
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887725114822388
*The name of the class is `Main209`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The inner class `InputBits` is an inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*`InputBits` has one constructor declared in it.* 匹配到的元操作或API：
未匹配成功元操作或API
*The constructor of `InputBits` is private.* 匹配到的元操作或API：
未匹配成功元操作或API
*The inner class `InputBits` is not final.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// #2536 [java] ClassWithOnlyPrivateConstructorsShouldBeFinal can't detect inner class with only private constructor
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isFinal() && node.isNested()) {
            boolean hasPrivateConstructor = node.descendants(ASTConstructorDeclaration.class)
                                               .allMatch(ASTConstructorDeclaration::isPrivate);
            if (hasPrivateConstructor) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class is a nested class.
3. Check whether the class is an inner class.
4. Check whether the class is static.
5. Get all constructors declared in class.
6. Check whether the constructor is private.
7. Check whether all constructors are private.
8. Check whether the class has declared annotations.
9. Check whether the class has x annotation.
10. Check whether the class is final.
11. Get the name of the package where the class is located.
12. Check whether the class is located in the same package as its enclosing class.
13. Check whether the class is accessible from outside its compilation unit.

For the given test case:
1. Get the name of class: Main209
2. Check whether the class is a nested class: Yes, Main209 contains InputBits.
3. Check whether the class is an inner class: Yes, InputBits is an inner class.
4. Check whether the class is static: Yes, InputBits is static.
5. Get all constructors declared in class: Get constructors for InputBits.
6. Check whether the constructor is private: Yes, the constructor for InputBits is private.
7. Check whether all constructors are private: Yes, InputBits has only one constructor and it is private.
8. Check whether the class has declared annotations: No, InputBits does not have any annotations.
9. Check whether the class has x annotation: Not applicable, since there are no annotations.
10. Check whether the class is final: No, InputBits is not final.
11. Get the name of the package where the class is located: Not explicitly provided, but assume the same package for Main209 and InputBits.
12. Check whether the class is located in the same package as its enclosing class: Yes, InputBits is in the same package as Main209.
13. Check whether the class is accessible from outside its compilation unit: No, InputBits is private and thus not accessible from outside its compilation unit.

If the class is an inner class, all of its constructors are private, and it is not already final, then it should be made final. In this case, InputBits meets those criteria, so it should be marked as final to adhere to the rule.
['Get the name of class.', 'Check whether the class is a nested class.', 'Check whether the class is an inner class.', 'Check whether the class is static.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether all constructors are private.', 'Check whether the class has declared annotations.', 'Check whether the class has x annotation.', 'Check whether the class is final.', 'Get the name of the package where the class is located.', 'Check whether the class is located in the same package as its enclosing class.', 'Check whether the class is accessible from outside its compilation unit.', 'Get the name of class: Main209', 'Check whether the class is a nested class: Yes, Main209 contains InputBits.', 'Check whether the class is an inner class: Yes, InputBits is an inner class.', 'Check whether the class is static: Yes, InputBits is static.', 'Get all constructors declared in class: Get constructors for InputBits.', 'Check whether the constructor is private: Yes, the constructor for InputBits is private.', 'Check whether all constructors are private: Yes, InputBits has only one constructor and it is private.', 'Check whether the class has declared annotations: No, InputBits does not have any annotations.', 'Check whether the class has x annotation: Not applicable, since there are no annotations.', 'Check whether the class is final: No, InputBits is not final.', 'Get the name of the package where the class is located: Not explicitly provided, but assume the same package for Main209 and InputBits.', 'Check whether the class is located in the same package as its enclosing class: Yes, InputBits is in the same package as Main209.', 'Check whether the class is accessible from outside its compilation unit: No, InputBits is private and thus not accessible from outside its compilation unit.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is a nested class.* 匹配到的元操作或API：
logic: Check whether the class is a nested class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8703588843345642
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831406474113464
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520915031433
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether all constructors are private.* 匹配到的元操作或API：
logic: Check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9365217685699463
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Check whether the class has x annotation.* 匹配到的元操作或API：
logic: Check whether the class has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9908235669136047
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887725114822388
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the class is located in the same package as its enclosing class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is accessible from outside its compilation unit.* 匹配到的元操作或API：
query: Check whether the class is accessible from outside its compilation unit.
most similar API: Check whether the class or interface is local
cosine Similarity: 0.8100329041481018
*Get the name of class: Main209* 匹配到的元操作或API：
logic: Get the name of class: Main209
most similar meta operation: Get the name of class
cosine Similarity: 0.8585508465766907
*Check whether the class is a nested class: Yes, Main209 contains InputBits.* 匹配到的元操作或API：
query: Check whether the class is a nested class: Yes, Main209 contains InputBits.
most similar API: Check whether the class or interface is nested
cosine Similarity: 0.8549663424491882
*Check whether the class is an inner class: Yes, InputBits is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class: Yes, InputBits is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8889586925506592
*Check whether the class is static: Yes, InputBits is static.* 匹配到的元操作或API：
logic: Check whether the class is static: Yes, InputBits is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.8680508136749268
*Get all constructors declared in class: Get constructors for InputBits.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: Yes, the constructor for InputBits is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private: Yes, the constructor for InputBits is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8727701902389526
*Check whether all constructors are private: Yes, InputBits has only one constructor and it is private.* 匹配到的元操作或API：
query: Check whether all constructors are private: Yes, InputBits has only one constructor and it is private.
most similar API: Check whether the constructor is private
cosine Similarity: 0.8395479321479797
*Check whether the class has declared annotations: No, InputBits does not have any annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations: No, InputBits does not have any annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.8757008910179138
*Check whether the class has x annotation: Not applicable, since there are no annotations.* 匹配到的元操作或API：
logic: Check whether the class has x annotation: Not applicable, since there are no annotations.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9087803363800049
*Check whether the class is final: No, InputBits is not final.* 匹配到的元操作或API：
logic: Check whether the class is final: No, InputBits is not final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9011573195457458
*Get the name of the package where the class is located: Not explicitly provided, but assume the same package for Main209 and InputBits.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located: Not explicitly provided, but assume the same package for Main209 and InputBits.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.8845309019088745
*Check whether the class is located in the same package as its enclosing class: Yes, InputBits is in the same package as Main209.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is accessible from outside its compilation unit: No, InputBits is private and thus not accessible from outside its compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// #2536 [java] ClassWithOnlyPrivateConstructorsShouldBeFinal can't detect inner class with only private constructor
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isLocal(), //Returns true if the class is declared inside a block other than the body of another class, or the top level. Anonymous classes are not considered local. Only class declarations can be local. Local classes cannot be static.
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested(), //Returns true if this type declaration is nested inside an interface, class or annotation.

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isFinal() && node.isNested() && node.isStatic() && hasOnlyPrivateConstructors(node) && !hasAnnotations(node)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    private boolean hasOnlyPrivateConstructors(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class);
        return constructors.nonEmpty() && constructors.allMatch(ASTConstructorDeclaration::isPrivate);
    }

    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 3
804
574
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
To analyze the adherence of the provided test case to the rule, we need to perform the following granular checks:

1. Get the name of class.
2. Get the inner class of class.
3. Check whether the inner class is private.
4. Check whether the inner class has declared constructors.
5. If inner class has declared constructors, check whether all constructors are private.
6. Check whether the inner class has any usage outside its compilation unit. (Note: This check is more complex and typically requires static analysis beyond just parsing the file. For this scenario, we assume that there is no usage outside the compilation unit as stated in the test case description.)

Let's perform the checks:

1. Get the name of class.
   - The name of the class is `Main209`.

2. Get the inner class of class.
   - The inner class of `Main209` is `InputBits`.

3. Check whether the inner class is private.
   - `InputBits` is a private static class, so this check passes.

4. Check whether the inner class has declared constructors.
   - `InputBits` does not have any explicitly declared constructors. The default constructor is implicitly private due to the private class.

5. If inner class has declared constructors, check whether all constructors are private.
   - Since `InputBits` does not have any explicitly declared constructors, this check is not applicable. However, the default constructor is private.

6. Check whether the inner class has any usage outside its compilation unit.
   - According to the test case description, `InputBits` has no usage outside its compilation unit, so this check passes.

Based on these checks, the test case `InputBits` adheres to the rule description because:
- It is a private static class.
- Its default constructor is implicitly private.
- It has no usage outside its compilation unit.

Therefore, the provided description of "bad 4" with "The number of violating the rule in this test case is: 1" seems incorrect. The class `InputBits` should not be reported as violating the rule since it cannot be extended from outside its compilation unit due to its private nature.

If the intent was to report the class because it is private (and thus implicitly final), the rule description might need to be clarified to explicitly state that private classes should be made final. However, based on the current rule description, the test case does not violate the rule.
['Get the name of class.', 'Get the inner class of class.', 'Check whether the inner class is private.', 'Check whether the inner class has declared constructors.', 'If inner class has declared constructors, check whether all constructors are private.', 'Check whether the inner class has any usage outside its compilation unit. (Note: This check is more complex and typically requires static analysis beyond just parsing the file. For this scenario, we assume that there is no usage outside the compilation unit as stated in the test case description.)', 'Get the name of class.', 'Get the inner class of class.', 'Check whether the inner class is private.', 'Check whether the inner class has declared constructors.', 'If inner class has declared constructors, check whether all constructors are private.', 'Check whether the inner class has any usage outside its compilation unit.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'TypesFromAst', 'ASTClassOrInterfaceBody', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the inner class of class.* 匹配到的元操作或API：
logic: Get the inner class of class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8724628686904907
*Check whether the inner class is private.* 匹配到的元操作或API：
logic: Check whether the inner class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9290029406547546
*Check whether the inner class has declared constructors.* 匹配到的元操作或API：
logic: Check whether the inner class has declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.8522487878799438
*If inner class has declared constructors, check whether all constructors are private.* 匹配到的元操作或API：
logic: If inner class has declared constructors, check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8955320119857788
*Check whether the inner class has any usage outside its compilation unit. (Note: This check is more complex and typically requires static analysis beyond just parsing the file. For this scenario, we assume that there is no usage outside the compilation unit as stated in the test case description.)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the inner class of class.* 匹配到的元操作或API：
logic: Get the inner class of class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8724628686904907
*Check whether the inner class is private.* 匹配到的元操作或API：
logic: Check whether the inner class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9290029406547546
*Check whether the inner class has declared constructors.* 匹配到的元操作或API：
logic: Check whether the inner class has declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.8522487878799438
*If inner class has declared constructors, check whether all constructors are private.* 匹配到的元操作或API：
logic: If inner class has declared constructors, check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8955320119857788
*Check whether the inner class has any usage outside its compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Private inner class with no ctor and no usage
public class Main209 {
    private static class InputBits {
        // default ctor is implicitly private
    }
}
The description of this test case is: bad 4
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()

1.  //Check whether constructor has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTConstructorDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if the class is nested, private, and not final
        if (node.isNested() && node.isPrivate() && !node.isFinal()) {
            boolean hasPublicConstructor = node.descendants(ASTConstructorDeclaration.class).anyMatch(ASTConstructorDeclaration::isPublic);
            boolean hasNoConstructor = node.descendants(ASTConstructorDeclaration.class).isEmpty();
            // Add violation if there are no constructors or all constructors are private
            if (hasNoConstructor || !hasPublicConstructor) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Utility method to check whether a constructor has declared annotations
    public boolean hasAnnotation(ASTConstructorDeclaration node) {
        NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
        return declaredAnnotations.nonEmpty();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
        2. Get all constructors declared in class.
        3. Check whether the class is static.
        4. Check whether the class is private.
        5. Get the number of constructors declared in class.
        6. Check whether the constructor is private.
        7. Check whether the class has been extended from outside its compilation unit.

For the provided test case:

1. Get the name of class: `Main209`
2. Get all constructors declared in class: `Main209` has no explicitly declared constructors, so the default constructor is used.
3. Check whether the class is static: `Main209` is not static.
4. Check whether the class is private: `Main209` is public.
5. Get the number of constructors declared in class: `Main209` has 1 constructor (default constructor).
6. Check whether the constructor is private: The default constructor of `Main209` is not private, it is package-private.
7. Get all inner classes declared in class: `Main209` has an inner class `InputBits`.
8. Get the name of inner class: `InputBits`
9. Get all constructors declared in inner class: `InputBits` has no explicitly declared constructors, so the default constructor is used.
10. Check whether the inner class is static: `InputBits` is static.
11. Check whether the inner class is private: `InputBits` is private.
12. Get the number of constructors declared in inner class: `InputBits` has 1 constructor (default constructor).
13. Check whether the constructor is private: The default constructor of `InputBits` is implicitly private.
14. Check whether the inner class has been extended from outside its compilation unit: There is no information provided indicating that `InputBits` is extended outside its compilation unit.

Given the test case, the relevant checks are:

1. Get the name of inner class: `InputBits`
2. Check whether the inner class is static: `InputBits` is static.
3. Check whether the inner class is private: `InputBits` is private.
4. Get the number of constructors declared in inner class: `InputBits` has 1 constructor (default constructor).
5. Check whether the constructor is private: The default constructor of `InputBits` is implicitly private.

The test case does not violate the rule because `InputBits` is an inner class, and the rule specifies that classes with private constructors that cannot be extended from outside their compilation unit should be made final. Since `InputBits` is private, it cannot be extended from outside its compilation unit, but the rule does not explicitly state that it should be made final in this scenario. However, the provided description indicates that this is a violation, so the checks are correctly identifying the potential issue.

The number of violating the rule in this test case is: 1 (as per the provided description, `InputBits` should be made final, even though it is not explicitly extended from outside its compilation unit).
['Get the name of class.', 'Get all constructors declared in class.', 'Check whether the class is static.', 'Check whether the class is private.', 'Get the number of constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has been extended from outside its compilation unit.', 'Get the name of class: `Main209`', 'Get all constructors declared in class: `Main209` has no explicitly declared constructors, so the default constructor is used.', 'Check whether the class is static: `Main209` is not static.', 'Check whether the class is private: `Main209` is public.', 'Get the number of constructors declared in class: `Main209` has 1 constructor (default constructor).', 'Check whether the constructor is private: The default constructor of `Main209` is not private, it is package-private.', 'Get all inner classes declared in class: `Main209` has an inner class `InputBits`.', 'Get the name of inner class: `InputBits`', 'Get all constructors declared in inner class: `InputBits` has no explicitly declared constructors, so the default constructor is used.', 'Check whether the inner class is static: `InputBits` is static.', 'Check whether the inner class is private: `InputBits` is private.', 'Get the number of constructors declared in inner class: `InputBits` has 1 constructor (default constructor).', 'Check whether the constructor is private: The default constructor of `InputBits` is implicitly private.', 'Check whether the inner class has been extended from outside its compilation unit: There is no information provided indicating that `InputBits` is extended outside its compilation unit.', 'Get the name of inner class: `InputBits`', 'Check whether the inner class is static: `InputBits` is static.', 'Check whether the inner class is private: `InputBits` is private.', 'Get the number of constructors declared in inner class: `InputBits` has 1 constructor (default constructor).', 'Check whether the constructor is private: The default constructor of `InputBits` is implicitly private.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'TypesFromAst', 'ASTClassOrInterfaceBody', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520915031433
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853934049606323
*Get the number of constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class has been extended from outside its compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: `Main209`* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors declared in class: `Main209` has no explicitly declared constructors, so the default constructor is used.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is static: `Main209` is not static.* 匹配到的元操作或API：
logic: Check whether the class is static: `Main209` is not static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.8897183537483215
*Check whether the class is private: `Main209` is public.* 匹配到的元操作或API：
logic: Check whether the class is private: `Main209` is public.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9021040201187134
*Get the number of constructors declared in class: `Main209` has 1 constructor (default constructor).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: The default constructor of `Main209` is not private, it is package-private.* 匹配到的元操作或API：
logic: Check whether the constructor is private: The default constructor of `Main209` is not private, it is package-private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8923578858375549
*Get all inner classes declared in class: `Main209` has an inner class `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of inner class: `InputBits`* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors declared in inner class: `InputBits` has no explicitly declared constructors, so the default constructor is used.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is static: `InputBits` is static.* 匹配到的元操作或API：
query: Check whether the inner class is static: `InputBits` is static.
most similar API: Check whether the class or interface is static
cosine Similarity: 0.8141883015632629
*Check whether the inner class is private: `InputBits` is private.* 匹配到的元操作或API：
query: Check whether the inner class is private: `InputBits` is private.
most similar API: Check whether the class or interface is private
cosine Similarity: 0.8257063031196594
*Get the number of constructors declared in inner class: `InputBits` has 1 constructor (default constructor).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: The default constructor of `InputBits` is implicitly private.* 匹配到的元操作或API：
logic: Check whether the constructor is private: The default constructor of `InputBits` is implicitly private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8734685778617859
*Check whether the inner class has been extended from outside its compilation unit: There is no information provided indicating that `InputBits` is extended outside its compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of inner class: `InputBits`* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is static: `InputBits` is static.* 匹配到的元操作或API：
query: Check whether the inner class is static: `InputBits` is static.
most similar API: Check whether the class or interface is static
cosine Similarity: 0.8141883015632629
*Check whether the inner class is private: `InputBits` is private.* 匹配到的元操作或API：
query: Check whether the inner class is private: `InputBits` is private.
most similar API: Check whether the class or interface is private
cosine Similarity: 0.8257063031196594
*Get the number of constructors declared in inner class: `InputBits` has 1 constructor (default constructor).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: The default constructor of `InputBits` is implicitly private.* 匹配到的元操作或API：
logic: Check whether the constructor is private: The default constructor of `InputBits` is implicitly private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8734685778617859
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Private inner class with no ctor and no usage
public class Main209 {
    private static class InputBits {
        // default ctor is implicitly private
    }
}
The description of this test case is: bad 4
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if the node is a class (not an interface) and not abstract
        if (!node.isInterface() && !node.isAbstract()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).toList();
            // Check if there are constructors and all are private
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                // Check if the class is not final
                if (!node.isFinal()) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
To perform the granular checks for the provided rule and test case:

1. Get the name of class (Main209).
2. Get the name of the inner class (InputBits).
3. Get the constructors of the inner class (InputBits).
4. Check whether the inner class has any declared constructors.
5. If the inner class has no declared constructors, check whether the default constructor is implicit and private.
6. If the inner class has declared constructors, check whether all constructors are private.
7. Get the access of the inner class (InputBits).
8. Check whether the inner class is static.
9. Check whether the inner class is private.
10. If the inner class is private and has no non-private constructors, check whether the inner class has any subclasses outside its compilation unit. (This step is often not straightforward to perform programmatically, as it requires analyzing the entire codebase, but for the sake of this rule, we assume it cannot be extended outside its compilation unit if it is private).

Based on these checks:
- The inner class `InputBits` is private.
- The inner class `InputBits` is static.
- The inner class `InputBits` has no declared constructors, so the default constructor is implicitly private.

Since the inner class `InputBits` is private and has no non-private constructors, it cannot be extended from outside its compilation unit, and there are no abstract methods to prevent it from being made final. Therefore, this test case violates the rule.

The number of violating the rule in this test case is indeed 1.
['Get the name of class (Main209).', 'Get the name of the inner class (InputBits).', 'Get the constructors of the inner class (InputBits).', 'Check whether the inner class has any declared constructors.', 'If the inner class has no declared constructors, check whether the default constructor is implicit and private.', 'If the inner class has declared constructors, check whether all constructors are private.', 'Get the access of the inner class (InputBits).', 'Check whether the inner class is static.', 'Check whether the inner class is private.', 'If the inner class is private and has no non-private constructors, check whether the inner class has any subclasses outside its compilation unit. (This step is often not straightforward to perform programmatically, as it requires analyzing the entire codebase, but for the sake of this rule, we assume it cannot be extended outside its compilation unit if it is private).']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'TypesFromAst', 'ASTClassOrInterfaceBody', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class (Main209).* 匹配到的元操作或API：
logic: Get the name of class (Main209).
most similar meta operation: Get the name of class
cosine Similarity: 0.868096649646759
*Get the name of the inner class (InputBits).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the constructors of the inner class (InputBits).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class has any declared constructors.* 匹配到的元操作或API：
query: Check whether the inner class has any declared constructors.
most similar API: Check whether is declared in class
cosine Similarity: 0.8181400299072266
*If the inner class has no declared constructors, check whether the default constructor is implicit and private.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the inner class has declared constructors, check whether all constructors are private.* 匹配到的元操作或API：
logic: If the inner class has declared constructors, check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8983884453773499
*Get the access of the inner class (InputBits).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is static.* 匹配到的元操作或API：
logic: Check whether the inner class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9092439413070679
*Check whether the inner class is private.* 匹配到的元操作或API：
logic: Check whether the inner class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9290029406547546
*If the inner class is private and has no non-private constructors, check whether the inner class has any subclasses outside its compilation unit. (This step is often not straightforward to perform programmatically, as it requires analyzing the entire codebase, but for the sake of this rule, we assume it cannot be extended outside its compilation unit if it is private).* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Private inner class with no ctor and no usage
public class Main209 {
    private static class InputBits {
        // default ctor is implicitly private
    }
}
The description of this test case is: bad 4
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.types.TypeTestUtil: static public boolean isDeclaredInClass(java.lang.Class, net.sourceforge.pmd.lang.java.types.JMethodSig), //Returns true if the signature is that of a method declared in the given class. @param klass Class @param sig   Method signature to test @throws NullPointerException If any argument is null
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isPrivate() || node.isStatic() || node.isInterface()) {
            return super.visit(node, data);
        }

        ASTClassOrInterfaceBody body = node.getFirstChildOfType(ASTClassOrInterfaceBody.class);
        if (body == null || !body.hasDescendants(ASTConstructorDeclaration.class)) {
            return super.visit(node, data);
        }

        boolean hasNonPrivateConstructor = body.descendants(ASTConstructorDeclaration.class)
                                               .anyMatch(c -> !c.isPrivate());

        if (!hasNonPrivateConstructor) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Get the name of the package where the class is located.
3. Check whether the class has declared annotations.
4. Get the name of inner class.
5. Check whether the inner class is static.
6. Check whether the inner class is private.
7. Get all constructors declared in inner class.
8. Check whether the number of constructors declared in inner class is 0.
9. If the number of constructors is 0, check whether the default constructor is implicitly private.
10. Check whether the inner class is used outside its enclosing class.

For the provided test case:
- Step 4: The inner class is named `InputBits`.
- Step 6: The inner class `InputBits` is private.
- Step 7: There are no constructors explicitly declared in `InputBits`.
- Step 8: The number of constructors declared is 0.
- Step 9: Since the inner class is private, the default constructor is implicitly private.
- Step 10: The inner class `InputBits` is not used outside its enclosing class `Main209`.

Given the above checks, the class `InputBits` does not violate the rule because while it is private and has no explicitly declared constructors (making the default constructor implicitly private), it is not used outside its enclosing class. Therefore, it can still be extended within the same compilation unit, and the rule does not apply.

To correctly identify a violation, the inner class should be used within the same compilation unit, but not extended. Here’s the revised check considering the description of the test case:

1. Get the name of class.
2. Get the name of the package where the class is located.
3. Check whether the class has declared annotations.
4. Get the name of inner class.
5. Check whether the inner class is static.
6. Check whether the inner class is private.
7. Get all constructors declared in inner class.
8. Check whether the number of constructors declared in inner class is 0.
9. If the number of constructors is 0, check whether the default constructor is implicitly private.
10. Check whether the inner class is used outside its enclosing class.
11. Check whether the inner class is extended within the same compilation unit.

For the provided test case:
- Step 4: The inner class is named `InputBits`.
- Step 6: The inner class `InputBits` is private.
- Step 7: There are no constructors explicitly declared in `InputBits`.
- Step 8: The number of constructors declared is 0.
- Step 9: Since the inner class is private, the default constructor is implicitly private.
- Step 10: The inner class `InputBits` is not used outside its enclosing class `Main209`.
- Step 11: The inner class `InputBits` is not extended within the same compilation unit.

Since the inner class `InputBits` is not extended within the same compilation unit, it does not violate the rule. However, if we were to consider a scenario where `InputBits` is used but not extended within the same compilation unit, the rule would still not apply. The description "bad 4" and the number of violations "1" suggest that the rule checker might be incorrectly flagging this private inner class without explicit usage or extension.

To ensure the correct identification:
- The rule checker should verify if the class is extended within the same compilation unit.
- If not extended and the class is private, it should not report a violation.

The provided test case does not violate the rule as per the description and should not be flagged.
['Get the name of class.', 'Get the name of the package where the class is located.', 'Check whether the class has declared annotations.', 'Get the name of inner class.', 'Check whether the inner class is static.', 'Check whether the inner class is private.', 'Get all constructors declared in inner class.', 'Check whether the number of constructors declared in inner class is 0.', 'If the number of constructors is 0, check whether the default constructor is implicitly private.', 'Check whether the inner class is used outside its enclosing class.', 'Get the name of class.', 'Get the name of the package where the class is located.', 'Check whether the class has declared annotations.', 'Get the name of inner class.', 'Check whether the inner class is static.', 'Check whether the inner class is private.', 'Get all constructors declared in inner class.', 'Check whether the number of constructors declared in inner class is 0.', 'If the number of constructors is 0, check whether the default constructor is implicitly private.', 'Check whether the inner class is used outside its enclosing class.', 'Check whether the inner class is extended within the same compilation unit.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'TypesFromAst', 'ASTClassOrInterfaceBody', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get the name of inner class.* 匹配到的元操作或API：
logic: Get the name of inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.8755849599838257
*Check whether the inner class is static.* 匹配到的元操作或API：
logic: Check whether the inner class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9092439413070679
*Check whether the inner class is private.* 匹配到的元操作或API：
logic: Check whether the inner class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9290029406547546
*Get all constructors declared in inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the number of constructors declared in inner class is 0.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the number of constructors is 0, check whether the default constructor is implicitly private.* 匹配到的元操作或API：
logic: If the number of constructors is 0, check whether the default constructor is implicitly private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8719805479049683
*Check whether the inner class is used outside its enclosing class.* 匹配到的元操作或API：
logic: Check whether the inner class is used outside its enclosing class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8714233040809631
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get the name of inner class.* 匹配到的元操作或API：
logic: Get the name of inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.8755849599838257
*Check whether the inner class is static.* 匹配到的元操作或API：
logic: Check whether the inner class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9092439413070679
*Check whether the inner class is private.* 匹配到的元操作或API：
logic: Check whether the inner class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9290029406547546
*Get all constructors declared in inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the number of constructors declared in inner class is 0.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the number of constructors is 0, check whether the default constructor is implicitly private.* 匹配到的元操作或API：
logic: If the number of constructors is 0, check whether the default constructor is implicitly private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8719805479049683
*Check whether the inner class is used outside its enclosing class.* 匹配到的元操作或API：
logic: Check whether the inner class is used outside its enclosing class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8714233040809631
*Check whether the inner class is extended within the same compilation unit.* 匹配到的元操作或API：
query: Check whether the inner class is extended within the same compilation unit.
most similar API: Check whether the compilation unit equals
cosine Similarity: 0.817338228225708
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Private inner class with no ctor and no usage
public class Main209 {
    private static class InputBits {
        // default ctor is implicitly private
    }
}
The description of this test case is: bad 4
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
7. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean equals(java.lang.Object)

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class, ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isPrivate() && node.isStatic() && node.isNested()) {
            NodeStream<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class);
            if (constructors.isEmpty() || constructors.allMatch(ASTConstructorDeclaration::isPrivate)) {
                if (!node.isFinal()) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    // Helper method to check whether class has declared annotations
    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
Let's analyze the provided test case with the given rule description:

1. Get the name of class.
2. Check whether the class has declared annotations.
3. Get the name of the package where the class is located.
4. Check whether the class is abstract.
5. Check whether the class is public.
6. Check whether the class is private.
7. Check whether the class is protected.
8. Check whether the class is default package-private.
9. Check whether the class is final.
10. Check whether the class is static.
11. Get the super class of class.
12. Check whether the class has extended x class.
13. Get a implemented interface of class.
14. Check whether the class has implemented x interface.
15. Get the name of interface.
16. Check whether interface has declared annotations.
17. Get a declared annotation of interface.
18. Check whether the interface has x annotation.
19. Get the javadoc comment of interface.
20. Check whether the interface is abstract.
21. Check whether the interface is public.
22. Check whether the interface is private.
23. Check whether the interface is protected.
24. Check whether the interface is default package-private.
25. Check whether the interface is final.
26. Check whether the interface is static.
27. Get the super interface of interface.
28. Check whether the interface has extended x interface.
29. Get the name of the package where the interface is located.
30. Check whether the interface is inner interface.
31. Check whether the interface is anonymous class.
32. Get the name of inner class.
33. Check whether inner class has declared annotations.
34. Get a declared annotation of inner class.
35. Check whether the inner class has x annotation.
36. Get the javadoc comment of inner class.
37. Check whether the inner class is abstract.
38. Check whether the inner class is public.
39. Check whether the inner class is private.
40. Check whether the inner class is protected.
41. Check whether the inner class is default package-private.
42. Check whether the inner class is final.
43. Check whether the inner class is static.
44. Get the super class of inner class.
45. Check whether the inner class has extended x class.
46. Get a implemented interface of inner class.
47. Check whether the inner class has implemented x interface.
48. Get the signature of method.
49. Check whether the method is abstract.
50. Check whether the method is private.
51. Check whether the method is public.
52. Check whether the method is default package-private.
53. Check whether the method is protected.
54. Check whether the method is main method.
55. Get the number of formal parameters of method.
56. Get the name of formal parameter.
57. Get the type of formal parameter.
58. Check whether the formal parameter is string type.
59. Check whether the formal parameter is boolean type.
60. Check whether the formal parameter is char type.
61. Check whether the formal parameter is byte type.
62. Check whether the formal parameter is short type.
63. Check whether the formal parameter is int type.
64. Check whether the formal parameter is long type.
65. Check whether the formal parameter is float type.
66. Check whether the formal parameter is double type.
67. Check whether the formal parameter is boxed type.
68. Check whether the formal parameter is a x class type.
69. Check whether the formal parameter is array type.
70. Check whether the formal parameter is enum type.
71. Check whether the formal parameter is record type.
72. Check whether formal parameter has declared annotations.
73. Get a declared annotation of formal parameter.
74. Check whether the formal parameter has x annotation.
75. Get an usage of formal parameter.
76. Check whether the formal parameter is final.
77. Get the return type of method.
78. Check whether the return type of method is void.
79. Check whether the return type of method is string type.
80. Check whether the return type of method is boolean type.
81. Check whether the return type of method is char type.
82. Check whether the return type of method is byte type.
83. Check whether the return type of method is short type.
84. Check whether the return type of method is int type.
85. Check whether the return type of method is long type.
86. Check whether the return type of method is float type.
87. Check whether the return type of method is double type.
88. Check whether the return type of method is boxed type.
89. Check whether the return type of method is x class type.
90. Check whether the return type of method is array type.
91. Check whether the return type of method is enum type.
92. Check whether the return type of method is record type.
93. Get a throw exception in method signature.
94. Check whether the method signature throws x Exception.
95. Check whether method has declared annotations.
96. Get a declared annotation of method.
97. Check whether the method has x annotation.
98. Get the name of constructor.
99. Get the signature of constructor.
100. Get the javadoc comment of constructor.
101. Check whether the constructor is private.
102. Check whether the constructor is public.
103. Check whether the constructor is default package-private.
104. Check whether the constructor is protected.
105. Get a formal parameter of constructor.
106. Get the number of formal parameters of constructor.
107. Get a throw exception in constructor signature.
108. Check whether the constructor signature throws x Exception.
109. Check whether constructor has declared annotations.
110. Get a declared annotation of constructor.
111. Check whether the constructor has x annotation.
112. Check whether the class is inner class.
113. Check whether the class is anonymous class.

Now, applying these checks to the provided test case:

1. Get the name of class.
        - The name of the class is Main209.
2. Check whether the class has declared annotations.
        - The class Main209 has no declared annotations.
3. Get the name of the package where the class is located.
        - The package name is not provided in the test case.
4. Check whether the class is abstract.
        - The class Main209 is not abstract.
5. Check whether the class is public.
        - The class Main209 is public.
6. Check whether the class is private.
        - The class Main209 is not private.
7. Check whether the class is protected.
        - The class Main209 is not protected.
8. Check whether the class is default package-private.
        - The class Main209 is not default package-private.
9. Check whether the class is final.
        - The class Main209 is not final.
10. Check whether the class is static.
        - The class Main209 is not static.
11. Get the super class of class.
        - The super class of Main209 is Object.
12. Check whether the class has extended x class.
        - The class Main209 has extended Object.
13. Get a implemented interface of class.
        - The class Main209 does not implement any interfaces.
14. Check whether the class has implemented x interface.
        - The class Main209 has not implemented any interfaces.
15. Get the name of interface.
        - Not applicable as Main209 is not an interface.
16. Check whether interface has declared annotations.
        - Not applicable as Main209 is not an interface.
17. Get a declared annotation of interface.
        - Not applicable as Main209 is not an interface.
18. Check whether the interface has x annotation.
        - Not applicable as Main209 is not an interface.
19. Get the javadoc comment of interface.
        - Not applicable as Main209 is not an interface.
20. Check whether the interface is abstract.
        - Not applicable as Main209 is not an interface.
21. Check whether the interface is public.
        - Not applicable as Main209 is not an interface.
22. Check whether the interface is private.
        - Not applicable as Main209 is not an interface.
23. Check whether the interface is protected.
        - Not applicable as Main209 is not an interface.
24. Check whether the interface is default package-private.
        - Not applicable as Main209 is not an interface.
25. Check whether the interface is final.
        - Not applicable as Main209 is not an interface.
26. Check whether the interface is static.
        - Not applicable as Main209 is not an interface.
27. Get the super interface of interface.
        - Not applicable as Main209 is not an interface.
28. Check whether the interface has extended x interface.
        - Not applicable as Main209 is not an interface.
29. Get the name of the package where the interface is located.
        - Not applicable as Main209 is not an interface.
30. Check whether the interface is inner interface.
        - Not applicable as Main209 is not an interface.
31. Check whether the interface is anonymous class.
        - Not applicable as Main209 is not an interface.
32. Get the name of inner class.
        - The name of the inner class is InputBits.
33. Check whether inner class has declared annotations.
        - The inner class InputBits does not have declared annotations.
34. Get a declared annotation of inner class.
        - Not applicable as InputBits does not have declared annotations.
35. Check whether the inner class has x annotation.
        - Not applicable as InputBits does not have declared annotations.
36. Get the javadoc comment of inner class.
        - There is no javadoc comment for the inner class InputBits.
37. Check whether the inner class is abstract.
        - The inner class InputBits is not abstract.
38. Check whether the inner class is public.
        - The inner class InputBits is not public.
39. Check whether the inner class is private.
        - The inner class InputBits is private.
40. Check whether the inner class is protected.
        - The inner class InputBits is not protected.
41. Check whether the inner class is default package-private.
        - The inner class InputBits is not default package-private.
42. Check whether the inner class is final.
        - The inner class InputBits is not final.
43. Check whether the inner class is static.
        - The inner class InputBits is static.
44. Get the super class of inner class.
        - The super class of InputBits is Object.
45. Check whether the inner class has extended x class.
        - The inner class InputBits has extended Object.
46. Get a implemented interface of inner class.
        - The inner class InputBits does not implement any interfaces.
47. Check whether the inner class has implemented x interface.
        - The inner class InputBits has not implemented any interfaces.
48. Get the signature of method.
        - Not applicable as there are no methods defined in InputBits.
49. Check whether the method is abstract.
        - Not applicable as there are no methods defined in InputBits.
50. Check whether the method is private.
        - Not applicable as there are no methods defined in InputBits.
51. Check whether the method is public.
        - Not applicable as there are no methods defined in InputBits.
52. Check whether the method is default package-private.
        - Not applicable as there are no methods defined in InputBits.
53. Check whether the method is protected.
        - Not applicable as there are no methods defined in InputBits.
54. Check whether the method is main method.
        - Not applicable as there are no methods defined in InputBits.
55. Get the number of formal parameters of method.
        - Not applicable as there are no methods defined in InputBits.
56. Get the name of formal parameter.
        - Not applicable as there are no methods defined in InputBits.
57. Get the type of formal parameter.
        - Not applicable as there are no methods defined in InputBits.
58. Check whether the formal parameter is string type.
        - Not applicable as there are no methods defined in InputBits.
59. Check whether the formal parameter is boolean type.
        - Not applicable as there are no methods defined in InputBits.
60. Check whether the formal parameter is char type.
        - Not applicable as there are no methods defined in InputBits.
61. Check whether the formal parameter is byte type.
        - Not applicable as there are no methods defined in InputBits.
62. Check whether the formal parameter is short type.
        - Not applicable as there are no methods defined in InputBits.
63. Check whether the formal parameter is int type.
        - Not applicable as there are no methods defined in InputBits.
64. Check whether the formal parameter is long type.
        - Not applicable as there are no methods defined in InputBits.
65. Check whether the formal parameter is float type.
        - Not applicable as there are no methods defined in InputBits.
66. Check whether the formal parameter is double type.
        - Not applicable as there are no methods defined in InputBits.
67. Check whether the formal parameter is boxed type.
        - Not applicable as there are no methods defined in InputBits.
68. Check whether the formal parameter is a x class type.
        - Not applicable as there are no methods defined in InputBits.
69. Check whether the formal parameter is array type.
        - Not applicable as there are no methods defined in InputBits.
70. Check whether the formal parameter is enum type.
        - Not applicable as there are no methods defined in InputBits.
71. Check whether the formal parameter is record type.
        - Not applicable as there are no methods defined in InputBits.
72. Check whether formal parameter has declared annotations.
        - Not applicable as there are no methods defined in InputBits.
73. Get a declared annotation of formal parameter.
        - Not applicable as there are no methods defined in InputBits.
74. Check whether the formal parameter has x annotation.
        - Not applicable as there are no methods defined in InputBits.
75. Get an usage of formal parameter.
        - Not applicable as there are no methods defined in InputBits.
76. Check whether the formal parameter is final.
        - Not applicable as there are no methods defined in InputBits.
77. Get the return type of method.
        - Not applicable as there are no methods defined in InputBits.
78. Check whether the return type of method is void.
        - Not applicable as there are no methods defined in InputBits.
79. Check whether the return type of method is string type.
        - Not applicable as there are no methods defined in InputBits.
80. Check whether the return type of method is boolean type.
        - Not applicable as there are no methods defined in InputBits.
81. Check whether the return type of method is char type.
        - Not applicable as there are no methods defined in InputBits.
82. Check whether the return type of method is byte type.
        - Not applicable as there are no methods defined in InputBits.
83. Check whether the return type of method is short type.
        - Not applicable as there are no methods defined in InputBits.
84. Check whether the return type of method is int type.
        - Not applicable as there are no methods defined in InputBits.
85. Check whether the return type of method is long type.
        - Not applicable as there are no methods defined in InputBits.
86. Check whether the return type of method is float type.
        - Not applicable as there are no methods defined in InputBits.
87. Check whether the return type of method is double type.
        - Not applicable as there are no methods defined in InputBits.
88. Check whether the return type of method is boxed type.
        - Not applicable as there are no methods defined in InputBits.
89. Check whether the return type of method is x class type.
        - Not applicable as there are no methods defined in InputBits.
90. Check whether the return type of method is array type.
        - Not applicable as there are no methods defined in InputBits.
91. Check whether the return type of method is enum type.
        - Not applicable as there are no methods defined in InputBits.
92. Check whether the return type of method is record type.
        - Not applicable as there are no methods defined in InputBits.
93. Get a throw exception in method signature.
        - Not applicable as there are no methods defined in InputBits.
94. Check whether the method signature throws x Exception.
        - Not applicable as there are no methods defined in InputBits.
95. Check whether method has declared annotations.
        - Not applicable as there are no methods defined in InputBits.
96. Get a declared annotation of method.
        - Not applicable as there are no methods defined in InputBits.
97. Check whether the method has x annotation.
        - Not applicable as there are no methods defined in InputBits.
98. Get the name of constructor.
        - The constructor name is InputBits.
99. Get the signature of constructor.
        - The signature of the constructor is InputBits().
100. Get the javadoc comment of constructor.
        - There is no javadoc comment for the constructor of InputBits.
101. Check whether the constructor is private.
        - The constructor of InputBits is implicitly private.
102. Check whether the constructor is public.
        - The constructor of InputBits is not public.
103. Check whether the constructor is default package-private.
        - The constructor of InputBits is not default package-private.
104. Check whether the constructor is protected.
        - The constructor of InputBits is not protected.
105. Get a formal parameter of constructor.
        - Not applicable as the constructor of InputBits has no formal parameters.
106. Get the number of formal parameters of constructor.
        - The number of formal parameters of the constructor of InputBits is 0.
107. Get a throw exception in constructor signature.
        - Not applicable as there is no throw exception in the constructor signature.
108. Check whether the constructor signature throws x Exception.
        - Not applicable as there is no throw exception in the constructor signature.
109. Check whether constructor has declared annotations.
        - Not applicable as there are no declared annotations in the constructor.
110. Get a declared annotation of constructor.
        - Not applicable as there are no declared annotations in the constructor.
111. Check whether the constructor has x annotation.
        - Not applicable as there are no declared annotations in the constructor.
112. Check whether the class is inner class.
        - The class InputBits is an inner class.
113. Check whether the class is anonymous class.
        - The class InputBits is not an anonymous class.

Based on the checks:
- The class InputBits is an inner class.
- It is private.
- It has no constructors explicitly defined, so the default constructor is implicitly private.
- It does not contain any abstract methods.

Since the inner class InputBits is private and has an implicitly private constructor, it cannot be extended from outside its compilation unit. Therefore, this test case does not violate the rule as it does not contain any abstract methods, and it can be made final. However, the description mentioned it as a violation, which seems to be incorrect based on the rule provided. If the rule intends to report any private inner class as a violation regardless of abstract methods, then the test case would be considered as violating the rule.

So, the correct interpretation and adherence to the provided rule would not consider this a violation, but if the description of the test case is correct and it has to be reported as a violation, then the rule might need a clarification or adjustment.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get the name of the package where the class is located.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get a implemented interface of class.', 'Check whether the class has implemented x interface.', 'Get the name of interface.', 'Check whether interface has declared annotations.', 'Get a declared annotation of interface.', 'Check whether the interface has x annotation.', 'Get the javadoc comment of interface.', 'Check whether the interface is abstract.', 'Check whether the interface is public.', 'Check whether the interface is private.', 'Check whether the interface is protected.', 'Check whether the interface is default package-private.', 'Check whether the interface is final.', 'Check whether the interface is static.', 'Get the super interface of interface.', 'Check whether the interface has extended x interface.', 'Get the name of the package where the interface is located.', 'Check whether the interface is inner interface.', 'Check whether the interface is anonymous class.', 'Get the name of inner class.', 'Check whether inner class has declared annotations.', 'Get a declared annotation of inner class.', 'Check whether the inner class has x annotation.', 'Get the javadoc comment of inner class.', 'Check whether the inner class is abstract.', 'Check whether the inner class is public.', 'Check whether the inner class is private.', 'Check whether the inner class is protected.', 'Check whether the inner class is default package-private.', 'Check whether the inner class is final.', 'Check whether the inner class is static.', 'Get the super class of inner class.', 'Check whether the inner class has extended x class.', 'Get a implemented interface of inner class.', 'Check whether the inner class has implemented x interface.', 'Get the signature of method.', 'Check whether the method is abstract.', 'Check whether the method is private.', 'Check whether the method is public.', 'Check whether the method is default package-private.', 'Check whether the method is protected.', 'Check whether the method is main method.', 'Get the number of formal parameters of method.', 'Get the name of formal parameter.', 'Get the type of formal parameter.', 'Check whether the formal parameter is string type.', 'Check whether the formal parameter is boolean type.', 'Check whether the formal parameter is char type.', 'Check whether the formal parameter is byte type.', 'Check whether the formal parameter is short type.', 'Check whether the formal parameter is int type.', 'Check whether the formal parameter is long type.', 'Check whether the formal parameter is float type.', 'Check whether the formal parameter is double type.', 'Check whether the formal parameter is boxed type.', 'Check whether the formal parameter is a x class type.', 'Check whether the formal parameter is array type.', 'Check whether the formal parameter is enum type.', 'Check whether the formal parameter is record type.', 'Check whether formal parameter has declared annotations.', 'Get a declared annotation of formal parameter.', 'Check whether the formal parameter has x annotation.', 'Get an usage of formal parameter.', 'Check whether the formal parameter is final.', 'Get the return type of method.', 'Check whether the return type of method is void.', 'Check whether the return type of method is string type.', 'Check whether the return type of method is boolean type.', 'Check whether the return type of method is char type.', 'Check whether the return type of method is byte type.', 'Check whether the return type of method is short type.', 'Check whether the return type of method is int type.', 'Check whether the return type of method is long type.', 'Check whether the return type of method is float type.', 'Check whether the return type of method is double type.', 'Check whether the return type of method is boxed type.', 'Check whether the return type of method is x class type.', 'Check whether the return type of method is array type.', 'Check whether the return type of method is enum type.', 'Check whether the return type of method is record type.', 'Get a throw exception in method signature.', 'Check whether the method signature throws x Exception.', 'Check whether method has declared annotations.', 'Get a declared annotation of method.', 'Check whether the method has x annotation.', 'Get the name of constructor.', 'Get the signature of constructor.', 'Get the javadoc comment of constructor.', 'Check whether the constructor is private.', 'Check whether the constructor is public.', 'Check whether the constructor is default package-private.', 'Check whether the constructor is protected.', 'Get a formal parameter of constructor.', 'Get the number of formal parameters of constructor.', 'Get a throw exception in constructor signature.', 'Check whether the constructor signature throws x Exception.', 'Check whether constructor has declared annotations.', 'Get a declared annotation of constructor.', 'Check whether the constructor has x annotation.', 'Check whether the class is inner class.', 'Check whether the class is anonymous class.', 'Get the name of class.', 'Check whether the class has declared annotations.', 'Get the name of the package where the class is located.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get a implemented interface of class.', 'Check whether the class has implemented x interface.', 'Get the name of interface.', 'Check whether interface has declared annotations.', 'Get a declared annotation of interface.', 'Check whether the interface has x annotation.', 'Get the javadoc comment of interface.', 'Check whether the interface is abstract.', 'Check whether the interface is public.', 'Check whether the interface is private.', 'Check whether the interface is protected.', 'Check whether the interface is default package-private.', 'Check whether the interface is final.', 'Check whether the interface is static.', 'Get the super interface of interface.', 'Check whether the interface has extended x interface.', 'Get the name of the package where the interface is located.', 'Check whether the interface is inner interface.', 'Check whether the interface is anonymous class.', 'Get the name of inner class.', 'Check whether inner class has declared annotations.', 'Get a declared annotation of inner class.', 'Check whether the inner class has x annotation.', 'Get the javadoc comment of inner class.', 'Check whether the inner class is abstract.', 'Check whether the inner class is public.', 'Check whether the inner class is private.', 'Check whether the inner class is protected.', 'Check whether the inner class is default package-private.', 'Check whether the inner class is final.', 'Check whether the inner class is static.', 'Get the super class of inner class.', 'Check whether the inner class has extended x class.', 'Get a implemented interface of inner class.', 'Check whether the inner class has implemented x interface.', 'Get the signature of method.', 'Check whether the method is abstract.', 'Check whether the method is private.', 'Check whether the method is public.', 'Check whether the method is default package-private.', 'Check whether the method is protected.', 'Check whether the method is main method.', 'Get the number of formal parameters of method.', 'Get the name of formal parameter.', 'Get the type of formal parameter.', 'Check whether the formal parameter is string type.', 'Check whether the formal parameter is boolean type.', 'Check whether the formal parameter is char type.', 'Check whether the formal parameter is byte type.', 'Check whether the formal parameter is short type.', 'Check whether the formal parameter is int type.', 'Check whether the formal parameter is long type.', 'Check whether the formal parameter is float type.', 'Check whether the formal parameter is double type.', 'Check whether the formal parameter is boxed type.', 'Check whether the formal parameter is a x class type.', 'Check whether the formal parameter is array type.', 'Check whether the formal parameter is enum type.', 'Check whether the formal parameter is record type.', 'Check whether formal parameter has declared annotations.', 'Get a declared annotation of formal parameter.', 'Check whether the formal parameter has x annotation.', 'Get an usage of formal parameter.', 'Check whether the formal parameter is final.', 'Get the return type of method.', 'Check whether the return type of method is void.', 'Check whether the return type of method is string type.', 'Check whether the return type of method is boolean type.', 'Check whether the return type of method is char type.', 'Check whether the return type of method is byte type.', 'Check whether the return type of method is short type.', 'Check whether the return type of method is int type.', 'Check whether the return type of method is long type.', 'Check whether the return type of method is float type.', 'Check whether the return type of method is double type.', 'Check whether the return type of method is boxed type.', 'Check whether the return type of method is x class type.', 'Check whether the return type of method is array type.', 'Check whether the return type of method is enum type.', 'Check whether the return type of method is record type.', 'Get a throw exception in method signature.', 'Check whether the method signature throws x Exception.', 'Check whether method has declared annotations.', 'Get a declared annotation of method.', 'Check whether the method has x annotation.', 'Get the name of constructor.', 'Get the signature of constructor.', 'Get the javadoc comment of constructor.', 'Check whether the constructor is private.', 'Check whether the constructor is public.', 'Check whether the constructor is default package-private.', 'Check whether the constructor is protected.', 'Get a formal parameter of constructor.', 'Get the number of formal parameters of constructor.', 'Get a throw exception in constructor signature.', 'Check whether the constructor signature throws x Exception.', 'Check whether constructor has declared annotations.', 'Get a declared annotation of constructor.', 'Check whether the constructor has x annotation.', 'Check whether the class is inner class.', 'Check whether the class is anonymous class.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'TypesFromAst', 'ASTClassOrInterfaceBody', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853934049606323
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844119548797607
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887725114822388
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520915031433
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851945042610168
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a implemented interface of class.* 匹配到的元操作或API：
logic: Get a implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9851537942886353
*Check whether the class has implemented x interface.* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9905825257301331
*Get the name of interface.* 匹配到的元操作或API：
logic: Get the name of interface.
most similar meta operation: Get the name of interface
cosine Similarity: 0.9824906587600708
*Check whether interface has declared annotations.* 匹配到的元操作或API：
logic: Check whether interface has declared annotations.
most similar meta operation: Check whether interface has declared annotations
cosine Similarity: 0.9906367063522339
*Get a declared annotation of interface.* 匹配到的元操作或API：
logic: Get a declared annotation of interface.
most similar meta operation: Get a declared annotation of interface
cosine Similarity: 0.9874464273452759
*Check whether the interface has x annotation.* 匹配到的元操作或API：
logic: Check whether the interface has x annotation.
most similar meta operation: Check whether the interface has x annotation
cosine Similarity: 0.9911919236183167
*Get the javadoc comment of interface.* 匹配到的元操作或API：
logic: Get the javadoc comment of interface.
most similar meta operation: Get the javadoc comment of interface
cosine Similarity: 0.990967333316803
*Check whether the interface is abstract.* 匹配到的元操作或API：
logic: Check whether the interface is abstract.
most similar meta operation: Check whether the interface is abstract
cosine Similarity: 0.9858804941177368
*Check whether the interface is public.* 匹配到的元操作或API：
logic: Check whether the interface is public.
most similar meta operation: Check whether the interface is public
cosine Similarity: 0.9863296747207642
*Check whether the interface is private.* 匹配到的元操作或API：
logic: Check whether the interface is private.
most similar meta operation: Check whether the interface is private
cosine Similarity: 0.9853708148002625
*Check whether the interface is protected.* 匹配到的元操作或API：
logic: Check whether the interface is protected.
most similar meta operation: Check whether the interface is protected
cosine Similarity: 0.9851821660995483
*Check whether the interface is default package-private.* 匹配到的元操作或API：
logic: Check whether the interface is default package-private.
most similar meta operation: Check whether the interface is default package-private
cosine Similarity: 0.9761513471603394
*Check whether the interface is final.* 匹配到的元操作或API：
logic: Check whether the interface is final.
most similar meta operation: Check whether the interface is final
cosine Similarity: 0.9865636825561523
*Check whether the interface is static.* 匹配到的元操作或API：
logic: Check whether the interface is static.
most similar meta operation: Check whether the interface is static
cosine Similarity: 0.9835489988327026
*Get the super interface of interface.* 匹配到的元操作或API：
logic: Get the super interface of interface.
most similar meta operation: Get the super interface of interface
cosine Similarity: 0.9873321652412415
*Check whether the interface has extended x interface.* 匹配到的元操作或API：
logic: Check whether the interface has extended x interface.
most similar meta operation: Check whether the interface has extended x interface
cosine Similarity: 0.9926908612251282
*Get the name of the package where the interface is located.* 匹配到的元操作或API：
logic: Get the name of the package where the interface is located.
most similar meta operation: Get the name of the package where the interface is located
cosine Similarity: 0.9859918355941772
*Check whether the interface is inner interface.* 匹配到的元操作或API：
logic: Check whether the interface is inner interface.
most similar meta operation: Check whether the interface is inner interface
cosine Similarity: 0.9846948385238647
*Check whether the interface is anonymous class.* 匹配到的元操作或API：
logic: Check whether the interface is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9175833463668823
*Get the name of inner class.* 匹配到的元操作或API：
logic: Get the name of inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.8755849599838257
*Check whether inner class has declared annotations.* 匹配到的元操作或API：
logic: Check whether inner class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9293761849403381
*Get a declared annotation of inner class.* 匹配到的元操作或API：
logic: Get a declared annotation of inner class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9325211644172668
*Check whether the inner class has x annotation.* 匹配到的元操作或API：
logic: Check whether the inner class has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9544621706008911
*Get the javadoc comment of inner class.* 匹配到的元操作或API：
logic: Get the javadoc comment of inner class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9575253129005432
*Check whether the inner class is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.932644784450531
*Check whether the inner class is public.* 匹配到的元操作或API：
logic: Check whether the inner class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9261536002159119
*Check whether the inner class is private.* 匹配到的元操作或API：
logic: Check whether the inner class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9290029406547546
*Check whether the inner class is protected.* 匹配到的元操作或API：
logic: Check whether the inner class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9165269136428833
*Check whether the inner class is default package-private.* 匹配到的元操作或API：
logic: Check whether the inner class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9503231048583984
*Check whether the inner class is final.* 匹配到的元操作或API：
logic: Check whether the inner class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9427244663238525
*Check whether the inner class is static.* 匹配到的元操作或API：
logic: Check whether the inner class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9092439413070679
*Get the super class of inner class.* 匹配到的元操作或API：
logic: Get the super class of inner class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.923866868019104
*Check whether the inner class has extended x class.* 匹配到的元操作或API：
logic: Check whether the inner class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9668768048286438
*Get a implemented interface of inner class.* 匹配到的元操作或API：
logic: Get a implemented interface of inner class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.94257652759552
*Check whether the inner class has implemented x interface.* 匹配到的元操作或API：
logic: Check whether the inner class has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9648982882499695
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827433228492737
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833380579948425
*Check whether the method is private.* 匹配到的元操作或API：
logic: Check whether the method is private.
most similar meta operation: Check whether the method is private
cosine Similarity: 0.982123851776123
*Check whether the method is public.* 匹配到的元操作或API：
logic: Check whether the method is public.
most similar meta operation: Check whether the method is public
cosine Similarity: 0.9820576906204224
*Check whether the method is default package-private.* 匹配到的元操作或API：
logic: Check whether the method is default package-private.
most similar meta operation: Check whether the method is default package-private
cosine Similarity: 0.972201406955719
*Check whether the method is protected.* 匹配到的元操作或API：
logic: Check whether the method is protected.
most similar meta operation: Check whether the method is protected
cosine Similarity: 0.98154217004776
*Check whether the method is main method.* 匹配到的元操作或API：
logic: Check whether the method is main method.
most similar meta operation: Check whether the method is main method
cosine Similarity: 0.9875174760818481
*Get the number of formal parameters of method.* 匹配到的元操作或API：
logic: Get the number of formal parameters of method.
most similar meta operation: Get the number of formal parameters of method
cosine Similarity: 0.9860841035842896
*Get the name of formal parameter.* 匹配到的元操作或API：
logic: Get the name of formal parameter.
most similar meta operation: Get the name of formal parameter
cosine Similarity: 0.9837440252304077
*Get the type of formal parameter.* 匹配到的元操作或API：
logic: Get the type of formal parameter.
most similar meta operation: Get the type of formal parameter
cosine Similarity: 0.985480785369873
*Check whether the formal parameter is string type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is string type.
most similar meta operation: Check whether the formal parameter is string type
cosine Similarity: 0.9882044792175293
*Check whether the formal parameter is boolean type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is boolean type.
most similar meta operation: Check whether the formal parameter is boolean type
cosine Similarity: 0.986154317855835
*Check whether the formal parameter is char type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is char type.
most similar meta operation: Check whether the formal parameter is char type
cosine Similarity: 0.9883655309677124
*Check whether the formal parameter is byte type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is byte type.
most similar meta operation: Check whether the formal parameter is byte type
cosine Similarity: 0.9892827272415161
*Check whether the formal parameter is short type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is short type.
most similar meta operation: Check whether the formal parameter is short type
cosine Similarity: 0.987637996673584
*Check whether the formal parameter is int type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is int type.
most similar meta operation: Check whether the formal parameter is int type
cosine Similarity: 0.9879910945892334
*Check whether the formal parameter is long type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is long type.
most similar meta operation: Check whether the formal parameter is long type
cosine Similarity: 0.9884085059165955
*Check whether the formal parameter is float type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is float type.
most similar meta operation: Check whether the formal parameter is float type
cosine Similarity: 0.9876443147659302
*Check whether the formal parameter is double type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is double type.
most similar meta operation: Check whether the formal parameter is double type
cosine Similarity: 0.987713634967804
*Check whether the formal parameter is boxed type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is boxed type.
most similar meta operation: Check whether the formal parameter is boxed primitive type
cosine Similarity: 0.961267352104187
*Check whether the formal parameter is a x class type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is a x class type.
most similar meta operation: Check whether the formal parameter is a x class type
cosine Similarity: 0.9905358552932739
*Check whether the formal parameter is array type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is array type.
most similar meta operation: Check whether the formal parameter is array type
cosine Similarity: 0.9873113632202148
*Check whether the formal parameter is enum type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is enum type.
most similar meta operation: Check whether the formal parameter is enum type
cosine Similarity: 0.9871471524238586
*Check whether the formal parameter is record type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is record type.
most similar meta operation: Check whether the formal parameter is record type
cosine Similarity: 0.9890473484992981
*Check whether formal parameter has declared annotations.* 匹配到的元操作或API：
logic: Check whether formal parameter has declared annotations.
most similar meta operation: Check whether formal parameter has declared annotations
cosine Similarity: 0.9899721145629883
*Get a declared annotation of formal parameter.* 匹配到的元操作或API：
logic: Get a declared annotation of formal parameter.
most similar meta operation: Get a declared annotation of formal parameter
cosine Similarity: 0.987197756767273
*Check whether the formal parameter has x annotation.* 匹配到的元操作或API：
logic: Check whether the formal parameter has x annotation.
most similar meta operation: Check whether the formal parameter has x annotation
cosine Similarity: 0.98989337682724
*Get an usage of formal parameter.* 匹配到的元操作或API：
logic: Get an usage of formal parameter.
most similar meta operation: Get an usage of formal parameter
cosine Similarity: 0.9862848520278931
*Check whether the formal parameter is final.* 匹配到的元操作或API：
logic: Check whether the formal parameter is final.
most similar meta operation: Check whether the formal parameter is final
cosine Similarity: 0.9881320595741272
*Get the return type of method.* 匹配到的元操作或API：
logic: Get the return type of method.
most similar meta operation: Get the return type of method
cosine Similarity: 0.9835967421531677
*Check whether the return type of method is void.* 匹配到的元操作或API：
logic: Check whether the return type of method is void.
most similar meta operation: Check whether the return type of method is void
cosine Similarity: 0.9854096174240112
*Check whether the return type of method is string type.* 匹配到的元操作或API：
logic: Check whether the return type of method is string type.
most similar meta operation: Check whether the return type of method is string type
cosine Similarity: 0.989208459854126
*Check whether the return type of method is boolean type.* 匹配到的元操作或API：
logic: Check whether the return type of method is boolean type.
most similar meta operation: Check whether the return type of method is boolean
cosine Similarity: 0.9835399985313416
*Check whether the return type of method is char type.* 匹配到的元操作或API：
logic: Check whether the return type of method is char type.
most similar meta operation: Check whether the return type of method is char
cosine Similarity: 0.9825599789619446
*Check whether the return type of method is byte type.* 匹配到的元操作或API：
logic: Check whether the return type of method is byte type.
most similar meta operation: Check whether the return type of method is byte
cosine Similarity: 0.9845081567764282
*Check whether the return type of method is short type.* 匹配到的元操作或API：
logic: Check whether the return type of method is short type.
most similar meta operation: Check whether the return type of called method is short type
cosine Similarity: 0.9720065593719482
*Check whether the return type of method is int type.* 匹配到的元操作或API：
logic: Check whether the return type of method is int type.
most similar meta operation: Check whether the return type of method is int
cosine Similarity: 0.984236478805542
*Check whether the return type of method is long type.* 匹配到的元操作或API：
logic: Check whether the return type of method is long type.
most similar meta operation: Check whether the return type of method is long
cosine Similarity: 0.9787602424621582
*Check whether the return type of method is float type.* 匹配到的元操作或API：
logic: Check whether the return type of method is float type.
most similar meta operation: Check whether the return type of method is float
cosine Similarity: 0.9870142936706543
*Check whether the return type of method is double type.* 匹配到的元操作或API：
logic: Check whether the return type of method is double type.
most similar meta operation: Check whether the return type of method is double
cosine Similarity: 0.9748761653900146
*Check whether the return type of method is boxed type.* 匹配到的元操作或API：
logic: Check whether the return type of method is boxed type.
most similar meta operation: Check whether the return type of called method is boxed type
cosine Similarity: 0.9796502590179443
*Check whether the return type of method is x class type.* 匹配到的元操作或API：
logic: Check whether the return type of method is x class type.
most similar meta operation: Check whether the return type of method is x class type
cosine Similarity: 0.9898589849472046
*Check whether the return type of method is array type.* 匹配到的元操作或API：
logic: Check whether the return type of method is array type.
most similar meta operation: Check whether the return type of method is array type
cosine Similarity: 0.9890990257263184
*Check whether the return type of method is enum type.* 匹配到的元操作或API：
logic: Check whether the return type of method is enum type.
most similar meta operation: Check whether the return type of method is enum type
cosine Similarity: 0.9887509942054749
*Check whether the return type of method is record type.* 匹配到的元操作或API：
logic: Check whether the return type of method is record type.
most similar meta operation: Check whether the return type of method is record type
cosine Similarity: 0.9906390905380249
*Get a throw exception in method signature.* 匹配到的元操作或API：
logic: Get a throw exception in method signature.
most similar meta operation: Get a throw exception in method signature
cosine Similarity: 0.9811146259307861
*Check whether the method signature throws x Exception.* 匹配到的元操作或API：
logic: Check whether the method signature throws x Exception.
most similar meta operation: Check whether the method signature throws x Exception
cosine Similarity: 0.9918777346611023
*Check whether method has declared annotations.* 匹配到的元操作或API：
logic: Check whether method has declared annotations.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9891548156738281
*Get a declared annotation of method.* 匹配到的元操作或API：
logic: Get a declared annotation of method.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9867770075798035
*Check whether the method has x annotation.* 匹配到的元操作或API：
logic: Check whether the method has x annotation.
most similar meta operation: Check whether the method has x annotation
cosine Similarity: 0.9902997016906738
*Get the name of constructor.* 匹配到的元操作或API：
logic: Get the name of constructor.
most similar meta operation: Get the name of constructor
cosine Similarity: 0.9789291620254517
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828829765319824
*Get the javadoc comment of constructor.* 匹配到的元操作或API：
logic: Get the javadoc comment of constructor.
most similar meta operation: Get the javadoc comment of constructor
cosine Similarity: 0.990827739238739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Check whether the constructor is default package-private.* 匹配到的元操作或API：
logic: Check whether the constructor is default package-private.
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.961661159992218
*Check whether the constructor is protected.* 匹配到的元操作或API：
logic: Check whether the constructor is protected.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9850410223007202
*Get a formal parameter of constructor.* 匹配到的元操作或API：
logic: Get a formal parameter of constructor.
most similar meta operation: Get a formal parameter of constructor
cosine Similarity: 0.9820768237113953
*Get the number of formal parameters of constructor.* 匹配到的元操作或API：
logic: Get the number of formal parameters of constructor.
most similar meta operation: Get the number of formal parameters of constructor
cosine Similarity: 0.9865635633468628
*Get a throw exception in constructor signature.* 匹配到的元操作或API：
logic: Get a throw exception in constructor signature.
most similar meta operation: Get a throw exception in constructor signature
cosine Similarity: 0.9784085154533386
*Check whether the constructor signature throws x Exception.* 匹配到的元操作或API：
logic: Check whether the constructor signature throws x Exception.
most similar meta operation: Check whether the constructor signature throws x Exception
cosine Similarity: 0.992306113243103
*Check whether constructor has declared annotations.* 匹配到的元操作或API：
logic: Check whether constructor has declared annotations.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.9901278018951416
*Get a declared annotation of constructor.* 匹配到的元操作或API：
logic: Get a declared annotation of constructor.
most similar meta operation: Get a declared annotation of constructor
cosine Similarity: 0.9872555732727051
*Check whether the constructor has x annotation.* 匹配到的元操作或API：
logic: Check whether the constructor has x annotation.
most similar meta operation: Check whether the constructor has x annotation
cosine Similarity: 0.9916678667068481
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9875447154045105
*Check whether the class is anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9849607944488525
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853934049606323
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844119548797607
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887725114822388
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520915031433
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851945042610168
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a implemented interface of class.* 匹配到的元操作或API：
logic: Get a implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9851537942886353
*Check whether the class has implemented x interface.* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9905825257301331
*Get the name of interface.* 匹配到的元操作或API：
logic: Get the name of interface.
most similar meta operation: Get the name of interface
cosine Similarity: 0.9824906587600708
*Check whether interface has declared annotations.* 匹配到的元操作或API：
logic: Check whether interface has declared annotations.
most similar meta operation: Check whether interface has declared annotations
cosine Similarity: 0.9906367063522339
*Get a declared annotation of interface.* 匹配到的元操作或API：
logic: Get a declared annotation of interface.
most similar meta operation: Get a declared annotation of interface
cosine Similarity: 0.9874464273452759
*Check whether the interface has x annotation.* 匹配到的元操作或API：
logic: Check whether the interface has x annotation.
most similar meta operation: Check whether the interface has x annotation
cosine Similarity: 0.9911919236183167
*Get the javadoc comment of interface.* 匹配到的元操作或API：
logic: Get the javadoc comment of interface.
most similar meta operation: Get the javadoc comment of interface
cosine Similarity: 0.990967333316803
*Check whether the interface is abstract.* 匹配到的元操作或API：
logic: Check whether the interface is abstract.
most similar meta operation: Check whether the interface is abstract
cosine Similarity: 0.9858804941177368
*Check whether the interface is public.* 匹配到的元操作或API：
logic: Check whether the interface is public.
most similar meta operation: Check whether the interface is public
cosine Similarity: 0.9863296747207642
*Check whether the interface is private.* 匹配到的元操作或API：
logic: Check whether the interface is private.
most similar meta operation: Check whether the interface is private
cosine Similarity: 0.9853708148002625
*Check whether the interface is protected.* 匹配到的元操作或API：
logic: Check whether the interface is protected.
most similar meta operation: Check whether the interface is protected
cosine Similarity: 0.9851821660995483
*Check whether the interface is default package-private.* 匹配到的元操作或API：
logic: Check whether the interface is default package-private.
most similar meta operation: Check whether the interface is default package-private
cosine Similarity: 0.9761513471603394
*Check whether the interface is final.* 匹配到的元操作或API：
logic: Check whether the interface is final.
most similar meta operation: Check whether the interface is final
cosine Similarity: 0.9865636825561523
*Check whether the interface is static.* 匹配到的元操作或API：
logic: Check whether the interface is static.
most similar meta operation: Check whether the interface is static
cosine Similarity: 0.9835489988327026
*Get the super interface of interface.* 匹配到的元操作或API：
logic: Get the super interface of interface.
most similar meta operation: Get the super interface of interface
cosine Similarity: 0.9873321652412415
*Check whether the interface has extended x interface.* 匹配到的元操作或API：
logic: Check whether the interface has extended x interface.
most similar meta operation: Check whether the interface has extended x interface
cosine Similarity: 0.9926908612251282
*Get the name of the package where the interface is located.* 匹配到的元操作或API：
logic: Get the name of the package where the interface is located.
most similar meta operation: Get the name of the package where the interface is located
cosine Similarity: 0.9859918355941772
*Check whether the interface is inner interface.* 匹配到的元操作或API：
logic: Check whether the interface is inner interface.
most similar meta operation: Check whether the interface is inner interface
cosine Similarity: 0.9846948385238647
*Check whether the interface is anonymous class.* 匹配到的元操作或API：
logic: Check whether the interface is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9175833463668823
*Get the name of inner class.* 匹配到的元操作或API：
logic: Get the name of inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.8755849599838257
*Check whether inner class has declared annotations.* 匹配到的元操作或API：
logic: Check whether inner class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9293761849403381
*Get a declared annotation of inner class.* 匹配到的元操作或API：
logic: Get a declared annotation of inner class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9325211644172668
*Check whether the inner class has x annotation.* 匹配到的元操作或API：
logic: Check whether the inner class has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9544621706008911
*Get the javadoc comment of inner class.* 匹配到的元操作或API：
logic: Get the javadoc comment of inner class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9575253129005432
*Check whether the inner class is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.932644784450531
*Check whether the inner class is public.* 匹配到的元操作或API：
logic: Check whether the inner class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9261536002159119
*Check whether the inner class is private.* 匹配到的元操作或API：
logic: Check whether the inner class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9290029406547546
*Check whether the inner class is protected.* 匹配到的元操作或API：
logic: Check whether the inner class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9165269136428833
*Check whether the inner class is default package-private.* 匹配到的元操作或API：
logic: Check whether the inner class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9503231048583984
*Check whether the inner class is final.* 匹配到的元操作或API：
logic: Check whether the inner class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9427244663238525
*Check whether the inner class is static.* 匹配到的元操作或API：
logic: Check whether the inner class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9092439413070679
*Get the super class of inner class.* 匹配到的元操作或API：
logic: Get the super class of inner class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.923866868019104
*Check whether the inner class has extended x class.* 匹配到的元操作或API：
logic: Check whether the inner class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9668768048286438
*Get a implemented interface of inner class.* 匹配到的元操作或API：
logic: Get a implemented interface of inner class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.94257652759552
*Check whether the inner class has implemented x interface.* 匹配到的元操作或API：
logic: Check whether the inner class has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9648982882499695
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827433228492737
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833380579948425
*Check whether the method is private.* 匹配到的元操作或API：
logic: Check whether the method is private.
most similar meta operation: Check whether the method is private
cosine Similarity: 0.982123851776123
*Check whether the method is public.* 匹配到的元操作或API：
logic: Check whether the method is public.
most similar meta operation: Check whether the method is public
cosine Similarity: 0.9820576906204224
*Check whether the method is default package-private.* 匹配到的元操作或API：
logic: Check whether the method is default package-private.
most similar meta operation: Check whether the method is default package-private
cosine Similarity: 0.972201406955719
*Check whether the method is protected.* 匹配到的元操作或API：
logic: Check whether the method is protected.
most similar meta operation: Check whether the method is protected
cosine Similarity: 0.98154217004776
*Check whether the method is main method.* 匹配到的元操作或API：
logic: Check whether the method is main method.
most similar meta operation: Check whether the method is main method
cosine Similarity: 0.9875174760818481
*Get the number of formal parameters of method.* 匹配到的元操作或API：
logic: Get the number of formal parameters of method.
most similar meta operation: Get the number of formal parameters of method
cosine Similarity: 0.9860841035842896
*Get the name of formal parameter.* 匹配到的元操作或API：
logic: Get the name of formal parameter.
most similar meta operation: Get the name of formal parameter
cosine Similarity: 0.9837440252304077
*Get the type of formal parameter.* 匹配到的元操作或API：
logic: Get the type of formal parameter.
most similar meta operation: Get the type of formal parameter
cosine Similarity: 0.985480785369873
*Check whether the formal parameter is string type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is string type.
most similar meta operation: Check whether the formal parameter is string type
cosine Similarity: 0.9882044792175293
*Check whether the formal parameter is boolean type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is boolean type.
most similar meta operation: Check whether the formal parameter is boolean type
cosine Similarity: 0.986154317855835
*Check whether the formal parameter is char type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is char type.
most similar meta operation: Check whether the formal parameter is char type
cosine Similarity: 0.9883655309677124
*Check whether the formal parameter is byte type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is byte type.
most similar meta operation: Check whether the formal parameter is byte type
cosine Similarity: 0.9892827272415161
*Check whether the formal parameter is short type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is short type.
most similar meta operation: Check whether the formal parameter is short type
cosine Similarity: 0.987637996673584
*Check whether the formal parameter is int type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is int type.
most similar meta operation: Check whether the formal parameter is int type
cosine Similarity: 0.9879910945892334
*Check whether the formal parameter is long type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is long type.
most similar meta operation: Check whether the formal parameter is long type
cosine Similarity: 0.9884085059165955
*Check whether the formal parameter is float type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is float type.
most similar meta operation: Check whether the formal parameter is float type
cosine Similarity: 0.9876443147659302
*Check whether the formal parameter is double type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is double type.
most similar meta operation: Check whether the formal parameter is double type
cosine Similarity: 0.987713634967804
*Check whether the formal parameter is boxed type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is boxed type.
most similar meta operation: Check whether the formal parameter is boxed primitive type
cosine Similarity: 0.961267352104187
*Check whether the formal parameter is a x class type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is a x class type.
most similar meta operation: Check whether the formal parameter is a x class type
cosine Similarity: 0.9905358552932739
*Check whether the formal parameter is array type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is array type.
most similar meta operation: Check whether the formal parameter is array type
cosine Similarity: 0.9873113632202148
*Check whether the formal parameter is enum type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is enum type.
most similar meta operation: Check whether the formal parameter is enum type
cosine Similarity: 0.9871471524238586
*Check whether the formal parameter is record type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is record type.
most similar meta operation: Check whether the formal parameter is record type
cosine Similarity: 0.9890473484992981
*Check whether formal parameter has declared annotations.* 匹配到的元操作或API：
logic: Check whether formal parameter has declared annotations.
most similar meta operation: Check whether formal parameter has declared annotations
cosine Similarity: 0.9899721145629883
*Get a declared annotation of formal parameter.* 匹配到的元操作或API：
logic: Get a declared annotation of formal parameter.
most similar meta operation: Get a declared annotation of formal parameter
cosine Similarity: 0.987197756767273
*Check whether the formal parameter has x annotation.* 匹配到的元操作或API：
logic: Check whether the formal parameter has x annotation.
most similar meta operation: Check whether the formal parameter has x annotation
cosine Similarity: 0.98989337682724
*Get an usage of formal parameter.* 匹配到的元操作或API：
logic: Get an usage of formal parameter.
most similar meta operation: Get an usage of formal parameter
cosine Similarity: 0.9862848520278931
*Check whether the formal parameter is final.* 匹配到的元操作或API：
logic: Check whether the formal parameter is final.
most similar meta operation: Check whether the formal parameter is final
cosine Similarity: 0.9881320595741272
*Get the return type of method.* 匹配到的元操作或API：
logic: Get the return type of method.
most similar meta operation: Get the return type of method
cosine Similarity: 0.9835967421531677
*Check whether the return type of method is void.* 匹配到的元操作或API：
logic: Check whether the return type of method is void.
most similar meta operation: Check whether the return type of method is void
cosine Similarity: 0.9854096174240112
*Check whether the return type of method is string type.* 匹配到的元操作或API：
logic: Check whether the return type of method is string type.
most similar meta operation: Check whether the return type of method is string type
cosine Similarity: 0.989208459854126
*Check whether the return type of method is boolean type.* 匹配到的元操作或API：
logic: Check whether the return type of method is boolean type.
most similar meta operation: Check whether the return type of method is boolean
cosine Similarity: 0.9835399985313416
*Check whether the return type of method is char type.* 匹配到的元操作或API：
logic: Check whether the return type of method is char type.
most similar meta operation: Check whether the return type of method is char
cosine Similarity: 0.9825599789619446
*Check whether the return type of method is byte type.* 匹配到的元操作或API：
logic: Check whether the return type of method is byte type.
most similar meta operation: Check whether the return type of method is byte
cosine Similarity: 0.9845081567764282
*Check whether the return type of method is short type.* 匹配到的元操作或API：
logic: Check whether the return type of method is short type.
most similar meta operation: Check whether the return type of called method is short type
cosine Similarity: 0.9720065593719482
*Check whether the return type of method is int type.* 匹配到的元操作或API：
logic: Check whether the return type of method is int type.
most similar meta operation: Check whether the return type of method is int
cosine Similarity: 0.984236478805542
*Check whether the return type of method is long type.* 匹配到的元操作或API：
logic: Check whether the return type of method is long type.
most similar meta operation: Check whether the return type of method is long
cosine Similarity: 0.9787602424621582
*Check whether the return type of method is float type.* 匹配到的元操作或API：
logic: Check whether the return type of method is float type.
most similar meta operation: Check whether the return type of method is float
cosine Similarity: 0.9870142936706543
*Check whether the return type of method is double type.* 匹配到的元操作或API：
logic: Check whether the return type of method is double type.
most similar meta operation: Check whether the return type of method is double
cosine Similarity: 0.9748761653900146
*Check whether the return type of method is boxed type.* 匹配到的元操作或API：
logic: Check whether the return type of method is boxed type.
most similar meta operation: Check whether the return type of called method is boxed type
cosine Similarity: 0.9796502590179443
*Check whether the return type of method is x class type.* 匹配到的元操作或API：
logic: Check whether the return type of method is x class type.
most similar meta operation: Check whether the return type of method is x class type
cosine Similarity: 0.9898589849472046
*Check whether the return type of method is array type.* 匹配到的元操作或API：
logic: Check whether the return type of method is array type.
most similar meta operation: Check whether the return type of method is array type
cosine Similarity: 0.9890990257263184
*Check whether the return type of method is enum type.* 匹配到的元操作或API：
logic: Check whether the return type of method is enum type.
most similar meta operation: Check whether the return type of method is enum type
cosine Similarity: 0.9887509942054749
*Check whether the return type of method is record type.* 匹配到的元操作或API：
logic: Check whether the return type of method is record type.
most similar meta operation: Check whether the return type of method is record type
cosine Similarity: 0.9906390905380249
*Get a throw exception in method signature.* 匹配到的元操作或API：
logic: Get a throw exception in method signature.
most similar meta operation: Get a throw exception in method signature
cosine Similarity: 0.9811146259307861
*Check whether the method signature throws x Exception.* 匹配到的元操作或API：
logic: Check whether the method signature throws x Exception.
most similar meta operation: Check whether the method signature throws x Exception
cosine Similarity: 0.9918777346611023
*Check whether method has declared annotations.* 匹配到的元操作或API：
logic: Check whether method has declared annotations.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9891548156738281
*Get a declared annotation of method.* 匹配到的元操作或API：
logic: Get a declared annotation of method.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9867770075798035
*Check whether the method has x annotation.* 匹配到的元操作或API：
logic: Check whether the method has x annotation.
most similar meta operation: Check whether the method has x annotation
cosine Similarity: 0.9902997016906738
*Get the name of constructor.* 匹配到的元操作或API：
logic: Get the name of constructor.
most similar meta operation: Get the name of constructor
cosine Similarity: 0.9789291620254517
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828829765319824
*Get the javadoc comment of constructor.* 匹配到的元操作或API：
logic: Get the javadoc comment of constructor.
most similar meta operation: Get the javadoc comment of constructor
cosine Similarity: 0.990827739238739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Check whether the constructor is default package-private.* 匹配到的元操作或API：
logic: Check whether the constructor is default package-private.
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.961661159992218
*Check whether the constructor is protected.* 匹配到的元操作或API：
logic: Check whether the constructor is protected.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9850410223007202
*Get a formal parameter of constructor.* 匹配到的元操作或API：
logic: Get a formal parameter of constructor.
most similar meta operation: Get a formal parameter of constructor
cosine Similarity: 0.9820768237113953
*Get the number of formal parameters of constructor.* 匹配到的元操作或API：
logic: Get the number of formal parameters of constructor.
most similar meta operation: Get the number of formal parameters of constructor
cosine Similarity: 0.9865635633468628
*Get a throw exception in constructor signature.* 匹配到的元操作或API：
logic: Get a throw exception in constructor signature.
most similar meta operation: Get a throw exception in constructor signature
cosine Similarity: 0.9784085154533386
*Check whether the constructor signature throws x Exception.* 匹配到的元操作或API：
logic: Check whether the constructor signature throws x Exception.
most similar meta operation: Check whether the constructor signature throws x Exception
cosine Similarity: 0.992306113243103
*Check whether constructor has declared annotations.* 匹配到的元操作或API：
logic: Check whether constructor has declared annotations.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.9901278018951416
*Get a declared annotation of constructor.* 匹配到的元操作或API：
logic: Get a declared annotation of constructor.
most similar meta operation: Get a declared annotation of constructor
cosine Similarity: 0.9872555732727051
*Check whether the constructor has x annotation.* 匹配到的元操作或API：
logic: Check whether the constructor has x annotation.
most similar meta operation: Check whether the constructor has x annotation
cosine Similarity: 0.9916678667068481
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9875447154045105
*Check whether the class is anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9849607944488525
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Private inner class with no ctor and no usage
public class Main209 {
    private static class InputBits {
        // default ctor is implicitly private
    }
}
The description of this test case is: bad 4
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isProtected()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
11. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getSuperInterfaceTypeNodes()
12. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
13. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
14. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
15. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
16. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnonymous()
17. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
18. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
19. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPrivate()
20. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPublic()
21. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPackagePrivate()
22. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isProtected()
23. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isMainMethod()
24. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
25. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
26. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public boolean isAnyAnnotationPresent(java.util.Collection)
27. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public boolean isFinal()
28. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getResultTypeNode()
29. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isVoid()
30. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTThrowsList getThrowsList()
31. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
32. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
33. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.String getName()
34. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
35. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
36. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
37. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()
38. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPackagePrivate()
39. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isProtected()
40. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTFormalParameters getFormalParameters()
41. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTThrowsList getThrowsList()
42. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
43. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```
3.  //Check whether the class has implemented x interface
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node) {
    if (TypeTestUtil.isA(interfaceName.class, node)) {
        return true;
    }
    return false;
}
```
4.  //Get the number of formal parameters of method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTMethodDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```
5.  //Get the name of formal parameter
```java
import net.sourceforge.pmd.lang.java.ast.*;
public String getFormalParameterName(ASTFormalParameter node) {
    return node.getVarId().getName();
}
```
6.  //Check whether the formal parameter is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFormalParameterStringType(ASTFormalParameter node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```
7.  //Check whether the formal parameter is boolean type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterBooleanType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN);
}
```
8.  //Check whether the formal parameter is char type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterCharType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.CHAR);
}
```
9.  //Check whether the formal parameter is byte type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterByteType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
}
```
10.  //Check whether the formal parameter is short type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterShortType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.SHORT);
}
```
11.  //Check whether the formal parameter is int type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterIntType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.INT);
}
```
12.  //Check whether the formal parameter is long type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterLongType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.LONG);
}
```
13.  //Check whether the formal parameter is float type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterFloatType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.FLOAT);
}
```
14.  //Check whether the formal parameter is double type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterDoubleType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.DOUBLE);
}
```
15.  //Check whether the formal parameter is boxed primitive type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public boolean isFormalParameterBoxedPrimitiveType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isBoxedPrimitive();
}
```
16.  //Check whether the formal parameter is a x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFormalParameterClassType(ASTFormalParameter node) {
    return TypeTestUtil.isA(x.class, node.getTypeNode());
}
```
17.  //Check whether the formal parameter is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isFormalParameterArrayType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```
18.  //Check whether the formal parameter is enum type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isFormalParameterEnumType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) type.getTypeMirror().getSymbol()).isEnum();
}
```
19.  //Check whether the formal parameter is record type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isFormalParameterRecordType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) type.getTypeMirror().getSymbol()).isRecord();
}
```
20.  //Check whether formal parameter has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotation(ASTFormalParameter node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```
21.  //Get an usage of formal parameter
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr;
import java.util.List;
public List<ASTAssignableExpr.ASTNamedReferenceExpr> getAUsage(ASTFormalParameter node){
    List<ASTAssignableExpr.ASTNamedReferenceExpr> localUsages = node.getVarId().getLocalUsages();
    return localUsages;
}
```
22.  //Check whether the return type of method is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnValueStringType(ASTMethodDeclaration method) {
    return TypeTestUtil.isA(String.class, method.getResultTypeNode());
}
```
23.  //Check whether the return type of method is boolean
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueBooleanType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN)) {
        return true;
    }
    return false;
}
```
24.  //Check whether the return type of method is char
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueCharType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.CHAR)) {
        return true;
    }
    return false;
}
```
25.  //Check whether the return type of method is byte
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueByteType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE)) {
        return true;
    }
    return false;
}
```
26.  //Check whether the return type of called method is short type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.JMethodSig;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnShortType(ASTMethodCall call) {
    JMethodSig m = call.getMethodType();
    return m.getReturnType().isPrimitive(JPrimitiveType.PrimitiveTypeKind.SHORT);
}
```
27.  //Check whether the return type of method is int
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueIntType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.INT)) {
        return true;
    }
    return false;
}
```
28.  //Check whether the return type of method is long
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueLongType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.LONG)) {
        return true;
    }
    return false;
}
```
29.  //Check whether the return type of method is float
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueFloatType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.FLOAT)) {
        return true;
    }
    return false;
}
```
30.  //Check whether the return type of method is double
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueDoubleType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.DOUBLE)) {
        return true;
    }
    return false;
}
```
31.  //Check whether the return type of called method is boxed type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.JMethodSig;
public boolean isReturnBoxedPrimitiveType(ASTMethodCall call) {
    JMethodSig m = call.getMethodType();
    return m.getReturnType().isBoxedPrimitive();
}
```
32.  //Check whether the return type of method is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnValueClassType(ASTMethodDeclaration method) {
    return TypeTestUtil.isA(x.class, method.getResultTypeNode());
}
```
33.  //Check whether the return type of method is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
public boolean isReturnValueArrayType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isArray()) {
        return true;
    }
    return false;
}
```
34.  //Check whether the return type of method is enum type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isReturnValueEnumType(ASTMethodDeclaration method) {
    return method.getResultTypeNode().getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) method.getResultTypeNode().getTypeMirror().getSymbol()).isEnum();
}
```
35.  //Check whether the return type of method is record type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isReturnValueRecordType(ASTMethodDeclaration method) {
    return method.getResultTypeNode().getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) method.getResultTypeNode().getTypeMirror().getSymbol()).isRecord();
}
```
36.  //Check whether the method signature throws x Exception
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean throwsSpecificException(ASTMethodDeclaration node){
    ASTThrowsList list = node.getThrowsList();
    if(list == null){
        return false;
    }else{
        for(ASTClassOrInterfaceType classOrInterfaceType : list){
            if(TypeTestUtil.isA(x.class, classOrInterfaceType)){
                return true;
            }
        }
    }
    return false;
}
```
37.  //Check whether method has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTMethodDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```
38.  //Get the number of formal parameters of constructor
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTConstructorDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```
39.  //Check whether the constructor signature throws x Exception
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean throwsSpecificException(ASTConstructorDeclaration node){
    ASTThrowsList list = node.getThrowsList();
    if(list == null){
        return false;
    }else{
        for(ASTClassOrInterfaceType classOrInterfaceType : list){
            if(TypeTestUtil.isA(x.class, classOrInterfaceType)){
                return true;
            }
        }
    }
    return false;
}
```
40.  //Check whether constructor has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTConstructorDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal() && !node.hasAnnotations() && !hasImplementComparable(node) && !extendsSpecificClass(node)) {
            boolean allConstructorsPrivate = true;
            for (ASTConstructorDeclaration constructor : node.descendants(ASTConstructorDeclaration.class)) {
                if (!constructor.isPrivate()) {
                    allConstructorsPrivate = false;
                    break;
                }
            }
            if (allConstructorsPrivate) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }

    public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTClassOrInterfaceType> interfaces = node.getSuperInterfaceTypeNodes();
        return interfaces.anyMatch(interf -> interf.getName().equals("Comparable"));
    }

    public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node) {
        ASTClassOrInterfaceType superClass = node.getSuperClassTypeNode();
        return superClass != null && !superClass.getName().equals("Object");
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 4
1233
939
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class has declared annotations.
3. Get a declared annotation of class.
4. Check whether the class is abstract.
5. Get all constructors declared in class.
6. Check whether the constructor is private.
7. Check whether the class has any subclasses.
8. Check whether the class is public.
9. Check whether the class is final.

To ascertain the adherence to the rule:

1. Get the name of class (Base).
2. Check whether the class has declared annotations (No annotations present).
3. Check whether the class is abstract (Yes, Base is abstract).
4. Get all constructors declared in class (Base has no explicitly declared constructors).
5. Since there are no explicitly declared constructors, we infer that the default constructor is present. Check whether the constructor is private (No, the default constructor is not private).
6. Check whether the class has any subclasses (No subclasses are declared).
7. Check whether the class is public (No, Base is private).
8. Check whether the class is final (No, Base is not final).

The test case does not adhere to the rule description because:
- The class `Base` is not public, so it cannot be extended from outside its compilation unit regardless of its constructors.
- The class `Base` is private, which makes it impossible to extend from outside its compilation unit.

The provided description "bad 5" and the number of violations "1" seem to suggest a different interpretation or a specific context that wasn't captured in the initial rule description. Given the rule description provided, `Base` should not be reported as a violation because it is private and thus cannot be extended from outside its compilation unit.

However, if the rule is intended to catch private abstract classes that could be made final (despite being abstract), and there is a specific reason why such classes should be flagged (e.g., they are intended to be utility classes or should not have any subclasses), the test case would be a valid violation under that specific context.

For the given rule description, this test case does not violate the rule. If you have a specific context or additional details, please provide them for a more accurate assessment.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has any subclasses.', 'Check whether the class is public.', 'Check whether the class is final.', 'Get the name of class (Base).', 'Check whether the class has declared annotations (No annotations present).', 'Check whether the class is abstract (Yes, Base is abstract).', 'Get all constructors declared in class (Base has no explicitly declared constructors).', 'Since there are no explicitly declared constructors, we infer that the default constructor is present. Check whether the constructor is private (No, the default constructor is not private).', 'Check whether the class has any subclasses (No subclasses are declared).', 'Check whether the class is public (No, Base is private).', 'Check whether the class is final (No, Base is not final).']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9878389835357666
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class has any subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887725114822388
*Get the name of class (Base).* 匹配到的元操作或API：
logic: Get the name of class (Base).
most similar meta operation: Get the name of class
cosine Similarity: 0.8888645172119141
*Check whether the class has declared annotations (No annotations present).* 匹配到的元操作或API：
logic: Check whether the class has declared annotations (No annotations present).
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9559304118156433
*Check whether the class is abstract (Yes, Base is abstract).* 匹配到的元操作或API：
logic: Check whether the class is abstract (Yes, Base is abstract).
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9319409132003784
*Get all constructors declared in class (Base has no explicitly declared constructors).* 匹配到的元操作或API：
未匹配成功元操作或API
*Since there are no explicitly declared constructors, we infer that the default constructor is present. Check whether the constructor is private (No, the default constructor is not private).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has any subclasses (No subclasses are declared).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is public (No, Base is private).* 匹配到的元操作或API：
logic: Check whether the class is public (No, Base is private).
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9293055534362793
*Check whether the class is final (No, Base is not final).* 匹配到的元操作或API：
logic: Check whether the class is final (No, Base is not final).
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9354207515716553
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Private abstract classes without abstract methods and subclasses #3668
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
The description of this test case is: bad 5
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal() && !hasAnnotations(node)) {
            ASTClassOrInterfaceBody body = node.getFirstChildOfType(ASTClassOrInterfaceBody.class);
            if (body != null) {
                boolean hasNonPrivateConstructors = false;
                boolean hasPrivateConstructors = false;

                for (ASTConstructorDeclaration constructor : body.getChildrenOfType(ASTConstructorDeclaration.class)) {
                    if (constructor.isPrivate()) {
                        hasPrivateConstructors = true;
                    } else {
                        hasNonPrivateConstructors = true;
                    }
                }

                if (hasPrivateConstructors && !hasNonPrivateConstructors && !node.isAbstract()) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class has declared annotations.
3. Get the declared annotations of class.
4. Check whether the class is abstract.
5. Get all constructors declared in class.
6. Check whether the constructor is private.
7. Check whether the class has any subclasses declared within the same compilation unit.
8. Check whether the class has any subclasses declared outside the compilation unit.

For the provided test case:
1. The name of the class is `Base`.
2. Check whether the class has declared annotations.
3. Get the declared annotations of class (none in this case).
4. Check whether the class is abstract (yes).
5. Get all constructors declared in class.
6. Check whether the constructor is private (no constructors are shown, but if there were any, we would check their access level).
7. Check whether the class has any subclasses declared within the same compilation unit (none shown in the snippet).
8. Check whether the class has any subclasses declared outside the compilation unit (cannot be determined from the snippet, but for the purpose of this check, we assume there are none outside the compilation unit).

Given the test case, the key checks are:
4. Check whether the class is abstract (yes).
5. Get all constructors declared in class (there are no constructors shown, but we can infer that if there were no constructors, a default private constructor would be present, or if constructors were present, they would need to be private).
7. Check whether the class has any subclasses declared within the same compilation unit (none shown in the snippet).

Since the class `Base` is abstract and has no constructors declared, it implies a default private constructor exists, preventing it from being extended outside the `Outer` class. However, the rule specifically states that classes with abstract methods should not be reported. So, we need to check for abstract methods as well:
5. Get all methods declared in class.
6. Check whether method is abstract (none in this case).

Since there are no abstract methods, the presence of a private constructor would make the class eligible to be made final because it cannot be extended from outside its compilation unit. Therefore, this test case violates the rule.

However, given the description "bad 5" and the number of violations "1", it seems there may be another aspect to the rule or additional context not provided in the snippet. The checks above should be sufficient for the given rule, but if there are other specifics, they would need to be addressed accordingly.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get the declared annotations of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has any subclasses declared within the same compilation unit.', 'Check whether the class has any subclasses declared outside the compilation unit.', 'The name of the class is `Base`.', 'Check whether the class has declared annotations.', 'Get the declared annotations of class (none in this case).', 'Check whether the class is abstract (yes).', 'Get all constructors declared in class.', 'Check whether the constructor is private (no constructors are shown, but if there were any, we would check their access level).', 'Check whether the class has any subclasses declared within the same compilation unit (none shown in the snippet).', 'Check whether the class has any subclasses declared outside the compilation unit (cannot be determined from the snippet, but for the purpose of this check, we assume there are none outside the compilation unit).', 'Check whether the class is abstract (yes).', 'Get all constructors declared in class (there are no constructors shown, but we can infer that if there were no constructors, a default private constructor would be present, or if constructors were present, they would need to be private).', 'Check whether the class has any subclasses declared within the same compilation unit (none shown in the snippet).', 'Get all methods declared in class.', 'Check whether method is abstract (none in this case).']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get the declared annotations of class.* 匹配到的元操作或API：
logic: Get the declared annotations of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9313311576843262
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class has any subclasses declared within the same compilation unit.* 匹配到的元操作或API：
query: Check whether the class has any subclasses declared within the same compilation unit.
most similar API: Check whether is declared in class
cosine Similarity: 0.802797257900238
*Check whether the class has any subclasses declared outside the compilation unit.* 匹配到的元操作或API：
query: Check whether the class has any subclasses declared outside the compilation unit.
most similar API: Check whether is declared in class
cosine Similarity: 0.8070017099380493
*The name of the class is `Base`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get the declared annotations of class (none in this case).* 匹配到的元操作或API：
logic: Get the declared annotations of class (none in this case).
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.901868462562561
*Check whether the class is abstract (yes).* 匹配到的元操作或API：
logic: Check whether the class is abstract (yes).
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9448426961898804
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private (no constructors are shown, but if there were any, we would check their access level).* 匹配到的元操作或API：
logic: Check whether the constructor is private (no constructors are shown, but if there were any, we would check their access level).
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9435516595840454
*Check whether the class has any subclasses declared within the same compilation unit (none shown in the snippet).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has any subclasses declared outside the compilation unit (cannot be determined from the snippet, but for the purpose of this check, we assume there are none outside the compilation unit).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is abstract (yes).* 匹配到的元操作或API：
logic: Check whether the class is abstract (yes).
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9448426961898804
*Get all constructors declared in class (there are no constructors shown, but we can infer that if there were no constructors, a default private constructor would be present, or if constructors were present, they would need to be private).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has any subclasses declared within the same compilation unit (none shown in the snippet).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366355895996094
*Check whether method is abstract (none in this case).* 匹配到的元操作或API：
logic: Check whether method is abstract (none in this case).
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9486003518104553
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Private abstract classes without abstract methods and subclasses #3668
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
The description of this test case is: bad 5
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.types.TypeTestUtil: static public boolean isDeclaredInClass(java.lang.Class, net.sourceforge.pmd.lang.java.types.JMethodSig), //Returns true if the signature is that of a method declared in the given class. @param klass Class @param sig   Method signature to test @throws NullPointerException If any argument is null
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!hasAnnotations(node) && node.isClass() && !node.isFinal()) {
            boolean allConstructorsPrivate = node.getDeclaredConstructors().allMatch(ASTConstructorDeclaration::isPrivate);
            if (allConstructorsPrivate) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Check whether class has declared annotations
    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class is public.
3. Check whether the class has a private constructor.
4. Check whether the class is abstract.
5. Get all methods declared in class.
6. Check whether the method is abstract.
7. Get the name of the package where the class is located.
8. Check whether the class has inner classes.
9. Get the inner class of the outer class.
10. Check whether the inner class is private.
11. Check whether the inner class is abstract.
12. Get all methods declared in the inner class.
13. Check whether the method is abstract.
14. Check whether the inner class has a private constructor.
15. Check whether the inner class is final.

For the provided test case:

1. Get the name of class: Outer
2. Check whether the class is public: True
3. Check whether the class has a private constructor: False (Outer does not have a private constructor)
4. Check whether the class is abstract: False (Outer is not an abstract class)
5. Get all methods declared in class: No methods declared in Outer
6. Check whether the method is abstract: Not applicable (no methods to check)
7. Get the name of the package where the class is located: Not specified in the test case, but assuming it's in some package
8. Check whether the class has inner classes: True (Base is an inner class)
9. Get the inner class of the outer class: Base
10. Check whether the inner class is private: True (Base is a private class)
11. Check whether the inner class is abstract: True (Base is an abstract class)
12. Get all methods declared in the inner class: run()
13. Check whether the method is abstract: False (run is not an abstract method)
14. Check whether the inner class has a private constructor: True (run is private, but this is a method not a constructor; there is no constructor declared, so it defaults to a private constructor if the class is private)
15. Check whether the inner class is final: False (Base is not a final class)

Since Base is a private abstract class without abstract methods, it is not being extended outside its compilation unit, but it is not violating the rule because it is not final. The rule is about non-abstract classes that cannot be extended from outside their compilation unit. The provided test case does not violate the rule because Base is abstract and not final. However, the test case does illustrate a class that cannot be extended from outside its compilation unit due to its private constructor. 

To correctly identify a violation, the rule should check for non-abstract classes with private constructors. Here’s the correct check for the given test case:

1. Get the name of class: Base
2. Check whether the class is public: False (Base is a private class)
3. Check whether the class has a private constructor: True (by default, because it is a private class)
4. Check whether the class is abstract: True (Base is an abstract class)
5. Check whether the class is final: False (Base is not a final class)

The test case does not violate the rule because Base is abstract and not final. If Base were a non-abstract class without abstract methods and a private constructor, it would be a violation. 

To ensure the correct identification, we need to adjust the checks to focus on non-abstract classes with private constructors:

1. Get the name of class: Base
2. Check whether the class is public: False (Base is a private class)
3. Check whether the class has a private constructor: True (by default, because it is a private class)
4. Check whether the class is abstract: False (assuming Base were non-abstract in a different test case)
5. Check whether the class is final: False (Base is not a final class)

This would correctly identify a violation if Base were a non-abstract class. Since Base is abstract, it does not violate the rule.
['Get the name of class.', 'Check whether the class is public.', 'Check whether the class has a private constructor.', 'Check whether the class is abstract.', 'Get all methods declared in class.', 'Check whether the method is abstract.', 'Get the name of the package where the class is located.', 'Check whether the class has inner classes.', 'Get the inner class of the outer class.', 'Check whether the inner class is private.', 'Check whether the inner class is abstract.', 'Get all methods declared in the inner class.', 'Check whether the method is abstract.', 'Check whether the inner class has a private constructor.', 'Check whether the inner class is final.', 'Get the name of class: Outer', 'Check whether the class is public: True', 'Check whether the class has a private constructor: False (Outer does not have a private constructor)', 'Check whether the class is abstract: False (Outer is not an abstract class)', 'Get all methods declared in class: No methods declared in Outer', 'Check whether the method is abstract: Not applicable (no methods to check)', "Get the name of the package where the class is located: Not specified in the test case, but assuming it's in some package", 'Check whether the class has inner classes: True (Base is an inner class)', 'Get the inner class of the outer class: Base', 'Check whether the inner class is private: True (Base is a private class)', 'Check whether the inner class is abstract: True (Base is an abstract class)', 'Get all methods declared in the inner class: run()', 'Check whether the method is abstract: False (run is not an abstract method)', 'Check whether the inner class has a private constructor: True (run is private, but this is a method not a constructor; there is no constructor declared, so it defaults to a private constructor if the class is private)', 'Check whether the inner class is final: False (Base is not a final class)', 'Get the name of class: Base', 'Check whether the class is public: False (Base is a private class)', 'Check whether the class has a private constructor: True (by default, because it is a private class)', 'Check whether the class is abstract: True (Base is an abstract class)', 'Check whether the class is final: False (Base is not a final class)', 'Get the name of class: Base', 'Check whether the class is public: False (Base is a private class)', 'Check whether the class has a private constructor: True (by default, because it is a private class)', 'Check whether the class is abstract: False (assuming Base were non-abstract in a different test case)', 'Check whether the class is final: False (Base is not a final class)']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Check whether the class has a private constructor.* 匹配到的元操作或API：
logic: Check whether the class has a private constructor.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9239640831947327
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366355895996094
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833380579948425
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the class has inner classes.* 匹配到的元操作或API：
logic: Check whether the class has inner classes.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9536194801330566
*Get the inner class of the outer class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is private.* 匹配到的元操作或API：
logic: Check whether the inner class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9290029406547546
*Check whether the inner class is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.932644784450531
*Get all methods declared in the inner class.* 匹配到的元操作或API：
query: Get all methods declared in the inner class.
most similar API: get declared annotations of method
cosine Similarity: 0.8091907501220703
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833380579948425
*Check whether the inner class has a private constructor.* 匹配到的元操作或API：
logic: Check whether the inner class has a private constructor.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.893987774848938
*Check whether the inner class is final.* 匹配到的元操作或API：
logic: Check whether the inner class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9427244663238525
*Get the name of class: Outer* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is public: True* 匹配到的元操作或API：
logic: Check whether the class is public: True
most similar meta operation: Check whether the class is public
cosine Similarity: 0.970706582069397
*Check whether the class has a private constructor: False (Outer does not have a private constructor)* 匹配到的元操作或API：
logic: Check whether the class has a private constructor: False (Outer does not have a private constructor)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.883786141872406
*Check whether the class is abstract: False (Outer is not an abstract class)* 匹配到的元操作或API：
logic: Check whether the class is abstract: False (Outer is not an abstract class)
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9122560024261475
*Get all methods declared in class: No methods declared in Outer* 匹配到的元操作或API：
query: Get all methods declared in class: No methods declared in Outer
most similar API: get declared annotations of method
cosine Similarity: 0.8111904859542847
*Check whether the method is abstract: Not applicable (no methods to check)* 匹配到的元操作或API：
logic: Check whether the method is abstract: Not applicable (no methods to check)
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.8985356092453003
*Get the name of the package where the class is located: Not specified in the test case, but assuming it's in some package* 匹配到的元操作或API：
logic: Get the name of the package where the class is located: Not specified in the test case, but assuming it's in some package
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.92548006772995
*Check whether the class has inner classes: True (Base is an inner class)* 匹配到的元操作或API：
logic: Check whether the class has inner classes: True (Base is an inner class)
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9020039439201355
*Get the inner class of the outer class: Base* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is private: True (Base is a private class)* 匹配到的元操作或API：
logic: Check whether the inner class is private: True (Base is a private class)
most similar meta operation: Check whether the class is private
cosine Similarity: 0.8712137937545776
*Check whether the inner class is abstract: True (Base is an abstract class)* 匹配到的元操作或API：
logic: Check whether the inner class is abstract: True (Base is an abstract class)
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.8833626508712769
*Get all methods declared in the inner class: run()* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is abstract: False (run is not an abstract method)* 匹配到的元操作或API：
logic: Check whether the method is abstract: False (run is not an abstract method)
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.8981912136077881
*Check whether the inner class has a private constructor: True (run is private, but this is a method not a constructor; there is no constructor declared, so it defaults to a private constructor if the class is private)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is final: False (Base is not a final class)* 匹配到的元操作或API：
logic: Check whether the inner class is final: False (Base is not a final class)
most similar meta operation: Check whether the class is final
cosine Similarity: 0.8717058897018433
*Get the name of class: Base* 匹配到的元操作或API：
logic: Get the name of class: Base
most similar meta operation: Get the name of class
cosine Similarity: 0.8843188881874084
*Check whether the class is public: False (Base is a private class)* 匹配到的元操作或API：
logic: Check whether the class is public: False (Base is a private class)
most similar meta operation: Check whether the class is private
cosine Similarity: 0.8893812894821167
*Check whether the class has a private constructor: True (by default, because it is a private class)* 匹配到的元操作或API：
logic: Check whether the class has a private constructor: True (by default, because it is a private class)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9049845933914185
*Check whether the class is abstract: True (Base is an abstract class)* 匹配到的元操作或API：
logic: Check whether the class is abstract: True (Base is an abstract class)
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9133002161979675
*Check whether the class is final: False (Base is not a final class)* 匹配到的元操作或API：
logic: Check whether the class is final: False (Base is not a final class)
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9037352800369263
*Get the name of class: Base* 匹配到的元操作或API：
logic: Get the name of class: Base
most similar meta operation: Get the name of class
cosine Similarity: 0.8843188881874084
*Check whether the class is public: False (Base is a private class)* 匹配到的元操作或API：
logic: Check whether the class is public: False (Base is a private class)
most similar meta operation: Check whether the class is private
cosine Similarity: 0.8893812894821167
*Check whether the class has a private constructor: True (by default, because it is a private class)* 匹配到的元操作或API：
logic: Check whether the class has a private constructor: True (by default, because it is a private class)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9049845933914185
*Check whether the class is abstract: False (assuming Base were non-abstract in a different test case)* 匹配到的元操作或API：
logic: Check whether the class is abstract: False (assuming Base were non-abstract in a different test case)
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.886850118637085
*Check whether the class is final: False (Base is not a final class)* 匹配到的元操作或API：
logic: Check whether the class is final: False (Base is not a final class)
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9037352800369263
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Private abstract classes without abstract methods and subclasses #3668
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
The description of this test case is: bad 5
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isFinal()) {
            boolean allConstructorsPrivate = node.children(ASTConstructorDeclaration.class)
                                                .allMatch(ASTConstructorDeclaration::isPrivate);
            if (allConstructorsPrivate) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
        2. Check whether the class is an inner class.
        3. Check whether the class is abstract.
        4. Get the constructors of class.
        5. Check whether all constructors are private.
        6. Check whether the class has subclasses.
        If the class is an inner class, is abstract, all its constructors are private, and it does not have subclasses, then this class should be made final. However, in this test case, the class `Base` is abstract and has a private constructor, but the description states this is a bad test case (number of violations is 1), suggesting the class should not be reported as final. This implies there might be a subclass defined in the same compilation unit that is not shown in the provided snippet.

Let's assume the provided snippet is the complete code and proceed with the checks:

1. Get the name of class: Outer
2. Check whether the class is an inner class: No (Outer is the outer class)
3. Get classes declared in Outer class: Base
4. Check whether the class Base is an inner class: Yes
5. Check whether the class Base is abstract: Yes
6. Get the constructors of class Base: private Base()
7. Check whether all constructors are private: Yes
8. Check whether the class Base has subclasses: No (not shown in the snippet, so assume no)
        Since the class Base is an inner class, abstract, has all private constructors, and does not have visible subclasses, it should be made final according to the rule. However, as per the provided description, this is not a valid violation case. Therefore, the test case does not strictly adhere to the rule as described, given the current snippet.

If there were a subclass defined within the same compilation unit, we would need to include that in the checks to determine if the rule was truly violated. Based on the current snippet, no violation is reported by the rule.
['Get the name of class.', 'Check whether the class is an inner class.', 'Check whether the class is abstract.', 'Get the constructors of class.', 'Check whether all constructors are private.', 'Check whether the class has subclasses.', 'Get the name of class: Outer', 'Check whether the class is an inner class: No (Outer is the outer class)', 'Get classes declared in Outer class: Base', 'Check whether the class Base is an inner class: Yes', 'Check whether the class Base is abstract: Yes', 'Get the constructors of class Base: private Base()', 'Check whether all constructors are private: Yes', 'Check whether the class Base has subclasses: No (not shown in the snippet, so assume no)']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831406474113464
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get the constructors of class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether all constructors are private.* 匹配到的元操作或API：
logic: Check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9365217685699463
*Check whether the class has subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: Outer* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is an inner class: No (Outer is the outer class)* 匹配到的元操作或API：
logic: Check whether the class is an inner class: No (Outer is the outer class)
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9156382083892822
*Get classes declared in Outer class: Base* 匹配到的元操作或API：
query: Get classes declared in Outer class: Base
most similar API: get declarations of class or interface
cosine Similarity: 0.8036845326423645
*Check whether the class Base is an inner class: Yes* 匹配到的元操作或API：
logic: Check whether the class Base is an inner class: Yes
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9283914566040039
*Check whether the class Base is abstract: Yes* 匹配到的元操作或API：
logic: Check whether the class Base is abstract: Yes
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9142873287200928
*Get the constructors of class Base: private Base()* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether all constructors are private: Yes* 匹配到的元操作或API：
logic: Check whether all constructors are private: Yes
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.922950267791748
*Check whether the class Base has subclasses: No (not shown in the snippet, so assume no)* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Private abstract classes without abstract methods and subclasses #3668
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
The description of this test case is: bad 5
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if the class is not an interface and not already final
        if (!node.isInterface() && !node.isFinal()) {
            NodeStream<ASTConstructorDeclaration> constructors = node.getDeclarations(ASTConstructorDeclaration.class);
            // Check if all constructors are private
            if (constructors.allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Get the name of the package where the class is located.
3. Check whether the class is public.
4. Get all inner classes of the class.
5. Get the name of inner class.
6. Check whether the inner class is abstract.
7. Get all constructors declared in inner class.
8. Check whether each constructor is private.
9. Check whether the inner class has subclasses.
If the inner class is abstract, all its constructors are private, and it has no subclasses, then this test case violates the rule.

For the provided test case:
1. Get the name of class: Outer
2. Get the name of the package where the class is located: (assuming it's in some package, let's denote it as PackageName)
3. Check whether the class is public: True
4. Get all inner classes of the class: Base
5. Get the name of inner class: Base
6. Check whether the inner class is abstract: True
7. Get all constructors declared in inner class: (assuming default constructor exists)
8. Check whether each constructor is private: False (default constructor is not private)
9. Check whether the inner class has subclasses: False

Based on the rule description, the test case doesn't violate the rule because the constructor is not private, but rather it has multiple issues based on the provided description. Let's correct the checks for the described issue:

1. Get the name of class: Outer
2. Get the name of the package where the class is located: (assuming it's in some package, let's denote it as PackageName)
3. Check whether the class is public: True
4. Get all inner classes of the class: Base
5. Get the name of inner class: Base
6. Check whether the inner class is abstract: True
7. Get all constructors declared in inner class: (assuming no constructors explicitly declared, so default constructor exists)
8. Check whether each constructor is private: False (default constructor is not private)
9. Get all constructors declared in inner class: (explicitly declare a private constructor)
10. Check whether each constructor is private: True (explicitly declared constructor is private)
11. Check whether the inner class has subclasses: False

Given the provided test case, the issue is that the class is abstract, all constructors are private (which needs to be explicitly declared to test this), but it has no subclasses. Therefore, it should be made final according to the rule.

So, correcting the checks:
1. Get the name of class: Outer
2. Get the name of the package where the class is located: (assuming it's in some package, let's denote it as PackageName)
3. Check whether the class is public: True
4. Get all inner classes of the class: Base
5. Get the name of inner class: Base
6. Check whether the inner class is abstract: True
7. Get all constructors declared in inner class: Base (explicitly declared private constructor)
8. Check whether each constructor is private: True
9. Check whether the inner class has subclasses: False

Based on these checks, the test case violates the rule because it has an abstract inner class with private constructors and no subclasses, making it eligible to be final.
['Get the name of class.', 'Get the name of the package where the class is located.', 'Check whether the class is public.', 'Get all inner classes of the class.', 'Get the name of inner class.', 'Check whether the inner class is abstract.', 'Get all constructors declared in inner class.', 'Check whether each constructor is private.', 'Check whether the inner class has subclasses.', 'Get the name of class: Outer', "Get the name of the package where the class is located: (assuming it's in some package, let's denote it as PackageName)", 'Check whether the class is public: True', 'Get all inner classes of the class: Base', 'Get the name of inner class: Base', 'Check whether the inner class is abstract: True', 'Get all constructors declared in inner class: (assuming default constructor exists)', 'Check whether each constructor is private: False (default constructor is not private)', 'Check whether the inner class has subclasses: False', 'Get the name of class: Outer', "Get the name of the package where the class is located: (assuming it's in some package, let's denote it as PackageName)", 'Check whether the class is public: True', 'Get all inner classes of the class: Base', 'Get the name of inner class: Base', 'Check whether the inner class is abstract: True', 'Get all constructors declared in inner class: (assuming no constructors explicitly declared, so default constructor exists)', 'Check whether each constructor is private: False (default constructor is not private)', 'Get all constructors declared in inner class: (explicitly declare a private constructor)', 'Check whether each constructor is private: True (explicitly declared constructor is private)', 'Check whether the inner class has subclasses: False', 'Get the name of class: Outer', "Get the name of the package where the class is located: (assuming it's in some package, let's denote it as PackageName)", 'Check whether the class is public: True', 'Get all inner classes of the class: Base', 'Get the name of inner class: Base', 'Check whether the inner class is abstract: True', 'Get all constructors declared in inner class: Base (explicitly declared private constructor)', 'Check whether each constructor is private: True', 'Check whether the inner class has subclasses: False']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Get all inner classes of the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of inner class.* 匹配到的元操作或API：
logic: Get the name of inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.8755849599838257
*Check whether the inner class is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.932644784450531
*Get all constructors declared in inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442477226257324
*Check whether the inner class has subclasses.* 匹配到的元操作或API：
logic: Check whether the inner class has subclasses.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8886170983314514
*Get the name of class: Outer* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the package where the class is located: (assuming it's in some package, let's denote it as PackageName)* 匹配到的元操作或API：
logic: Get the name of the package where the class is located: (assuming it's in some package, let's denote it as PackageName)
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9574475288391113
*Check whether the class is public: True* 匹配到的元操作或API：
logic: Check whether the class is public: True
most similar meta operation: Check whether the class is public
cosine Similarity: 0.970706582069397
*Get all inner classes of the class: Base* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of inner class: Base* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is abstract: True* 匹配到的元操作或API：
logic: Check whether the inner class is abstract: True
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9215442538261414
*Get all constructors declared in inner class: (assuming default constructor exists)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each constructor is private: False (default constructor is not private)* 匹配到的元操作或API：
logic: Check whether each constructor is private: False (default constructor is not private)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9154402613639832
*Check whether the inner class has subclasses: False* 匹配到的元操作或API：
logic: Check whether the inner class has subclasses: False
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.879813551902771
*Get the name of class: Outer* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the package where the class is located: (assuming it's in some package, let's denote it as PackageName)* 匹配到的元操作或API：
logic: Get the name of the package where the class is located: (assuming it's in some package, let's denote it as PackageName)
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9574475288391113
*Check whether the class is public: True* 匹配到的元操作或API：
logic: Check whether the class is public: True
most similar meta operation: Check whether the class is public
cosine Similarity: 0.970706582069397
*Get all inner classes of the class: Base* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of inner class: Base* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is abstract: True* 匹配到的元操作或API：
logic: Check whether the inner class is abstract: True
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9215442538261414
*Get all constructors declared in inner class: (assuming no constructors explicitly declared, so default constructor exists)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each constructor is private: False (default constructor is not private)* 匹配到的元操作或API：
logic: Check whether each constructor is private: False (default constructor is not private)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9154402613639832
*Get all constructors declared in inner class: (explicitly declare a private constructor)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each constructor is private: True (explicitly declared constructor is private)* 匹配到的元操作或API：
logic: Check whether each constructor is private: True (explicitly declared constructor is private)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9239740371704102
*Check whether the inner class has subclasses: False* 匹配到的元操作或API：
logic: Check whether the inner class has subclasses: False
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.879813551902771
*Get the name of class: Outer* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the package where the class is located: (assuming it's in some package, let's denote it as PackageName)* 匹配到的元操作或API：
logic: Get the name of the package where the class is located: (assuming it's in some package, let's denote it as PackageName)
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9574475288391113
*Check whether the class is public: True* 匹配到的元操作或API：
logic: Check whether the class is public: True
most similar meta operation: Check whether the class is public
cosine Similarity: 0.970706582069397
*Get all inner classes of the class: Base* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of inner class: Base* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is abstract: True* 匹配到的元操作或API：
logic: Check whether the inner class is abstract: True
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9215442538261414
*Get all constructors declared in inner class: Base (explicitly declared private constructor)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each constructor is private: True* 匹配到的元操作或API：
logic: Check whether each constructor is private: True
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9421420097351074
*Check whether the inner class has subclasses: False* 匹配到的元操作或API：
logic: Check whether the inner class has subclasses: False
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.879813551902771
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Private abstract classes without abstract methods and subclasses #3668
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
The description of this test case is: bad 5
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        boolean allPrivateConstructors = true;
        boolean hasConstructor = false;

        for (ASTConstructorDeclaration constructor : node.descendants(ASTConstructorDeclaration.class)) {
            hasConstructor = true;
            if (!constructor.isPrivate()) {
                allPrivateConstructors = false;
                break;
            }
        }

        if (hasConstructor && allPrivateConstructors && !node.isFinal()) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 5
1117
839
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Check whether the class is public.
2. Check whether the class is abstract.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Check whether the class has any non-private constructors.
6. Check whether the class is final.

To determine if the test case violates the rule:

1. Check whether the class is public.
   - Result: Yes, the class `FooUtils` is public.

2. Check whether the class is abstract.
   - Result: Yes, the class `FooUtils` is abstract.

3. Get all constructors declared in class.
   - Result: There is one constructor declared in `FooUtils`.

4. Check whether the constructor is private.
   - Result: Yes, the constructor is private.

5. Check whether the class has any non-private constructors.
   - Result: No, the class does not have any non-private constructors.

6. Check whether the class is final.
   - Result: No, the class is not final.

Given that the class `FooUtils` is public, abstract, and all its constructors are private (meaning it cannot be extended from outside its compilation unit), the class should be made final to adhere to the rule. Therefore, this test case violates the rule.
['Check whether the class is public.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has any non-private constructors.', 'Check whether the class is final.', 'Check whether the class is public.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has any non-private constructors.', 'Check whether the class is final.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class has any non-private constructors.* 匹配到的元操作或API：
logic: Check whether the class has any non-private constructors.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.884695291519165
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887725114822388
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class has any non-private constructors.* 匹配到的元操作或API：
logic: Check whether the class has any non-private constructors.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.884695291519165
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887725114822388
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Abstract outer classes should be flagged #3668
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
The description of this test case is: bad 6
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'FooUtils')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if the class is not an interface and has only private constructors
        if (!node.isInterface() && node.children(ASTConstructorDeclaration.class).allMatch(ASTConstructorDeclaration::isPrivate) && !node.isFinal()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class is abstract.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Count the number of private constructors.
6. Check whether the class has any non-private constructors.
7. Check whether the class has any declared methods.
8. Check whether any declared method is abstract.

If the class is abstract, has all private constructors, and does not have any non-private constructors or abstract methods, then this test case violates the rule. 

In this specific test case:
- The class `FooUtils` is abstract (2.).
- It has one constructor which is private (4.).
- The count of private constructors is 1 (5.).
- There are no non-private constructors (6.).
- The class does not have any declared methods, so it certainly does not have abstract methods (7. and 8.).

Therefore, this test case violates the rule as it can be made final because it cannot be extended from outside its compilation unit.
['Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Count the number of private constructors.', 'Check whether the class has any non-private constructors.', 'Check whether the class has any declared methods.', 'Check whether any declared method is abstract.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Count the number of private constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has any non-private constructors.* 匹配到的元操作或API：
logic: Check whether the class has any non-private constructors.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.884695291519165
*Check whether the class has any declared methods.* 匹配到的元操作或API：
logic: Check whether the class has any declared methods.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.864813506603241
*Check whether any declared method is abstract.* 匹配到的元操作或API：
logic: Check whether any declared method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9418355822563171
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Abstract outer classes should be flagged #3668
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
The description of this test case is: bad 6
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'FooUtils')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()

1.  //Check whether method has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTMethodDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isAbstract() && !hasAnnotation(node)) {
            boolean allConstructorsPrivate = node.descendants(ASTConstructorDeclaration.class)
                                                   .allMatch(ASTConstructorDeclaration::isPrivate);
            if (allConstructorsPrivate && !node.isFinal()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Check whether class has declared annotations
    public boolean hasAnnotation(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
        return declaredAnnotations.nonEmpty();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class is abstract.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Get the class that method located in.
6. Check whether the class has extended any class.
7. Check whether the class has declared annotations.
8. Get a declared annotation of class.
9. Check whether the class has implemented any interfaces.
10. Get a implemented interface of class.

For the given test case:
1. Get the name of class: FooUtils
2. Check whether the class is abstract: Yes, FooUtils is declared as abstract.
3. Get all constructors declared in class: There is one constructor.
4. Check whether the constructor is private: Yes, the constructor is private.
5. Get the class that method located in: FooUtils (already known from step 1).
6. Check whether the class has extended any class: No, FooUtils does not extend any class.
7. Check whether the class has declared annotations: No, FooUtils does not have any declared annotations.
8. Get a declared annotation of class: Not applicable since there are no declared annotations.
9. Check whether the class has implemented any interfaces: No, FooUtils does not implement any interfaces.
10. Get a implemented interface of class: Not applicable since there are no implemented interfaces.

Since the class is abstract, has a private constructor, and does not extend any class or implement any interfaces, it does not violate the rule as stated. The rule specifically targets non-abstract classes with private constructors. Therefore, this test case does not actually violate the rule. The description "bad 6" and the number of violations being "1" seem inaccurate based on the provided rule description.
['Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get the class that method located in.', 'Check whether the class has extended any class.', 'Check whether the class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the class has implemented any interfaces.', 'Get a implemented interface of class.', 'Get the name of class: FooUtils', 'Check whether the class is abstract: Yes, FooUtils is declared as abstract.', 'Get all constructors declared in class: There is one constructor.', 'Check whether the constructor is private: Yes, the constructor is private.', 'Get the class that method located in: FooUtils (already known from step 1).', 'Check whether the class has extended any class: No, FooUtils does not extend any class.', 'Check whether the class has declared annotations: No, FooUtils does not have any declared annotations.', 'Get a declared annotation of class: Not applicable since there are no declared annotations.', 'Check whether the class has implemented any interfaces: No, FooUtils does not implement any interfaces.', 'Get a implemented interface of class: Not applicable since there are no implemented interfaces.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Get the class that method located in.* 匹配到的元操作或API：
logic: Get the class that method located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9805242419242859
*Check whether the class has extended any class.* 匹配到的元操作或API：
logic: Check whether the class has extended any class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.8995493650436401
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9878389835357666
*Check whether the class has implemented any interfaces.* 匹配到的元操作或API：
logic: Check whether the class has implemented any interfaces.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.8998101353645325
*Get a implemented interface of class.* 匹配到的元操作或API：
logic: Get a implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9851537942886353
*Get the name of class: FooUtils* 匹配到的元操作或API：
logic: Get the name of class: FooUtils
most similar meta operation: Get the name of class
cosine Similarity: 0.8838019967079163
*Check whether the class is abstract: Yes, FooUtils is declared as abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract: Yes, FooUtils is declared as abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.906098484992981
*Get all constructors declared in class: There is one constructor.* 匹配到的元操作或API：
query: Get all constructors declared in class: There is one constructor.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8195163607597351
*Check whether the constructor is private: Yes, the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private: Yes, the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9586447477340698
*Get the class that method located in: FooUtils (already known from step 1).* 匹配到的元操作或API：
logic: Get the class that method located in: FooUtils (already known from step 1).
most similar meta operation: Get the class that method located in
cosine Similarity: 0.8641189336776733
*Check whether the class has extended any class: No, FooUtils does not extend any class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has declared annotations: No, FooUtils does not have any declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations: No, FooUtils does not have any declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9097755551338196
*Get a declared annotation of class: Not applicable since there are no declared annotations.* 匹配到的元操作或API：
logic: Get a declared annotation of class: Not applicable since there are no declared annotations.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9118651747703552
*Check whether the class has implemented any interfaces: No, FooUtils does not implement any interfaces.* 匹配到的元操作或API：
logic: Check whether the class has implemented any interfaces: No, FooUtils does not implement any interfaces.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.8519394397735596
*Get a implemented interface of class: Not applicable since there are no implemented interfaces.* 匹配到的元操作或API：
logic: Get a implemented interface of class: Not applicable since there are no implemented interfaces.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9093112349510193
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Abstract outer classes should be flagged #3668
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
The description of this test case is: bad 6
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'FooUtils')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getSuperInterfaceTypeNodes()

1.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```
2.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
3.  //Check whether the class has implemented x interface
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node) {
    if (TypeTestUtil.isA(interfaceName.class, node)) {
        return true;
    }
    return false;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {

    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if the class is abstract and has only private constructors
        if (!node.isInterface() && node.getDeclaredConstructors().allMatch(ASTConstructorDeclaration::isPrivate)) {
            // Check if the class is already final
            if (!node.isFinal()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Check whether the class has extended a specific class
    public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node, Class<?> x) {
        ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
        return TypeTestUtil.isA(x, classOrInterfaceType);
    }

    // Check whether class has declared annotations
    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }

    // Check whether the class has implemented a specific interface
    public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node, Class<?> interfaceName) {
        return TypeTestUtil.isA(interfaceName, node);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class is abstract.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Check whether the class contains any abstract methods.
6. Check whether the class is contained within another compilation unit.
7. Check whether the class is public.

### Granular Checks for the Test Case:
1. Get the name of class.
        - The class name is `FooUtils`.

2. Check whether the class is abstract.
        - The class `FooUtils` is declared as abstract.

3. Get all constructors declared in class.
        - There is one constructor declared in `FooUtils`: `private FooUtils()`.

4. Check whether the constructor is private.
        - The constructor `private FooUtils()` is indeed private.

5. Check whether the class contains any abstract methods.
        - The class `FooUtils` does not contain any abstract methods.

6. Check whether the class is contained within another compilation unit.
        - The class `FooUtils` is contained within its own compilation unit (i.e., the same file).

7. Check whether the class is public.
        - The class `FooUtils` is declared as public.

### Conclusion:
The test case violates the rule because:
- The class `FooUtils` is abstract.
- All its constructors are private, meaning it cannot be instantiated or extended from outside its compilation unit.
- Despite being abstract, it does not contain any abstract methods.

Hence, it should be flagged as a violation and made final to prevent extension. The number of violations in this test case is 1.
['Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class contains any abstract methods.', 'Check whether the class is contained within another compilation unit.', 'Check whether the class is public.', 'Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class contains any abstract methods.', 'Check whether the class is contained within another compilation unit.', 'Check whether the class is public.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class contains any abstract methods.* 匹配到的元操作或API：
logic: Check whether the class contains any abstract methods.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9070538282394409
*Check whether the class is contained within another compilation unit.* 匹配到的元操作或API：
query: Check whether the class is contained within another compilation unit.
most similar API: Check whether the compilation unit equals
cosine Similarity: 0.8480795621871948
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class contains any abstract methods.* 匹配到的元操作或API：
logic: Check whether the class contains any abstract methods.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9070538282394409
*Check whether the class is contained within another compilation unit.* 匹配到的元操作或API：
query: Check whether the class is contained within another compilation unit.
most similar API: Check whether the compilation unit equals
cosine Similarity: 0.8480795621871948
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Abstract outer classes should be flagged #3668
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
The description of this test case is: bad 6
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'FooUtils')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
6. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean equals(java.lang.Object)
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if the class is public and has only private constructors
        if (node.isPublic() && node.getChildren(ASTConstructorDeclaration.class).allMatch(ASTConstructorDeclaration::isPrivate)) {
            // Check if the class is not final
            if (!node.isFinal()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Check whether the class is abstract.
2. Get the constructors of the class.
3. Check whether the class has any constructors.
4. For each constructor in the class, check whether the constructor is private.
5. Check whether all constructors of the class are private.
6. Check whether the class is declared in a package that is not default package-private.
7. Check whether there are any other classes in the same compilation unit that could extend this class.

Based on the description of the rule and the test case:
- The class `FooUtils` is abstract (Check whether the class is abstract).
- It has a constructor (Get the constructors of the class).
- The constructor is private (For each constructor in the class, check whether the constructor is private).
- Since the constructor is private, it cannot be called from subclasses outside the compilation unit (Check whether all constructors of the class are private).

However, the rule specifies that if the class is declared in a package that is not default package-private, we should also check whether there are any other classes in the same compilation unit that could extend this class (Check whether the class is declared in a package that is not default package-private and Check whether there are any other classes in the same compilation unit that could extend this class).

Since the description states that the class is declared as abstract to prevent instantiation and not necessarily because it cannot be extended, and there is no additional information about other classes in the same compilation unit, we can infer that the class is indeed violating the rule because it has a private constructor and is declared abstract.

If no other classes in the same compilation unit are extending this class, then the test case violates the rule.
The number of violating the rule in this test case is: 1 (as stated in the description).
['Check whether the class is abstract.', 'Get the constructors of the class.', 'Check whether the class has any constructors.', 'For each constructor in the class, check whether the constructor is private.', 'Check whether all constructors of the class are private.', 'Check whether the class is declared in a package that is not default package-private.', 'Check whether there are any other classes in the same compilation unit that could extend this class.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get the constructors of the class.* 匹配到的元操作或API：
query: Get the constructors of the class.
most similar API: get parents of type of constructor
cosine Similarity: 0.8249256610870361
*Check whether the class has any constructors.* 匹配到的元操作或API：
query: Check whether the class has any constructors.
most similar API: Check whether the constructor is any annotation present
cosine Similarity: 0.868806779384613
*For each constructor in the class, check whether the constructor is private.* 匹配到的元操作或API：
logic: For each constructor in the class, check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9349416494369507
*Check whether all constructors of the class are private.* 匹配到的元操作或API：
logic: Check whether all constructors of the class are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9245821833610535
*Check whether the class is declared in a package that is not default package-private.* 匹配到的元操作或API：
logic: Check whether the class is declared in a package that is not default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9122040271759033
*Check whether there are any other classes in the same compilation unit that could extend this class.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Abstract outer classes should be flagged #3668
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
The description of this test case is: bad 6
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'FooUtils')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.util.List<List<T> getParentsOfType(java.lang.Class)
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection), //Checks whether any annotation is present on this node. @param binaryNames            Collection that contains binary names of annotations.            Note: for now, canonical names are tolerated, this may be changed in PMD 7. @return <code>true</code> if any annotation is present on this node, else <code>false</code>
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
True
此测试用例生成了first checker: bad 6


======================接下来开始迭代=====================
[ERROR]   "ok 4" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
94
78
107
91
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get the constructor of class.
3. Check whether the constructor is private.
4. Get the name of the class with the private constructor.
5. Get all subclasses declared in the same compilation unit.
6. Check whether any subclass extends the class with the private constructor.
7. Get the constructor of the subclass.
8. Check whether the subclass constructor calls the super constructor.

In this test case:
1. The name of the class is Foo.
2. Foo has a constructor.
3. The constructor of Foo is private.
4. The name of the class with the private constructor is Foo.
5. There is a subclass declared in the same compilation unit, Bar.
6. Bar extends Foo.
7. Bar has a constructor.
8. The Bar constructor does not explicitly call the super constructor, but since Foo's constructor is private, Bar implicitly cannot call it. However, the test case explicitly shows a scenario that would violate the rule if it were possible.

To precisely adhere to the rule and test case:
1. Get the name of class.
2. Get the constructor of class.
3. Check whether the constructor is private.
4. Get the name of the class with the private constructor.
5. Get all subclasses declared in the same compilation unit.
6. Check whether any subclass extends the class with the private constructor.
7. Get the constructor of the subclass.
8. Check whether the subclass constructor calls the super constructor.

Since the test case explicitly shows a subclass trying to extend a class with a private constructor, it indicates that the rule checker would report this as a violation. However, the rule description specifically states that the rule is about classes that cannot be extended from outside their compilation unit, and in this case, Bar is within the same compilation unit as Foo. Since the private constructor prevents external subclassing, the rule is technically not violated. But the test case setup is misleading as it shows a scenario that attempts subclassing.

To correctly check adherence to the rule:
1. Get the name of class (Foo).
2. Get the constructor of class (Foo).
3. Check whether the constructor is private (True).
4. Get the name of the class with the private constructor (Foo).
5. Get all subclasses declared in the same compilation unit (Bar).
6. Check whether any subclass extends the class with the private constructor (True, Bar extends Foo).
7. Get the constructor of the subclass (Bar).
8. Check whether the subclass constructor calls the super constructor (False, the Bar constructor does not explicitly call the super constructor, but it cannot due to the private constructor in Foo).

Given that the subclass Bar is within the same compilation unit and the private constructor in Foo prevents external subclassing, the test case does not violate the rule. The number of violations in this test case is: 0.
['Get the name of class.', 'Get the constructor of class.', 'Check whether the constructor is private.', 'Get the name of the class with the private constructor.', 'Get all subclasses declared in the same compilation unit.', 'Check whether any subclass extends the class with the private constructor.', 'Get the constructor of the subclass.', 'Check whether the subclass constructor calls the super constructor.', 'The name of the class is Foo.', 'Foo has a constructor.', 'The constructor of Foo is private.', 'The name of the class with the private constructor is Foo.', 'There is a subclass declared in the same compilation unit, Bar.', 'Bar extends Foo.', 'Bar has a constructor.', "The Bar constructor does not explicitly call the super constructor, but since Foo's constructor is private, Bar implicitly cannot call it. However, the test case explicitly shows a scenario that would violate the rule if it were possible.", 'Get the name of class.', 'Get the constructor of class.', 'Check whether the constructor is private.', 'Get the name of the class with the private constructor.', 'Get all subclasses declared in the same compilation unit.', 'Check whether any subclass extends the class with the private constructor.', 'Get the constructor of the subclass.', 'Check whether the subclass constructor calls the super constructor.', 'Get the name of class (Foo).', 'Get the constructor of class (Foo).', 'Check whether the constructor is private (True).', 'Get the name of the class with the private constructor (Foo).', 'Get all subclasses declared in the same compilation unit (Bar).', 'Check whether any subclass extends the class with the private constructor (True, Bar extends Foo).', 'Get the constructor of the subclass (Bar).', 'Check whether the subclass constructor calls the super constructor (False, the Bar constructor does not explicitly call the super constructor, but it cannot due to the private constructor in Foo).']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the constructor of class.* 匹配到的元操作或API：
query: Get the constructor of class.
most similar API: get class of constructor
cosine Similarity: 0.8697571158409119
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Get the name of the class with the private constructor.* 匹配到的元操作或API：
logic: Get the name of the class with the private constructor.
most similar meta operation: Get the name of class
cosine Similarity: 0.8607545495033264
*Get all subclasses declared in the same compilation unit.* 匹配到的元操作或API：
query: Get all subclasses declared in the same compilation unit.
most similar API: get class of compilation unit
cosine Similarity: 0.8010209798812866
*Check whether any subclass extends the class with the private constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the constructor of the subclass.* 匹配到的元操作或API：
query: Get the constructor of the subclass.
most similar API: get child of constructor
cosine Similarity: 0.8129884004592896
*Check whether the subclass constructor calls the super constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*The name of the class is Foo.* 匹配到的元操作或API：
未匹配成功元操作或API
*Foo has a constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*The constructor of Foo is private.* 匹配到的元操作或API：
query: The constructor of Foo is private.
most similar API: Check whether the constructor is private
cosine Similarity: 0.8366401195526123
*The name of the class with the private constructor is Foo.* 匹配到的元操作或API：
未匹配成功元操作或API
*There is a subclass declared in the same compilation unit, Bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Bar extends Foo.* 匹配到的元操作或API：
未匹配成功元操作或API
*Bar has a constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*The Bar constructor does not explicitly call the super constructor, but since Foo's constructor is private, Bar implicitly cannot call it. However, the test case explicitly shows a scenario that would violate the rule if it were possible.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the constructor of class.* 匹配到的元操作或API：
query: Get the constructor of class.
most similar API: get class of constructor
cosine Similarity: 0.8697571158409119
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Get the name of the class with the private constructor.* 匹配到的元操作或API：
logic: Get the name of the class with the private constructor.
most similar meta operation: Get the name of class
cosine Similarity: 0.8607545495033264
*Get all subclasses declared in the same compilation unit.* 匹配到的元操作或API：
query: Get all subclasses declared in the same compilation unit.
most similar API: get class of compilation unit
cosine Similarity: 0.8010209798812866
*Check whether any subclass extends the class with the private constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the constructor of the subclass.* 匹配到的元操作或API：
query: Get the constructor of the subclass.
most similar API: get child of constructor
cosine Similarity: 0.8129884004592896
*Check whether the subclass constructor calls the super constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class (Foo).* 匹配到的元操作或API：
logic: Get the name of class (Foo).
most similar meta operation: Get the name of class
cosine Similarity: 0.9299685955047607
*Get the constructor of class (Foo).* 匹配到的元操作或API：
query: Get the constructor of class (Foo).
most similar API: get class of constructor
cosine Similarity: 0.8425899744033813
*Check whether the constructor is private (True).* 匹配到的元操作或API：
logic: Check whether the constructor is private (True).
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9671589136123657
*Get the name of the class with the private constructor (Foo).* 匹配到的元操作或API：
query: Get the name of the class with the private constructor (Foo).
most similar API: get name of constructor
cosine Similarity: 0.8347017765045166
*Get all subclasses declared in the same compilation unit (Bar).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any subclass extends the class with the private constructor (True, Bar extends Foo).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the constructor of the subclass (Bar).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass constructor calls the super constructor (False, the Bar constructor does not explicitly call the super constructor, but it cannot due to the private constructor in Foo).* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor
public class Foo {
    private Foo() { }

    public static class Bar extends Foo {
        public Bar() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public java.lang.Class<Class<?> getClass()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.impl.GenericNode getChild(int)
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.String getName()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                ASTCompilationUnit compilationUnit = node.getCompilationUnit();
                if (compilationUnit.descendants(ASTClassOrInterfaceDeclaration.class)
                    .filter(subNode -> !subNode.equals(node))
                    .noneMatch(subNode -> subNode.getExtendsList() != null && subNode.getExtendsList().getType().getSimpleName().equals(node.getSimpleName()))) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is public.
3. Get all constructors of class.
4. Check whether the constructor is private.
5. Get the name of the package where the class is located.
6. Check whether class has declared annotations.
7. Get a declared annotation of class.
8. Check whether the class has x annotation.
9. Check whether the class is abstract.
10. Check whether the class is interface.
11. Check whether the class is inner class.
12. Get all methods declared in class.
13. Check whether the method is abstract.
14. Get all fields declared in class.
15. Check whether the field is final.
16. Get all classes that extend the class.
17. Check whether the subclass is in the same package.

Perform these checks on the `Foo` class:

1. Get the name of class.
   - Class name is `Foo`.

2. Check whether the class is public.
   - The class `Foo` is public.

3. Get all constructors of class.
   - Found one constructor: `private Foo() { }`.

4. Check whether the constructor is private.
   - The constructor `Foo()` is private.

5. Get the name of the package where the class is located.
   - The class is in the default package (since no package is specified).

6. Check whether class has declared annotations.
   - The class `Foo` has no declared annotations.

7. Check whether the class has x annotation.
   - Not applicable here as no annotations are present.

8. Check whether the class is abstract.
   - The class `Foo` is not abstract.

9. Check whether the class is interface.
   - The class `Foo` is not an interface.

10. Check whether the class is inner class.
    - The class `Foo` is not an inner class.

11. Get all methods declared in class.
    - No methods declared in `Foo`.

12. Check whether the method is abstract.
    - Not applicable as no methods are present.

13. Get all fields declared in class.
    - Found two fields: `final int a = 1;` and `int b = 0;`.

14. Check whether the field is final.
    - Field `a` is final, and field `b` is not.

15. Get all classes that extend the class.
    - Found one subclass: `Bar`.

16. Check whether the subclass is in the same package.
    - Subclass `Bar` is in the default package, which is the same as `Foo`.

Since the constructor of `Foo` is private and the subclass `Bar` is in the same package, the rule is not violated. Therefore, the number of violations in this test case is: 0.
['Get the name of class.', 'Check whether the class is public.', 'Get all constructors of class.', 'Check whether the constructor is private.', 'Get the name of the package where the class is located.', 'Check whether class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the class has x annotation.', 'Check whether the class is abstract.', 'Check whether the class is interface.', 'Check whether the class is inner class.', 'Get all methods declared in class.', 'Check whether the method is abstract.', 'Get all fields declared in class.', 'Check whether the field is final.', 'Get all classes that extend the class.', 'Check whether the subclass is in the same package.', 'Get the name of class.', 'Check whether the class is public.', 'Get all constructors of class.', 'Check whether the constructor is private.', 'Get the name of the package where the class is located.', 'Check whether class has declared annotations.', 'Check whether the class has x annotation.', 'Check whether the class is abstract.', 'Check whether the class is interface.', 'Check whether the class is inner class.', 'Get all methods declared in class.', 'Check whether the method is abstract.', 'Get all fields declared in class.', 'Check whether the field is final.', 'Get all classes that extend the class.', 'Check whether the subclass is in the same package.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Get all constructors of class.* 匹配到的元操作或API：
query: Get all constructors of class.
most similar API: get class of constructor
cosine Similarity: 0.8041397333145142
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether class has declared annotations.* 匹配到的元操作或API：
logic: Check whether class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9901520013809204
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9878389835357666
*Check whether the class has x annotation.* 匹配到的元操作或API：
logic: Check whether the class has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9908235669136047
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Check whether the class is interface.* 匹配到的元操作或API：
logic: Check whether the class is interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9844173789024353
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9875447154045105
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8142817616462708
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833380579948425
*Get all fields declared in class.* 匹配到的元操作或API：
query: Get all fields declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8290460109710693
*Check whether the field is final.* 匹配到的元操作或API：
logic: Check whether the field is final.
most similar meta operation: Check whether the field is final
cosine Similarity: 0.9875955581665039
*Get all classes that extend the class.* 匹配到的元操作或API：
query: Get all classes that extend the class.
most similar API: get class of extends list
cosine Similarity: 0.8301785588264465
*Check whether the subclass is in the same package.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Get all constructors of class.* 匹配到的元操作或API：
query: Get all constructors of class.
most similar API: get class of constructor
cosine Similarity: 0.8041397333145142
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether class has declared annotations.* 匹配到的元操作或API：
logic: Check whether class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9901520013809204
*Check whether the class has x annotation.* 匹配到的元操作或API：
logic: Check whether the class has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9908235669136047
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Check whether the class is interface.* 匹配到的元操作或API：
logic: Check whether the class is interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9844173789024353
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9875447154045105
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8142817616462708
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833380579948425
*Get all fields declared in class.* 匹配到的元操作或API：
query: Get all fields declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8290460109710693
*Check whether the field is final.* 匹配到的元操作或API：
logic: Check whether the field is final.
most similar meta operation: Check whether the field is final
cosine Similarity: 0.9875955581665039
*Get all classes that extend the class.* 匹配到的元操作或API：
query: Get all classes that extend the class.
most similar API: get class of extends list
cosine Similarity: 0.8301785588264465
*Check whether the subclass is in the same package.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor
public class Foo {
    private Foo() { }

    public static class Bar extends Foo {
        public Bar() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
11. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
12. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
13. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isFinal()
14. net.sourceforge.pmd.lang.java.ast.ASTExtendsList: public java.lang.Class<Class<?> getClass()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                if (!hasSubclassInSameCompilationUnit(node)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean hasSubclassInSameCompilationUnit(ASTClassOrInterfaceDeclaration node) {
        String packageName = node.getPackageName();
        String simpleName = node.getSimpleName();
        return node.getRoot().descendants(ASTClassOrInterfaceDeclaration.class)
                .anyMatch(subclass -> subclass.getPackageName().equals(packageName) && 
                        subclass.isPublic() && 
                        isExtending(subclass, simpleName));
    }

    private boolean isExtending(ASTClassOrInterfaceDeclaration subclass, String simpleName) {
        ASTExtendsList extendsList = subclass.getFirstDescendantOfType(ASTExtendsList.class);
        if (extendsList != null) {
            ASTClassOrInterfaceType superclassType = extendsList.getFirstDescendantOfType(ASTClassOrInterfaceType.class);
            if (superclassType != null) {
                return simpleName.equals(superclassType.getSimpleName());
            }
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Get all constructors declared in class.
        3. Check whether the constructor is private.
        4. Check whether the class has any subclasses outside its compilation unit.
        5. Check whether the class has any subclasses inside its compilation unit.
        6. Check whether the class is final.

### For Class `Foo`:
7. Get all constructors declared in class `Foo`.
8. Check whether the constructor is private.
9. Get the name of the subclass.
10. Check whether the subclass `Bar` is inside the same compilation unit as `Foo`.
11. Check whether the class `Foo` is final.

### For Subclass `Bar`:
12. Get the class that method located in.
13. Check whether the class is a subclass of `Foo`.
14. Check whether the constructor of `Bar` calls the super constructor of `Foo`.

### Detailed Checks:
1. Get the name of class `Foo`.
2. Get all constructors declared in class `Foo`.
3. Check whether the constructor is private. (This should be true as `private Foo() { }`)
4. Check whether the class `Foo` has any subclasses outside its compilation unit. (This should be false as `Bar` is inside the same file)
5. Check whether the class `Foo` has any subclasses inside its compilation unit. (This should be true as `Bar` is inside the same file)
6. Check whether the class `Foo` is final. (This should be false as `Foo` is not declared final)
7. Get the name of the subclass `Bar`.
8. Check whether the subclass `Bar` is inside the same compilation unit as `Foo`. (This should be true as both are in the same file)
9. Get the class that constructor `Bar` is located in.
10. Check whether the class `Bar` is a subclass of `Foo`. (This should be true as `Bar` extends `Foo`)
11. Get the signature of constructor `Bar`.
12. Get the number of formal parameters of constructor `Bar`.
13. Get the signature of the super constructor call in constructor `Bar`. (This should be false as there is no explicit super constructor call, but the constructor of `Foo` is private, so it's not callable)
14. Check whether the constructor of `Bar` calls the super constructor of `Foo`. (This should be false as the private constructor of `Foo` cannot be called from outside the `Foo` class)

### Conclusion:
Since `Foo` has a private constructor and `Bar` is a subclass inside the same compilation unit, the rule does not apply as `Bar` can extend `Foo` within the same file. Therefore, the number of violations in this test case is: 0.
['Get the name of class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has any subclasses outside its compilation unit.', 'Check whether the class has any subclasses inside its compilation unit.', 'Check whether the class is final.', 'Get all constructors declared in class `Foo`.', 'Check whether the constructor is private.', 'Get the name of the subclass.', 'Check whether the subclass `Bar` is inside the same compilation unit as `Foo`.', 'Check whether the class `Foo` is final.', 'Get the class that method located in.', 'Check whether the class is a subclass of `Foo`.', 'Check whether the constructor of `Bar` calls the super constructor of `Foo`.', 'Get the name of class `Foo`.', 'Get all constructors declared in class `Foo`.', 'Check whether the constructor is private. (This should be true as `private Foo() { }`)', 'Check whether the class `Foo` has any subclasses outside its compilation unit. (This should be false as `Bar` is inside the same file)', 'Check whether the class `Foo` has any subclasses inside its compilation unit. (This should be true as `Bar` is inside the same file)', 'Check whether the class `Foo` is final. (This should be false as `Foo` is not declared final)', 'Get the name of the subclass `Bar`.', 'Check whether the subclass `Bar` is inside the same compilation unit as `Foo`. (This should be true as both are in the same file)', 'Get the class that constructor `Bar` is located in.', 'Check whether the class `Bar` is a subclass of `Foo`. (This should be true as `Bar` extends `Foo`)', 'Get the signature of constructor `Bar`.', 'Get the number of formal parameters of constructor `Bar`.', "Get the signature of the super constructor call in constructor `Bar`. (This should be false as there is no explicit super constructor call, but the constructor of `Foo` is private, so it's not callable)", 'Check whether the constructor of `Bar` calls the super constructor of `Foo`. (This should be false as the private constructor of `Foo` cannot be called from outside the `Foo` class)']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class has any subclasses outside its compilation unit.* 匹配到的元操作或API：
query: Check whether the class has any subclasses outside its compilation unit.
most similar API: Check whether the compilation unit has descendant of type
cosine Similarity: 0.8128637671470642
*Check whether the class has any subclasses inside its compilation unit.* 匹配到的元操作或API：
query: Check whether the class has any subclasses inside its compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8203034400939941
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887725114822388
*Get all constructors declared in class `Foo`.* 匹配到的元操作或API：
query: Get all constructors declared in class `Foo`.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8030155897140503
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Get the name of the subclass.* 匹配到的元操作或API：
logic: Get the name of the subclass.
most similar meta operation: Get the name of class
cosine Similarity: 0.8767188191413879
*Check whether the subclass `Bar` is inside the same compilation unit as `Foo`.* 匹配到的元操作或API：
query: Check whether the subclass `Bar` is inside the same compilation unit as `Foo`.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8258435726165771
*Check whether the class `Foo` is final.* 匹配到的元操作或API：
logic: Check whether the class `Foo` is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9427198171615601
*Get the class that method located in.* 匹配到的元操作或API：
logic: Get the class that method located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9805242419242859
*Check whether the class is a subclass of `Foo`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor of `Bar` calls the super constructor of `Foo`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class `Foo`.* 匹配到的元操作或API：
logic: Get the name of class `Foo`.
most similar meta operation: Get the name of class
cosine Similarity: 0.8926639556884766
*Get all constructors declared in class `Foo`.* 匹配到的元操作或API：
query: Get all constructors declared in class `Foo`.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8030155897140503
*Check whether the constructor is private. (This should be true as `private Foo() { }`)* 匹配到的元操作或API：
logic: Check whether the constructor is private. (This should be true as `private Foo() { }`)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9533160328865051
*Check whether the class `Foo` has any subclasses outside its compilation unit. (This should be false as `Bar` is inside the same file)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class `Foo` has any subclasses inside its compilation unit. (This should be true as `Bar` is inside the same file)* 匹配到的元操作或API：
query: Check whether the class `Foo` has any subclasses inside its compilation unit. (This should be true as `Bar` is inside the same file)
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8068974018096924
*Check whether the class `Foo` is final. (This should be false as `Foo` is not declared final)* 匹配到的元操作或API：
logic: Check whether the class `Foo` is final. (This should be false as `Foo` is not declared final)
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9169503450393677
*Get the name of the subclass `Bar`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass `Bar` is inside the same compilation unit as `Foo`. (This should be true as both are in the same file)* 匹配到的元操作或API：
query: Check whether the subclass `Bar` is inside the same compilation unit as `Foo`. (This should be true as both are in the same file)
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8266420364379883
*Get the class that constructor `Bar` is located in.* 匹配到的元操作或API：
query: Get the class that constructor `Bar` is located in.
most similar API: get class of constructor
cosine Similarity: 0.8281686305999756
*Check whether the class `Bar` is a subclass of `Foo`. (This should be true as `Bar` extends `Foo`)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the signature of constructor `Bar`.* 匹配到的元操作或API：
logic: Get the signature of constructor `Bar`.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.8923802971839905
*Get the number of formal parameters of constructor `Bar`.* 匹配到的元操作或API：
logic: Get the number of formal parameters of constructor `Bar`.
most similar meta operation: Get the number of formal parameters of constructor
cosine Similarity: 0.9232417345046997
*Get the signature of the super constructor call in constructor `Bar`. (This should be false as there is no explicit super constructor call, but the constructor of `Foo` is private, so it's not callable)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor of `Bar` calls the super constructor of `Foo`. (This should be false as the private constructor of `Foo` cannot be called from outside the `Foo` class)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor
public class Foo {
    private Foo() { }

    public static class Bar extends Foo {
        public Bar() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean hasDescendantOfType(java.lang.Class)
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType()
8. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
9. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()

1.  //Get the number of formal parameters of constructor
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTConstructorDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                if (!isSubclassInSameCompilationUnit(node)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isSubclassInSameCompilationUnit(ASTClassOrInterfaceDeclaration node) {
        ASTCompilationUnit compilationUnit = (ASTCompilationUnit) node.getFirstParentOfType(ASTCompilationUnit.class);
        return compilationUnit.hasDescendantOfType(ASTClassOrInterfaceDeclaration.class) &&
               compilationUnit.descendants(ASTClassOrInterfaceDeclaration.class)
                              .anyMatch(subNode -> isSubclassOf(subNode, node));
    }

    private boolean isSubclassOf(ASTClassOrInterfaceDeclaration subNode, ASTClassOrInterfaceDeclaration node) {
        if (subNode.getExtendsList() == null) {
            return false;
        }
        for (ASTClassOrInterfaceType type : subNode.getExtendsList().getTypeNodes()) {
            if (type.getType() != null && type.getType().getQualifiedName().equals(node.getQualifiedName())) {
                return true;
            } else if (type.isReferenceToClassSameCompilationUnit() && type.getTypeNodeName().equals(node.getSimpleName())) {
                return true;
            }
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get a constructor of class.
3. Check whether the constructor is private.
4. Get all subclasses of class.
5. Check whether the subclass is located in the same compilation unit as the class.
6. If the class has a private constructor and any subclass is located outside the same compilation unit, then the class violates the rule.
         In this specific test case:
1. Get the name of class: Foo.
2. Get a constructor of class: Foo().
3. Check whether the constructor is private: Yes.
4. Get all subclasses of class: Bar.
5. Check whether the subclass is located in the same compilation unit as the class: Yes, Bar is a nested class within Foo, so it is in the same compilation unit.
Since Bar is a subclass located within the same compilation unit and Foo has a private constructor, this test case does not violate the rule. The rule is about avoiding final classes when they can be extended from outside their compilation unit, but in this case, Bar is within the same compilation unit as Foo.
['Get the name of class.', 'Get a constructor of class.', 'Check whether the constructor is private.', 'Get all subclasses of class.', 'Check whether the subclass is located in the same compilation unit as the class.', 'If the class has a private constructor and any subclass is located outside the same compilation unit, then the class violates the rule.', 'Get the name of class: Foo.', 'Get a constructor of class: Foo().', 'Check whether the constructor is private: Yes.', 'Get all subclasses of class: Bar.', 'Check whether the subclass is located in the same compilation unit as the class: Yes, Bar is a nested class within Foo, so it is in the same compilation unit.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get a constructor of class.* 匹配到的元操作或API：
query: Get a constructor of class.
most similar API: get class of constructor
cosine Similarity: 0.8336950540542603
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Get all subclasses of class.* 匹配到的元操作或API：
query: Get all subclasses of class.
most similar API: get permitted subclasses of class or interface
cosine Similarity: 0.8182533979415894
*Check whether the subclass is located in the same compilation unit as the class.* 匹配到的元操作或API：
query: Check whether the subclass is located in the same compilation unit as the class.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8569080829620361
*If the class has a private constructor and any subclass is located outside the same compilation unit, then the class violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: Foo.* 匹配到的元操作或API：
logic: Get the name of class: Foo.
most similar meta operation: Get the name of class
cosine Similarity: 0.9150534868240356
*Get a constructor of class: Foo().* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: Yes.* 匹配到的元操作或API：
logic: Check whether the constructor is private: Yes.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9459784030914307
*Get all subclasses of class: Bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass is located in the same compilation unit as the class: Yes, Bar is a nested class within Foo, so it is in the same compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor
public class Foo {
    private Foo() { }

    public static class Bar extends Foo {
        public Bar() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.util.List<ASTClassOrInterfaceType> getPermittedSubclasses()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                List<ASTClassOrInterfaceType> subclasses = node.getRoot().descendants(ASTClassOrInterfaceType.class)
                    .filter(type -> type.isReferenceToClassSameCompilationUnit() && type.getType() != null)
                    .filter(type -> TypeTestUtil.isClassType(type.getType()))
                    .filter(type -> TypeTestUtil.isSubType(type.getType(), node.getType()))
                    .collect(Collectors.toList());

                if (subclasses.isEmpty()) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To ascertain the adherence of the provided test case to the rule, let's perform the necessary granular checks:

1. Get the name of class.
2. Get the name of the package where the class is located.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Check whether the class is public.
6. Get all inner classes declared in class.
7. Get the name of inner class.
8. Check whether the inner class is a subclass.
9. Get the super class of inner class.
10. Check whether the super class is the outer class.
11. Get all constructors declared in inner class.
12. Check whether the constructor is public.

Let's go through these checks step-by-step:

1. Get the name of class.
   - The class name is `Foo`.

2. Get the name of the package where the class is located.
   - The class is in the default package (no package declaration).

3. Get all constructors declared in class.
   - There is one constructor declared in `Foo`.

4. Check whether the constructor is private.
   - The constructor `Foo()` is private.

5. Check whether the class is public.
   - The class `Foo` is public.

6. Get all inner classes declared in class.
   - There is one inner class declared in `Foo`.

7. Get the name of inner class.
   - The inner class name is `Bar`.

8. Check whether the inner class is a subclass.
   - The inner class `Bar` extends `Foo`, so it is a subclass.

9. Get the super class of inner class.
   - The super class of `Bar` is `Foo`.

10. Check whether the super class is the outer class.
    - The super class `Foo` is indeed the outer class.

11. Get all constructors declared in inner class.
    - There is one constructor declared in `Bar`.

12. Check whether the constructor is public.
    - The constructor `Bar()` is public.

Based on these checks, we can see that the class `Foo` has a private constructor, making it impossible to extend from outside its compilation unit. However, the inner class `Bar` extends `Foo` and can access the private constructor of `Foo` because they are in the same compilation unit. Therefore, the test case is indeed correct and does not violate the rule, as the rule is concerned about extending from outside the compilation unit. The number of violations in this test case is 0.
['Get the name of class.', 'Get the name of the package where the class is located.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is public.', 'Get all inner classes declared in class.', 'Get the name of inner class.', 'Check whether the inner class is a subclass.', 'Get the super class of inner class.', 'Check whether the super class is the outer class.', 'Get all constructors declared in inner class.', 'Check whether the constructor is public.', 'Get the name of class.', 'Get the name of the package where the class is located.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is public.', 'Get all inner classes declared in class.', 'Get the name of inner class.', 'Check whether the inner class is a subclass.', 'Get the super class of inner class.', 'Check whether the super class is the outer class.', 'Get all constructors declared in inner class.', 'Check whether the constructor is public.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Get all inner classes declared in class.* 匹配到的元操作或API：
query: Get all inner classes declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8037850260734558
*Get the name of inner class.* 匹配到的元操作或API：
logic: Get the name of inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.8755849599838257
*Check whether the inner class is a subclass.* 匹配到的元操作或API：
logic: Check whether the inner class is a subclass.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9170817136764526
*Get the super class of inner class.* 匹配到的元操作或API：
logic: Get the super class of inner class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.923866868019104
*Check whether the super class is the outer class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors declared in inner class.* 匹配到的元操作或API：
query: Get all constructors declared in inner class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8095780611038208
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Get all inner classes declared in class.* 匹配到的元操作或API：
query: Get all inner classes declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8037850260734558
*Get the name of inner class.* 匹配到的元操作或API：
logic: Get the name of inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.8755849599838257
*Check whether the inner class is a subclass.* 匹配到的元操作或API：
logic: Check whether the inner class is a subclass.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9170817136764526
*Get the super class of inner class.* 匹配到的元操作或API：
logic: Get the super class of inner class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.923866868019104
*Check whether the super class is the outer class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors declared in inner class.* 匹配到的元操作或API：
query: Get all constructors declared in inner class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8095780611038208
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor
public class Foo {
    private Foo() { }

    public static class Bar extends Foo {
        public Bar() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
9. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                ASTClassOrInterfaceType superClassTypeNode = node.getSuperClassTypeNode();
                if (superClassTypeNode == null || !superClassTypeNode.getPackageName().equals(node.getPackageName()) || 
                    !superClassTypeNode.getSimpleName().equals(node.getSimpleName())) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 4
[ERROR]   "ok 5" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
94
78
107
91
=========================error_testcase_logics=========================
To ascertain whether the provided test case adheres to the rule, we need to perform a series of granular checks on the class `Foo` and its inner classes `Bar` and `Barbie`.

1. Get the name of class.
2. Get all constructors of the class.
3. Check whether the constructor is private.
4. Get the name of the package where the class is located.
5. Check whether the class has any subclasses.
6. Get the name of the subclass.
7. Get the name of the package where the subclass is located.
8. Get all constructors of the subclass.
9. Check whether the constructor of the subclass calls a super constructor.
10. Check whether the super constructor is private.
11. Check whether the subclass is in the same package as the superclass.

For the provided test case:

1. Get the name of class. // Foo
2. Get all constructors of the class. // Foo()
3. Check whether the constructor is private. // No, Foo() is public.
4. Get the name of the package where the class is located. // Assume package name is `com.example`
5. Check whether the class has any subclasses. // Yes, Bar and Barbie are subclasses.
6. Get the name of the subclass. // Bar
7. Get the name of the package where the subclass is located. // `com.example`, same as Foo.
8. Get all constructors of the subclass. // Bar()
9. Check whether the constructor of the subclass calls a super constructor. // No explicit call, but default constructor calls super.
10. Check whether the super constructor is private. // No, super constructor (Foo()) is public.
11. Check whether the subclass is in the same package as the superclass. // Yes, Bar is in the same package as Foo.
12. Get the name of the subclass. // Barbie
13. Get the name of the package where the subclass is located. // `com.example`, same as Foo.
14. Get all constructors of the subclass. // Barbie()
15. Check whether the constructor of the subclass calls a super constructor. // No explicit call, but default constructor calls super.
16. Check whether the super constructor is private. // No, super constructor (Bar()) is private.

Since `Barbie` extends `Bar`, and `Bar` has a private constructor, `Barbie` can only call `Bar`'s constructor within the same package, which aligns with the rule. However, `Foo` itself does not have a private constructor, so it can be extended by any class within the same package or another package that can access it. Since `Foo` has no private constructors, it is not violating the rule by being non-final.

Thus, the number of classes violating the rule in this test case is: 0

The checks show that `Foo` does not violate the rule because it does not have private constructors. `Bar` has a private constructor, and `Barbie` extends `Bar` within the same package, so it is correctly using `Bar`'s private constructor.
['Get the name of class.', 'Get all constructors of the class.', 'Check whether the constructor is private.', 'Get the name of the package where the class is located.', 'Check whether the class has any subclasses.', 'Get the name of the subclass.', 'Get the name of the package where the subclass is located.', 'Get all constructors of the subclass.', 'Check whether the constructor of the subclass calls a super constructor.', 'Check whether the super constructor is private.', 'Check whether the subclass is in the same package as the superclass.', 'Get the name of class. // Foo', 'Get all constructors of the class. // Foo()', 'Check whether the constructor is private. // No, Foo() is public.', 'Get the name of the package where the class is located. // Assume package name is `com.example`', 'Check whether the class has any subclasses. // Yes, Bar and Barbie are subclasses.', 'Get the name of the subclass. // Bar', 'Get the name of the package where the subclass is located. // `com.example`, same as Foo.', 'Get all constructors of the subclass. // Bar()', 'Check whether the constructor of the subclass calls a super constructor. // No explicit call, but default constructor calls super.', 'Check whether the super constructor is private. // No, super constructor (Foo()) is public.', 'Check whether the subclass is in the same package as the superclass. // Yes, Bar is in the same package as Foo.', 'Get the name of the subclass. // Barbie', 'Get the name of the package where the subclass is located. // `com.example`, same as Foo.', 'Get all constructors of the subclass. // Barbie()', 'Check whether the constructor of the subclass calls a super constructor. // No explicit call, but default constructor calls super.', 'Check whether the super constructor is private. // No, super constructor (Bar()) is private.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all constructors of the class.* 匹配到的元操作或API：
query: Get all constructors of the class.
most similar API: get parents of type of constructor
cosine Similarity: 0.8007245063781738
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the class has any subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the subclass.* 匹配到的元操作或API：
logic: Get the name of the subclass.
most similar meta operation: Get the name of class
cosine Similarity: 0.8767188191413879
*Get the name of the package where the subclass is located.* 匹配到的元操作或API：
logic: Get the name of the package where the subclass is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9279201030731201
*Get all constructors of the subclass.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor of the subclass calls a super constructor.* 匹配到的元操作或API：
logic: Check whether the constructor of the subclass calls a super constructor.
most similar meta operation: Check whether the method caller is super
cosine Similarity: 0.8563629388809204
*Check whether the super constructor is private.* 匹配到的元操作或API：
logic: Check whether the super constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9269571304321289
*Check whether the subclass is in the same package as the superclass.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class. // Foo* 匹配到的元操作或API：
logic: Get the name of class. // Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9075838327407837
*Get all constructors of the class. // Foo()* 匹配到的元操作或API：
query: Get all constructors of the class. // Foo()
most similar API: get parents of type of constructor
cosine Similarity: 0.8056363463401794
*Check whether the constructor is private. // No, Foo() is public.* 匹配到的元操作或API：
logic: Check whether the constructor is private. // No, Foo() is public.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9334290027618408
*Get the name of the package where the class is located. // Assume package name is `com.example`* 匹配到的元操作或API：
logic: Get the name of the package where the class is located. // Assume package name is `com.example`
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9213669300079346
*Check whether the class has any subclasses. // Yes, Bar and Barbie are subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the subclass. // Bar* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the package where the subclass is located. // `com.example`, same as Foo.* 匹配到的元操作或API：
logic: Get the name of the package where the subclass is located. // `com.example`, same as Foo.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.861168622970581
*Get all constructors of the subclass. // Bar()* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor of the subclass calls a super constructor. // No explicit call, but default constructor calls super.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the super constructor is private. // No, super constructor (Foo()) is public.* 匹配到的元操作或API：
logic: Check whether the super constructor is private. // No, super constructor (Foo()) is public.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8905213475227356
*Check whether the subclass is in the same package as the superclass. // Yes, Bar is in the same package as Foo.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the subclass. // Barbie* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the package where the subclass is located. // `com.example`, same as Foo.* 匹配到的元操作或API：
logic: Get the name of the package where the subclass is located. // `com.example`, same as Foo.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.861168622970581
*Get all constructors of the subclass. // Barbie()* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor of the subclass calls a super constructor. // No explicit call, but default constructor calls super.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the super constructor is private. // No, super constructor (Bar()) is private.* 匹配到的元操作或API：
logic: Check whether the super constructor is private. // No, super constructor (Bar()) is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8693615794181824
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor of another subclass
public class Foo {
    public Foo() { }

    public static class Bar {
        private Bar() { }
    }

    public static class Barbie extends Bar {
        public Barbie() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Barbie')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.util.List<List<T> getParentsOfType(java.lang.Class)
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()

1.  //Check whether the method caller is super
```java
import net.sourceforge.pmd.lang.java.ast.ASTSuperExpression;
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
public boolean isMethodCallerSuper(ASTMethodCall methodCall){
    if (methodCall.getQualifier() instanceof ASTSuperExpression){
        return true;
    }
    return false;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                if (!hasSubclassWithSuperConstructorCall(node)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean hasSubclassWithSuperConstructorCall(ASTClassOrInterfaceDeclaration node) {
        String packageName = node.getPackageName();
        String simpleName = node.getSimpleName();
        return node.getRoot().descendants(ASTClassOrInterfaceDeclaration.class)
                   .filter(subclass -> !subclass.equals(node))
                   .filter(subclass -> subclass.getPackageName().equals(packageName))
                   .anyMatch(subclass -> subclass.hasDescendantMatching(descendant -> 
                       descendant instanceof ASTSuperConstructorCall && 
                       ((ASTSuperConstructorCall) descendant).getConstructorName().equals(simpleName)));
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all methods declared in class.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Get all inner classes declared in class.
6. Check whether the inner class is a subclass.
7. Get the super class of inner class.
8. Get all constructors declared in super class.
9. Check whether the constructor is private.

Let's perform the checks on the given test case:

1. Get the name of class.
        - The name of the class is `Foo`.

2. Get all methods declared in class.
        - The class `Foo` has no methods declared other than a default constructor.

3. Get all constructors declared in class.
        - Get the constructor for `Foo`.
        - The constructor for `Foo` is public.

4. Check whether the constructor is private.
        - The constructor for `Foo` is not private.

5. Get all inner classes declared in class.
        - The inner classes declared in `Foo` are `Bar` and `Barbie`.

6. Check whether the inner class is a subclass.
        - `Bar` is not a subclass.
        - `Barbie` is a subclass of `Bar`.

7. Get the super class of inner class.
        - The super class of `Barbie` is `Bar`.

8. Get all constructors declared in super class.
        - Get the constructor for `Bar`.
        - The constructor for `Bar` is private.

9. Check whether the constructor is private.
        - The constructor for `Bar` is private.

Based on the checks performed, `Barbie` is able to extend `Bar`, even though `Bar` has a private constructor. This is because the subclass `Barbie` is located in the same compilation unit (the same file) as the super class `Bar`. Therefore, `Barbie` can still call the private constructor of `Bar` without any issues. 

Given this, the class `Foo` does not violate the rule because it contains an inner class `Barbie` that extends another inner class `Bar` with a private constructor, and this is allowed within the same compilation unit.

The number of violations in this test case is: 0.
['Get the name of class.', 'Get all methods declared in class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get all inner classes declared in class.', 'Check whether the inner class is a subclass.', 'Get the super class of inner class.', 'Get all constructors declared in super class.', 'Check whether the constructor is private.', 'Get the name of class.', 'Get all methods declared in class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get all inner classes declared in class.', 'Check whether the inner class is a subclass.', 'Get the super class of inner class.', 'Get all constructors declared in super class.', 'Check whether the constructor is private.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8142817616462708
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Get all inner classes declared in class.* 匹配到的元操作或API：
query: Get all inner classes declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8037850260734558
*Check whether the inner class is a subclass.* 匹配到的元操作或API：
logic: Check whether the inner class is a subclass.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9170817136764526
*Get the super class of inner class.* 匹配到的元操作或API：
logic: Get the super class of inner class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.923866868019104
*Get all constructors declared in super class.* 匹配到的元操作或API：
query: Get all constructors declared in super class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8012975454330444
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8142817616462708
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Get all inner classes declared in class.* 匹配到的元操作或API：
query: Get all inner classes declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8037850260734558
*Check whether the inner class is a subclass.* 匹配到的元操作或API：
logic: Check whether the inner class is a subclass.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9170817136764526
*Get the super class of inner class.* 匹配到的元操作或API：
logic: Get the super class of inner class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.923866868019104
*Get all constructors declared in super class.* 匹配到的元操作或API：
query: Get all constructors declared in super class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8012975454330444
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor of another subclass
public class Foo {
    public Foo() { }

    public static class Bar {
        private Bar() { }
    }

    public static class Barbie extends Bar {
        public Barbie() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Barbie')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal() && !node.isNested()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                ASTClassOrInterfaceType superClass = node.getSuperClassTypeNode();
                if (superClass != null && superClass.getType() != null) {
                    String superClassSimpleName = superClass.getType().getSimpleName();
                    if (!node.getEnclosingClass().getDeclarations(ASTClassOrInterfaceDeclaration.class)
                            .map(ASTClassOrInterfaceDeclaration::getSimpleName)
                            .collect(Collectors.toList())
                            .contains(superClassSimpleName)) {
                        addViolation(data, node);
                    }
                } else {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is public.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Check whether the class has any subclasses.
6. Check whether the subclass is declared in the same compilation unit.
7. Check whether the subclass can call the private constructor of the super class.

For the given test case:

1. Get the name of class: `Foo`
2. Check whether the class is public: Yes, `Foo` is public.
3. Get all constructors declared in class: `Foo` has one constructor `public Foo()`.
4. Check whether the constructor is private: No, the constructor of `Foo` is not private.
5. Check whether the class has any subclasses: Yes, `Bar` and `Barbie` are subclasses.
6. Check whether the subclass is declared in the same compilation unit: Yes, `Bar` and `Barbie` are declared within the same class `Foo`.
7. Check whether the subclass can call the private constructor of the super class: No, `Barbie` cannot call the private constructor of `Bar`.

Since the constructor of `Foo` is not private, the class `Foo` does not violate the rule.

Now, let's check the inner class `Bar`:

1. Get the name of class: `Bar`
2. Check whether the class is public: No, `Bar` is package-private.
3. Get all constructors declared in class: `Bar` has one constructor `private Bar()`.
4. Check whether the constructor is private: Yes, the constructor of `Bar` is private.
5. Check whether the class has any subclasses: Yes, `Barbie` is a subclass.
6. Check whether the subclass is declared in the same compilation unit: Yes, `Barbie` is declared within the same class `Foo`.
7. Check whether the subclass can call the private constructor of the super class: Yes, `Barbie` can call the private constructor of `Bar` because it is in the same compilation unit.

Since `Bar` has a private constructor and a subclass `Barbie` in the same compilation unit that can call the private constructor, `Bar` does not violate the rule.

The number of classes violating the rule in this test case is: 0
['Get the name of class.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has any subclasses.', 'Check whether the subclass is declared in the same compilation unit.', 'Check whether the subclass can call the private constructor of the super class.', 'Get the name of class: `Foo`', 'Check whether the class is public: Yes, `Foo` is public.', 'Get all constructors declared in class: `Foo` has one constructor `public Foo()`.', 'Check whether the constructor is private: No, the constructor of `Foo` is not private.', 'Check whether the class has any subclasses: Yes, `Bar` and `Barbie` are subclasses.', 'Check whether the subclass is declared in the same compilation unit: Yes, `Bar` and `Barbie` are declared within the same class `Foo`.', 'Check whether the subclass can call the private constructor of the super class: No, `Barbie` cannot call the private constructor of `Bar`.', 'Get the name of class: `Bar`', 'Check whether the class is public: No, `Bar` is package-private.', 'Get all constructors declared in class: `Bar` has one constructor `private Bar()`.', 'Check whether the constructor is private: Yes, the constructor of `Bar` is private.', 'Check whether the class has any subclasses: Yes, `Barbie` is a subclass.', 'Check whether the subclass is declared in the same compilation unit: Yes, `Barbie` is declared within the same class `Foo`.', 'Check whether the subclass can call the private constructor of the super class: Yes, `Barbie` can call the private constructor of `Bar` because it is in the same compilation unit.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class has any subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass is declared in the same compilation unit.* 匹配到的元操作或API：
query: Check whether the subclass is declared in the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8679711818695068
*Check whether the subclass can call the private constructor of the super class.* 匹配到的元操作或API：
query: Check whether the subclass can call the private constructor of the super class.
most similar API: Check whether the constructor is private
cosine Similarity: 0.8241037130355835
*Get the name of class: `Foo`* 匹配到的元操作或API：
logic: Get the name of class: `Foo`
most similar meta operation: Get the name of class
cosine Similarity: 0.898124098777771
*Check whether the class is public: Yes, `Foo` is public.* 匹配到的元操作或API：
logic: Check whether the class is public: Yes, `Foo` is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9114856719970703
*Get all constructors declared in class: `Foo` has one constructor `public Foo()`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: No, the constructor of `Foo` is not private.* 匹配到的元操作或API：
logic: Check whether the constructor is private: No, the constructor of `Foo` is not private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9268549084663391
*Check whether the class has any subclasses: Yes, `Bar` and `Barbie` are subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass is declared in the same compilation unit: Yes, `Bar` and `Barbie` are declared within the same class `Foo`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass can call the private constructor of the super class: No, `Barbie` cannot call the private constructor of `Bar`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: `Bar`* 匹配到的元操作或API：
logic: Get the name of class: `Bar`
most similar meta operation: Get the name of class
cosine Similarity: 0.875647783279419
*Check whether the class is public: No, `Bar` is package-private.* 匹配到的元操作或API：
logic: Check whether the class is public: No, `Bar` is package-private.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.8767541646957397
*Get all constructors declared in class: `Bar` has one constructor `private Bar()`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: Yes, the constructor of `Bar` is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private: Yes, the constructor of `Bar` is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9039936065673828
*Check whether the class has any subclasses: Yes, `Barbie` is a subclass.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass is declared in the same compilation unit: Yes, `Barbie` is declared within the same class `Foo`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass can call the private constructor of the super class: Yes, `Barbie` can call the private constructor of `Bar` because it is in the same compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor of another subclass
public class Foo {
    public Foo() { }

    public static class Bar {
        private Bar() { }
    }

    public static class Barbie extends Bar {
        public Barbie() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Barbie')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                if (!canBeSubclassedInSameCompilationUnit(node)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean canBeSubclassedInSameCompilationUnit(ASTClassOrInterfaceDeclaration node) {
        String simpleName = node.getSimpleName();
        return node.getCompilationUnit().descendants(ASTClassOrInterfaceDeclaration.class)
                   .filter(n -> !n.equals(node) && n.isPublic() && n.hasExtendsClause() &&
                          n.getExtendsList().getFirstExtendsType().isReferenceToClassSameCompilationUnit() &&
                          n.getExtendsList().getFirstExtendsType().getType() != null &&
                          simpleName.equals(n.getExtendsList().getFirstExtendsType().getType().getSimpleName()))
                   .findFirst().isPresent();
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Check whether the class has declared constructors.
        3. Get a declared constructor of class.
        4. Check whether the constructor is private.
        5. Get the class that method located in.
        6. Get all subclasses of the class.
        7. Check whether the subclass is within the same compilation unit.
        8. Check whether the subclass has declared constructors.
        9. Get a declared constructor of subclass.
        10. Check whether the constructor of subclass is calling a super constructor.
        11. If the super constructor is private, check whether the subclass is within the same compilation unit.
        12. If all constructors of the class are private, check whether all subclasses are within the same compilation unit.

For the provided test case:

1. Get the name of class (Foo).
2. Check whether the class has declared constructors (Yes, public Foo() {}).
3. Get a declared constructor of class (public Foo() {}).
4. Check whether the constructor is private (No).
5. Get the class that method located in (Not applicable for constructors in this context).
6. Get all subclasses of the class (Bar and Barbie).
7. Check whether the subclass Bar is within the same compilation unit (Yes, it is an inner static class).
8. Check whether the subclass Bar has declared constructors (Yes, private Bar() {}).
9. Get a declared constructor of subclass Bar (private Bar() {}).
10. Check whether the constructor of subclass Bar is calling a super constructor (Not applicable, as Bar is a static inner class).
11. Check whether the subclass Barbie is within the same compilation unit (Yes, it is an inner static class).
12. Check whether the subclass Barbie has declared constructors (Yes, public Barbie() {}).
13. Get a declared constructor of subclass Barbie (public Barbie() {}).
14. Check whether the constructor of subclass Barbie is calling a super constructor (Yes, it implicitly calls the super constructor of Bar).
15. Check whether the super constructor of Barbie is private (Yes, private Bar() {}).
16. Check whether the subclass Barbie is within the same compilation unit (Yes, it is an inner static class).
17. Get the name of class (Bar).
18. Check whether the class has declared constructors (Yes, private Bar() {}).
19. Get a declared constructor of class (private Bar() {}).
20. Check whether the constructor is private (Yes).
21. Get the class that method located in (Bar).
22. Get all subclasses of the class (Barbie).
23. Check whether the subclass Barbie is within the same compilation unit (Yes, it is an inner static class).

No violations of the rule are found in the provided test case as the subclass `Barbie` is within the same compilation unit as the parent class `Bar` which has a private constructor. Therefore, the number of violations in this test case is indeed 0.
['Get the name of class.', 'Check whether the class has declared constructors.', 'Get a declared constructor of class.', 'Check whether the constructor is private.', 'Get the class that method located in.', 'Get all subclasses of the class.', 'Check whether the subclass is within the same compilation unit.', 'Check whether the subclass has declared constructors.', 'Get a declared constructor of subclass.', 'Check whether the constructor of subclass is calling a super constructor.', 'If the super constructor is private, check whether the subclass is within the same compilation unit.', 'If all constructors of the class are private, check whether all subclasses are within the same compilation unit.', 'Get the name of class (Foo).', 'Check whether the class has declared constructors (Yes, public Foo() {}).', 'Get a declared constructor of class (public Foo() {}).', 'Check whether the constructor is private (No).', 'Get the class that method located in (Not applicable for constructors in this context).', 'Get all subclasses of the class (Bar and Barbie).', 'Check whether the subclass Bar is within the same compilation unit (Yes, it is an inner static class).', 'Check whether the subclass Bar has declared constructors (Yes, private Bar() {}).', 'Get a declared constructor of subclass Bar (private Bar() {}).', 'Check whether the constructor of subclass Bar is calling a super constructor (Not applicable, as Bar is a static inner class).', 'Check whether the subclass Barbie is within the same compilation unit (Yes, it is an inner static class).', 'Check whether the subclass Barbie has declared constructors (Yes, public Barbie() {}).', 'Get a declared constructor of subclass Barbie (public Barbie() {}).', 'Check whether the constructor of subclass Barbie is calling a super constructor (Yes, it implicitly calls the super constructor of Bar).', 'Check whether the super constructor of Barbie is private (Yes, private Bar() {}).', 'Check whether the subclass Barbie is within the same compilation unit (Yes, it is an inner static class).', 'Get the name of class (Bar).', 'Check whether the class has declared constructors (Yes, private Bar() {}).', 'Get a declared constructor of class (private Bar() {}).', 'Check whether the constructor is private (Yes).', 'Get the class that method located in (Bar).', 'Get all subclasses of the class (Barbie).', 'Check whether the subclass Barbie is within the same compilation unit (Yes, it is an inner static class).']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared constructors.* 匹配到的元操作或API：
logic: Check whether the class has declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.8875758051872253
*Get a declared constructor of class.* 匹配到的元操作或API：
logic: Get a declared constructor of class.
most similar meta operation: Get a declared annotation of constructor
cosine Similarity: 0.8581588864326477
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Get the class that method located in.* 匹配到的元操作或API：
logic: Get the class that method located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9805242419242859
*Get all subclasses of the class.* 匹配到的元操作或API：
query: Get all subclasses of the class.
most similar API: get permitted subclasses of class or interface
cosine Similarity: 0.8104345202445984
*Check whether the subclass is within the same compilation unit.* 匹配到的元操作或API：
query: Check whether the subclass is within the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8663298487663269
*Check whether the subclass has declared constructors.* 匹配到的元操作或API：
logic: Check whether the subclass has declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.8736307621002197
*Get a declared constructor of subclass.* 匹配到的元操作或API：
query: Get a declared constructor of subclass.
most similar API: get class of constructor
cosine Similarity: 0.806240975856781
*Check whether the constructor of subclass is calling a super constructor.* 匹配到的元操作或API：
query: Check whether the constructor of subclass is calling a super constructor.
most similar API: Check whether the constructor equals
cosine Similarity: 0.8013418912887573
*If the super constructor is private, check whether the subclass is within the same compilation unit.* 匹配到的元操作或API：
query: If the super constructor is private, check whether the subclass is within the same compilation unit.
most similar API: Check whether the constructor is package private
cosine Similarity: 0.849428653717041
*If all constructors of the class are private, check whether all subclasses are within the same compilation unit.* 匹配到的元操作或API：
query: If all constructors of the class are private, check whether all subclasses are within the same compilation unit.
most similar API: Check whether the constructor is package private
cosine Similarity: 0.8336350321769714
*Get the name of class (Foo).* 匹配到的元操作或API：
logic: Get the name of class (Foo).
most similar meta operation: Get the name of class
cosine Similarity: 0.9299685955047607
*Check whether the class has declared constructors (Yes, public Foo() {}).* 匹配到的元操作或API：
logic: Check whether the class has declared constructors (Yes, public Foo() {}).
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.8690996170043945
*Get a declared constructor of class (public Foo() {}).* 匹配到的元操作或API：
query: Get a declared constructor of class (public Foo() {}).
most similar API: get class of constructor
cosine Similarity: 0.8209894299507141
*Check whether the constructor is private (No).* 匹配到的元操作或API：
logic: Check whether the constructor is private (No).
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9569287300109863
*Get the class that method located in (Not applicable for constructors in this context).* 匹配到的元操作或API：
logic: Get the class that method located in (Not applicable for constructors in this context).
most similar meta operation: Get the class that method located in
cosine Similarity: 0.911188006401062
*Get all subclasses of the class (Bar and Barbie).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass Bar is within the same compilation unit (Yes, it is an inner static class).* 匹配到的元操作或API：
query: Check whether the subclass Bar is within the same compilation unit (Yes, it is an inner static class).
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.812312662601471
*Check whether the subclass Bar has declared constructors (Yes, private Bar() {}).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get a declared constructor of subclass Bar (private Bar() {}).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor of subclass Bar is calling a super constructor (Not applicable, as Bar is a static inner class).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass Barbie is within the same compilation unit (Yes, it is an inner static class).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass Barbie has declared constructors (Yes, public Barbie() {}).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get a declared constructor of subclass Barbie (public Barbie() {}).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor of subclass Barbie is calling a super constructor (Yes, it implicitly calls the super constructor of Bar).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the super constructor of Barbie is private (Yes, private Bar() {}).* 匹配到的元操作或API：
query: Check whether the super constructor of Barbie is private (Yes, private Bar() {}).
most similar API: Check whether the constructor is private
cosine Similarity: 0.8404396176338196
*Check whether the subclass Barbie is within the same compilation unit (Yes, it is an inner static class).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class (Bar).* 匹配到的元操作或API：
logic: Get the name of class (Bar).
most similar meta operation: Get the name of class
cosine Similarity: 0.8879575729370117
*Check whether the class has declared constructors (Yes, private Bar() {}).* 匹配到的元操作或API：
query: Check whether the class has declared constructors (Yes, private Bar() {}).
most similar API: Check whether is declared in class
cosine Similarity: 0.818688690662384
*Get a declared constructor of class (private Bar() {}).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private (Yes).* 匹配到的元操作或API：
logic: Check whether the constructor is private (Yes).
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9517254829406738
*Get the class that method located in (Bar).* 匹配到的元操作或API：
logic: Get the class that method located in (Bar).
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9159724712371826
*Get all subclasses of the class (Barbie).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass Barbie is within the same compilation unit (Yes, it is an inner static class).* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor of another subclass
public class Foo {
    public Foo() { }

    public static class Bar {
        private Bar() { }
    }

    public static class Barbie extends Bar {
        public Barbie() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Barbie')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.util.List<ASTClassOrInterfaceType> getPermittedSubclasses()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
8. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean equals(java.lang.Object)
9. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPackagePrivate()
10. net.sourceforge.pmd.lang.java.types.TypeTestUtil: static public boolean isDeclaredInClass(java.lang.Class, net.sourceforge.pmd.lang.java.types.JMethodSig), //Returns true if the signature is that of a method declared in the given class. @param klass Class @param sig   Method signature to test @throws NullPointerException If any argument is null

1.  //Check whether constructor has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTConstructorDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                if (!hasSubclassInSameCompilationUnit(node)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean hasSubclassInSameCompilationUnit(ASTClassOrInterfaceDeclaration node) {
        String className = node.getSimpleName();
        return node.getRoot().findDescendantsOfType(ASTClassOrInterfaceDeclaration.class)
                .stream()
                .filter(subclass -> !subclass.equals(node))
                .anyMatch(subclass -> {
                    ASTExtendsList extendsList = subclass.getFirstDescendantOfType(ASTExtendsList.class);
                    return extendsList != null && extendsList.getFirstChildOfType(ASTClassOrInterfaceType.class)
                            .isReferenceToClassSameCompilationUnit() && extendsList.getFirstChildOfType(ASTClassOrInterfaceType.class)
                            .getType() != null && extendsList.getFirstChildOfType(ASTClassOrInterfaceType.class)
                            .getType().getSimpleName().equals(className);
                });
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 5" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 5" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Check whether class has any constructors.
        3. Check whether each constructor is private.
        4. Get all subclasses declared within the same compilation unit.
        5. Check whether each subclass has a constructor.
        6. Check whether each constructor of subclasses calls the constructor of the super class.
        7. Check whether the super class constructor called by subclass is private.

In this specific test case:
1. Get the name of class. -> Foo
2. Check whether class has any constructors. -> Yes, it has one public constructor.
3. Check whether each constructor is private. -> No, the constructor is not private.
4. Get all subclasses declared within the same compilation unit. -> Bar, Barbie
5. Check whether each subclass has a constructor. -> Bar has one private constructor, Barbie has one public constructor.
6. Check whether each constructor of subclasses calls the constructor of the super class. -> Barbie's constructor doesn't explicitly call Bar's constructor, but implicitly calls the default constructor of Bar, which is not possible since Bar's constructor is private.
7. Check whether the super class constructor called by subclass is private. -> No, because Barbie's constructor doesn't call Bar's constructor.

However, the specific issue here is with `Barbie` attempting to extend `Bar` using `Bar`'s private constructor, which is not allowed.

To clarify the checks for the rule:
1. Get the name of class. -> Bar
2. Check whether class has any constructors. -> Yes, it has one private constructor.
3. Check whether each constructor is private. -> Yes, the constructor is private.
4. Get all subclasses declared within the same compilation unit. -> Barbie
5. Check whether each subclass has a constructor. -> Barbie has one public constructor.
6. Check whether each constructor of subclasses calls the constructor of the super class. -> Barbie's constructor does not call Bar's constructor.
7. Check whether the super class constructor called by subclass is private. -> This step is not applicable here because Barbie doesn't attempt to call Bar's constructor explicitly. But since Bar's constructor is private, Barbie cannot extend Bar outside the compilation unit.

Therefore, the test case violates the rule because `Bar` has a private constructor, but `Barbie` attempts to extend `Bar`, which is not possible outside the compilation unit.

The number of violating the rule in this test case is: 1 (Bar class)
['Get the name of class.', 'Check whether class has any constructors.', 'Check whether each constructor is private.', 'Get all subclasses declared within the same compilation unit.', 'Check whether each subclass has a constructor.', 'Check whether each constructor of subclasses calls the constructor of the super class.', 'Check whether the super class constructor called by subclass is private.', 'Get the name of class. -> Foo', 'Check whether class has any constructors. -> Yes, it has one public constructor.', 'Check whether each constructor is private. -> No, the constructor is not private.', 'Get all subclasses declared within the same compilation unit. -> Bar, Barbie', 'Check whether each subclass has a constructor. -> Bar has one private constructor, Barbie has one public constructor.', "Check whether each constructor of subclasses calls the constructor of the super class. -> Barbie's constructor doesn't explicitly call Bar's constructor, but implicitly calls the default constructor of Bar, which is not possible since Bar's constructor is private.", "Check whether the super class constructor called by subclass is private. -> No, because Barbie's constructor doesn't call Bar's constructor.", 'Get the name of class. -> Bar', 'Check whether class has any constructors. -> Yes, it has one private constructor.', 'Check whether each constructor is private. -> Yes, the constructor is private.', 'Get all subclasses declared within the same compilation unit. -> Barbie', 'Check whether each subclass has a constructor. -> Barbie has one public constructor.', "Check whether each constructor of subclasses calls the constructor of the super class. -> Barbie's constructor does not call Bar's constructor.", "Check whether the super class constructor called by subclass is private. -> This step is not applicable here because Barbie doesn't attempt to call Bar's constructor explicitly. But since Bar's constructor is private, Barbie cannot extend Bar outside the compilation unit."]
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether class has any constructors.* 匹配到的元操作或API：
query: Check whether class has any constructors.
most similar API: Check whether the constructor is any annotation present
cosine Similarity: 0.864251971244812
*Check whether each constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442477226257324
*Get all subclasses declared within the same compilation unit.* 匹配到的元操作或API：
query: Get all subclasses declared within the same compilation unit.
most similar API: get class of compilation unit
cosine Similarity: 0.802825927734375
*Check whether each subclass has a constructor.* 匹配到的元操作或API：
query: Check whether each subclass has a constructor.
most similar API: Check whether the constructor is any annotation present
cosine Similarity: 0.8316447734832764
*Check whether each constructor of subclasses calls the constructor of the super class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the super class constructor called by subclass is private.* 匹配到的元操作或API：
logic: Check whether the super class constructor called by subclass is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8966695666313171
*Get the name of class. -> Foo* 匹配到的元操作或API：
logic: Get the name of class. -> Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9176737666130066
*Check whether class has any constructors. -> Yes, it has one public constructor.* 匹配到的元操作或API：
query: Check whether class has any constructors. -> Yes, it has one public constructor.
most similar API: Check whether the constructor is public
cosine Similarity: 0.8341292142868042
*Check whether each constructor is private. -> No, the constructor is not private.* 匹配到的元操作或API：
logic: Check whether each constructor is private. -> No, the constructor is not private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9236092567443848
*Get all subclasses declared within the same compilation unit. -> Bar, Barbie* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each subclass has a constructor. -> Bar has one private constructor, Barbie has one public constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each constructor of subclasses calls the constructor of the super class. -> Barbie's constructor doesn't explicitly call Bar's constructor, but implicitly calls the default constructor of Bar, which is not possible since Bar's constructor is private.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the super class constructor called by subclass is private. -> No, because Barbie's constructor doesn't call Bar's constructor.* 匹配到的元操作或API：
query: Check whether the super class constructor called by subclass is private. -> No, because Barbie's constructor doesn't call Bar's constructor.
most similar API: Check whether the constructor is private
cosine Similarity: 0.8370088338851929
*Get the name of class. -> Bar* 匹配到的元操作或API：
logic: Get the name of class. -> Bar
most similar meta operation: Get the name of class
cosine Similarity: 0.8880960941314697
*Check whether class has any constructors. -> Yes, it has one private constructor.* 匹配到的元操作或API：
query: Check whether class has any constructors. -> Yes, it has one private constructor.
most similar API: Check whether the constructor is private
cosine Similarity: 0.8452368378639221
*Check whether each constructor is private. -> Yes, the constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private. -> Yes, the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9309709668159485
*Get all subclasses declared within the same compilation unit. -> Barbie* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each subclass has a constructor. -> Barbie has one public constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each constructor of subclasses calls the constructor of the super class. -> Barbie's constructor does not call Bar's constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the super class constructor called by subclass is private. -> This step is not applicable here because Barbie doesn't attempt to call Bar's constructor explicitly. But since Bar's constructor is private, Barbie cannot extend Bar outside the compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor of another subclass
public class Foo {
    public Foo() { }

    public static class Bar {
        private Bar() { }
    }

    public static class Barbie extends Bar {
        public Barbie() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Barbie')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection), //Checks whether any annotation is present on this node. @param binaryNames            Collection that contains binary names of annotations.            Note: for now, canonical names are tolerated, this may be changed in PMD 7. @return <code>true</code> if any annotation is present on this node, else <code>false</code>
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public java.lang.Class<Class<?> getClass()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                String className = node.getSimpleName();
                ASTCompilationUnit compilationUnit = node.getFirstParentOfType(ASTCompilationUnit.class);
                if (!compilationUnit.descendants(ASTClassOrInterfaceDeclaration.class)
                    .filter(n -> n.isExtendingClass(className))
                    .findAny().isPresent()) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isExtendingClass(ASTClassOrInterfaceDeclaration node, String className) {
        ASTExtendsList extendsList = node.getFirstChildOfType(ASTExtendsList.class);
        return extendsList != null && extendsList.getType() != null && extendsList.getType().getImage().equals(className);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 5
[ERROR]   "ok 6" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
94
78
107
91
=========================error_testcase_logics=========================
To granularly check whether the test case adheres to the rule, we will perform the following checks:

1. Get the name of class.
        2. Check whether the class is public.
        3. Get all constructors declared in class.
        4. Check whether the constructor is private.
        5. Get the name of the class where the constructor is declared.
        6. Get the name of class.
        7. Check whether the class has extended x class.
        8. Get the name of the package where the class is located.
        9. Get the name of the package where the extended class is located.
        10. Check whether the package where the class is located is the same as the package where the extended class is located.
        If the class is public, all its constructors are private, and it is extended by another class in a different package, then this test case violates the rule.

For the provided test case:

1. Get the name of class: Foo
        2. Check whether the class is public: True
        3. Get all constructors declared in class: private Foo()
        4. Check whether the constructor is private: True
        5. Get the name of the class where the constructor is declared: Foo
        6. Get the name of class: Bar
        7. Check whether the class has extended x class: True (extended Foo)
        8. Get the name of the package where the class is located: (Assume) Package A for Foo and Package B for Bar
        9. Get the name of the package where the extended class is located: (Assume) Package A for Foo
        10. Check whether the package where the class is located is the same as the package where the extended class is located: False (Foo is in Package A, Bar is in Package B)

Since the class `Bar` extends `Foo` from a different package and `Foo` has a private constructor, the rule is not violated. Therefore, the number of classes violating the rule in this test case is 0.
['Get the name of class.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get the name of the class where the constructor is declared.', 'Get the name of class.', 'Check whether the class has extended x class.', 'Get the name of the package where the class is located.', 'Get the name of the package where the extended class is located.', 'Check whether the package where the class is located is the same as the package where the extended class is located.', 'Get the name of class: Foo', 'Check whether the class is public: True', 'Get all constructors declared in class: private Foo()', 'Check whether the constructor is private: True', 'Get the name of the class where the constructor is declared: Foo', 'Get the name of class: Bar', 'Check whether the class has extended x class: True (extended Foo)', 'Get the name of the package where the class is located: (Assume) Package A for Foo and Package B for Bar', 'Get the name of the package where the extended class is located: (Assume) Package A for Foo', 'Check whether the package where the class is located is the same as the package where the extended class is located: False (Foo is in Package A, Bar is in Package B)']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Get the name of the class where the constructor is declared.* 匹配到的元操作或API：
logic: Get the name of the class where the constructor is declared.
most similar meta operation: Get the name of constructor
cosine Similarity: 0.8592052459716797
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Get the name of the package where the extended class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the extended class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9088035225868225
*Check whether the package where the class is located is the same as the package where the extended class is located.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: Foo* 匹配到的元操作或API：
logic: Get the name of class: Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9263079166412354
*Check whether the class is public: True* 匹配到的元操作或API：
logic: Check whether the class is public: True
most similar meta operation: Check whether the class is public
cosine Similarity: 0.970706582069397
*Get all constructors declared in class: private Foo()* 匹配到的元操作或API：
query: Get all constructors declared in class: private Foo()
most similar API: get declared annotations of constructor
cosine Similarity: 0.8338078856468201
*Check whether the constructor is private: True* 匹配到的元操作或API：
logic: Check whether the constructor is private: True
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9794566035270691
*Get the name of the class where the constructor is declared: Foo* 匹配到的元操作或API：
logic: Get the name of the class where the constructor is declared: Foo
most similar meta operation: Get the name of constructor
cosine Similarity: 0.8519772291183472
*Get the name of class: Bar* 匹配到的元操作或API：
logic: Get the name of class: Bar
most similar meta operation: Get the name of class
cosine Similarity: 0.8756612539291382
*Check whether the class has extended x class: True (extended Foo)* 匹配到的元操作或API：
logic: Check whether the class has extended x class: True (extended Foo)
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9555427432060242
*Get the name of the package where the class is located: (Assume) Package A for Foo and Package B for Bar* 匹配到的元操作或API：
logic: Get the name of the package where the class is located: (Assume) Package A for Foo and Package B for Bar
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9165159463882446
*Get the name of the package where the extended class is located: (Assume) Package A for Foo* 匹配到的元操作或API：
logic: Get the name of the package where the extended class is located: (Assume) Package A for Foo
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.8865658640861511
*Check whether the package where the class is located is the same as the package where the extended class is located: False (Foo is in Package A, Bar is in Package B)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Ok, two classes
public class Foo {
    private Foo() { }
}
class Bar extends Foo {
    public Bar() { }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
——ASTClassOrInterfaceDeclaration (class name = 'Bar')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.String getName()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()

1.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                if (node.getPackageName() == null || node.getPackageName().isEmpty()) {
                    addViolation(data, node);
                } else {
                    NodeStream<ASTClassOrInterfaceDeclaration> allClasses = node.getRoot().descendants(ASTClassOrInterfaceDeclaration.class);
                    boolean hasSubclassInSamePackage = allClasses.anyMatch(c -> !c.equals(node) && node.getSimpleName().equals(c.getSuperClassTypeNode().getSimpleName()) && node.getPackageName().equals(c.getPackageName()));
                    if (!hasSubclassInSamePackage) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Get the constructors of class.
        3. Check whether the constructor is private.
        4. Get the class that method is located in.
        5. Check whether the class has declared annotations.
        6. Get the name of the package where the class is located.
        7. Check whether the class is public.
        8. Check whether the class is abstract.
        9. Get a class that extends this class.
        10. Check whether the extending class is in the same package.
        11. Get the constructors of the extending class.
        12. Check whether the constructor of the extending class is public.

For class Foo:
1. Get the name of class: Foo
2. Get the constructors of class: Foo()
3. Check whether the constructor is private: true
4. Get the class that method is located in: Foo
5. Check whether the class has declared annotations: false
6. Get the name of the package where the class is located: (default package)
7. Check whether the class is public: true
8. Check whether the class is abstract: false
9. Get a class that extends this class: Bar
10. Check whether the extending class is in the same package: true
11. Get the constructors of the extending class: Bar()
12. Check whether the constructor of the extending class is public: true

For class Bar:
1. Get the name of class: Bar
2. Get the constructors of class: Bar()
3. Check whether the constructor is private: false
4. Get the class that method is located in: Bar
5. Check whether the class has declared annotations: false
6. Get the name of the package where the class is located: (default package)
7. Check whether the class is public: false
8. Check whether the class is abstract: false
9. Get a class that extends this class: (none)
10. (Not applicable as Bar is not extending any class)
11. (Not applicable as Bar is not extending any class)
12. (Not applicable as Bar is not extending any class)

13. Get the accessed variable in the assignment expression: a
14. Check whether the accessed variable is a field: true
15. Check whether the accessed variable is final: true
16. Check whether the accessed variable is in the same class: false
17. Get the class that the field is located in: Foo

Based on the checks performed, the test case does not violate the rule because:
- Class Foo has a private constructor.
- Class Bar extends Foo but is in the same package, which means it could still technically extend Foo within the same compilation unit.
- The rule specifies to report classes that cannot be extended from outside their compilation unit, and since Bar is in the same package, Foo could still be extended.
- There is no reassignment to a final field within the same class.

Thus, the number of classes violating the rule in this test case is: 0
['Get the name of class.', 'Get the constructors of class.', 'Check whether the constructor is private.', 'Get the class that method is located in.', 'Check whether the class has declared annotations.', 'Get the name of the package where the class is located.', 'Check whether the class is public.', 'Check whether the class is abstract.', 'Get a class that extends this class.', 'Check whether the extending class is in the same package.', 'Get the constructors of the extending class.', 'Check whether the constructor of the extending class is public.', 'Get the name of class: Foo', 'Get the constructors of class: Foo()', 'Check whether the constructor is private: true', 'Get the class that method is located in: Foo', 'Check whether the class has declared annotations: false', 'Get the name of the package where the class is located: (default package)', 'Check whether the class is public: true', 'Check whether the class is abstract: false', 'Get a class that extends this class: Bar', 'Check whether the extending class is in the same package: true', 'Get the constructors of the extending class: Bar()', 'Check whether the constructor of the extending class is public: true', 'Get the name of class: Bar', 'Get the constructors of class: Bar()', 'Check whether the constructor is private: false', 'Get the class that method is located in: Bar', 'Check whether the class has declared annotations: false', 'Get the name of the package where the class is located: (default package)', 'Check whether the class is public: false', 'Check whether the class is abstract: false', 'Get a class that extends this class: (none)', '(Not applicable as Bar is not extending any class)', '(Not applicable as Bar is not extending any class)', '(Not applicable as Bar is not extending any class)', 'Get the accessed variable in the assignment expression: a', 'Check whether the accessed variable is a field: true', 'Check whether the accessed variable is final: true', 'Check whether the accessed variable is in the same class: false', 'Get the class that the field is located in: Foo']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the constructors of class.* 匹配到的元操作或API：
query: Get the constructors of class.
most similar API: get class of constructor
cosine Similarity: 0.8381322622299194
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Get the class that method is located in.* 匹配到的元操作或API：
logic: Get the class that method is located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.973173975944519
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Get a class that extends this class.* 匹配到的元操作或API：
query: Get a class that extends this class.
most similar API: get class of extends list
cosine Similarity: 0.8253310322761536
*Check whether the extending class is in the same package.* 匹配到的元操作或API：
query: Check whether the extending class is in the same package.
most similar API: Check whether the extends list equals
cosine Similarity: 0.8059285283088684
*Get the constructors of the extending class.* 匹配到的元操作或API：
query: Get the constructors of the extending class.
most similar API: get parents of type of constructor
cosine Similarity: 0.8055493831634521
*Check whether the constructor of the extending class is public.* 匹配到的元操作或API：
logic: Check whether the constructor of the extending class is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.9326698780059814
*Get the name of class: Foo* 匹配到的元操作或API：
logic: Get the name of class: Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9263079166412354
*Get the constructors of class: Foo()* 匹配到的元操作或API：
query: Get the constructors of class: Foo()
most similar API: get parents of type of constructor
cosine Similarity: 0.8332954049110413
*Check whether the constructor is private: true* 匹配到的元操作或API：
logic: Check whether the constructor is private: true
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9794566035270691
*Get the class that method is located in: Foo* 匹配到的元操作或API：
logic: Get the class that method is located in: Foo
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9508589506149292
*Check whether the class has declared annotations: false* 匹配到的元操作或API：
logic: Check whether the class has declared annotations: false
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9624305963516235
*Get the name of the package where the class is located: (default package)* 匹配到的元操作或API：
logic: Get the name of the package where the class is located: (default package)
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9495745897293091
*Check whether the class is public: true* 匹配到的元操作或API：
logic: Check whether the class is public: true
most similar meta operation: Check whether the class is public
cosine Similarity: 0.970706582069397
*Check whether the class is abstract: false* 匹配到的元操作或API：
logic: Check whether the class is abstract: false
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9601573944091797
*Get a class that extends this class: Bar* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the extending class is in the same package: true* 匹配到的元操作或API：
query: Check whether the extending class is in the same package: true
most similar API: Check whether the extends list equals
cosine Similarity: 0.8114404082298279
*Get the constructors of the extending class: Bar()* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor of the extending class is public: true* 匹配到的元操作或API：
logic: Check whether the constructor of the extending class is public: true
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.9197568893432617
*Get the name of class: Bar* 匹配到的元操作或API：
logic: Get the name of class: Bar
most similar meta operation: Get the name of class
cosine Similarity: 0.8756612539291382
*Get the constructors of class: Bar()* 匹配到的元操作或API：
query: Get the constructors of class: Bar()
most similar API: get parents of type of constructor
cosine Similarity: 0.8018052577972412
*Check whether the constructor is private: false* 匹配到的元操作或API：
logic: Check whether the constructor is private: false
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.977182149887085
*Get the class that method is located in: Bar* 匹配到的元操作或API：
logic: Get the class that method is located in: Bar
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9141895771026611
*Check whether the class has declared annotations: false* 匹配到的元操作或API：
logic: Check whether the class has declared annotations: false
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9624305963516235
*Get the name of the package where the class is located: (default package)* 匹配到的元操作或API：
logic: Get the name of the package where the class is located: (default package)
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9495745897293091
*Check whether the class is public: false* 匹配到的元操作或API：
logic: Check whether the class is public: false
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9623566269874573
*Check whether the class is abstract: false* 匹配到的元操作或API：
logic: Check whether the class is abstract: false
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9601573944091797
*Get a class that extends this class: (none)* 匹配到的元操作或API：
query: Get a class that extends this class: (none)
most similar API: get class of extends list
cosine Similarity: 0.826433002948761
*(Not applicable as Bar is not extending any class)* 匹配到的元操作或API：
未匹配成功元操作或API
*(Not applicable as Bar is not extending any class)* 匹配到的元操作或API：
未匹配成功元操作或API
*(Not applicable as Bar is not extending any class)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the accessed variable in the assignment expression: a* 匹配到的元操作或API：
logic: Get the accessed variable in the assignment expression: a
most similar meta operation: Get the variable declaration of the accessed variable
cosine Similarity: 0.8623800277709961
*Check whether the accessed variable is a field: true* 匹配到的元操作或API：
logic: Check whether the accessed variable is a field: true
most similar meta operation: Check whether the accessed variable is a field
cosine Similarity: 0.9743279218673706
*Check whether the accessed variable is final: true* 匹配到的元操作或API：
logic: Check whether the accessed variable is final: true
most similar meta operation: Check whether the accessed variable is final
cosine Similarity: 0.9802031517028809
*Check whether the accessed variable is in the same class: false* 匹配到的元操作或API：
logic: Check whether the accessed variable is in the same class: false
most similar meta operation: Check whether the accessed variable is a local variable
cosine Similarity: 0.8742850422859192
*Get the class that the field is located in: Foo* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Ok, two classes
public class Foo {
    private Foo() { }
}
class Bar extends Foo {
    public Bar() { }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
——ASTClassOrInterfaceDeclaration (class name = 'Bar')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
8. net.sourceforge.pmd.lang.java.ast.ASTExtendsList: public java.lang.Class<Class<?> getClass()
9. net.sourceforge.pmd.lang.java.ast.ASTExtendsList: public boolean equals(java.lang.Object)
10. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.util.List<List<T> getParentsOfType(java.lang.Class)
11. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Get the variable declaration of the accessed variable
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
public ASTVariableDeclaratorId getVariableDeclaration(ASTVariableAccess var) {
    JVariableSymbol symbol = var.getReferencedSym();
    if(symbol != null){
        ASTVariableDeclaratorId declaratorId = symbol.tryGetNode();
        return declaratorId;
    }
    return null;
}
```
3.  //Check whether the accessed variable is a field
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;
public boolean isVariableAccessField(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JFieldSymbol) {
        JFieldSymbol fieldSym = (JFieldSymbol) sym;
        return true;
    }
    return false;
}
```
4.  //Check whether the accessed variable is final
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
public boolean isVariableAccessFinal(ASTVariableAccess var){
    JVariableSymbol symbol = var.getReferencedSym();
    if (symbol == null) {
        return false;
    }
    if (var.getReferencedSym().isFinal()) {
        return true;
    }
    return false;
}
```
5.  //Check whether the accessed variable is a local variable
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JLocalVariableSymbol;
public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JLocalVariableSymbol) {
        JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
        return true;
    }
    return false;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                // Check if there are any subclasses in the same compilation unit
                if (!hasClassSubclassInSameCompilationUnit(node)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean hasClassSubclassInSameCompilationUnit(ASTClassOrInterfaceDeclaration node) {
        String packageName = node.getPackageName();
        String simpleName = node.getSimpleName();
        return node.getRoot().descendants(ASTClassOrInterfaceDeclaration.class)
                .filter(sub -> sub.getPackageName().equals(packageName))
                .anyMatch(sub -> sub.hasExtendsList() && sub.getExtendsList().getExtendedType().getType().getSimpleName().equals(simpleName));
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Check whether the class is public.
        3. Get the constructors of class.
        4. Check whether each constructor is private.
        5. Get the subclasses of class.
        6. Check whether each subclass is outside the compilation unit.

Let's break down the checks for the provided test case:

1. Get the name of class.
   - Class name: Foo

2. Check whether the class is public.
   - Yes, the class Foo is public.

3. Get the constructors of class.
   - Constructor: private Foo() { }

4. Check whether each constructor is private.
   - Yes, the constructor of Foo is private.

5. Get the subclasses of class.
   - Subclass: Bar

6. Check whether each subclass is outside the compilation unit.
   - No, the subclass Bar is in the same compilation unit as Foo.

Since the subclass Bar is within the same compilation unit as Foo, the rule does not apply here. Therefore, the number of violations in this test case is 0.

If we wanted to ensure that Foo itself is not incorrectly flagged as a violation, we would also need to check whether Foo has any non-private constructors, but given the test case, that is already clear.
['Get the name of class.', 'Check whether the class is public.', 'Get the constructors of class.', 'Check whether each constructor is private.', 'Get the subclasses of class.', 'Check whether each subclass is outside the compilation unit.', 'Get the name of class.', 'Check whether the class is public.', 'Get the constructors of class.', 'Check whether each constructor is private.', 'Get the subclasses of class.', 'Check whether each subclass is outside the compilation unit.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Get the constructors of class.* 匹配到的元操作或API：
query: Get the constructors of class.
most similar API: get class of constructor
cosine Similarity: 0.8381322622299194
*Check whether each constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442477226257324
*Get the subclasses of class.* 匹配到的元操作或API：
logic: Get the subclasses of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.8690205216407776
*Check whether each subclass is outside the compilation unit.* 匹配到的元操作或API：
query: Check whether each subclass is outside the compilation unit.
most similar API: Check whether the compilation unit is find boundary
cosine Similarity: 0.8044644594192505
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Get the constructors of class.* 匹配到的元操作或API：
query: Get the constructors of class.
most similar API: get class of constructor
cosine Similarity: 0.8381322622299194
*Check whether each constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442477226257324
*Get the subclasses of class.* 匹配到的元操作或API：
logic: Get the subclasses of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.8690205216407776
*Check whether each subclass is outside the compilation unit.* 匹配到的元操作或API：
query: Check whether each subclass is outside the compilation unit.
most similar API: Check whether the compilation unit is find boundary
cosine Similarity: 0.8044644594192505
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Ok, two classes
public class Foo {
    private Foo() { }
}
class Bar extends Foo {
    public Bar() { }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
——ASTClassOrInterfaceDeclaration (class name = 'Bar')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
6. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean isFindBoundary()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                ASTCompilationUnit compilationUnit = node.getNthParent(ASTCompilationUnit.class, 0);
                NodeStream<ASTClassOrInterfaceDeclaration> classesInUnit = compilationUnit.descendants(ASTClassOrInterfaceDeclaration.class);
                boolean hasSubclassInSameUnit = classesInUnit.filter(subNode -> !subNode.equals(node))
                                                           .anyMatch(subNode -> subNode.getSuperClassTypeNode() != null &&
                                                                                  subNode.getSuperClassTypeNode().getType().getSimpleName().equals(node.getSimpleName()));
                if (!hasSubclassInSameUnit) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Check whether the class is public.
        3. Get all constructors declared in class Foo.
        4. Check whether the constructor is private.
        5. Get the name of class.
        6. Check whether the class is public.
        7. Check whether class Bar extends Foo.
        8. Get all constructors declared in class Bar.
        9. Check whether the constructor is public.
        10. Check whether the class Foo has any non-private constructors.
        11. Check whether the class Bar is in the same compilation unit as Foo.
        
In this test case:
- Class Foo has only a private constructor.
- Class Bar extends Foo and has a public constructor.
- Class Bar is in the same compilation unit as Foo, allowing it to call the private constructor of Foo.

Since Class Foo has a private constructor and Class Bar is in the same compilation unit and extends Foo, this does not violate the rule described. The rule would be violated if Class Bar were in a different compilation unit and still attempted to extend Foo. Therefore, the number of violations in this test case is indeed 0.
['Get the name of class.', 'Check whether the class is public.', 'Get all constructors declared in class Foo.', 'Check whether the constructor is private.', 'Get the name of class.', 'Check whether the class is public.', 'Check whether class Bar extends Foo.', 'Get all constructors declared in class Bar.', 'Check whether the constructor is public.', 'Check whether the class Foo has any non-private constructors.', 'Check whether the class Bar is in the same compilation unit as Foo.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Get all constructors declared in class Foo.* 匹配到的元操作或API：
query: Get all constructors declared in class Foo.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8184831142425537
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Check whether class Bar extends Foo.* 匹配到的元操作或API：
query: Check whether class Bar extends Foo.
most similar API: Check whether the extends list equals
cosine Similarity: 0.80636066198349
*Get all constructors declared in class Bar.* 匹配到的元操作或API：
query: Get all constructors declared in class Bar.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8043984770774841
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Check whether the class Foo has any non-private constructors.* 匹配到的元操作或API：
logic: Check whether the class Foo has any non-private constructors.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.880648672580719
*Check whether the class Bar is in the same compilation unit as Foo.* 匹配到的元操作或API：
query: Check whether the class Bar is in the same compilation unit as Foo.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8606075644493103
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Ok, two classes
public class Foo {
    private Foo() { }
}
class Bar extends Foo {
    public Bar() { }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
——ASTClassOrInterfaceDeclaration (class name = 'Bar')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTExtendsList: public boolean equals(java.lang.Object)
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                // Check if there are no subclasses in the same compilation unit
                if (node.isPublic() && node.getExtendsList() != null) {
                    String simpleName = node.getSimpleName();
                    boolean hasSubclassInSameUnit = node.getRoot().descendants(ASTClassOrInterfaceDeclaration.class)
                            .anyMatch(subclass -> subclass.getExtendsList() != null && subclass.getExtendsList().hasSuperType(simpleName) && subclass.isReferenceToClassSameCompilationUnit());
                    if (!hasSubclassInSameUnit) {
                        addViolation(data, node);
                    }
                } else if (!node.isPublic()) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Check whether the class is public.
        3. Get all constructors of class.
        4. Check whether a constructor is private.
        5. Get the number of constructors of class.
        6. Check whether all constructors are private.
        7. Get the name of class.
        8. Check whether the class has extended x class.
        9. Check whether the extending class is located in the same compilation unit.

Let's apply these checks to the given test case:

1. Get the name of class.
        - Class name is `Foo`.
2. Check whether the class is public.
        - `Foo` is public.
3. Get all constructors of class.
        - `Foo` has one constructor.
4. Check whether a constructor is private.
        - The constructor of `Foo` is private.
5. Get the number of constructors of class.
        - `Foo` has one constructor.
6. Check whether all constructors are private.
        - All constructors (one constructor in this case) of `Foo` are private.
7. Get the name of class.
        - Class name is `Bar`.
8. Check whether the class has extended x class.
        - `Bar` extends `Foo`.
9. Check whether the extending class is located in the same compilation unit.
        - The description does not specify the location of `Bar`, but based on the statement that the number of violations is 0, we can assume that `Bar` is located in the same compilation unit as `Foo`.

Given these checks, `Foo` has a private constructor and `Bar` extends `Foo` within the same compilation unit, which means `Foo` can still be extended from within the same compilation unit. Therefore, the test case does not violate the rule as it stands. If `Bar` were not in the same compilation unit, `Foo` could be made final because it cannot be extended from outside its compilation unit.
['Get the name of class.', 'Check whether the class is public.', 'Get all constructors of class.', 'Check whether a constructor is private.', 'Get the number of constructors of class.', 'Check whether all constructors are private.', 'Get the name of class.', 'Check whether the class has extended x class.', 'Check whether the extending class is located in the same compilation unit.', 'Get the name of class.', 'Check whether the class is public.', 'Get all constructors of class.', 'Check whether a constructor is private.', 'Get the number of constructors of class.', 'Check whether all constructors are private.', 'Get the name of class.', 'Check whether the class has extended x class.', 'Check whether the extending class is located in the same compilation unit.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Get all constructors of class.* 匹配到的元操作或API：
query: Get all constructors of class.
most similar API: get class of constructor
cosine Similarity: 0.8041397333145142
*Check whether a constructor is private.* 匹配到的元操作或API：
logic: Check whether a constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9856700897216797
*Get the number of constructors of class.* 匹配到的元操作或API：
query: Get the number of constructors of class.
most similar API: get num children of constructor
cosine Similarity: 0.8339147567749023
*Check whether all constructors are private.* 匹配到的元操作或API：
logic: Check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9365217685699463
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Check whether the extending class is located in the same compilation unit.* 匹配到的元操作或API：
query: Check whether the extending class is located in the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.852212131023407
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Get all constructors of class.* 匹配到的元操作或API：
query: Get all constructors of class.
most similar API: get class of constructor
cosine Similarity: 0.8041397333145142
*Check whether a constructor is private.* 匹配到的元操作或API：
logic: Check whether a constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9856700897216797
*Get the number of constructors of class.* 匹配到的元操作或API：
query: Get the number of constructors of class.
most similar API: get num children of constructor
cosine Similarity: 0.8339147567749023
*Check whether all constructors are private.* 匹配到的元操作或API：
logic: Check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9365217685699463
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Check whether the extending class is located in the same compilation unit.* 匹配到的元操作或API：
query: Check whether the extending class is located in the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.852212131023407
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Ok, two classes
public class Foo {
    private Foo() { }
}
class Bar extends Foo {
    public Bar() { }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
——ASTClassOrInterfaceDeclaration (class name = 'Bar')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public int getNumChildren()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot

1.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                // Check if there are any subclasses in the same compilation unit
                boolean hasSubclassesInSameUnit = false;
                for (ASTClassOrInterfaceDeclaration otherClass : node.getRoot().descendants(ASTClassOrInterfaceDeclaration.class).collect(Collectors.toList())) {
                    ASTClassOrInterfaceType superClassType = otherClass.getSuperClassTypeNode();
                    if (superClassType != null && superClassType.isReferenceToClassSameCompilationUnit() && superClassType.getType() != null && superClassType.getType().getSimpleName().equals(node.getSimpleName())) {
                        hasSubclassesInSameUnit = true;
                        break;
                    }
                }
                if (!hasSubclassesInSameUnit) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node) {
        ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
        return classOrInterfaceType != null && TypeTestUtil.isA(node.getClass(), classOrInterfaceType);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 6" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 6" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 6
[ERROR]   "bad 8" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
84
70
99
82
107
91
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class has declared annotations.
3. Get a declared annotation of class.
4. Check whether the declared annotation is `@NoArgsConstructor`.
5. Get all constructors declared in class.
6. Check whether the constructor is private.
7. Check whether the constructor is public.
8. Check whether the constructor is default package-private.
9. Check whether the constructor is protected.
10. Get the number of constructors with public or default package-private access.
11. Check whether the class is final.

In this test case:
- The class `NoArgs1` is declared with `@NoArgsConstructor`, which suggests it might have a default no-argument constructor generated by Lombok.
- However, the explicitly declared constructor `private NoArgs1(String a) {}` is private.
- Since there is no public or default package-private constructor, subclasses cannot be created outside the compilation unit.
- The class `NoArgs1` is not declared as final.

Given these checks, the test case does not violate the rule because the class cannot be extended from outside its compilation unit due to the private constructor. Therefore, the number of violations is indeed 0.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the declared annotation is `@NoArgsConstructor`.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the constructor is public.', 'Check whether the constructor is default package-private.', 'Check whether the constructor is protected.', 'Get the number of constructors with public or default package-private access.', 'Check whether the class is final.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTImportDeclaration', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTConstructorDeclaration', 'ASTBlock', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'ASTAnnotation', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9878389835357666
*Check whether the declared annotation is `@NoArgsConstructor`.* 匹配到的元操作或API：
logic: Check whether the declared annotation is `@NoArgsConstructor`.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.855776309967041
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Check whether the constructor is default package-private.* 匹配到的元操作或API：
logic: Check whether the constructor is default package-private.
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.961661159992218
*Check whether the constructor is protected.* 匹配到的元操作或API：
logic: Check whether the constructor is protected.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9850410223007202
*Get the number of constructors with public or default package-private access.* 匹配到的元操作或API：
query: Get the number of constructors with public or default package-private access.
most similar API: Check whether the constructor is package private
cosine Similarity: 0.8014760613441467
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887725114822388
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if it's a class (not an interface) and not already final
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// [java] ClassWithOnlyPrivateConstructorsShouldBeFinal false positive with Lombok's @NoArgsConstructor #4188
import lombok.NoArgsConstructor;
@NoArgsConstructor
class NoArgs1 { private NoArgs1(String a) {} } // no violation
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'NoArgs1')
  ——ASTModifierList
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'a')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPackagePrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isProtected()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether constructor has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTConstructorDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate) && !hasAnnotations(node)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "ok 9" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
94
78
94
78
95
80
107
91
111
94
=========================error_testcase_logics=========================
Let's break down the test case to ensure it adheres to the rule:

1. Get the name of class.
2. Check whether the class has declared annotations.
3. Get a declared annotation of class.
4. Check whether the class has x annotation.
5. Get the javadoc comment of class.
6. Check whether the class is abstract.
7. Check whether the class is public.
8. Check whether the class is private.
9. Check whether the class is protected.
10. Check whether the class is default package-private.
11. Check whether the class is final.
12. Check whether the class is static.
13. Get the super class of class.
14. Check whether the class has extended x class.
15. Get a implemented interface of class.
16. Check whether the class has implemented x interface.
17. Get the name of the package where the class is located.
18. Check whether the class is inner class.
19. Check whether the class is anonymous class.

Now, specifically for the `InputBits` and `Sub` classes:

### For `InputBits`:

1. Get the name of class.
        - `InputBits`
2. Check whether the class has declared annotations.
        - No annotations declared.
3. Get the javadoc comment of class.
        - No javadoc comment.
4. Check whether the class is abstract.
        - No, it is not abstract.
5. Check whether the class is public.
        - No, it is private.
6. Check whether the class is private.
        - Yes, it is private.
7. Check whether the class is protected.
        - No, it is not protected.
8. Check whether the class is default package-private.
        - No, it is not default package-private.
9. Check whether the class is final.
        - No, it is not final.
10. Check whether the class is static.
        - Yes, it is static.
11. Get the super class of class.
        - `Object`
12. Check whether the class has extended x class.
        - No specific extension check.
13. Get a implemented interface of class.
        - No interfaces implemented.
14. Check whether the class has implemented x interface.
        - No specific implementation check.
15. Get the name of the package where the class is located.
        - Not relevant to the rule.
16. Check whether the class is inner class.
        - Yes, it is an inner class.
17. Check whether the class is anonymous class.
        - No, it is not an anonymous class.

### For `Sub`:

1. Get the name of class.
        - `Sub`
2. Check whether the class has declared annotations.
        - No annotations declared.
3. Get the javadoc comment of class.
        - No javadoc comment.
4. Check whether the class is abstract.
        - No, it is not abstract.
5. Check whether the class is public.
        - Yes, it is public.
6. Check whether the class is private.
        - No, it is not private.
7. Check whether the class is protected.
        - No, it is not protected.
8. Check whether the class is default package-private.
        - No, it is not default package-private.
9. Check whether the class is final.
        - Yes, it is final.
10. Check whether the class is static.
        - Yes, it is static.
11. Get the super class of class.
        - `InputBits`
12. Check whether the class has extended x class.
        - Yes, it has extended `InputBits`.
13. Get a implemented interface of class.
        - No interfaces implemented.
14. Check whether the class has implemented x interface.
        - No specific implementation check.
15. Get the name of the package where the class is located.
        - Not relevant to the rule.
16. Check whether the class is inner class.
        - Yes, it is an inner class.
17. Check whether the class is anonymous class.
        - No, it is not an anonymous class.

### Additional Checks:

1. Get the constructor list of the `InputBits` class.
        - Only one private constructor.
2. Check whether the constructor is public.
        - No, the constructor is private.
3. Check whether the constructor is private.
        - Yes, the constructor is private.

Since the `Sub` class is extending `InputBits` and `InputBits` has only a private constructor, it is not possible for `Sub` to be extended from outside its compilation unit. Therefore, `InputBits` should not be reported as a violation of the rule, and since `Sub` is final, it also does not violate the rule.

The number of violations in this test case is 0, as expected.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the class has x annotation.', 'Get the javadoc comment of class.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get a implemented interface of class.', 'Check whether the class has implemented x interface.', 'Get the name of the package where the class is located.', 'Check whether the class is inner class.', 'Check whether the class is anonymous class.', 'Get the name of class.', 'Check whether the class has declared annotations.', 'Get the javadoc comment of class.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get a implemented interface of class.', 'Check whether the class has implemented x interface.', 'Get the name of the package where the class is located.', 'Check whether the class is inner class.', 'Check whether the class is anonymous class.', 'Get the name of class.', 'Check whether the class has declared annotations.', 'Get the javadoc comment of class.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get a implemented interface of class.', 'Check whether the class has implemented x interface.', 'Get the name of the package where the class is located.', 'Check whether the class is inner class.', 'Check whether the class is anonymous class.', 'Get the constructor list of the `InputBits` class.', 'Check whether the constructor is public.', 'Check whether the constructor is private.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTConstructorDeclaration', 'ASTBlock', 'ASTArgumentList', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTExplicitConstructorInvocation', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTNumericLiteral']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9878389835357666
*Check whether the class has x annotation.* 匹配到的元操作或API：
logic: Check whether the class has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9908235669136047
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853934049606323
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844119548797607
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887725114822388
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520915031433
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851945042610168
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a implemented interface of class.* 匹配到的元操作或API：
logic: Get a implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9851537942886353
*Check whether the class has implemented x interface.* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9905825257301331
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9875447154045105
*Check whether the class is anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9849607944488525
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853934049606323
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844119548797607
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887725114822388
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520915031433
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851945042610168
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a implemented interface of class.* 匹配到的元操作或API：
logic: Get a implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9851537942886353
*Check whether the class has implemented x interface.* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9905825257301331
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9875447154045105
*Check whether the class is anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9849607944488525
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833340048789978
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731688499451
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853934049606323
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844119548797607
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887725114822388
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520915031433
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851945042610168
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a implemented interface of class.* 匹配到的元操作或API：
logic: Get a implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9851537942886353
*Check whether the class has implemented x interface.* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9905825257301331
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851536750793457
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9875447154045105
*Check whether the class is anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9849607944488525
*Get the constructor list of the `InputBits` class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate) && !hasAnnotations(node)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this positive testcase:
import lombok.NoArgsConstructor;
@NoArgsConstructor
class NoArgs1 { private NoArgs1(String a) {} } // no violation


This checker is failed(false positive) on this positive test case:
```
// Inner class with only private constructor extended within compilation unit (#2536)
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
    public static final class Sub extends InputBits {
        private Sub() {
            super(1);
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
            ——ASTExplicitConstructorInvocation
              ——ASTArgumentList (size = 1)
                ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isProtected()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
11. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
12. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
13. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getSuperInterfaceTypeNodes()
14. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
15. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
16. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnonymous()
17. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()
18. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```
3.  //Check whether the class has implemented x interface
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node) {
    if (TypeTestUtil.isA(interfaceName.class, node)) {
        return true;
    }
    return false;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal() && !node.isNested()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate) && !hasAnnotations(node)) {
                addViolation(data, node);
            }
        } else if (!node.isInterface() && !node.isFinal() && node.isNested()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate) && !hasAnnotations(node)) {
                ASTClassOrInterfaceType superClassTypeNode = node.getSuperClassTypeNode();
                if (superClassTypeNode != null) {
                    String superClassName = superClassTypeNode.getName();
                    if (!node.getPackageName().equals("") && !isExtendedOutsideCompilationUnit(node, superClassName)) {
                        addViolation(data, node);
                    }
                } else {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }

    private boolean isExtendedOutsideCompilationUnit(ASTClassOrInterfaceDeclaration node, String superClassName) {
        return node.getRoot().getDescendantScopes()
            .stream()
            .flatMap(scope -> scope.getDeclarations(ASTClassOrInterfaceDeclaration.class).stream())
            .filter(subClass -> !subClass.equals(node) && subClass.getSimpleName().equals(superClassName))
            .anyMatch(subClass -> !subClass.getPackageName().equals(node.getPackageName()));
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get a constructor of class.
3. Check whether the constructor is private.
4. Check whether the class is extended by another class within the same compilation unit.
5. Check whether the class is final.
6. Get the super class of class.
7. Get a constructor of super class.
8. Check whether the super class constructor is private.
9. Check whether the sub-class has a constructor that calls the super constructor.

Let's perform these checks on the provided test case:

1. Get the name of class -> Main209
2. Get a constructor of class -> No need to check further here as Main209 has no constructors.
3. Check whether the constructor is private -> N/A
4. Check whether the class is extended by another class within the same compilation unit -> InputBits is extended by Sub within the same compilation unit.
5. Check whether the class is final -> Main209 is not final.
6. Get the super class of class -> For Sub, the super class is InputBits.
7. Get a constructor of super class -> InputBits has a constructor with signature InputBits(int number).
8. Check whether the super class constructor is private -> The constructor of InputBits is private.
9. Check whether the sub-class has a constructor that calls the super constructor -> Sub has a constructor that calls the super constructor with super(1).

Since InputBits is an inner class with a private constructor and it is extended by the Sub class within the same compilation unit, Sub itself cannot be made final based on the constructors of InputBits. The rule is specifically about classes that cannot be extended from outside their compilation unit, and in this case, Sub could still be extended from within the same compilation unit.

However, the rule also implies that if a class cannot be extended due to its private constructor, it should be made final. Here, InputBits should be made final because its constructor is private, and it is not extended from outside the compilation unit. Sub class does not violate the rule as it is a valid class within the same compilation unit.

Given the test case, the number of violating the rule is indeed 0, as InputBits is the class that should be made final, but the rule checker would report it on InputBits, not Sub. Sub does not violate the rule as it is correctly defined within the same compilation unit.

If we were to check the rule for InputBits:

1. Get the name of class -> InputBits
2. Get a constructor of class -> InputBits(int number)
3. Check whether the constructor is private -> Yes, InputBits(int number) is private.
4. Check whether the class is extended by another class within the same compilation unit -> Yes, InputBits is extended by Sub within the same compilation unit.
5. Check whether the class is final -> No, InputBits is not final.
6. Get the super class of class -> The super class of InputBits is Object.
7. Get a constructor of super class -> Object() is the constructor of Object.
8. Check whether the super class constructor is private -> No, Object() is not private.
9. Check whether the sub-class has a constructor that calls the super constructor -> Yes, Sub has a constructor that calls the super constructor with super(1).

Since InputBits is an abstract class (interface/has super classes/has implemented interfaces are ignored) with a private constructor and it is not final, it would violate the rule if the rule checker is focused on this class.

Given the test case provided, the number of violations is 0, as the rule checker is likely focused on the outer class Main209 and not the inner class InputBits. However, if the rule checker is detailed enough to check inner classes, InputBits would be reported as violating the rule.
['Get the name of class.', 'Get a constructor of class.', 'Check whether the constructor is private.', 'Check whether the class is extended by another class within the same compilation unit.', 'Check whether the class is final.', 'Get the super class of class.', 'Get a constructor of super class.', 'Check whether the super class constructor is private.', 'Check whether the sub-class has a constructor that calls the super constructor.', 'Get the name of class -> Main209', 'Get a constructor of class -> No need to check further here as Main209 has no constructors.', 'Check whether the constructor is private -> N/A', 'Check whether the class is extended by another class within the same compilation unit -> InputBits is extended by Sub within the same compilation unit.', 'Check whether the class is final -> Main209 is not final.', 'Get the super class of class -> For Sub, the super class is InputBits.', 'Get a constructor of super class -> InputBits has a constructor with signature InputBits(int number).', 'Check whether the super class constructor is private -> The constructor of InputBits is private.', 'Check whether the sub-class has a constructor that calls the super constructor -> Sub has a constructor that calls the super constructor with super(1).', 'Get the name of class -> InputBits', 'Get a constructor of class -> InputBits(int number)', 'Check whether the constructor is private -> Yes, InputBits(int number) is private.', 'Check whether the class is extended by another class within the same compilation unit -> Yes, InputBits is extended by Sub within the same compilation unit.', 'Check whether the class is final -> No, InputBits is not final.', 'Get the super class of class -> The super class of InputBits is Object.', 'Get a constructor of super class -> Object() is the constructor of Object.', 'Check whether the super class constructor is private -> No, Object() is not private.', 'Check whether the sub-class has a constructor that calls the super constructor -> Yes, Sub has a constructor that calls the super constructor with super(1).']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTConstructorDeclaration', 'ASTBlock', 'ASTArgumentList', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTExplicitConstructorInvocation', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTNumericLiteral']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get a constructor of class.* 匹配到的元操作或API：
query: Get a constructor of class.
most similar API: get class of constructor
cosine Similarity: 0.8336950540542603
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Check whether the class is extended by another class within the same compilation unit.* 匹配到的元操作或API：
query: Check whether the class is extended by another class within the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.839073121547699
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887725114822388
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851945042610168
*Get a constructor of super class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the super class constructor is private.* 匹配到的元操作或API：
logic: Check whether the super class constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9259912967681885
*Check whether the sub-class has a constructor that calls the super constructor.* 匹配到的元操作或API：
query: Check whether the sub-class has a constructor that calls the super constructor.
most similar API: Check whether the explicit constructor invocation is super
cosine Similarity: 0.8580042123794556
*Get the name of class -> Main209* 匹配到的元操作或API：
query: Get the name of class -> Main209
most similar API: get simple name of class or interface
cosine Similarity: 0.8042715787887573
*Get a constructor of class -> No need to check further here as Main209 has no constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private -> N/A* 匹配到的元操作或API：
logic: Check whether the constructor is private -> N/A
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9479575753211975
*Check whether the class is extended by another class within the same compilation unit -> InputBits is extended by Sub within the same compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is final -> Main209 is not final.* 匹配到的元操作或API：
logic: Check whether the class is final -> Main209 is not final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.924491822719574
*Get the super class of class -> For Sub, the super class is InputBits.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get a constructor of super class -> InputBits has a constructor with signature InputBits(int number).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the super class constructor is private -> The constructor of InputBits is private.* 匹配到的元操作或API：
logic: Check whether the super class constructor is private -> The constructor of InputBits is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8647868037223816
*Check whether the sub-class has a constructor that calls the super constructor -> Sub has a constructor that calls the super constructor with super(1).* 匹配到的元操作或API：
query: Check whether the sub-class has a constructor that calls the super constructor -> Sub has a constructor that calls the super constructor with super(1).
most similar API: Check whether the explicit constructor invocation is super
cosine Similarity: 0.8108845353126526
*Get the name of class -> InputBits* 匹配到的元操作或API：
未匹配成功元操作或API
*Get a constructor of class -> InputBits(int number)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private -> Yes, InputBits(int number) is private.* 匹配到的元操作或API：
query: Check whether the constructor is private -> Yes, InputBits(int number) is private.
most similar API: Check whether the constructor is private
cosine Similarity: 0.8494359850883484
*Check whether the class is extended by another class within the same compilation unit -> Yes, InputBits is extended by Sub within the same compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is final -> No, InputBits is not final.* 匹配到的元操作或API：
logic: Check whether the class is final -> No, InputBits is not final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.8996233940124512
*Get the super class of class -> The super class of InputBits is Object.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get a constructor of super class -> Object() is the constructor of Object.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the super class constructor is private -> No, Object() is not private.* 匹配到的元操作或API：
logic: Check whether the super class constructor is private -> No, Object() is not private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8937114477157593
*Check whether the sub-class has a constructor that calls the super constructor -> Yes, Sub has a constructor that calls the super constructor with super(1).* 匹配到的元操作或API：
query: Check whether the sub-class has a constructor that calls the super constructor -> Yes, Sub has a constructor that calls the super constructor with super(1).
most similar API: Check whether the explicit constructor invocation is super: Returns true if this statement calls a constructor of the direct superclass. The JLS calls that a <i>superclass constructor invocation</i>.
cosine Similarity: 0.8030076026916504
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate) && !hasAnnotations(node)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this positive testcase:
import lombok.NoArgsConstructor;
@NoArgsConstructor
class NoArgs1 { private NoArgs1(String a) {} } // no violation


This checker is failed(false positive) on this positive test case:
```
// Inner class with only private constructor extended within compilation unit (#2536)
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
    public static final class Sub extends InputBits {
        private Sub() {
            super(1);
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
            ——ASTExplicitConstructorInvocation
              ——ASTArgumentList (size = 1)
                ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
7. net.sourceforge.pmd.lang.java.ast.ASTExplicitConstructorInvocation: public boolean isSuper(), //Returns true if this statement calls a constructor of the direct superclass. The JLS calls that a <i>superclass constructor invocation</i>.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate) && !hasAnnotations(node)) {
                ASTClassOrInterfaceType superClassTypeNode = node.getSuperClassTypeNode();
                if (superClassTypeNode == null || superClassTypeNode.isReferenceToClassSameCompilationUnit()) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 9" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 9" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
To verify whether the provided test case violates the rule, we need to perform the following granular checks:

1. Get the class that `Sub` extends.
2. Check whether the class `Sub` extends is `InputBits`.
3. Get all constructors declared in `InputBits`.
4. Check whether each constructor in `InputBits` is private.
5. Get the class that `Sub` is declared in.
6. Check whether `Sub` is declared in the same compilation unit as `InputBits`.
7. Check whether `Sub` is final.
8. Check whether `InputBits` is final.

Since `Sub` is an inner class and extends `InputBits`, we need to ensure that `InputBits`'s constructors are private and that `Sub` is declared in the same compilation unit. In this case, it is clear from the code that `InputBits` is an inner class with a private constructor, and `Sub` is declared in the same outer class `Main209`.

Given the rule and test case, let's proceed with the checks:

1. Get the class that `Sub` extends.
   - `Sub` extends `InputBits`.

2. Check whether the class `Sub` extends is `InputBits`.
   - `Sub` extends `InputBits`, so this condition is true.

3. Get all constructors declared in `InputBits`.
   - `InputBits` has one constructor: `private InputBits(int number)`.

4. Check whether each constructor in `InputBits` is private.
   - The constructor in `InputBits` is private, so this condition is true.

5. Get the class that `Sub` is declared in.
   - `Sub` is declared in `Main209`.

6. Check whether `Sub` is declared in the same compilation unit as `InputBits`.
   - Both `InputBits` and `Sub` are declared in the same outer class `Main209`, so they are in the same compilation unit.

7. Check whether `Sub` is final.
   - `Sub` is declared as `public static final class`.

8. Check whether `InputBits` is final.
   - `InputBits` is not declared as final.

From these checks, we can see that `InputBits` has a private constructor, and `Sub` is declared in the same compilation unit as `InputBits`. However, `Sub` is already final, so it does not violate the rule. The rule is specifically for classes that may be made final because their superclasses cannot be extended from outside their compilation unit. In this case, `InputBits` is an inner class with a private constructor, and `Sub` is correctly declared as final, so there is no violation.

The number of violations in this test case is indeed 0.
['Get the class that `Sub` extends.', 'Check whether the class `Sub` extends is `InputBits`.', 'Get all constructors declared in `InputBits`.', 'Check whether each constructor in `InputBits` is private.', 'Get the class that `Sub` is declared in.', 'Check whether `Sub` is declared in the same compilation unit as `InputBits`.', 'Check whether `Sub` is final.', 'Check whether `InputBits` is final.', 'Get the class that `Sub` extends.', 'Check whether the class `Sub` extends is `InputBits`.', 'Get all constructors declared in `InputBits`.', 'Check whether each constructor in `InputBits` is private.', 'Get the class that `Sub` is declared in.', 'Check whether `Sub` is declared in the same compilation unit as `InputBits`.', 'Check whether `Sub` is final.', 'Check whether `InputBits` is final.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTConstructorDeclaration', 'ASTBlock', 'ASTArgumentList', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTExplicitConstructorInvocation', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTNumericLiteral']
*Get the class that `Sub` extends.* 匹配到的元操作或API：
query: Get the class that `Sub` extends.
most similar API: get class of extends list
cosine Similarity: 0.8417040705680847
*Check whether the class `Sub` extends is `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors declared in `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each constructor in `InputBits` is private.* 匹配到的元操作或API：
logic: Check whether each constructor in `InputBits` is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8783043622970581
*Get the class that `Sub` is declared in.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether `Sub` is declared in the same compilation unit as `InputBits`.* 匹配到的元操作或API：
query: Check whether `Sub` is declared in the same compilation unit as `InputBits`.
most similar API: Check whether the compilation unit equals
cosine Similarity: 0.8032166361808777
*Check whether `Sub` is final.* 匹配到的元操作或API：
logic: Check whether `Sub` is final.
most similar meta operation: Check whether the local variable is final
cosine Similarity: 0.8513016700744629
*Check whether `InputBits` is final.* 匹配到的元操作或API：
query: Check whether `InputBits` is final.
most similar API: Check whether the class or interface is final
cosine Similarity: 0.8178253173828125
*Get the class that `Sub` extends.* 匹配到的元操作或API：
query: Get the class that `Sub` extends.
most similar API: get class of extends list
cosine Similarity: 0.8417040705680847
*Check whether the class `Sub` extends is `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors declared in `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each constructor in `InputBits` is private.* 匹配到的元操作或API：
logic: Check whether each constructor in `InputBits` is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8783043622970581
*Get the class that `Sub` is declared in.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether `Sub` is declared in the same compilation unit as `InputBits`.* 匹配到的元操作或API：
query: Check whether `Sub` is declared in the same compilation unit as `InputBits`.
most similar API: Check whether the compilation unit equals
cosine Similarity: 0.8032166361808777
*Check whether `Sub` is final.* 匹配到的元操作或API：
logic: Check whether `Sub` is final.
most similar meta operation: Check whether the local variable is final
cosine Similarity: 0.8513016700744629
*Check whether `InputBits` is final.* 匹配到的元操作或API：
query: Check whether `InputBits` is final.
most similar API: Check whether the class or interface is final
cosine Similarity: 0.8178253173828125
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate) && !hasAnnotations(node)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this positive testcase:
import lombok.NoArgsConstructor;
@NoArgsConstructor
class NoArgs1 { private NoArgs1(String a) {} } // no violation


This checker is failed(false positive) on this positive test case:
```
// Inner class with only private constructor extended within compilation unit (#2536)
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
    public static final class Sub extends InputBits {
        private Sub() {
            super(1);
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
            ——ASTExplicitConstructorInvocation
              ——ASTArgumentList (size = 1)
                ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTExtendsList: public java.lang.Class<Class<?> getClass()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
3. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration: public boolean isFinal()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal(), //Returns true if this variable, method or class is final (even implicitly).



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate) && !hasAnnotations(node)) {
                if (!isExtendedWithinCompilationUnit(node, (ASTCompilationUnit) data)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }

    private boolean isExtendedWithinCompilationUnit(ASTClassOrInterfaceDeclaration node, ASTCompilationUnit compilationUnit) {
        JClassSymbol classSymbol = node.getSymbol();
        return compilationUnit.descendants(ASTClassOrInterfaceDeclaration.class)
                .anyMatch(subClass -> subClass.getExtends() != null && classSymbol.equals(subClass.getExtends().getReferencedClass()));
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To perform the required checks and ensure that the test case does not violate the rule, let's break down the operations step-by-step:

1. Get the name of class. (Main209)
2. Get a declared inner class of class. (InputBits)
3. Check whether the inner class is public.
4. Check whether the inner class is private.
5. Check whether the inner class is protected.
6. Check whether the inner class is default package-private.
7. Get the signature of constructor of inner class.
8. Check whether the constructor is private.
9. Get the signature of another constructor in the same class. (If there are multiple constructors)
10. Check whether this additional constructor is private. (If there are multiple constructors)
11. Get a declared inner class of main class. (Sub)
12. Check whether this inner class extends the inner class with private constructors. (InputBits)
13. Get the signature of constructor of Sub class.
14. Check whether the constructor is private.
15. Get the super class of class Sub.
16. Check whether the super class is InputBits.
17. Get the signature of super constructor call in Sub class's constructor.
18. Check whether the super constructor call has the argument list.
19. Check whether the super constructor call has a specific argument.

Based on the provided test case, let's perform these checks:

1. Get the name of class. (Main209)
        Result: Main209

2. Get a declared inner class of class. (InputBits)
        Result: InputBits

3. Check whether the inner class is public.
        Result: False

4. Check whether the inner class is private.
        Result: True

5. Check whether the inner class is protected.
        Result: False

6. Check whether the inner class is default package-private.
        Result: False

7. Get the signature of constructor of inner class.
        Result: InputBits(int number)

8. Check whether the constructor is private.
        Result: True

9. Get the signature of another constructor in the same class. (If there are multiple constructors)
        Result: None (InputBits has only one constructor)

10. Check whether this additional constructor is private. (If there are multiple constructors)
        Result: None (No additional constructors to check)

11. Get a declared inner class of main class. (Sub)
        Result: Sub

12. Check whether this inner class extends the inner class with private constructors. (InputBits)
        Result: True

13. Get the signature of constructor of Sub class.
        Result: Sub()

14. Check whether the constructor is private.
        Result: True

15. Get the super class of class Sub.
        Result: InputBits

16. Check whether the super class is InputBits.
        Result: True

17. Get the signature of super constructor call in Sub class's constructor.
        Result: super(1)

18. Check whether the super constructor call has the argument list.
        Result: True

19. Check whether the super constructor call has a specific argument.
        Result: True (Argument is 1)

Since the class `InputBits` has a private constructor and `Sub` is a subclass of `InputBits` and is also declared as `final`, it cannot be extended outside its compilation unit. However, the rule is specifically about making the class `final` if it cannot be extended from outside its compilation unit due to only having private constructors. In this case, `InputBits` cannot be extended from outside its compilation unit, but the rule does not apply to `InputBits` itself, but rather to classes that could be made final due to the private constructors of their superclass.

Since `Sub` is final and extends `InputBits` which has a private constructor, `Sub` adheres to the rule as it cannot be extended further outside its compilation unit.

The number of violations is indeed: 0
['Get the name of class. (Main209)', 'Get a declared inner class of class. (InputBits)', 'Check whether the inner class is public.', 'Check whether the inner class is private.', 'Check whether the inner class is protected.', 'Check whether the inner class is default package-private.', 'Get the signature of constructor of inner class.', 'Check whether the constructor is private.', 'Get the signature of another constructor in the same class. (If there are multiple constructors)', 'Check whether this additional constructor is private. (If there are multiple constructors)', 'Get a declared inner class of main class. (Sub)', 'Check whether this inner class extends the inner class with private constructors. (InputBits)', 'Get the signature of constructor of Sub class.', 'Check whether the constructor is private.', 'Get the super class of class Sub.', 'Check whether the super class is InputBits.', "Get the signature of super constructor call in Sub class's constructor.", 'Check whether the super constructor call has the argument list.', 'Check whether the super constructor call has a specific argument.', 'Get the name of class. (Main209)', 'Get a declared inner class of class. (InputBits)', 'Check whether the inner class is public.', 'Check whether the inner class is private.', 'Check whether the inner class is protected.', 'Check whether the inner class is default package-private.', 'Get the signature of constructor of inner class.', 'Check whether the constructor is private.', 'Get the signature of another constructor in the same class. (If there are multiple constructors)', 'Check whether this additional constructor is private. (If there are multiple constructors)', 'Get a declared inner class of main class. (Sub)', 'Check whether this inner class extends the inner class with private constructors. (InputBits)', 'Get the signature of constructor of Sub class.', 'Check whether the constructor is private.', 'Get the super class of class Sub.', 'Check whether the super class is InputBits.', "Get the signature of super constructor call in Sub class's constructor.", 'Check whether the super constructor call has the argument list.', 'Check whether the super constructor call has a specific argument.']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTConstructorDeclaration', 'ASTBlock', 'ASTArgumentList', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTExplicitConstructorInvocation', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTNumericLiteral']
*Get the name of class. (Main209)* 匹配到的元操作或API：
logic: Get the name of class. (Main209)
most similar meta operation: Get the name of class
cosine Similarity: 0.8902491331100464
*Get a declared inner class of class. (InputBits)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is public.* 匹配到的元操作或API：
logic: Check whether the inner class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9261536002159119
*Check whether the inner class is private.* 匹配到的元操作或API：
logic: Check whether the inner class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9290029406547546
*Check whether the inner class is protected.* 匹配到的元操作或API：
logic: Check whether the inner class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9165269136428833
*Check whether the inner class is default package-private.* 匹配到的元操作或API：
logic: Check whether the inner class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9503231048583984
*Get the signature of constructor of inner class.* 匹配到的元操作或API：
logic: Get the signature of constructor of inner class.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9193941354751587
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Get the signature of another constructor in the same class. (If there are multiple constructors)* 匹配到的元操作或API：
logic: Get the signature of another constructor in the same class. (If there are multiple constructors)
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9150363206863403
*Check whether this additional constructor is private. (If there are multiple constructors)* 匹配到的元操作或API：
logic: Check whether this additional constructor is private. (If there are multiple constructors)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9351152181625366
*Get a declared inner class of main class. (Sub)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether this inner class extends the inner class with private constructors. (InputBits)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the signature of constructor of Sub class.* 匹配到的元操作或API：
logic: Get the signature of constructor of Sub class.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9316446185112
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Get the super class of class Sub.* 匹配到的元操作或API：
logic: Get the super class of class Sub.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9338056445121765
*Check whether the super class is InputBits.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the signature of super constructor call in Sub class's constructor.* 匹配到的元操作或API：
logic: Get the signature of super constructor call in Sub class's constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.8654947280883789
*Check whether the super constructor call has the argument list.* 匹配到的元操作或API：
query: Check whether the super constructor call has the argument list.
most similar API: Check whether the explicit constructor invocation is super
cosine Similarity: 0.8369186520576477
*Check whether the super constructor call has a specific argument.* 匹配到的元操作或API：
query: Check whether the super constructor call has a specific argument.
most similar API: Check whether the explicit constructor invocation is super
cosine Similarity: 0.8498702645301819
*Get the name of class. (Main209)* 匹配到的元操作或API：
logic: Get the name of class. (Main209)
most similar meta operation: Get the name of class
cosine Similarity: 0.8902491331100464
*Get a declared inner class of class. (InputBits)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is public.* 匹配到的元操作或API：
logic: Check whether the inner class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9261536002159119
*Check whether the inner class is private.* 匹配到的元操作或API：
logic: Check whether the inner class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9290029406547546
*Check whether the inner class is protected.* 匹配到的元操作或API：
logic: Check whether the inner class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9165269136428833
*Check whether the inner class is default package-private.* 匹配到的元操作或API：
logic: Check whether the inner class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9503231048583984
*Get the signature of constructor of inner class.* 匹配到的元操作或API：
logic: Get the signature of constructor of inner class.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9193941354751587
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Get the signature of another constructor in the same class. (If there are multiple constructors)* 匹配到的元操作或API：
logic: Get the signature of another constructor in the same class. (If there are multiple constructors)
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9150363206863403
*Check whether this additional constructor is private. (If there are multiple constructors)* 匹配到的元操作或API：
logic: Check whether this additional constructor is private. (If there are multiple constructors)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9351152181625366
*Get a declared inner class of main class. (Sub)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether this inner class extends the inner class with private constructors. (InputBits)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the signature of constructor of Sub class.* 匹配到的元操作或API：
logic: Get the signature of constructor of Sub class.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9316446185112
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331815719604
*Get the super class of class Sub.* 匹配到的元操作或API：
logic: Get the super class of class Sub.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9338056445121765
*Check whether the super class is InputBits.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the signature of super constructor call in Sub class's constructor.* 匹配到的元操作或API：
logic: Get the signature of super constructor call in Sub class's constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.8654947280883789
*Check whether the super constructor call has the argument list.* 匹配到的元操作或API：
query: Check whether the super constructor call has the argument list.
most similar API: Check whether the explicit constructor invocation is super
cosine Similarity: 0.8369186520576477
*Check whether the super constructor call has a specific argument.* 匹配到的元操作或API：
query: Check whether the super constructor call has a specific argument.
most similar API: Check whether the explicit constructor invocation is super
cosine Similarity: 0.8498702645301819
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate) && !hasAnnotations(node)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this positive testcase:
import lombok.NoArgsConstructor;
@NoArgsConstructor
class NoArgs1 { private NoArgs1(String a) {} } // no violation


This checker is failed(false positive) on this positive test case:
```
// Inner class with only private constructor extended within compilation unit (#2536)
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
    public static final class Sub extends InputBits {
        private Sub() {
            super(1);
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
            ——ASTExplicitConstructorInvocation
              ——ASTArgumentList (size = 1)
                ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isProtected()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
9. net.sourceforge.pmd.lang.java.ast.ASTExplicitConstructorInvocation: public boolean isSuper(), //Returns true if this statement calls a constructor of the direct superclass. The JLS calls that a <i>superclass constructor invocation</i>.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal() && !hasAnnotations(node)) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                if (!canBeExtendedWithinCompilationUnit(node)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }

    private boolean canBeExtendedWithinCompilationUnit(ASTClassOrInterfaceDeclaration node) {
        String simpleName = node.getSimpleName();
        return node.getRoot().descendants(ASTClassOrInterfaceDeclaration.class)
                   .filter(n -> n.getSuperClassTypeNode() != null)
                   .anyMatch(n -> n.getSuperClassTypeNode().getTypeMirror().getErasure().getSimpleName().equals(simpleName));
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is public.
3. Get all constructors declared in class.
4. Check whether all constructors are private.
5. Get all subclasses of class.
6. Check whether the subclass is in the same compilation unit.
7. Repeat steps 3-6 for each subclass.

For the `Main209` class:
1. Get the name of class: Main209
2. Check whether the class is public: True
3. Get all constructors declared in class: None found, as Main209 does not have any explicit constructors (default constructor is not private).
4. Check whether all constructors are private: Not applicable, as Main209 does not have any constructors.
5. Get all subclasses of class: Sub
6. Check whether the subclass is in the same compilation unit: True
   - For `Sub` class:
     1. Get the name of class: Sub
     2. Check whether the class is public: True
     3. Get all constructors declared in class: Sub()
     4. Check whether all constructors are private: False

For the `InputBits` inner class:
1. Get the name of class: InputBits
2. Check whether the class is public: False
3. Get all constructors declared in class: InputBits(int number)
4. Check whether all constructors are private: True
5. Get all subclasses of class: Sub
6. Check whether the subclass is in the same compilation unit: True
   - For `Sub` class:
     1. Get the name of class: Sub
     2. Check whether the class is public: True
     3. Get all constructors declared in class: Sub()
     4. Check whether all constructors are private: False

Since the subclass `Sub` is public and has a non-private constructor, the rule does not apply, and there are no violations in this test case.
['Get the name of class.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether all constructors are private.', 'Get all subclasses of class.', 'Check whether the subclass is in the same compilation unit.', 'Repeat steps 3-6 for each subclass.', 'Get the name of class: Main209', 'Check whether the class is public: True', 'Get all constructors declared in class: None found, as Main209 does not have any explicit constructors (default constructor is not private).', 'Check whether all constructors are private: Not applicable, as Main209 does not have any constructors.', 'Get all subclasses of class: Sub', 'Check whether the subclass is in the same compilation unit: True', 'Get the name of class: Sub', 'Check whether the class is public: True', 'Get all constructors declared in class: Sub()', 'Check whether all constructors are private: False', 'Get the name of class: InputBits', 'Check whether the class is public: False', 'Get all constructors declared in class: InputBits(int number)', 'Check whether all constructors are private: True', 'Get all subclasses of class: Sub', 'Check whether the subclass is in the same compilation unit: True', 'Get the name of class: Sub', 'Check whether the class is public: True', 'Get all constructors declared in class: Sub()', 'Check whether all constructors are private: False']
['ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'ASTExtendsList', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTConstructorDeclaration', 'ASTBlock', 'ASTArgumentList', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTExplicitConstructorInvocation', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTNumericLiteral']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746823310852
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368497490882874
*Check whether all constructors are private.* 匹配到的元操作或API：
logic: Check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9365217685699463
*Get all subclasses of class.* 匹配到的元操作或API：
query: Get all subclasses of class.
most similar API: get permitted subclasses of class or interface
cosine Similarity: 0.8182533979415894
*Check whether the subclass is in the same compilation unit.* 匹配到的元操作或API：
query: Check whether the subclass is in the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8747339844703674
*Repeat steps 3-6 for each subclass.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: Main209* 匹配到的元操作或API：
logic: Get the name of class: Main209
most similar meta operation: Get the name of class
cosine Similarity: 0.8585508465766907
*Check whether the class is public: True* 匹配到的元操作或API：
logic: Check whether the class is public: True
most similar meta operation: Check whether the class is public
cosine Similarity: 0.970706582069397
*Get all constructors declared in class: None found, as Main209 does not have any explicit constructors (default constructor is not private).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether all constructors are private: Not applicable, as Main209 does not have any constructors.* 匹配到的元操作或API：
logic: Check whether all constructors are private: Not applicable, as Main209 does not have any constructors.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.868676483631134
*Get all subclasses of class: Sub* 匹配到的元操作或API：
query: Get all subclasses of class: Sub
most similar API: get permitted subclasses of class or interface
cosine Similarity: 0.8093759417533875
*Check whether the subclass is in the same compilation unit: True* 匹配到的元操作或API：
query: Check whether the subclass is in the same compilation unit: True
most similar API: Check whether the compilation unit equals
cosine Similarity: 0.8703303933143616
*Get the name of class: Sub* 匹配到的元操作或API：
logic: Get the name of class: Sub
most similar meta operation: Get the name of class
cosine Similarity: 0.8676701784133911
*Check whether the class is public: True* 匹配到的元操作或API：
logic: Check whether the class is public: True
most similar meta operation: Check whether the class is public
cosine Similarity: 0.970706582069397
*Get all constructors declared in class: Sub()* 匹配到的元操作或API：
query: Get all constructors declared in class: Sub()
most similar API: find children of type of constructor
cosine Similarity: 0.8012104034423828
*Check whether all constructors are private: False* 匹配到的元操作或API：
logic: Check whether all constructors are private: False
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9276671409606934
*Get the name of class: InputBits* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is public: False* 匹配到的元操作或API：
logic: Check whether the class is public: False
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9623566269874573
*Get all constructors declared in class: InputBits(int number)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether all constructors are private: True* 匹配到的元操作或API：
logic: Check whether all constructors are private: True
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.93179851770401
*Get all subclasses of class: Sub* 匹配到的元操作或API：
query: Get all subclasses of class: Sub
most similar API: get permitted subclasses of class or interface
cosine Similarity: 0.8093759417533875
*Check whether the subclass is in the same compilation unit: True* 匹配到的元操作或API：
query: Check whether the subclass is in the same compilation unit: True
most similar API: Check whether the compilation unit equals
cosine Similarity: 0.8703303933143616
*Get the name of class: Sub* 匹配到的元操作或API：
logic: Get the name of class: Sub
most similar meta operation: Get the name of class
cosine Similarity: 0.8676701784133911
*Check whether the class is public: True* 匹配到的元操作或API：
logic: Check whether the class is public: True
most similar meta operation: Check whether the class is public
cosine Similarity: 0.970706582069397
*Get all constructors declared in class: Sub()* 匹配到的元操作或API：
query: Get all constructors declared in class: Sub()
most similar API: find children of type of constructor
cosine Similarity: 0.8012104034423828
*Check whether all constructors are private: False* 匹配到的元操作或API：
logic: Check whether all constructors are private: False
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9276671409606934
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate) && !hasAnnotations(node)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this positive testcase:
import lombok.NoArgsConstructor;
@NoArgsConstructor
class NoArgs1 { private NoArgs1(String a) {} } // no violation


This checker is failed(false positive) on this positive test case:
```
// Inner class with only private constructor extended within compilation unit (#2536)
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
    public static final class Sub extends InputBits {
        private Sub() {
            super(1);
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
            ——ASTExplicitConstructorInvocation
              ——ASTArgumentList (size = 1)
                ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.util.List<ASTClassOrInterfaceType> getPermittedSubclasses()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot
7. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean equals(java.lang.Object)
8. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.util.List<List<T> findChildrenOfType(java.lang.Class)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (!constructors.isEmpty() && constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate) && !hasAnnotations(node)) {
                if (!canBeExtendedWithinCompilationUnit(node, (ASTCompilationUnit) data)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }

    private boolean canBeExtendedWithinCompilationUnit(ASTClassOrInterfaceDeclaration node, ASTCompilationUnit compilationUnit) {
        String className = node.getSimpleName();
        return compilationUnit.descendants(ASTClassOrInterfaceDeclaration.class)
                .filter(c -> c.getExtendsList() != null)
                .flatMap(c -> c.getExtendsList().getExtendsTypes())
                .anyMatch(type -> type.isReferenceToClassSameCompilationUnit() && type.getSimpleName().equals(className));
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 9
测试用例全部通过
最终通过 13 个测试用例
正例 11 个
反例 2 个
输入token：1230579
输出token：823351
结束

规则执行完毕，时间总花销： 4487.0646069049835 秒
