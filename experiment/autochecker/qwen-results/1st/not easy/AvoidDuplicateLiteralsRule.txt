开始

========================================== Rule AvoidDuplicateLiteralsRule ===========================================
一共 11 个测试用例
正例 3 个
反例 8 个
1989
1586
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of the class.
2. Get all methods declared in class.
3. Get the method named `bar`.
4. Get the body of method `bar`.
5. Get all method calls in the body of method `bar`.
6. Get the number of arguments of method call named `buz`.
7. Get an argument of method call named `buz`.
8. Check whether the argument is a string literal.
9. Get the value of string literal.
10. Check whether the length of string literal is 3 or more.
11. Count occurrences of the string literal "Howdy" in the body of method `bar`.
12. Check whether the count of occurrences of "Howdy" is 4 or more.
13. Check whether the string literal "Howdy" is assigned to a constant field.

If the string literal "Howdy" is a string literal with a length of 3 or more, occurs 4 or more times in the body of method `bar`, and is not assigned to a constant field, then this test case violates the rule.
            
['Get the name of the class.', 'Get all methods declared in class.', 'Get the method named `bar`.', 'Get the body of method `bar`.', 'Get all method calls in the body of method `bar`.', 'Get the number of arguments of method call named `buz`.', 'Get an argument of method call named `buz`.', 'Check whether the argument is a string literal.', 'Get the value of string literal.', 'Check whether the length of string literal is 3 or more.', 'Count occurrences of the string literal "Howdy" in the body of method `bar`.', 'Check whether the count of occurrences of "Howdy" is 4 or more.', 'Check whether the string literal "Howdy" is assigned to a constant field.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTExpressionStatement', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of the class.* 匹配到的元操作或API：
logic: Get the name of the class.
most similar meta operation: Get the name of class
cosine Similarity: 0.968898594379425
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366355895996094
*Get the method named `bar`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of method `bar`.* 匹配到的元操作或API：
query: Get the body of method `bar`.
most similar API: get body of method
cosine Similarity: 0.8641099333763123
*Get all method calls in the body of method `bar`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of arguments of method call named `buz`.* 匹配到的元操作或API：
logic: Get the number of arguments of method call named `buz`.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.8938655257225037
*Get an argument of method call named `buz`.* 匹配到的元操作或API：
logic: Get an argument of method call named `buz`.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8570064306259155
*Check whether the argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9077174663543701
*Get the value of string literal.* 匹配到的元操作或API：
logic: Get the value of string literal.
most similar meta operation: Get the value of string literal
cosine Similarity: 0.9832245111465454
*Check whether the length of string literal is 3 or more.* 匹配到的元操作或API：
query: Check whether the length of string literal is 3 or more.
most similar API: length of string literal
cosine Similarity: 0.8466031551361084
*Count occurrences of the string literal "Howdy" in the body of method `bar`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of occurrences of "Howdy" is 4 or more.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the string literal "Howdy" is assigned to a constant field.* 匹配到的元操作或API：
query: Check whether the string literal "Howdy" is assigned to a constant field.
most similar API: Check whether the string literal is compile time constant
cosine Similarity: 0.8140707015991211
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
The test case corresponding to the rule:
```
// duplicate literals in argument list
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'buz')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.String getConstValue()
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length(), //Length of the constant value in characters.
7. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isCompileTimeConstant()

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
2.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class, ASTMethodCall.class, ASTStringLiteral.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        Map<String, Integer> literalCount = (Map<String, Integer>) data;
        int argumentNumber = getArgumentNumber(node);
        for (int i = 0; i < argumentNumber; i++) {
            if (isMethodCallArgumentStringType(node, i)) {
                ASTExpression expression = node.getArguments().get(i);
                if (expression instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expression;
                    String value = stringLiteral.getConstValue();
                    if (value.length() >= 3) {
                        literalCount.put(value, literalCount.getOrDefault(value, 0) + 1);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTStringLiteral node, Object data) {
        Map<String, Integer> literalCount = (Map<String, Integer>) data;
        String value = node.getConstValue();
        if (node.length() >= 3) {
            literalCount.put(value, literalCount.getOrDefault(value, 0) + 1);
        }
        return data;
    }

    @Override
    public void end(ASTClassOrInterfaceDeclaration node, Object data) {
        Map<String, Integer> literalCount = (Map<String, Integer>) data;
        for (Map.Entry<String, Integer> entry : literalCount.entrySet()) {
            if (entry.getValue() >= 4) {
                addViolation(node, entry.getKey());
            }
        }
    }

    @Override
    public Object start(ASTClassOrInterfaceDeclaration node, Object data) {
        return new HashMap<>();
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node, int index) {
        ASTArgumentList astArgumentList = node.getArguments();
        if (index < 0 || index >= astArgumentList.size()) {
            return false;
        }
        ASTExpression expression = astArgumentList.get(index);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of called method.
2. Check whether the called method name is buz.
3. Get the number of arguments of called method.
4. Check whether the number of arguments is 1.
5. Get an argument of called method.
6. Check whether the argument is a string literal.
7. Get the value of string literal.
8. Check whether the string literal value is "Howdy".
9. Get the length of string literal.
10. Check whether the length of string literal is 5 (greater than 2).
11. Get the method caller (which should be the class where the method is called).
12. Get all method calls in the class.
13. Filter method calls to only those with the method name buz.
14. Count the number of unique string literals passed to the buz method.
15. Check whether the count of unique string literals is 1.
16. Count the total number of occurrences of the string literal "Howdy" in the filtered method calls.
17. Check whether the total number of occurrences of the string literal "Howdy" is 4 or more.

If the total number of occurrences of the string literal "Howdy" in the buz method calls is 4 or more, then this test case violates the rule.
['Get the name of called method.', 'Check whether the called method name is buz.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 1.', 'Get an argument of called method.', 'Check whether the argument is a string literal.', 'Get the value of string literal.', 'Check whether the string literal value is "Howdy".', 'Get the length of string literal.', 'Check whether the length of string literal is 5 (greater than 2).', 'Get the method caller (which should be the class where the method is called).', 'Get all method calls in the class.', 'Filter method calls to only those with the method name buz.', 'Count the number of unique string literals passed to the buz method.', 'Check whether the count of unique string literals is 1.', 'Count the total number of occurrences of the string literal "Howdy" in the filtered method calls.', 'Check whether the total number of occurrences of the string literal "Howdy" is 4 or more.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTExpressionStatement', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the called method name is buz.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9077174663543701
*Get the value of string literal.* 匹配到的元操作或API：
logic: Get the value of string literal.
most similar meta operation: Get the value of string literal
cosine Similarity: 0.9832245111465454
*Check whether the string literal value is "Howdy".* 匹配到的元操作或API：
query: Check whether the string literal value is "Howdy".
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8269344568252563
*Get the length of string literal.* 匹配到的元操作或API：
logic: Get the length of string literal.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.987589955329895
*Check whether the length of string literal is 5 (greater than 2).* 匹配到的元操作或API：
query: Check whether the length of string literal is 5 (greater than 2).
most similar API: length of string literal
cosine Similarity: 0.8457603454589844
*Get the method caller (which should be the class where the method is called).* 匹配到的元操作或API：
logic: Get the method caller (which should be the class where the method is called).
most similar meta operation: Get the method caller
cosine Similarity: 0.9315767288208008
*Get all method calls in the class.* 匹配到的元操作或API：
query: Get all method calls in the class.
most similar API: get method name of method call
cosine Similarity: 0.8157885670661926
*Filter method calls to only those with the method name buz.* 匹配到的元操作或API：
未匹配成功元操作或API
*Count the number of unique string literals passed to the buz method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of unique string literals is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Count the total number of occurrences of the string literal "Howdy" in the filtered method calls.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the total number of occurrences of the string literal "Howdy" is 4 or more.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
The test case corresponding to the rule:
```
// duplicate literals in argument list
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'buz')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.String getConstValue()
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length()
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length(), //Length of the constant value in characters.
7. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
2.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTStringLiteral.class, ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTStringLiteral node, Object data) {
        if (node.length() < 3) {
            return data;
        }

        Map<String, Integer> literalCounts = (Map<String, Integer>) data;
        String literalValue = node.getConstValue();

        if (literalCounts.containsKey(literalValue)) {
            literalCounts.put(literalValue, literalCounts.get(literalValue) + 1);
        } else {
            literalCounts.put(literalValue, 1);
        }

        if (literalCounts.get(literalValue) == 4) {
            addViolation(node);
        }

        return data;
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        Map<String, Integer> literalCounts = (Map<String, Integer>) data;
        ASTArgumentList arguments = node.getArguments();

        for (int i = 0; i < arguments.size(); i++) {
            ASTExpression expression = arguments.get(i);
            if (TypeTestUtil.isA(String.class, expression.getTypeMirror())) {
                String literalValue = expression.getConstValue();
                if (literalValue != null) {
                    if (literalCounts.containsKey(literalValue)) {
                        literalCounts.put(literalValue, literalCounts.get(literalValue) + 1);
                    } else {
                        literalCounts.put(literalValue, 1);
                    }

                    if (literalCounts.get(literalValue) == 4) {
                        addViolation(expression);
                    }
                }
            }
        }

        return data;
    }

    @Override
    public Object initialize() {
        return new HashMap<String, Integer>();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Get all method declarations in class.
3. Get the name of method from method declaration.
4. Get the method body from method declaration.
5. Get all method calls in method body.
6. Get the name of called method.
7. Check whether the called method is buz.
8. Get the argument list of method call.
9. Get an argument of called method.
10. Check whether the argument is a string literal.
11. Get the value of string literal.
12. Check whether the length of string literal is greater than or equal to 3.
13. Count the occurrences of each string literal in method calls.
14. Check whether the count of any string literal is greater than or equal to 4.

Based on the test case provided:
1. Get the name of class: Foo
2. Get all method declarations in class: bar and buz
3. Get the name of method from method declaration: bar
4. Get the method body from method declaration: Contains method calls to buz with string literals.
5. Get all method calls in method body: buz("Howdy"), buz("Howdy"), buz("Howdy"), buz("Howdy")
6. Get the name of called method: buz
7. Check whether the called method is buz: true
8. Get the argument list of method call: Each call contains one argument.
9. Get an argument of called method: "Howdy"
10. Check whether the argument is a string literal: true
11. Get the value of string literal: "Howdy"
12. Check whether the length of string literal is greater than or equal to 3: true
13. Count the occurrences of each string literal in method calls: "Howdy" occurs 4 times.
14. Check whether the count of any string literal is greater than or equal to 4: true

The test case violates the rule because the string literal "Howdy" is used in the method `bar` four times as an argument to the method `buz`. This can be improved by declaring "Howdy" as a constant field.
['Get the name of class.', 'Get all method declarations in class.', 'Get the name of method from method declaration.', 'Get the method body from method declaration.', 'Get all method calls in method body.', 'Get the name of called method.', 'Check whether the called method is buz.', 'Get the argument list of method call.', 'Get an argument of called method.', 'Check whether the argument is a string literal.', 'Get the value of string literal.', 'Check whether the length of string literal is greater than or equal to 3.', 'Count the occurrences of each string literal in method calls.', 'Check whether the count of any string literal is greater than or equal to 4.', 'Get the name of class: Foo', 'Get all method declarations in class: bar and buz', 'Get the name of method from method declaration: bar', 'Get the method body from method declaration: Contains method calls to buz with string literals.', 'Get all method calls in method body: buz("Howdy"), buz("Howdy"), buz("Howdy"), buz("Howdy")', 'Get the name of called method: buz', 'Check whether the called method is buz: true', 'Get the argument list of method call: Each call contains one argument.', 'Get an argument of called method: "Howdy"', 'Check whether the argument is a string literal: true', 'Get the value of string literal: "Howdy"', 'Check whether the length of string literal is greater than or equal to 3: true', 'Count the occurrences of each string literal in method calls: "Howdy" occurs 4 times.', 'Check whether the count of any string literal is greater than or equal to 4: true']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTExpressionStatement', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all method declarations in class.* 匹配到的元操作或API：
logic: Get all method declarations in class.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.8512491583824158
*Get the name of method from method declaration.* 匹配到的元操作或API：
logic: Get the name of method from method declaration.
most similar meta operation: Get the name of method
cosine Similarity: 0.9253699779510498
*Get the method body from method declaration.* 匹配到的元操作或API：
logic: Get the method body from method declaration.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.8859409093856812
*Get all method calls in method body.* 匹配到的元操作或API：
query: Get all method calls in method body.
most similar API: get body of method
cosine Similarity: 0.8351176381111145
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the called method is buz.* 匹配到的元操作或API：
query: Check whether the called method is buz.
most similar API: Check whether is test method
cosine Similarity: 0.8271233439445496
*Get the argument list of method call.* 匹配到的元操作或API：
logic: Get the argument list of method call.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8785549998283386
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9077174663543701
*Get the value of string literal.* 匹配到的元操作或API：
logic: Get the value of string literal.
most similar meta operation: Get the value of string literal
cosine Similarity: 0.9832245111465454
*Check whether the length of string literal is greater than or equal to 3.* 匹配到的元操作或API：
query: Check whether the length of string literal is greater than or equal to 3.
most similar API: Check whether the string literal is long literal
cosine Similarity: 0.8297568559646606
*Count the occurrences of each string literal in method calls.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of any string literal is greater than or equal to 4.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: Foo* 匹配到的元操作或API：
logic: Get the name of class: Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9263079166412354
*Get all method declarations in class: bar and buz* 匹配到的元操作或API：
query: Get all method declarations in class: bar and buz
most similar API: get declarations of class or interface
cosine Similarity: 0.8186039328575134
*Get the name of method from method declaration: bar* 匹配到的元操作或API：
logic: Get the name of method from method declaration: bar
most similar meta operation: Get the name of method
cosine Similarity: 0.8729888796806335
*Get the method body from method declaration: Contains method calls to buz with string literals.* 匹配到的元操作或API：
logic: Get the method body from method declaration: Contains method calls to buz with string literals.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.858741044998169
*Get all method calls in method body: buz("Howdy"), buz("Howdy"), buz("Howdy"), buz("Howdy")* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of called method: buz* 匹配到的元操作或API：
logic: Get the name of called method: buz
most similar meta operation: Get the name of called method
cosine Similarity: 0.8792607188224792
*Check whether the called method is buz: true* 匹配到的元操作或API：
query: Check whether the called method is buz: true
most similar API: Check whether the method call equals
cosine Similarity: 0.8240479230880737
*Get the argument list of method call: Each call contains one argument.* 匹配到的元操作或API：
logic: Get the argument list of method call: Each call contains one argument.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.8594601154327393
*Get an argument of called method: "Howdy"* 匹配到的元操作或API：
logic: Get an argument of called method: "Howdy"
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8822247982025146
*Check whether the argument is a string literal: true* 匹配到的元操作或API：
logic: Check whether the argument is a string literal: true
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8958649635314941
*Get the value of string literal: "Howdy"* 匹配到的元操作或API：
logic: Get the value of string literal: "Howdy"
most similar meta operation: Get the value of string literal
cosine Similarity: 0.8608798384666443
*Check whether the length of string literal is greater than or equal to 3: true* 匹配到的元操作或API：
query: Check whether the length of string literal is greater than or equal to 3: true
most similar API: Check whether the string literal is long literal
cosine Similarity: 0.8309847712516785
*Count the occurrences of each string literal in method calls: "Howdy" occurs 4 times.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of any string literal is greater than or equal to 4: true* 匹配到的元操作或API：
query: Check whether the count of any string literal is greater than or equal to 4: true
most similar API: Check whether the string literal equals
cosine Similarity: 0.8039535880088806
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
The test case corresponding to the rule:
```
// duplicate literals in argument list
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'buz')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
7. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.String getConstValue()
8. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isLongLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral long integer literal}.
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
10. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
11. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean equals(java.lang.Object)

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```
2.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
3.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class, ASTMethodCall.class, ASTStringLiteral.class);
    }

    private Map<String, Integer> stringLiteralCounts = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        stringLiteralCounts.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (TestFrameworksUtil.isTestMethod(node)) {
            return super.visit(node, data);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        if (getArgumentNumber(node) > 0) {
            ASTArgumentList arguments = node.getArguments();
            for (int i = 0; i < arguments.size(); i++) {
                ASTExpression expression = arguments.get(i);
                if (expression instanceof ASTStringLiteral) {
                    ASTStringLiteral literal = (ASTStringLiteral) expression;
                    String value = literal.getConstValue();
                    if (value.length() >= 3) {
                        stringLiteralCounts.put(value, stringLiteralCounts.getOrDefault(value, 0) + 1);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTStringLiteral node, Object data) {
        String value = node.getConstValue();
        if (value.length() >= 3 && stringLiteralCounts.getOrDefault(value, 0) >= 4) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method) {
        JMethodSymbol symbol = (JMethodSymbol) method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of called method.
2. Check whether the called method name is buz.
3. Get the number of arguments of called method.
4. Get the argument at position 1.
5. Check whether the argument is a string literal.
6. Get the length of string literal.
7. Check whether the length of string literal is 3 or more.
8. Get the value of string literal.
9. Check whether the string literal "Howdy" appears more than 3 times in the class.
10. Check whether the string literal "Howdy" is already declared as a constant field.
11. If the string literal "Howdy" appears more than 3 times and is not declared as a constant field, then this test case violates the rule.
            
['Get the name of called method.', 'Check whether the called method name is buz.', 'Get the number of arguments of called method.', 'Get the argument at position 1.', 'Check whether the argument is a string literal.', 'Get the length of string literal.', 'Check whether the length of string literal is 3 or more.', 'Get the value of string literal.', 'Check whether the string literal "Howdy" appears more than 3 times in the class.', 'Check whether the string literal "Howdy" is already declared as a constant field.', 'If the string literal "Howdy" appears more than 3 times and is not declared as a constant field, then this test case violates the rule.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTExpressionStatement', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the called method name is buz.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Get the argument at position 1.* 匹配到的元操作或API：
query: Get the argument at position 1.
most similar API: get first token of argument list
cosine Similarity: 0.8108179569244385
*Check whether the argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9077174663543701
*Get the length of string literal.* 匹配到的元操作或API：
logic: Get the length of string literal.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.987589955329895
*Check whether the length of string literal is 3 or more.* 匹配到的元操作或API：
query: Check whether the length of string literal is 3 or more.
most similar API: length of string literal
cosine Similarity: 0.8466031551361084
*Get the value of string literal.* 匹配到的元操作或API：
logic: Get the value of string literal.
most similar meta operation: Get the value of string literal
cosine Similarity: 0.9832245111465454
*Check whether the string literal "Howdy" appears more than 3 times in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the string literal "Howdy" is already declared as a constant field.* 匹配到的元操作或API：
query: Check whether the string literal "Howdy" is already declared as a constant field.
most similar API: Check whether the string literal is compile time constant
cosine Similarity: 0.8391487002372742
*If the string literal "Howdy" appears more than 3 times and is not declared as a constant field, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
The test case corresponding to the rule:
```
// duplicate literals in argument list
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'buz')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTArgumentList: public net.sourceforge.pmd.lang.ast.impl.javacc.JavaccToken getFirstToken()
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length()
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length(), //Length of the constant value in characters.
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.String getConstValue()
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isCompileTimeConstant()

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
2.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
True
此测试用例生成了first checker: bad 1


======================接下来开始迭代=====================
[ERROR]   "bad 2" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
97
81
87
72
117
102
93
78
94
78
83
69
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all fields declared in class.
3. Get the type of field.
4. Check whether the field is an array type.
5. Get the type of the elements in the array.
6. Check whether the element type is String type.
7. Get the initializer of the field.
8. Check whether the initializer is an array initializer.
9. Get the elements of the array initializer.
10. Get the literal value of each element.
11. Check whether the literal value has a length of 3 or more.
12. Count occurrences of each string literal that has a length of 3 or more.
13. Check whether any string literal occurs 4 or more times.

If a string literal with a length of 3 or more occurs 4 or more times in a field initializer, then the test case violates the rule. In this case, the string literal "foo" appears 9 times, which violates the rule. Therefore, the number of violations in this test case is 1.
['Get the name of class.', 'Get all fields declared in class.', 'Get the type of field.', 'Check whether the field is an array type.', 'Get the type of the elements in the array.', 'Check whether the element type is String type.', 'Get the initializer of the field.', 'Check whether the initializer is an array initializer.', 'Get the elements of the array initializer.', 'Get the literal value of each element.', 'Check whether the literal value has a length of 3 or more.', 'Count occurrences of each string literal that has a length of 3 or more.', 'Check whether any string literal occurs 4 or more times.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTVariableDeclaratorId', 'ASTArrayType', 'ASTArrayTypeDim', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'ASTArrayInitializer', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'ASTArrayDimensions', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all fields declared in class.* 匹配到的元操作或API：
query: Get all fields declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8290460109710693
*Get the type of field.* 匹配到的元操作或API：
logic: Get the type of field.
most similar meta operation: Get the type of field
cosine Similarity: 0.983250081539154
*Check whether the field is an array type.* 匹配到的元操作或API：
logic: Check whether the field is an array type.
most similar meta operation: Check whether the field is array type
cosine Similarity: 0.9805460572242737
*Get the type of the elements in the array.* 匹配到的元操作或API：
query: Get the type of the elements in the array.
most similar API: get element type of array type
cosine Similarity: 0.9324879050254822
*Check whether the element type is String type.* 匹配到的元操作或API：
logic: Check whether the element type is String type.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.8770722150802612
*Get the initializer of the field.* 匹配到的元操作或API：
query: Get the initializer of the field.
most similar API: get initializer of variable declarator
cosine Similarity: 0.8360726237297058
*Check whether the initializer is an array initializer.* 匹配到的元操作或API：
query: Check whether the initializer is an array initializer.
most similar API: Check whether is array initializer
cosine Similarity: 0.9679869413375854
*Get the elements of the array initializer.* 匹配到的元操作或API：
query: Get the elements of the array initializer.
most similar API: get text of array initializer
cosine Similarity: 0.8674233555793762
*Get the literal value of each element.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the literal value has a length of 3 or more.* 匹配到的元操作或API：
query: Check whether the literal value has a length of 3 or more.
most similar API: Check whether the string literal is long literal
cosine Similarity: 0.8014366030693054
*Count occurrences of each string literal that has a length of 3 or more.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}


This checker is failed(false negative) on this negative test case:
```
// duplicate literals in field decl
public class Foo {
    String[] FOO = {"foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"};
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTArrayType (this is a primitive type)
        ——ASTClassOrInterfaceType (this is a class type)
        ——ASTArrayDimensions
          ——ASTArrayTypeDim
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'FOO')
        ——ASTArrayInitializer
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
3. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
4. net.sourceforge.pmd.lang.java.ast.ASTArrayType: public net.sourceforge.pmd.lang.java.ast.ASTType getElementType()
5. net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator: public net.sourceforge.pmd.lang.java.ast.ASTExpression getInitializer(), //Returns the initializer, of the variable, or null if it doesn't exist.
6. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isArrayInitializer(net.sourceforge.pmd.lang.java.ast.ASTExpression)
7. net.sourceforge.pmd.lang.java.ast.ASTArrayInitializer: public net.sourceforge.pmd.lang.document.Chars getText()
8. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isLongLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral long integer literal}.

1.  //Check whether the field is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isFieldArrayType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```
2.  //Check whether the field is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFieldStringType(ASTFieldDeclaration node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class, ASTFieldDeclaration.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                if (stringLiteral.getValue().length() >= 3) {
                    String value = stringLiteral.getConstValue();
                    stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                    if (stringLiteralCount.get(value) == 4) {
                        addViolation(data, stringLiteral);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        ASTExpression initializer = node.getVariableDeclarator().getInitializer();
        if (initializer != null && JavaAstUtils.isArrayInitializer(initializer)) {
            ASTArrayInitializer arrayInitializer = (ASTArrayInitializer) initializer;
            Map<String, Integer> localCount = new HashMap<>();
            for (ASTExpression expr : arrayInitializer.children(ASTStringLiteral.class)) {
                ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                if (stringLiteral.getValue().length() >= 3) {
                    String value = stringLiteral.getConstValue();
                    localCount.put(value, localCount.getOrDefault(value, 0) + 1);
                    if (localCount.get(value) == 4) {
                        addViolation(data, stringLiteral);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }

    // Check whether the field is array type
    public boolean isFieldArrayType(ASTFieldDeclaration node) {
        ASTType type = node.getTypeNode();
        return type.getTypeMirror().isArray();
    }

    // Check whether the field is string type
    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all field declarations in class.
3. Get the name of field.
4. Get the type of field.
5. Check whether the field is array type.
6. Get the dimension of array.
7. Check whether the dimension of array is 1.
8. Get the type of one dimension array.
9. Check whether the type of one dimension array is String type.
10. Get the initial value of field.
11. Parse the initial value to get all string literals.
12. Get the length of each string literal.
13. Check whether the length of string literal is greater than or equal to 3.
14. Count the occurrences of each string literal that has a length greater than or equal to 3.
15. Check whether the count of any string literal is greater than or equal to 4.

In this test case:
- Steps 1 to 9: The field `FOO` is identified as a `String` array.
- Step 10: The initial value is `{"foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"}`.
- Step 11: The string literals in the initial value are parsed.
- Steps 12 and 13: The length of each string literal is checked, and "foo" has a length of 3.
- Step 14: The count of the string literal "foo" is 9.
- Step 15: Since the count of "foo" is greater than 4, this test case violates the rule.
['Get the name of class.', 'Get all field declarations in class.', 'Get the name of field.', 'Get the type of field.', 'Check whether the field is array type.', 'Get the dimension of array.', 'Check whether the dimension of array is 1.', 'Get the type of one dimension array.', 'Check whether the type of one dimension array is String type.', 'Get the initial value of field.', 'Parse the initial value to get all string literals.', 'Get the length of each string literal.', 'Check whether the length of string literal is greater than or equal to 3.', 'Count the occurrences of each string literal that has a length greater than or equal to 3.', 'Check whether the count of any string literal is greater than or equal to 4.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTVariableDeclaratorId', 'ASTArrayType', 'ASTArrayTypeDim', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'ASTArrayInitializer', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'ASTArrayDimensions', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all field declarations in class.* 匹配到的元操作或API：
query: Get all field declarations in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8478881120681763
*Get the name of field.* 匹配到的元操作或API：
logic: Get the name of field.
most similar meta operation: Get the name of field
cosine Similarity: 0.9782174825668335
*Get the type of field.* 匹配到的元操作或API：
logic: Get the type of field.
most similar meta operation: Get the type of field
cosine Similarity: 0.983250081539154
*Check whether the field is array type.* 匹配到的元操作或API：
logic: Check whether the field is array type.
most similar meta operation: Check whether the field is array type
cosine Similarity: 0.9860299825668335
*Get the dimension of array.* 匹配到的元操作或API：
logic: Get the dimension of array.
most similar meta operation: Get the dimension of array
cosine Similarity: 0.9793283343315125
*Check whether the dimension of array is 1.* 匹配到的元操作或API：
query: Check whether the dimension of array is 1.
most similar API: Check whether the array dimensions equals
cosine Similarity: 0.8850963115692139
*Get the type of one dimension array.* 匹配到的元操作或API：
query: Get the type of one dimension array.
most similar API: get type of array type
cosine Similarity: 0.8734851479530334
*Check whether the type of one dimension array is String type.* 匹配到的元操作或API：
logic: Check whether the type of one dimension array is String type.
most similar meta operation: Check whether the array is string type
cosine Similarity: 0.9008021950721741
*Get the initial value of field.* 匹配到的元操作或API：
logic: Get the initial value of field.
most similar meta operation: Get the literal value that the field is initialized to
cosine Similarity: 0.8744477033615112
*Parse the initial value to get all string literals.* 匹配到的元操作或API：
query: Parse the initial value to get all string literals.
most similar API: get first token of string literal
cosine Similarity: 0.8291918635368347
*Get the length of each string literal.* 匹配到的元操作或API：
logic: Get the length of each string literal.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.9603046774864197
*Check whether the length of string literal is greater than or equal to 3.* 匹配到的元操作或API：
query: Check whether the length of string literal is greater than or equal to 3.
most similar API: Check whether the string literal is long literal
cosine Similarity: 0.8297568559646606
*Count the occurrences of each string literal that has a length greater than or equal to 3.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of any string literal is greater than or equal to 4.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}


This checker is failed(false negative) on this negative test case:
```
// duplicate literals in field decl
public class Foo {
    String[] FOO = {"foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"};
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTArrayType (this is a primitive type)
        ——ASTClassOrInterfaceType (this is a class type)
        ——ASTArrayDimensions
          ——ASTArrayTypeDim
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'FOO')
        ——ASTArrayInitializer
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
3. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
4. net.sourceforge.pmd.lang.java.ast.ASTArrayDimensions: public boolean equals(java.lang.Object)
5. net.sourceforge.pmd.lang.java.ast.ASTArrayType: public java.lang.Class<Class<?> getType()
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public net.sourceforge.pmd.lang.ast.impl.javacc.JavaccToken getFirstToken()
7. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length()
8. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isLongLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral long integer literal}.

1.  //Get the name of field
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.ast.NodeStream;
public String getFieldName(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId variableDeclaratorId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(variableDeclaratorId.getName().equals("x")){
            String variableName = variableDeclaratorId.getName();
            return variableName;
        }
    }
    return null;
}
```
2.  //Check whether the field is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isFieldArrayType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```
3.  //Get the dimension of array
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimensions;
public int getArrayDimension(ASTVariableDeclaratorId varId) {
    int dimension = 0;
    if(varId.getType().isArray()){
        ASTArrayType arrayType = (ASTArrayType)varId.getTypeNode();
        ASTArrayDimensions arrayTypeDimensions = arrayType.getDimensions();
        dimension = arrayTypeDimensions.size();
    }
    return dimension;
}
```
4.  //Check whether the array is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isArrayStringType(ASTVariableDeclaratorId node) {
    if(node.getType().isArray()){
        ASTArrayType arrayType = (ASTArrayType)node.getTypeNode();
        ASTType astType = (ASTType) arrayType.getChild(0);
        if(astType instanceof ASTClassOrInterfaceType){
            ASTClassOrInterfaceType classOrInterfaceType = (ASTClassOrInterfaceType)astType;
            return TypeTestUtil.isA(String.class, classOrInterfaceType);
        }
    }
    return false;
}
```
5.  //Get the literal value that the field is initialized to
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTLiteral;
import net.sourceforge.pmd.lang.ast.NodeStream;
public ASTLiteral getInitializedValue(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTLiteral) {
                    return (ASTLiteral)init;
                }
            }
        }
    }
    return null;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class, ASTFieldDeclaration.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        ASTType type = node.getTypeNode();
        if (type.getTypeMirror().isArray()) {
            ASTArrayType arrayType = (ASTArrayType) type;
            ASTType astType = (ASTType) arrayType.getChild(0);
            if (astType instanceof ASTClassOrInterfaceType) {
                ASTClassOrInterfaceType classOrInterfaceType = (ASTClassOrInterfaceType) astType;
                if (TypeTestUtil.isA(String.class, classOrInterfaceType)) {
                    ASTExpression init = node.getFirstChildOfType(ASTExpression.class);
                    if (init instanceof ASTArrayInitializer) {
                        ASTArrayInitializer arrayInitializer = (ASTArrayInitializer) init;
                        Map<String, Integer> fieldLiteralCount = new HashMap<>();
                        for (ASTExpression expr : arrayInitializer.children(ASTStringLiteral.class)) {
                            if (expr instanceof ASTStringLiteral) {
                                ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                                if (stringLiteral.length() >= 3) {
                                    String value = stringLiteral.getConstValue();
                                    fieldLiteralCount.put(value, fieldLiteralCount.getOrDefault(value, 0) + 1);
                                    if (fieldLiteralCount.get(value) == 4) {
                                        addViolation(data, stringLiteral);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 2" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 2" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the name of the class.
2. Get all fields declared in the class.
3. Get the type of field.
4. Check whether the field type is array type.
5. Get the one dimension array length.
6. Check whether the field is initialized to literal value.
7. Get the literal value that the field is initialized to.
8. Get the length of string literal.
9. Check whether the length of string literal is greater than or equal to 3.
10. Get all elements in the array.
11. Count the occurrences of each string literal in the array.
12. Check whether any string literal appears more than 4 times.

If the field is an array of strings, where each string literal has a length of 3 or more, and any string literal appears more than 4 times, then this test case violates the rule. In this specific case, the string literal "foo" appears 9 times, which is more than 4 times, so it violates the rule.
['Get the name of the class.', 'Get all fields declared in the class.', 'Get the type of field.', 'Check whether the field type is array type.', 'Get the one dimension array length.', 'Check whether the field is initialized to literal value.', 'Get the literal value that the field is initialized to.', 'Get the length of string literal.', 'Check whether the length of string literal is greater than or equal to 3.', 'Get all elements in the array.', 'Count the occurrences of each string literal in the array.', 'Check whether any string literal appears more than 4 times.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTVariableDeclaratorId', 'ASTArrayType', 'ASTArrayTypeDim', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'ASTArrayInitializer', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'ASTArrayDimensions', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the name of the class.* 匹配到的元操作或API：
logic: Get the name of the class.
most similar meta operation: Get the name of class
cosine Similarity: 0.968898594379425
*Get all fields declared in the class.* 匹配到的元操作或API：
query: Get all fields declared in the class.
most similar API: get declared annotations of field
cosine Similarity: 0.8222575187683105
*Get the type of field.* 匹配到的元操作或API：
logic: Get the type of field.
most similar meta operation: Get the type of field
cosine Similarity: 0.983250081539154
*Check whether the field type is array type.* 匹配到的元操作或API：
logic: Check whether the field type is array type.
most similar meta operation: Check whether the field is array type
cosine Similarity: 0.9776074886322021
*Get the one dimension array length.* 匹配到的元操作或API：
logic: Get the one dimension array length.
most similar meta operation: Get the length of one dimension array
cosine Similarity: 0.9719899296760559
*Check whether the field is initialized to literal value.* 匹配到的元操作或API：
logic: Check whether the field is initialized to literal value.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.909231424331665
*Get the literal value that the field is initialized to.* 匹配到的元操作或API：
logic: Get the literal value that the field is initialized to.
most similar meta operation: Get the literal value that the field is initialized to
cosine Similarity: 0.9854511022567749
*Get the length of string literal.* 匹配到的元操作或API：
logic: Get the length of string literal.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.987589955329895
*Check whether the length of string literal is greater than or equal to 3.* 匹配到的元操作或API：
query: Check whether the length of string literal is greater than or equal to 3.
most similar API: Check whether the string literal is long literal
cosine Similarity: 0.8297568559646606
*Get all elements in the array.* 匹配到的元操作或API：
未匹配成功元操作或API
*Count the occurrences of each string literal in the array.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal appears more than 4 times.* 匹配到的元操作或API：
query: Check whether any string literal appears more than 4 times.
most similar API: Check whether the string literal is double literal
cosine Similarity: 0.81272292137146
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}


This checker is failed(false negative) on this negative test case:
```
// duplicate literals in field decl
public class Foo {
    String[] FOO = {"foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"};
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTArrayType (this is a primitive type)
        ——ASTClassOrInterfaceType (this is a class type)
        ——ASTArrayDimensions
          ——ASTArrayTypeDim
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'FOO')
        ——ASTArrayInitializer
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length()
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isLongLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral long integer literal}.
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isDoubleLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral double literal}.

1.  //Check whether the field is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isFieldArrayType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```
2.  //Get the length of one dimension array
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimensions;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimExpr;
import net.sourceforge.pmd.lang.java.ast.ASTArrayAllocation;
import net.sourceforge.pmd.lang.java.ast.ASTArrayInitializer;
import net.sourceforge.pmd.lang.java.ast.ASTNumericLiteral;
public int getLengthOfOneDimensionArray(ASTVariableDeclaratorId varId) {
    int arrayLen = 0;
    int dimension;
    if (varId.getType().isArray()) {
        ASTArrayType arrayType = (ASTArrayType) varId.getTypeNode();
        ASTArrayDimensions arrayTypeDimensions = arrayType.getDimensions();
        dimension = arrayTypeDimensions.size();
        if (dimension == 1) {
            ASTArrayAllocation arrayAllocation = varId.getParent().firstChild(ASTArrayAllocation.class);
            if (arrayAllocation != null) {
                ASTArrayInitializer arrayInitializer = arrayAllocation.firstChild(ASTArrayInitializer.class);
                if (arrayInitializer != null) {
                    arrayLen = arrayInitializer.length();
                } else {
                    ASTArrayDimensions astArrayTypeDims = arrayAllocation.descendants(ASTArrayDimensions.class).first();
                    ASTArrayDimExpr arrayDimExpr = (ASTArrayDimExpr) astArrayTypeDims.get(0);
                    if (arrayDimExpr.getLengthExpression() instanceof ASTNumericLiteral) {
                        arrayLen = ((ASTNumericLiteral) arrayDimExpr.getLengthExpression()).getValueAsInt();
                    }
                }
            }
        }
    }
    return arrayLen;
}
```
3.  //Check whether the field is initialized
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean isInitialized(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                return true;
            }
        }
    }
    return false;
}
```
4.  //Get the literal value that the field is initialized to
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTLiteral;
import net.sourceforge.pmd.lang.ast.NodeStream;
public ASTLiteral getInitializedValue(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTLiteral) {
                    return (ASTLiteral)init;
                }
            }
        }
    }
    return null;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class, ASTFieldDeclaration.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldArrayType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTArrayInitializer arrayInitializer = varId.getFirstChildOfType(ASTArrayInitializer.class);
                if (arrayInitializer != null) {
                    checkArrayInitializer(arrayInitializer, data);
                }
            }
        }
        return super.visit(node, data);
    }

    private void checkArrayInitializer(ASTArrayInitializer arrayInitializer, Object data) {
        Map<String, Integer> localLiteralCount = new HashMap<>();
        for (ASTStringLiteral stringLiteral : arrayInitializer.children(ASTStringLiteral.class)) {
            if (stringLiteral.length() >= 3) {
                String value = stringLiteral.getConstValue();
                localLiteralCount.put(value, localLiteralCount.getOrDefault(value, 0) + 1);
                if (localLiteralCount.get(value) == 4) {
                    addViolation(data, stringLiteral);
                }
            }
        }
    }

    private boolean isFieldArrayType(ASTFieldDeclaration node) {
        ASTType type = node.getTypeNode();
        return type.getTypeMirror().isArray();
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 2" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 2" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all fields declared in class.
3. Get the type of field.
4. Check whether the type of field is array type.
5. Check whether the array is string type.
6. Get the dimension of array.
7. Check whether the dimension of array is 1.
8. Get the one dimension array length.
9. Get the initial value of array.
10. Check whether the initial value is a string literal.
11. Get the length of string literal.
12. Check whether the length of string literal is less than 3.
13. Count the occurrences of each string literal in the initial value.
14. Check whether any string literal occurs 4 or more times and its length is 3 or more.

This series of checks will determine if the test case violates the rule by checking for an array of strings where any single string literal appears 4 or more times and is at least 3 characters long. In the provided test case, the string literal "foo" appears 9 times, so it violates the rule.
['Get the name of class.', 'Get all fields declared in class.', 'Get the type of field.', 'Check whether the type of field is array type.', 'Check whether the array is string type.', 'Get the dimension of array.', 'Check whether the dimension of array is 1.', 'Get the one dimension array length.', 'Get the initial value of array.', 'Check whether the initial value is a string literal.', 'Get the length of string literal.', 'Check whether the length of string literal is less than 3.', 'Count the occurrences of each string literal in the initial value.', 'Check whether any string literal occurs 4 or more times and its length is 3 or more.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTVariableDeclaratorId', 'ASTArrayType', 'ASTArrayTypeDim', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'ASTArrayInitializer', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'ASTArrayDimensions', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all fields declared in class.* 匹配到的元操作或API：
query: Get all fields declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8290460109710693
*Get the type of field.* 匹配到的元操作或API：
logic: Get the type of field.
most similar meta operation: Get the type of field
cosine Similarity: 0.983250081539154
*Check whether the type of field is array type.* 匹配到的元操作或API：
logic: Check whether the type of field is array type.
most similar meta operation: Check whether the field is array type
cosine Similarity: 0.9783475399017334
*Check whether the array is string type.* 匹配到的元操作或API：
logic: Check whether the array is string type.
most similar meta operation: Check whether the array is string type
cosine Similarity: 0.9868484735488892
*Get the dimension of array.* 匹配到的元操作或API：
logic: Get the dimension of array.
most similar meta operation: Get the dimension of array
cosine Similarity: 0.9793283343315125
*Check whether the dimension of array is 1.* 匹配到的元操作或API：
query: Check whether the dimension of array is 1.
most similar API: Check whether the array dimensions equals
cosine Similarity: 0.8850963115692139
*Get the one dimension array length.* 匹配到的元操作或API：
logic: Get the one dimension array length.
most similar meta operation: Get the length of one dimension array
cosine Similarity: 0.9719899296760559
*Get the initial value of array.* 匹配到的元操作或API：
query: Get the initial value of array.
most similar API: get first token of array initializer
cosine Similarity: 0.8397504091262817
*Check whether the initial value is a string literal.* 匹配到的元操作或API：
query: Check whether the initial value is a string literal.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.9093655347824097
*Get the length of string literal.* 匹配到的元操作或API：
logic: Get the length of string literal.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.987589955329895
*Check whether the length of string literal is less than 3.* 匹配到的元操作或API：
query: Check whether the length of string literal is less than 3.
most similar API: length of string literal
cosine Similarity: 0.8233146667480469
*Count the occurrences of each string literal in the initial value.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs 4 or more times and its length is 3 or more.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}


This checker is failed(false negative) on this negative test case:
```
// duplicate literals in field decl
public class Foo {
    String[] FOO = {"foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"};
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTArrayType (this is a primitive type)
        ——ASTClassOrInterfaceType (this is a class type)
        ——ASTArrayDimensions
          ——ASTArrayTypeDim
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'FOO')
        ——ASTArrayInitializer
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
3. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
4. net.sourceforge.pmd.lang.java.ast.ASTArrayDimensions: public boolean equals(java.lang.Object)
5. net.sourceforge.pmd.lang.java.ast.ASTArrayInitializer: public net.sourceforge.pmd.lang.ast.impl.javacc.JavaccToken getFirstToken()
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
7. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length()
8. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length(), //Length of the constant value in characters.

1.  //Check whether the field is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isFieldArrayType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```
2.  //Check whether the array is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isArrayStringType(ASTVariableDeclaratorId node) {
    if(node.getType().isArray()){
        ASTArrayType arrayType = (ASTArrayType)node.getTypeNode();
        ASTType astType = (ASTType) arrayType.getChild(0);
        if(astType instanceof ASTClassOrInterfaceType){
            ASTClassOrInterfaceType classOrInterfaceType = (ASTClassOrInterfaceType)astType;
            return TypeTestUtil.isA(String.class, classOrInterfaceType);
        }
    }
    return false;
}
```
3.  //Get the dimension of array
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimensions;
public int getArrayDimension(ASTVariableDeclaratorId varId) {
    int dimension = 0;
    if(varId.getType().isArray()){
        ASTArrayType arrayType = (ASTArrayType)varId.getTypeNode();
        ASTArrayDimensions arrayTypeDimensions = arrayType.getDimensions();
        dimension = arrayTypeDimensions.size();
    }
    return dimension;
}
```
4.  //Get the length of one dimension array
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimensions;
import net.sourceforge.pmd.lang.java.ast.ASTArrayDimExpr;
import net.sourceforge.pmd.lang.java.ast.ASTArrayAllocation;
import net.sourceforge.pmd.lang.java.ast.ASTArrayInitializer;
import net.sourceforge.pmd.lang.java.ast.ASTNumericLiteral;
public int getLengthOfOneDimensionArray(ASTVariableDeclaratorId varId) {
    int arrayLen = 0;
    int dimension;
    if (varId.getType().isArray()) {
        ASTArrayType arrayType = (ASTArrayType) varId.getTypeNode();
        ASTArrayDimensions arrayTypeDimensions = arrayType.getDimensions();
        dimension = arrayTypeDimensions.size();
        if (dimension == 1) {
            ASTArrayAllocation arrayAllocation = varId.getParent().firstChild(ASTArrayAllocation.class);
            if (arrayAllocation != null) {
                ASTArrayInitializer arrayInitializer = arrayAllocation.firstChild(ASTArrayInitializer.class);
                if (arrayInitializer != null) {
                    arrayLen = arrayInitializer.length();
                } else {
                    ASTArrayDimensions astArrayTypeDims = arrayAllocation.descendants(ASTArrayDimensions.class).first();
                    ASTArrayDimExpr arrayDimExpr = (ASTArrayDimExpr) astArrayTypeDims.get(0);
                    if (arrayDimExpr.getLengthExpression() instanceof ASTNumericLiteral) {
                        arrayLen = ((ASTNumericLiteral) arrayDimExpr.getLengthExpression()).getValueAsInt();
                    }
                }
            }
        }
    }
    return arrayLen;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class, ASTFieldDeclaration.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            for (ASTExpression expr : methodCall.getArguments().children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        ASTVariableDeclaratorId varId = node.getFirstChildOfType(ASTVariableDeclaratorId.class);
        if (isFieldArrayType(node) && isArrayStringType(varId)) {
            ASTArrayInitializer arrayInitializer = node.getFirstChildOfType(ASTArrayInitializer.class);
            if (arrayInitializer != null) {
                for (ASTStringLiteral stringLiteral : arrayInitializer.children(ASTStringLiteral.class)) {
                    String value = stringLiteral.getConstValue();
                    if (stringLiteral.length() >= 3) {
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldArrayType(ASTFieldDeclaration node) {
        ASTType type = node.getTypeNode();
        return type.getTypeMirror().isArray();
    }

    public boolean isArrayStringType(ASTVariableDeclaratorId node) {
        if (node.getType().isArray()) {
            ASTArrayType arrayType = (ASTArrayType) node.getTypeNode();
            ASTType astType = (ASTType) arrayType.getChild(0);
            if (astType instanceof ASTClassOrInterfaceType) {
                ASTClassOrInterfaceType classOrInterfaceType = (ASTClassOrInterfaceType) astType;
                return TypeTestUtil.isA(String.class, classOrInterfaceType);
            }
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 2" failed'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 2" failed不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all field declarations in the class.
3. Get the type of field.
4. Check whether the field is an array type.
5. If the field is an array type, get the type of array elements.
6. Check whether the type of array elements is String.
7. Get the initializer of the field.
8. Check whether the initializer is an array initializer.
9. If the initializer is an array initializer, get all elements in the array initializer.
10. Check whether the length of the string literal is less than 3.
11. If the length of the string literal is not less than 3, count the occurrences of each string literal in the array initializer.
12. Check whether any string literal occurs 4 or more times.
13. If any string literal occurs 4 or more times, this test case violates the rule.

For the given test case:
1. Get the name of class: Foo
2. Get all field declarations in the class: FOO
3. Get the type of field: FOO is of type String[]
4. Check whether the field is an array type: Yes, it is an array type.
5. If the field is an array type, get the type of array elements: Elements are of type String.
6. Check whether the type of array elements is String: Yes, the elements are of type String.
7. Get the initializer of the field: FOO is initialized to {"foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"}
8. Check whether the initializer is an array initializer: Yes, it is an array initializer.
9. If the initializer is an array initializer, get all elements in the array initializer: Elements are "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"
10. Check whether the length of the string literal is less than 3: "foo" has a length of 3, which is not less than 3.
11. If the length of the string literal is not less than 3, count the occurrences of each string literal in the array initializer: "foo" occurs 9 times.
12. Check whether any string literal occurs 4 or more times: "foo" occurs 9 times, which is more than 4.
13. If any string literal occurs 4 or more times, this test case violates the rule: Therefore, this test case violates the rule.

The number of violating the rule in this test case is: 1
            
['Get the name of class.', 'Get all field declarations in the class.', 'Get the type of field.', 'Check whether the field is an array type.', 'If the field is an array type, get the type of array elements.', 'Check whether the type of array elements is String.', 'Get the initializer of the field.', 'Check whether the initializer is an array initializer.', 'If the initializer is an array initializer, get all elements in the array initializer.', 'Check whether the length of the string literal is less than 3.', 'If the length of the string literal is not less than 3, count the occurrences of each string literal in the array initializer.', 'Check whether any string literal occurs 4 or more times.', 'If any string literal occurs 4 or more times, this test case violates the rule.', 'Get the name of class: Foo', 'Get all field declarations in the class: FOO', 'Get the type of field: FOO is of type String[]', 'Check whether the field is an array type: Yes, it is an array type.', 'If the field is an array type, get the type of array elements: Elements are of type String.', 'Check whether the type of array elements is String: Yes, the elements are of type String.', 'Get the initializer of the field: FOO is initialized to {"foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"}', 'Check whether the initializer is an array initializer: Yes, it is an array initializer.', 'If the initializer is an array initializer, get all elements in the array initializer: Elements are "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"', 'Check whether the length of the string literal is less than 3: "foo" has a length of 3, which is not less than 3.', 'If the length of the string literal is not less than 3, count the occurrences of each string literal in the array initializer: "foo" occurs 9 times.', 'Check whether any string literal occurs 4 or more times: "foo" occurs 9 times, which is more than 4.', 'If any string literal occurs 4 or more times, this test case violates the rule: Therefore, this test case violates the rule.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTVariableDeclaratorId', 'ASTArrayType', 'ASTArrayTypeDim', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'ASTArrayInitializer', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'ASTArrayDimensions', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all field declarations in the class.* 匹配到的元操作或API：
query: Get all field declarations in the class.
most similar API: get declared annotations of field
cosine Similarity: 0.8462488055229187
*Get the type of field.* 匹配到的元操作或API：
logic: Get the type of field.
most similar meta operation: Get the type of field
cosine Similarity: 0.983250081539154
*Check whether the field is an array type.* 匹配到的元操作或API：
logic: Check whether the field is an array type.
most similar meta operation: Check whether the field is array type
cosine Similarity: 0.9805460572242737
*If the field is an array type, get the type of array elements.* 匹配到的元操作或API：
logic: If the field is an array type, get the type of array elements.
most similar meta operation: Check whether the field is array type
cosine Similarity: 0.8824908137321472
*Check whether the type of array elements is String.* 匹配到的元操作或API：
logic: Check whether the type of array elements is String.
most similar meta operation: Check whether the array is string type
cosine Similarity: 0.9506562948226929
*Get the initializer of the field.* 匹配到的元操作或API：
query: Get the initializer of the field.
most similar API: get initializer of variable declarator
cosine Similarity: 0.8360726237297058
*Check whether the initializer is an array initializer.* 匹配到的元操作或API：
query: Check whether the initializer is an array initializer.
most similar API: Check whether is array initializer
cosine Similarity: 0.9679869413375854
*If the initializer is an array initializer, get all elements in the array initializer.* 匹配到的元操作或API：
query: If the initializer is an array initializer, get all elements in the array initializer.
most similar API: for each of array initializer
cosine Similarity: 0.8558638095855713
*Check whether the length of the string literal is less than 3.* 匹配到的元操作或API：
query: Check whether the length of the string literal is less than 3.
most similar API: length of string literal
cosine Similarity: 0.8179245591163635
*If the length of the string literal is not less than 3, count the occurrences of each string literal in the array initializer.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
*If any string literal occurs 4 or more times, this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: Foo* 匹配到的元操作或API：
logic: Get the name of class: Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9263079166412354
*Get all field declarations in the class: FOO* 匹配到的元操作或API：
query: Get all field declarations in the class: FOO
most similar API: get declared annotations of field
cosine Similarity: 0.8471710085868835
*Get the type of field: FOO is of type String[]* 匹配到的元操作或API：
logic: Get the type of field: FOO is of type String[]
most similar meta operation: Get the type of field
cosine Similarity: 0.8727615475654602
*Check whether the field is an array type: Yes, it is an array type.* 匹配到的元操作或API：
logic: Check whether the field is an array type: Yes, it is an array type.
most similar meta operation: Check whether the field is array type
cosine Similarity: 0.9571654796600342
*If the field is an array type, get the type of array elements: Elements are of type String.* 匹配到的元操作或API：
logic: If the field is an array type, get the type of array elements: Elements are of type String.
most similar meta operation: Check whether the field is array type
cosine Similarity: 0.8737603425979614
*Check whether the type of array elements is String: Yes, the elements are of type String.* 匹配到的元操作或API：
logic: Check whether the type of array elements is String: Yes, the elements are of type String.
most similar meta operation: Check whether the array is string type
cosine Similarity: 0.925929605960846
*Get the initializer of the field: FOO is initialized to {"foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"}* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the initializer is an array initializer: Yes, it is an array initializer.* 匹配到的元操作或API：
query: Check whether the initializer is an array initializer: Yes, it is an array initializer.
most similar API: Check whether is array initializer
cosine Similarity: 0.9493153095245361
*If the initializer is an array initializer, get all elements in the array initializer: Elements are "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"* 匹配到的元操作或API：
query: If the initializer is an array initializer, get all elements in the array initializer: Elements are "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"
most similar API: for each of array initializer
cosine Similarity: 0.8335013389587402
*Check whether the length of the string literal is less than 3: "foo" has a length of 3, which is not less than 3.* 匹配到的元操作或API：
query: Check whether the length of the string literal is less than 3: "foo" has a length of 3, which is not less than 3.
most similar API: length of string literal
cosine Similarity: 0.827277660369873
*If the length of the string literal is not less than 3, count the occurrences of each string literal in the array initializer: "foo" occurs 9 times.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs 4 or more times: "foo" occurs 9 times, which is more than 4.* 匹配到的元操作或API：
未匹配成功元操作或API
*If any string literal occurs 4 or more times, this test case violates the rule: Therefore, this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}


This checker is failed(false negative) on this negative test case:
```
// duplicate literals in field decl
public class Foo {
    String[] FOO = {"foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"};
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTArrayType (this is a primitive type)
        ——ASTClassOrInterfaceType (this is a class type)
        ——ASTArrayDimensions
          ——ASTArrayTypeDim
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'FOO')
        ——ASTArrayInitializer
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral
          ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
4. net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator: public net.sourceforge.pmd.lang.java.ast.ASTExpression getInitializer(), //Returns the initializer, of the variable, or null if it doesn't exist.
5. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isArrayInitializer(net.sourceforge.pmd.lang.java.ast.ASTExpression)
6. net.sourceforge.pmd.lang.java.ast.ASTArrayInitializer: public void forEach(java.util.function.Consumer)
7. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length(), //Length of the constant value in characters.

1.  //Check whether the field is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isFieldArrayType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```
2.  //Check whether the array is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isArrayStringType(ASTVariableDeclaratorId node) {
    if(node.getType().isArray()){
        ASTArrayType arrayType = (ASTArrayType)node.getTypeNode();
        ASTType astType = (ASTType) arrayType.getChild(0);
        if(astType instanceof ASTClassOrInterfaceType){
            ASTClassOrInterfaceType classOrInterfaceType = (ASTClassOrInterfaceType)astType;
            return TypeTestUtil.isA(String.class, classOrInterfaceType);
        }
    }
    return false;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class, ASTFieldDeclaration.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        ASTExpression initializer = node.getFirstChildOfType(ASTVariableDeclarator.class).getInitializer();
        if (initializer != null && JavaAstUtils.isArrayInitializer(initializer)) {
            ASTArrayType arrayType = (ASTArrayType) node.getTypeNode();
            ASTClassOrInterfaceType classOrInterfaceType = (ASTClassOrInterfaceType) arrayType.getComponentType();
            if (TypeTestUtil.isA(String.class, classOrInterfaceType)) {
                ASTArrayInitializer arrayInitializer = (ASTArrayInitializer) initializer;
                for (ASTStringLiteral stringLiteral : arrayInitializer.children(ASTStringLiteral.class)) {
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 2
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
81
67
96
80
99
82
=========================error_testcase_logics=========================
To determine if the provided test case violates the rule, we need to perform the following granular checks:

1. Get the name of class.
2. Get all annotations declared on class.
3. Get the argument list of each annotation.
4. Check whether the argument is a string literal.
5. Check whether the string literal has a length greater than or equal to 3.
6. Count the occurrences of each string literal.
7. Check whether any string literal occurs more than 4 times.

Let's perform these checks:

1. Get the name of class.
   - The name of the class is `Foo`.

2. Get all annotations declared on class.
   - The annotations declared on the class are `@SuppressWarnings("foo")`.

3. Get the argument list of each annotation.
   - The argument list of `@SuppressWarnings("foo")` is `["foo"]`.

4. Check whether the argument is a string literal.
   - The argument `"foo"` is a string literal.

5. Check whether the string literal has a length greater than or equal to 3.
   - The length of the string literal `"foo"` is 3, which is greater than or equal to 3.

6. Count the occurrences of each string literal.
   - The string literal `"foo"` occurs 8 times.

7. Check whether any string literal occurs more than 4 times.
   - The string literal `"foo"` occurs 8 times, which is more than 4 times.

Since the string literal `"foo"` appears more than 4 times and has a length greater than or equal to 3, the test case violates the rule. Therefore, the number of violations in this test case is 1.
['Get the name of class.', 'Get all annotations declared on class.', 'Get the argument list of each annotation.', 'Check whether the argument is a string literal.', 'Check whether the string literal has a length greater than or equal to 3.', 'Count the occurrences of each string literal.', 'Check whether any string literal occurs more than 4 times.', 'Get the name of class.', 'Get all annotations declared on class.', 'Get the argument list of each annotation.', 'Check whether the argument is a string literal.', 'Check whether the string literal has a length greater than or equal to 3.', 'Count the occurrences of each string literal.', 'Check whether any string literal occurs more than 4 times.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMemberValuePair', 'ASTAnnotationMemberList', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'ASTAnnotation', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all annotations declared on class.* 匹配到的元操作或API：
logic: Get all annotations declared on class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.8879287242889404
*Get the argument list of each annotation.* 匹配到的元操作或API：
query: Get the argument list of each annotation.
most similar API: get member list of annotation
cosine Similarity: 0.8019334077835083
*Check whether the argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9077174663543701
*Check whether the string literal has a length greater than or equal to 3.* 匹配到的元操作或API：
query: Check whether the string literal has a length greater than or equal to 3.
most similar API: Check whether the string literal is long literal
cosine Similarity: 0.842180609703064
*Count the occurrences of each string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs more than 4 times.* 匹配到的元操作或API：
query: Check whether any string literal occurs more than 4 times.
most similar API: Check whether the string literal is double literal
cosine Similarity: 0.8026832938194275
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all annotations declared on class.* 匹配到的元操作或API：
logic: Get all annotations declared on class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.8879287242889404
*Get the argument list of each annotation.* 匹配到的元操作或API：
query: Get the argument list of each annotation.
most similar API: get member list of annotation
cosine Similarity: 0.8019334077835083
*Check whether the argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9077174663543701
*Check whether the string literal has a length greater than or equal to 3.* 匹配到的元操作或API：
query: Check whether the string literal has a length greater than or equal to 3.
most similar API: Check whether the string literal is long literal
cosine Similarity: 0.842180609703064
*Count the occurrences of each string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs more than 4 times.* 匹配到的元操作或API：
query: Check whether any string literal occurs more than 4 times.
most similar API: Check whether the string literal is double literal
cosine Similarity: 0.8026832938194275
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}


This checker is failed(false negative) on this negative test case:
```
// duplicate literals in annotations, default case
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
  ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTAnnotation: public net.sourceforge.pmd.lang.java.ast.ASTAnnotationMemberList getMemberList(), //Returns the list of members, or null if there is none.
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isLongLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral long integer literal}.
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isDoubleLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral double literal}.

1.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class, ASTClassOrInterfaceDeclaration.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        stringLiteralCount.clear();
        for (ASTAnnotation annotation : node.getDeclaredAnnotations()) {
            ASTAnnotationMemberList memberList = annotation.getMemberList();
            if (memberList != null) {
                for (ASTMemberValuePair pair : memberList) {
                    ASTStringLiteral stringLiteral = pair.getFirstChildOfType(ASTStringLiteral.class);
                    if (stringLiteral != null && stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
107
91
117
102
99
82
83
69
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all field declarations in class.
3. Get the type of field.
4. Check whether the field is string type.
5. Check whether the field length is less than 3.
6. Get the literal value that the field is initialized to.
7. Count occurrences of each string literal value in the class.
8. Check whether the string literal value occurs 4 or more times.
9. Check whether the string literal value is assigned to a final field or not.

For the provided test case:

1. Get the name of class: Duplicate
2. Get all field declarations in class: s1, s2, s3, s4, c, c0
3. For field s1:
   - Get the type of field: String
   - Check whether the field is string type: True
   - Check whether the field length is less than 3: False
   - Get the literal value that the field is initialized to: "Tokenizer \ud801\udc1ctest"
4. For field s2:
   - Get the type of field: String
   - Check whether the field is string type: True
   - Check whether the field length is less than 3: False
   - Get the literal value that the field is initialized to: "Tokenizer \ud801\udc1ctest"
5. For field s3:
   - Get the type of field: String
   - Check whether the field is string type: True
   - Check whether the field length is less than 3: False
   - Get the literal value that the field is initialized to: "Tokenizer \ud801\udc1ctest"
6. For field s4:
   - Get the type of field: String
   - Check whether the field is string type: True
   - Check whether the field length is less than 3: False
   - Get the literal value that the field is initialized to: "Tokenizer \ud801\udc1ctest"
7. Count occurrences of each string literal value in the class:
   - "Tokenizer \ud801\udc1ctest" occurs 4 times.
8. Check whether the string literal value occurs 4 or more times: True
9. Check whether the string literal value is assigned to a final field or not: False

Since the string literal "Tokenizer \ud801\udc1ctest" occurs 4 times and it is not assigned to a final field, this test case violates the rule. The number of violating the rule in this test case is: 1.
['Get the name of class.', 'Get all field declarations in class.', 'Get the type of field.', 'Check whether the field is string type.', 'Check whether the field length is less than 3.', 'Get the literal value that the field is initialized to.', 'Count occurrences of each string literal value in the class.', 'Check whether the string literal value occurs 4 or more times.', 'Check whether the string literal value is assigned to a final field or not.', 'Get the name of class: Duplicate', 'Get all field declarations in class: s1, s2, s3, s4, c, c0', 'For field s1:', 'For field s2:', 'For field s3:', 'For field s4:', 'Count occurrences of each string literal value in the class:', 'Check whether the string literal value occurs 4 or more times: True', 'Check whether the string literal value is assigned to a final field or not: False']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTCharLiteral', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTVariableDeclaratorId', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all field declarations in class.* 匹配到的元操作或API：
query: Get all field declarations in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8478881120681763
*Get the type of field.* 匹配到的元操作或API：
logic: Get the type of field.
most similar meta operation: Get the type of field
cosine Similarity: 0.983250081539154
*Check whether the field is string type.* 匹配到的元操作或API：
logic: Check whether the field is string type.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.9883737564086914
*Check whether the field length is less than 3.* 匹配到的元操作或API：
query: Check whether the field length is less than 3.
most similar API: Check whether is array length field access
cosine Similarity: 0.810366153717041
*Get the literal value that the field is initialized to.* 匹配到的元操作或API：
logic: Get the literal value that the field is initialized to.
most similar meta operation: Get the literal value that the field is initialized to
cosine Similarity: 0.9854511022567749
*Count occurrences of each string literal value in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the string literal value occurs 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the string literal value is assigned to a final field or not.* 匹配到的元操作或API：
logic: Check whether the string literal value is assigned to a final field or not.
most similar meta operation: Check whether the field is final
cosine Similarity: 0.8865537047386169
*Get the name of class: Duplicate* 匹配到的元操作或API：
logic: Get the name of class: Duplicate
most similar meta operation: Get the name of class
cosine Similarity: 0.887758731842041
*Get all field declarations in class: s1, s2, s3, s4, c, c0* 匹配到的元操作或API：
未匹配成功元操作或API
*For field s1:* 匹配到的元操作或API：
未匹配成功元操作或API
*For field s2:* 匹配到的元操作或API：
未匹配成功元操作或API
*For field s3:* 匹配到的元操作或API：
未匹配成功元操作或API
*For field s4:* 匹配到的元操作或API：
未匹配成功元操作或API
*Count occurrences of each string literal value in the class:* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the string literal value occurs 4 or more times: True* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the string literal value is assigned to a final field or not: False* 匹配到的元操作或API：
logic: Check whether the string literal value is assigned to a final field or not: False
most similar meta operation: Check whether the field is final
cosine Similarity: 0.8785458207130432
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class, ASTClassOrInterfaceDeclaration.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        stringLiteralCount.clear();
        for (ASTAnnotation annotation : node.getDeclaredAnnotations()) {
            ASTAnnotationMemberList memberList = annotation.getMemberList();
            if (memberList != null) {
                for (ASTMemberValuePair pair : memberList) {
                    ASTStringLiteral stringLiteral = pair.getFirstChildOfType(ASTStringLiteral.class);
                    if (stringLiteral != null && stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
This checker has passed this negative testcase:
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}


This checker is failed(false negative) on this negative test case:
```
// #1425 Invalid XML Characters in Output
public class Duplicate {
    String s1 = "Tokenizer \ud801\udc1ctest";
    String s2 = "Tokenizer \ud801\udc1ctest";
    String s3 = "Tokenizer \ud801\udc1ctest";
    String s4 = "Tokenizer \ud801\udc1ctest";
    char c = '\uffef';
    char c\u0030 = 'a';
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Duplicate')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 's1')
        ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 's2')
        ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 's3')
        ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 's4')
        ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTPrimitiveType (this is a primitive type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'c')
        ——ASTCharLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTPrimitiveType (this is a primitive type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'c0')
        ——ASTCharLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
3. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
4. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isArrayLengthFieldAccess(net.sourceforge.pmd.lang.java.ast.ASTExpression)
5. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isFinal()

1.  //Check whether the field is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFieldStringType(ASTFieldDeclaration node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```
2.  //Get the literal value that the field is initialized to
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTLiteral;
import net.sourceforge.pmd.lang.ast.NodeStream;
public ASTLiteral getInitializedValue(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTLiteral) {
                    return (ASTLiteral)init;
                }
            }
        }
    }
    return null;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class, ASTFieldDeclaration.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        ASTExpression init = node.getFirstChildOfType(ASTVariableDeclaratorId.class).getInitializer();
        if (init != null && init instanceof ASTStringLiteral) {
            ASTStringLiteral stringLiteral = (ASTStringLiteral) init;
            if (stringLiteral.length() >= 3) {
                String value = stringLiteral.getConstValue();
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (stringLiteralCount.get(value) == 4) {
                    addViolation(data, stringLiteral);
                }
            }
        }
        return super.visit(node, data);
    }

    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}, {'error_rules_info': '[ERROR]   "bad 7" failed'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all fields declared in class.
3. Check whether the field is of string type.
4. Get the literal value that the field is initialized to.
5. Check whether the literal value length is less than 3.
6. Count occurrences of each string literal value in the class.
7. Check whether the count of any string literal value is greater than or equal to 4.
8. If the count of any string literal value is greater than or equal to 4 and the string literal length is not less than 3, then the class violates the rule.

Let's apply these checks to the given test case:

1. Get the name of class.
   - The name of the class is `Duplicate`.

2. Get all fields declared in class.
   - The fields are `s1`, `s2`, `s3`, `s4`, `c`, and `c0`.

3. Check whether the field is of string type.
   - `s1`, `s2`, `s3`, and `s4` are of string type.
   - `c` and `c0` are of char type.

4. Get the literal value that the field is initialized to.
   - `s1` is initialized to `"Tokenizer \ud801\udc1ctest"`.
   - `s2` is initialized to `"Tokenizer \ud801\udc1ctest"`.
   - `s3` is initialized to `"Tokenizer \ud801\udc1ctest"`.
   - `s4` is initialized to `"Tokenizer \ud801\udc1ctest"`.
   - `c` is initialized to `'\uffef'`.
   - `c0` is initialized to `'a'`.

5. Check whether the literal value length is less than 3.
   - The length of `"Tokenizer \ud801\udc1ctest"` is greater than 3.
   - The length of `'\uffef'` is less than 3.
   - The length of `'a'` is less than 3.

6. Count occurrences of each string literal value in the class.
   - `"Tokenizer \ud801\udc1ctest"` occurs 4 times.

7. Check whether the count of any string literal value is greater than or equal to 4.
   - The count of `"Tokenizer \ud801\udc1ctest"` is 4.

8. If the count of any string literal value is greater than or equal to 4 and the string literal length is not less than 3, then the class violates the rule.
   - `"Tokenizer \ud801\udc1ctest"` occurs 4 times and its length is greater than 3, so the class violates the rule for this string literal.

The number of violating the rule in this test case is: 1.
['Get the name of class.', 'Get all fields declared in class.', 'Check whether the field is of string type.', 'Get the literal value that the field is initialized to.', 'Check whether the literal value length is less than 3.', 'Count occurrences of each string literal value in the class.', 'Check whether the count of any string literal value is greater than or equal to 4.', 'If the count of any string literal value is greater than or equal to 4 and the string literal length is not less than 3, then the class violates the rule.', 'Get the name of class.', 'Get all fields declared in class.', 'Check whether the field is of string type.', 'Get the literal value that the field is initialized to.', 'Check whether the literal value length is less than 3.', 'Count occurrences of each string literal value in the class.', 'Check whether the count of any string literal value is greater than or equal to 4.', 'If the count of any string literal value is greater than or equal to 4 and the string literal length is not less than 3, then the class violates the rule.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTCharLiteral', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTVariableDeclaratorId', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all fields declared in class.* 匹配到的元操作或API：
query: Get all fields declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8290460109710693
*Check whether the field is of string type.* 匹配到的元操作或API：
logic: Check whether the field is of string type.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.9844943284988403
*Get the literal value that the field is initialized to.* 匹配到的元操作或API：
logic: Get the literal value that the field is initialized to.
most similar meta operation: Get the literal value that the field is initialized to
cosine Similarity: 0.9854511022567749
*Check whether the literal value length is less than 3.* 匹配到的元操作或API：
未匹配成功元操作或API
*Count occurrences of each string literal value in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of any string literal value is greater than or equal to 4.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the count of any string literal value is greater than or equal to 4 and the string literal length is not less than 3, then the class violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all fields declared in class.* 匹配到的元操作或API：
query: Get all fields declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8290460109710693
*Check whether the field is of string type.* 匹配到的元操作或API：
logic: Check whether the field is of string type.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.9844943284988403
*Get the literal value that the field is initialized to.* 匹配到的元操作或API：
logic: Get the literal value that the field is initialized to.
most similar meta operation: Get the literal value that the field is initialized to
cosine Similarity: 0.9854511022567749
*Check whether the literal value length is less than 3.* 匹配到的元操作或API：
未匹配成功元操作或API
*Count occurrences of each string literal value in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of any string literal value is greater than or equal to 4.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the count of any string literal value is greater than or equal to 4 and the string literal length is not less than 3, then the class violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class, ASTClassOrInterfaceDeclaration.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        stringLiteralCount.clear();
        for (ASTAnnotation annotation : node.getDeclaredAnnotations()) {
            ASTAnnotationMemberList memberList = annotation.getMemberList();
            if (memberList != null) {
                for (ASTMemberValuePair pair : memberList) {
                    ASTStringLiteral stringLiteral = pair.getFirstChildOfType(ASTStringLiteral.class);
                    if (stringLiteral != null && stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
This checker has passed this negative testcase:
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}


This checker is failed(false negative) on this negative test case:
```
// #1425 Invalid XML Characters in Output
public class Duplicate {
    String s1 = "Tokenizer \ud801\udc1ctest";
    String s2 = "Tokenizer \ud801\udc1ctest";
    String s3 = "Tokenizer \ud801\udc1ctest";
    String s4 = "Tokenizer \ud801\udc1ctest";
    char c = '\uffef';
    char c\u0030 = 'a';
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Duplicate')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 's1')
        ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 's2')
        ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 's3')
        ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 's4')
        ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTPrimitiveType (this is a primitive type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'c')
        ——ASTCharLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTPrimitiveType (this is a primitive type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'c0')
        ——ASTCharLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)

1.  //Check whether the field is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFieldStringType(ASTFieldDeclaration node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```
2.  //Get the literal value that the field is initialized to
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTLiteral;
import net.sourceforge.pmd.lang.ast.NodeStream;
public ASTLiteral getInitializedValue(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTLiteral) {
                    return (ASTLiteral)init;
                }
            }
        }
    }
    return null;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class, ASTClassOrInterfaceDeclaration.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        stringLiteralCount.clear();
        for (ASTAnnotation annotation : node.getDeclaredAnnotations()) {
            ASTAnnotationMemberList memberList = annotation.getMemberList();
            if (memberList != null) {
                for (ASTMemberValuePair pair : memberList) {
                    ASTStringLiteral stringLiteral = pair.getFirstChildOfType(ASTStringLiteral.class);
                    if (stringLiteral != null && stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (TypeTestUtil.isA(String.class, node.getTypeNode())) {
            NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
            for (ASTVariableDeclaratorId varId : varIds) {
                ASTExpression init = varId.getInitializer();
                if (init != null && init instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) init;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all fields declared in class.
3. Check whether the field is of type String.
4. Get the literal value that the field is initialized to.
5. Get the length of string literal.
6. Check whether the length of string literal is greater than or equal to 3.
7. Count the occurrences of each string literal in the class.
8. Check whether the count of any string literal is greater than or equal to 4.

Based on your test case:
1. Get the name of class: Foo
2. Get all fields declared in class: s1, s2, s3, s4, c, c0
3. Check whether the field is of type String: s1, s2, s3, s4 are String fields.
4. Get the literal value that the field is initialized to: "Tokenizer \ud801\udc1ctest"
5. Get the length of string literal: Length of "Tokenizer \ud801\udc1ctest" is 18.
6. Check whether the length of string literal is greater than or equal to 3: True, since 18 >= 3.
7. Count the occurrences of each string literal in the class: "Tokenizer \ud801\udc1ctest" occurs 4 times.
8. Check whether the count of any string literal is greater than or equal to 4: True, since "Tokenizer \ud801\udc1ctest" occurs 4 times.

This test case violates the rule once.
['Get the name of class.', 'Get all fields declared in class.', 'Check whether the field is of type String.', 'Get the literal value that the field is initialized to.', 'Get the length of string literal.', 'Check whether the length of string literal is greater than or equal to 3.', 'Count the occurrences of each string literal in the class.', 'Check whether the count of any string literal is greater than or equal to 4.', 'Get the name of class: Foo', 'Get all fields declared in class: s1, s2, s3, s4, c, c0', 'Check whether the field is of type String: s1, s2, s3, s4 are String fields.', 'Get the literal value that the field is initialized to: "Tokenizer \\ud801\\udc1ctest"', 'Get the length of string literal: Length of "Tokenizer \\ud801\\udc1ctest" is 18.', 'Check whether the length of string literal is greater than or equal to 3: True, since 18 >= 3.', 'Count the occurrences of each string literal in the class: "Tokenizer \\ud801\\udc1ctest" occurs 4 times.', 'Check whether the count of any string literal is greater than or equal to 4: True, since "Tokenizer \\ud801\\udc1ctest" occurs 4 times.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTCharLiteral', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTVariableDeclaratorId', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all fields declared in class.* 匹配到的元操作或API：
query: Get all fields declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8290460109710693
*Check whether the field is of type String.* 匹配到的元操作或API：
logic: Check whether the field is of type String.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.9757716655731201
*Get the literal value that the field is initialized to.* 匹配到的元操作或API：
logic: Get the literal value that the field is initialized to.
most similar meta operation: Get the literal value that the field is initialized to
cosine Similarity: 0.9854511022567749
*Get the length of string literal.* 匹配到的元操作或API：
logic: Get the length of string literal.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.987589955329895
*Check whether the length of string literal is greater than or equal to 3.* 匹配到的元操作或API：
query: Check whether the length of string literal is greater than or equal to 3.
most similar API: Check whether the string literal is long literal
cosine Similarity: 0.8297568559646606
*Count the occurrences of each string literal in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of any string literal is greater than or equal to 4.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: Foo* 匹配到的元操作或API：
logic: Get the name of class: Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9263079166412354
*Get all fields declared in class: s1, s2, s3, s4, c, c0* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the field is of type String: s1, s2, s3, s4 are String fields.* 匹配到的元操作或API：
logic: Check whether the field is of type String: s1, s2, s3, s4 are String fields.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.9027078747749329
*Get the literal value that the field is initialized to: "Tokenizer \ud801\udc1ctest"* 匹配到的元操作或API：
logic: Get the literal value that the field is initialized to: "Tokenizer \ud801\udc1ctest"
most similar meta operation: Get the literal value that the field is initialized to
cosine Similarity: 0.8995764255523682
*Get the length of string literal: Length of "Tokenizer \ud801\udc1ctest" is 18.* 匹配到的元操作或API：
logic: Get the length of string literal: Length of "Tokenizer \ud801\udc1ctest" is 18.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.8707916736602783
*Check whether the length of string literal is greater than or equal to 3: True, since 18 >= 3.* 匹配到的元操作或API：
未匹配成功元操作或API
*Count the occurrences of each string literal in the class: "Tokenizer \ud801\udc1ctest" occurs 4 times.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of any string literal is greater than or equal to 4: True, since "Tokenizer \ud801\udc1ctest" occurs 4 times.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class, ASTClassOrInterfaceDeclaration.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        stringLiteralCount.clear();
        for (ASTAnnotation annotation : node.getDeclaredAnnotations()) {
            ASTAnnotationMemberList memberList = annotation.getMemberList();
            if (memberList != null) {
                for (ASTMemberValuePair pair : memberList) {
                    ASTStringLiteral stringLiteral = pair.getFirstChildOfType(ASTStringLiteral.class);
                    if (stringLiteral != null && stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
This checker has passed this negative testcase:
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}


This checker is failed(false negative) on this negative test case:
```
// #1425 Invalid XML Characters in Output
public class Duplicate {
    String s1 = "Tokenizer \ud801\udc1ctest";
    String s2 = "Tokenizer \ud801\udc1ctest";
    String s3 = "Tokenizer \ud801\udc1ctest";
    String s4 = "Tokenizer \ud801\udc1ctest";
    char c = '\uffef';
    char c\u0030 = 'a';
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Duplicate')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 's1')
        ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 's2')
        ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 's3')
        ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 's4')
        ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTPrimitiveType (this is a primitive type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'c')
        ——ASTCharLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTPrimitiveType (this is a primitive type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'c0')
        ——ASTCharLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length()
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isLongLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral long integer literal}.

1.  //Check whether the field is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFieldStringType(ASTFieldDeclaration node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```
2.  //Get the literal value that the field is initialized to
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTLiteral;
import net.sourceforge.pmd.lang.ast.NodeStream;
public ASTLiteral getInitializedValue(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTLiteral) {
                    return (ASTLiteral)init;
                }
            }
        }
    }
    return null;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class, ASTClassOrInterfaceDeclaration.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        stringLiteralCount.clear();
        for (ASTAnnotation annotation : node.getDeclaredAnnotations()) {
            ASTAnnotationMemberList memberList = annotation.getMemberList();
            if (memberList != null) {
                for (ASTMemberValuePair pair : memberList) {
                    ASTStringLiteral stringLiteral = pair.getFirstChildOfType(ASTStringLiteral.class);
                    if (stringLiteral != null && stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        visitFieldDeclarations(node.getChildren(ASTFieldDeclaration.class), data);
        return super.visit(node, data);
    }

    private void visitFieldDeclarations(NodeStream<ASTFieldDeclaration> fieldDeclarations, Object data) {
        for (ASTFieldDeclaration fieldDeclaration : fieldDeclarations) {
            if (isFieldStringType(fieldDeclaration)) {
                ASTLiteral literal = getInitializedValue(fieldDeclaration);
                if (literal instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) literal;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
    }

    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTLiteral) {
                    return (ASTLiteral) init;
                }
            }
        }
        return null;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get all string literals in class.
2. Get the length of the first string literal.
3. Check whether the length of the first string literal is less than 3.
4. If the length is not less than 3, count occurrences of the first string literal.
5. Repeat steps 2-4 for all string literals in the class.
6. Check whether any string literal occurs 4 or more times and its length is not less than 3.

In this case:
1. Get all string literals in class: "Tokenizer \ud801\udc1ctest"
2. Get the length of the first string literal: 20
3. Check whether the length of the first string literal is less than 3: False
4. Count occurrences of the first string literal: 4
5. Since there is a string literal that occurs 4 times and its length is not less than 3, the number of violations is 1.
['Get all string literals in class.', 'Get the length of the first string literal.', 'Check whether the length of the first string literal is less than 3.', 'If the length is not less than 3, count occurrences of the first string literal.', 'Repeat steps 2-4 for all string literals in the class.', 'Check whether any string literal occurs 4 or more times and its length is not less than 3.', 'Get all string literals in class: "Tokenizer \\ud801\\udc1ctest"', 'Get the length of the first string literal: 20', 'Check whether the length of the first string literal is less than 3: False', 'Count occurrences of the first string literal: 4', 'Since there is a string literal that occurs 4 times and its length is not less than 3, the number of violations is 1.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTCharLiteral', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTVariableDeclaratorId', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get all string literals in class.* 匹配到的元操作或API：
query: Get all string literals in class.
most similar API: get class of string literal
cosine Similarity: 0.8552724719047546
*Get the length of the first string literal.* 匹配到的元操作或API：
logic: Get the length of the first string literal.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.9455630779266357
*Check whether the length of the first string literal is less than 3.* 匹配到的元操作或API：
query: Check whether the length of the first string literal is less than 3.
most similar API: Check whether the string literal is long literal
cosine Similarity: 0.8101882934570312
*If the length is not less than 3, count occurrences of the first string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 2-4 for all string literals in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs 4 or more times and its length is not less than 3.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all string literals in class: "Tokenizer \ud801\udc1ctest"* 匹配到的元操作或API：
query: Get all string literals in class: "Tokenizer \ud801\udc1ctest"
most similar API: get class of string literal
cosine Similarity: 0.8042299747467041
*Get the length of the first string literal: 20* 匹配到的元操作或API：
logic: Get the length of the first string literal: 20
most similar meta operation: Get the length of string literal
cosine Similarity: 0.9261482954025269
*Check whether the length of the first string literal is less than 3: False* 匹配到的元操作或API：
query: Check whether the length of the first string literal is less than 3: False
most similar API: Check whether the string literal is long literal
cosine Similarity: 0.8176988363265991
*Count occurrences of the first string literal: 4* 匹配到的元操作或API：
未匹配成功元操作或API
*Since there is a string literal that occurs 4 times and its length is not less than 3, the number of violations is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class, ASTClassOrInterfaceDeclaration.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        stringLiteralCount.clear();
        for (ASTAnnotation annotation : node.getDeclaredAnnotations()) {
            ASTAnnotationMemberList memberList = annotation.getMemberList();
            if (memberList != null) {
                for (ASTMemberValuePair pair : memberList) {
                    ASTStringLiteral stringLiteral = pair.getFirstChildOfType(ASTStringLiteral.class);
                    if (stringLiteral != null && stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
This checker has passed this negative testcase:
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}


This checker is failed(false negative) on this negative test case:
```
// #1425 Invalid XML Characters in Output
public class Duplicate {
    String s1 = "Tokenizer \ud801\udc1ctest";
    String s2 = "Tokenizer \ud801\udc1ctest";
    String s3 = "Tokenizer \ud801\udc1ctest";
    String s4 = "Tokenizer \ud801\udc1ctest";
    char c = '\uffef';
    char c\u0030 = 'a';
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Duplicate')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 's1')
        ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 's2')
        ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 's3')
        ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 's4')
        ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTPrimitiveType (this is a primitive type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'c')
        ——ASTCharLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTPrimitiveType (this is a primitive type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'c0')
        ——ASTCharLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.Class<Class<?> getClass()
2. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length()
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isLongLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral long integer literal}.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class, ASTClassOrInterfaceDeclaration.class, ASTFieldDeclaration.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        stringLiteralCount.clear();
        for (ASTAnnotation annotation : node.getDeclaredAnnotations()) {
            ASTAnnotationMemberList memberList = annotation.getMemberList();
            if (memberList != null) {
                for (ASTMemberValuePair pair : memberList) {
                    ASTStringLiteral stringLiteral = pair.getFirstChildOfType(ASTStringLiteral.class);
                    if (stringLiteral != null && stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        for (ASTVariableDeclarator varDec : node.getVariableDeclarators()) {
            ASTExpression expr = varDec.getInitializer();
            if (expr instanceof ASTStringLiteral) {
                ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                if (stringLiteral.length() >= 3) {
                    String value = stringLiteral.getConstValue();
                    stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                    if (stringLiteralCount.get(value) == 4) {
                        addViolation(data, stringLiteral);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all fields declared in class.
3. Check whether the field is a String type.
4. Check whether the field is a literal value.
5. Check whether the literal value has a length of 3 or more.
6. Count the occurrences of each String literal in the class.
7. Check whether the count of any String literal is 4 or more.

Let's go through the checks:

1. Get the name of class.
        - The name of the class is `Duplicate`.

2. Get all fields declared in class.
        - The fields are `s1`, `s2`, `s3`, `s4`, `c`, and `c0`.

3. Check whether the field is a String type.
        - `s1`, `s2`, `s3`, and `s4` are String types.
        - `c` and `c0` are char types.

4. Check whether the field is a literal value.
        - `s1`, `s2`, `s3`, and `s4` are initialized with the literal value `"Tokenizer \ud801\udc1ctest"`.
        - `c` and `c0` are initialized with the literal values `'\uffef'` and `'a'`, respectively.

5. Check whether the literal value has a length of 3 or more.
        - The literal value `"Tokenizer \ud801\udc1ctest"` has a length of more than 3.
        - The literal values `'\uffef'` and `'a'` are characters and have a length of 1, so they are ignored.

6. Count the occurrences of each String literal in the class.
        - The literal value `"Tokenizer \ud801\udc1ctest"` appears 4 times.

7. Check whether the count of any String literal is 4 or more.
        - The count of the literal value `"Tokenizer \ud801\udc1ctest"` is 4, which meets or exceeds the threshold.

Since the literal value `"Tokenizer \ud801\udc1ctest"` appears 4 times and is of length 3 or more, the test case violates the rule.
['Get the name of class.', 'Get all fields declared in class.', 'Check whether the field is a String type.', 'Check whether the field is a literal value.', 'Check whether the literal value has a length of 3 or more.', 'Count the occurrences of each String literal in the class.', 'Check whether the count of any String literal is 4 or more.', 'Get the name of class.', 'Get all fields declared in class.', 'Check whether the field is a String type.', 'Check whether the field is a literal value.', 'Check whether the literal value has a length of 3 or more.', 'Count the occurrences of each String literal in the class.', 'Check whether the count of any String literal is 4 or more.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTCompilationUnit', 'ASTCharLiteral', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTVariableDeclaratorId', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all fields declared in class.* 匹配到的元操作或API：
query: Get all fields declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8290460109710693
*Check whether the field is a String type.* 匹配到的元操作或API：
logic: Check whether the field is a String type.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.9841240644454956
*Check whether the field is a literal value.* 匹配到的元操作或API：
query: Check whether the field is a literal value.
most similar API: Check whether the field is syntactically abstract
cosine Similarity: 0.8458528518676758
*Check whether the literal value has a length of 3 or more.* 匹配到的元操作或API：
query: Check whether the literal value has a length of 3 or more.
most similar API: Check whether the string literal is long literal
cosine Similarity: 0.8014366030693054
*Count the occurrences of each String literal in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of any String literal is 4 or more.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all fields declared in class.* 匹配到的元操作或API：
query: Get all fields declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8290460109710693
*Check whether the field is a String type.* 匹配到的元操作或API：
logic: Check whether the field is a String type.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.9841240644454956
*Check whether the field is a literal value.* 匹配到的元操作或API：
query: Check whether the field is a literal value.
most similar API: Check whether the field is syntactically abstract
cosine Similarity: 0.8458528518676758
*Check whether the literal value has a length of 3 or more.* 匹配到的元操作或API：
query: Check whether the literal value has a length of 3 or more.
most similar API: Check whether the string literal is long literal
cosine Similarity: 0.8014366030693054
*Count the occurrences of each String literal in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of any String literal is 4 or more.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class, ASTClassOrInterfaceDeclaration.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        stringLiteralCount.clear();
        for (ASTAnnotation annotation : node.getDeclaredAnnotations()) {
            ASTAnnotationMemberList memberList = annotation.getMemberList();
            if (memberList != null) {
                for (ASTMemberValuePair pair : memberList) {
                    ASTStringLiteral stringLiteral = pair.getFirstChildOfType(ASTStringLiteral.class);
                    if (stringLiteral != null && stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
This checker has passed this negative testcase:
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}


This checker is failed(false negative) on this negative test case:
```
// #1425 Invalid XML Characters in Output
public class Duplicate {
    String s1 = "Tokenizer \ud801\udc1ctest";
    String s2 = "Tokenizer \ud801\udc1ctest";
    String s3 = "Tokenizer \ud801\udc1ctest";
    String s4 = "Tokenizer \ud801\udc1ctest";
    char c = '\uffef';
    char c\u0030 = 'a';
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Duplicate')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 's1')
        ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 's2')
        ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 's3')
        ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 's4')
        ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTPrimitiveType (this is a primitive type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'c')
        ——ASTCharLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTPrimitiveType (this is a primitive type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'c0')
        ——ASTCharLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
3. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isSyntacticallyAbstract()
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isLongLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral long integer literal}.

1.  //Check whether the field is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFieldStringType(ASTFieldDeclaration node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class, ASTClassOrInterfaceDeclaration.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        stringLiteralCount.clear();
        for (ASTAnnotation annotation : node.getDeclaredAnnotations()) {
            ASTAnnotationMemberList memberList = annotation.getMemberList();
            if (memberList != null) {
                for (ASTMemberValuePair pair : memberList) {
                    ASTStringLiteral stringLiteral = pair.getFirstChildOfType(ASTStringLiteral.class);
                    if (stringLiteral != null && stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            ASTVariableDeclarator varDeclarator = node.getFirstChildOfType(ASTVariableDeclarator.class);
            if (varDeclarator != null) {
                ASTExpression expr = varDeclarator.getInitializer();
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 7
[ERROR]   "bad 8" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
81
67
96
80
99
82
=========================error_testcase_logics=========================
1. Get the javadoc comment of class.
        2. Get all annotations declared in class.
        3. For each annotation, get all arguments in annotation.
        4. For each argument, check whether it is a string literal.
        5. If the argument is a string literal, get the value of the string literal.
        6. Check whether the length of the string literal is less than 3.
        7. If the length is not less than 3, count the occurrences of the string literal.
        8. Repeat steps 2-7 for all methods in the class.
        9. For each method, get all annotations declared in method.
        10. For each annotation, get all arguments in annotation.
        11. For each argument, check whether it is a string literal.
        12. If the argument is a string literal, get the value of the string literal.
        13. Check whether the length of the string literal is less than 3.
        14. If the length is not less than 3, count the occurrences of the string literal.
        15. Check if any string literal occurs 4 or more times.
        16. Repeat steps 9-15 for all constructors in the class.
        17. For each constructor, get all annotations declared in constructor.
        18. For each annotation, get all arguments in annotation.
        19. For each argument, check whether it is a string literal.
        20. If the argument is a string literal, get the value of the string literal.
        21. Check whether the length of the string literal is less than 3.
        22. If the length is not less than 3, count the occurrences of the string literal.
        23. Check if any string literal occurs 4 or more times.
        24. Repeat steps 1-23 for all fields in the class.
        25. Check whether the field is a string literal.
        26. If the field is a string literal, get the value of the string literal.
        27. Check whether the length of the string literal is less than 3.
        28. If the length is not less than 3, count the occurrences of the string literal.
        29. Check if any string literal occurs 4 or more times.
        30. Repeat steps 1-29 for all method body statements in the class.
        31. For each method body statement, check whether it is an assignment expression.
        32. If it is an assignment expression, get the right-hand side operand.
        33. Check whether the right-hand side operand is a string literal.
        34. If it is a string literal, get the value of the string literal.
        35. Check whether the length of the string literal is less than 3.
        36. If the length is not less than 3, count the occurrences of the string literal.
        37. Check if any string literal occurs 4 or more times.
        38. Repeat steps 1-37 for all constructor body statements in the class.
        39. For each constructor body statement, check whether it is an assignment expression.
        40. If it is an assignment expression, get the right-hand side operand.
        41. Check whether the right-hand side operand is a string literal.
        42. If it is a string literal, get the value of the string literal.
        43. Check whether the length of the string literal is less than 3.
        44. If the length is not less than 3, count the occurrences of the string literal.
        45. Check if any string literal occurs 4 or more times.
        If a string literal occurs 4 or more times and its length is not less than 3, then this test case violates the rule. In this particular test case, we need to focus on annotations:

39. Get all annotations declared in class.
40. For each annotation, get all arguments in annotation.
41. For each argument, check whether it is a string literal.
42. If the argument is a string literal, get the value of the string literal.
43. Check whether the length of the string literal is less than 3.
44. If the length is not less than 3, count the occurrences of the string literal.

For the given test case, the string literal "unused" is used 4 times in method `foo` as an argument to the `@SuppressWarnings` annotation. Since the length of "unused" is not less than 3, it violates the rule.

So, the number of violations in this test case is: 1
['Get the javadoc comment of class.', 'Get all annotations declared in class.', 'For each annotation, get all arguments in annotation.', 'For each argument, check whether it is a string literal.', 'If the argument is a string literal, get the value of the string literal.', 'Check whether the length of the string literal is less than 3.', 'If the length is not less than 3, count the occurrences of the string literal.', 'Repeat steps 2-7 for all methods in the class.', 'For each method, get all annotations declared in method.', 'For each annotation, get all arguments in annotation.', 'For each argument, check whether it is a string literal.', 'If the argument is a string literal, get the value of the string literal.', 'Check whether the length of the string literal is less than 3.', 'If the length is not less than 3, count the occurrences of the string literal.', 'Check if any string literal occurs 4 or more times.', 'Repeat steps 9-15 for all constructors in the class.', 'For each constructor, get all annotations declared in constructor.', 'For each annotation, get all arguments in annotation.', 'For each argument, check whether it is a string literal.', 'If the argument is a string literal, get the value of the string literal.', 'Check whether the length of the string literal is less than 3.', 'If the length is not less than 3, count the occurrences of the string literal.', 'Check if any string literal occurs 4 or more times.', 'Repeat steps 1-23 for all fields in the class.', 'Check whether the field is a string literal.', 'If the field is a string literal, get the value of the string literal.', 'Check whether the length of the string literal is less than 3.', 'If the length is not less than 3, count the occurrences of the string literal.', 'Check if any string literal occurs 4 or more times.', 'Repeat steps 1-29 for all method body statements in the class.', 'For each method body statement, check whether it is an assignment expression.', 'If it is an assignment expression, get the right-hand side operand.', 'Check whether the right-hand side operand is a string literal.', 'If it is a string literal, get the value of the string literal.', 'Check whether the length of the string literal is less than 3.', 'If the length is not less than 3, count the occurrences of the string literal.', 'Check if any string literal occurs 4 or more times.', 'Repeat steps 1-37 for all constructor body statements in the class.', 'For each constructor body statement, check whether it is an assignment expression.', 'If it is an assignment expression, get the right-hand side operand.', 'Check whether the right-hand side operand is a string literal.', 'If it is a string literal, get the value of the string literal.', 'Check whether the length of the string literal is less than 3.', 'If the length is not less than 3, count the occurrences of the string literal.', 'Check if any string literal occurs 4 or more times.', 'Get all annotations declared in class.', 'For each annotation, get all arguments in annotation.', 'For each argument, check whether it is a string literal.', 'If the argument is a string literal, get the value of the string literal.', 'Check whether the length of the string literal is less than 3.', 'If the length is not less than 3, count the occurrences of the string literal.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMemberValuePair', 'ASTAnnotationMemberList', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'ASTAnnotation', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Get all annotations declared in class.* 匹配到的元操作或API：
logic: Get all annotations declared in class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.8872416615486145
*For each annotation, get all arguments in annotation.* 匹配到的元操作或API：
query: For each annotation, get all arguments in annotation.
most similar API: for each of annotation
cosine Similarity: 0.8199477195739746
*For each argument, check whether it is a string literal.* 匹配到的元操作或API：
logic: For each argument, check whether it is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8704664707183838
*If the argument is a string literal, get the value of the string literal.* 匹配到的元操作或API：
logic: If the argument is a string literal, get the value of the string literal.
most similar meta operation: Get the value of string literal
cosine Similarity: 0.9168165326118469
*Check whether the length of the string literal is less than 3.* 匹配到的元操作或API：
query: Check whether the length of the string literal is less than 3.
most similar API: length of string literal
cosine Similarity: 0.8179245591163635
*If the length is not less than 3, count the occurrences of the string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 2-7 for all methods in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each method, get all annotations declared in method.* 匹配到的元操作或API：
logic: For each method, get all annotations declared in method.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.8675566911697388
*For each annotation, get all arguments in annotation.* 匹配到的元操作或API：
query: For each annotation, get all arguments in annotation.
most similar API: for each of annotation
cosine Similarity: 0.8199477195739746
*For each argument, check whether it is a string literal.* 匹配到的元操作或API：
logic: For each argument, check whether it is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8704664707183838
*If the argument is a string literal, get the value of the string literal.* 匹配到的元操作或API：
logic: If the argument is a string literal, get the value of the string literal.
most similar meta operation: Get the value of string literal
cosine Similarity: 0.9168165326118469
*Check whether the length of the string literal is less than 3.* 匹配到的元操作或API：
query: Check whether the length of the string literal is less than 3.
most similar API: length of string literal
cosine Similarity: 0.8179245591163635
*If the length is not less than 3, count the occurrences of the string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check if any string literal occurs 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 9-15 for all constructors in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each constructor, get all annotations declared in constructor.* 匹配到的元操作或API：
logic: For each constructor, get all annotations declared in constructor.
most similar meta operation: Get a declared annotation of constructor
cosine Similarity: 0.8845046162605286
*For each annotation, get all arguments in annotation.* 匹配到的元操作或API：
query: For each annotation, get all arguments in annotation.
most similar API: for each of annotation
cosine Similarity: 0.8199477195739746
*For each argument, check whether it is a string literal.* 匹配到的元操作或API：
logic: For each argument, check whether it is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8704664707183838
*If the argument is a string literal, get the value of the string literal.* 匹配到的元操作或API：
logic: If the argument is a string literal, get the value of the string literal.
most similar meta operation: Get the value of string literal
cosine Similarity: 0.9168165326118469
*Check whether the length of the string literal is less than 3.* 匹配到的元操作或API：
query: Check whether the length of the string literal is less than 3.
most similar API: length of string literal
cosine Similarity: 0.8179245591163635
*If the length is not less than 3, count the occurrences of the string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check if any string literal occurs 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 1-23 for all fields in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the field is a string literal.* 匹配到的元操作或API：
logic: Check whether the field is a string literal.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.9028791189193726
*If the field is a string literal, get the value of the string literal.* 匹配到的元操作或API：
logic: If the field is a string literal, get the value of the string literal.
most similar meta operation: Get the value of string literal
cosine Similarity: 0.8934606313705444
*Check whether the length of the string literal is less than 3.* 匹配到的元操作或API：
query: Check whether the length of the string literal is less than 3.
most similar API: length of string literal
cosine Similarity: 0.8179245591163635
*If the length is not less than 3, count the occurrences of the string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check if any string literal occurs 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 1-29 for all method body statements in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each method body statement, check whether it is an assignment expression.* 匹配到的元操作或API：
未匹配成功元操作或API
*If it is an assignment expression, get the right-hand side operand.* 匹配到的元操作或API：
logic: If it is an assignment expression, get the right-hand side operand.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.9123324155807495
*Check whether the right-hand side operand is a string literal.* 匹配到的元操作或API：
query: Check whether the right-hand side operand is a string literal.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8810165524482727
*If it is a string literal, get the value of the string literal.* 匹配到的元操作或API：
logic: If it is a string literal, get the value of the string literal.
most similar meta operation: Get the value of string literal
cosine Similarity: 0.9492106437683105
*Check whether the length of the string literal is less than 3.* 匹配到的元操作或API：
query: Check whether the length of the string literal is less than 3.
most similar API: length of string literal
cosine Similarity: 0.8179245591163635
*If the length is not less than 3, count the occurrences of the string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check if any string literal occurs 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 1-37 for all constructor body statements in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each constructor body statement, check whether it is an assignment expression.* 匹配到的元操作或API：
未匹配成功元操作或API
*If it is an assignment expression, get the right-hand side operand.* 匹配到的元操作或API：
logic: If it is an assignment expression, get the right-hand side operand.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.9123324155807495
*Check whether the right-hand side operand is a string literal.* 匹配到的元操作或API：
query: Check whether the right-hand side operand is a string literal.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8810165524482727
*If it is a string literal, get the value of the string literal.* 匹配到的元操作或API：
logic: If it is a string literal, get the value of the string literal.
most similar meta operation: Get the value of string literal
cosine Similarity: 0.9492106437683105
*Check whether the length of the string literal is less than 3.* 匹配到的元操作或API：
query: Check whether the length of the string literal is less than 3.
most similar API: length of string literal
cosine Similarity: 0.8179245591163635
*If the length is not less than 3, count the occurrences of the string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check if any string literal occurs 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all annotations declared in class.* 匹配到的元操作或API：
logic: Get all annotations declared in class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.8872416615486145
*For each annotation, get all arguments in annotation.* 匹配到的元操作或API：
query: For each annotation, get all arguments in annotation.
most similar API: for each of annotation
cosine Similarity: 0.8199477195739746
*For each argument, check whether it is a string literal.* 匹配到的元操作或API：
logic: For each argument, check whether it is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8704664707183838
*If the argument is a string literal, get the value of the string literal.* 匹配到的元操作或API：
logic: If the argument is a string literal, get the value of the string literal.
most similar meta operation: Get the value of string literal
cosine Similarity: 0.9168165326118469
*Check whether the length of the string literal is less than 3.* 匹配到的元操作或API：
query: Check whether the length of the string literal is less than 3.
most similar API: length of string literal
cosine Similarity: 0.8179245591163635
*If the length is not less than 3, count the occurrences of the string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class, ASTClassOrInterfaceDeclaration.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        stringLiteralCount.clear();
        for (ASTAnnotation annotation : node.getDeclaredAnnotations()) {
            ASTAnnotationMemberList memberList = annotation.getMemberList();
            if (memberList != null) {
                for (ASTMemberValuePair pair : memberList) {
                    ASTStringLiteral stringLiteral = pair.getFirstChildOfType(ASTStringLiteral.class);
                    if (stringLiteral != null && stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
This checker has passed this negative testcase:
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}


This checker is failed(false negative) on this negative test case:
```
// Duplicated string literals as annotation parameter
public class AnnotationParams {
    public static void foo(@SuppressWarnings("unused") Object str,
                           @SuppressWarnings("unused") String str2,
                           @SuppressWarnings("unused") String str3,
                           @SuppressWarnings("unused") String str4) {}
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'AnnotationParams')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 4)
        ——ASTFormalParameter
          ——ASTModifierList
            ——ASTAnnotation
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTAnnotationMemberList
                ——ASTMemberValuePair
                  ——ASTStringLiteral
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
        ——ASTFormalParameter
          ——ASTModifierList
            ——ASTAnnotation
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTAnnotationMemberList
                ——ASTMemberValuePair
                  ——ASTStringLiteral
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str2')
        ——ASTFormalParameter
          ——ASTModifierList
            ——ASTAnnotation
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTAnnotationMemberList
                ——ASTMemberValuePair
                  ——ASTStringLiteral
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str3')
        ——ASTFormalParameter
          ——ASTModifierList
            ——ASTAnnotation
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTAnnotationMemberList
                ——ASTMemberValuePair
                  ——ASTStringLiteral
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str4')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTAnnotation: public void forEach(java.util.function.Consumer)
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.String getConstValue()
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length(), //Length of the constant value in characters.
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
8. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
9. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.

1.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
2.  //Check whether the field is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFieldStringType(ASTFieldDeclaration node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class, ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        stringLiteralCount.clear();
        for (ASTAnnotation annotation : node.getDeclaredAnnotations()) {
            processAnnotation(annotation);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        for (ASTAnnotation annotation : node.getDeclaredAnnotations()) {
            processAnnotation(annotation);
        }
        return super.visit(node, data);
    }

    private void processAnnotation(ASTAnnotation annotation) {
        ASTAnnotationMemberList memberList = annotation.getMemberList();
        if (memberList != null) {
            for (ASTMemberValuePair pair : memberList) {
                ASTStringLiteral stringLiteral = pair.getFirstChildOfType(ASTStringLiteral.class);
                if (stringLiteral != null && stringLiteral.length() >= 3) {
                    String value = stringLiteral.getConstValue();
                    stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                    if (stringLiteralCount.get(value) == 4) {
                        addViolation(data, stringLiteral);
                    }
                }
            }
        }
    }

    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all methods declared in class.
3. Get the method signature of the method.
4. Get all annotations declared in method signature.
5. For each annotation, get all parameters.
6. For each parameter in annotations, check whether it is a string literal.
7. Check whether the string literal length is greater than or equal to 3.
8. Count the occurrences of each string literal among all method parameters.
9. Check whether the count of any string literal is greater than or equal to 4.

In this specific test case:

1. Get the name of class: AnnotationParams
2. Get all methods declared in class: foo
3. Get the method signature of the method: foo(Object, String, String, String)
4. Get all annotations declared in method signature: @SuppressWarnings("unused")
5. For each annotation, get all parameters: unused, unused, unused, unused
6. For each parameter in annotations, check whether it is a string literal: false, true, true, true (the parameters are string literals, but "unused" is not the same as "a", "str2", "str3", "str4")
7. Check whether the string literal length is greater than or equal to 3: true, true, true, true
8. Count the occurrences of each string literal among all method parameters: unused=4, a=0, str2=0, str3=0, str4=0

Since the string literal "unused" is repeated 4 times in the method parameters, but it is the annotation parameter value and not the actual string literals in the code, we need to clarify the rule checking process. The rule specifically targets duplicate string literals in the code, not in annotations or other contexts.

Given the test case, let's recheck focusing only on string literals in the code:

1. Get the name of class: AnnotationParams
2. Get all methods declared in class: foo
3. Get the method signature of the method: foo(Object, String, String, String)
4. Get all annotations declared in method signature: @SuppressWarnings("unused")
5. For each parameter in the method signature, check whether it is a string literal: false, false, false, false (parameters are not string literals)
6. Check whether the method body contains any string literals: false (method body is empty)

Since there are no string literals in the method body or in the parameters that are not annotation parameters, the test case does not violate the rule as per the given description.

However, if the rule is intended to also check annotation parameters, then we need to adjust the rule checking process. But based on the provided description, duplicate string literals in annotations are not considered.

So, the number of violating the rule in this test case is: 0
['Get the name of class.', 'Get all methods declared in class.', 'Get the method signature of the method.', 'Get all annotations declared in method signature.', 'For each annotation, get all parameters.', 'For each parameter in annotations, check whether it is a string literal.', 'Check whether the string literal length is greater than or equal to 3.', 'Count the occurrences of each string literal among all method parameters.', 'Check whether the count of any string literal is greater than or equal to 4.', 'Get the name of class: AnnotationParams', 'Get all methods declared in class: foo', 'Get the method signature of the method: foo(Object, String, String, String)', 'Get all annotations declared in method signature: @SuppressWarnings("unused")', 'For each annotation, get all parameters: unused, unused, unused, unused', 'For each parameter in annotations, check whether it is a string literal: false, true, true, true (the parameters are string literals, but "unused" is not the same as "a", "str2", "str3", "str4")', 'Check whether the string literal length is greater than or equal to 3: true, true, true, true', 'Count the occurrences of each string literal among all method parameters: unused=4, a=0, str2=0, str3=0, str4=0', 'Get the name of class: AnnotationParams', 'Get all methods declared in class: foo', 'Get the method signature of the method: foo(Object, String, String, String)', 'Get all annotations declared in method signature: @SuppressWarnings("unused")', 'For each parameter in the method signature, check whether it is a string literal: false, false, false, false (parameters are not string literals)', 'Check whether the method body contains any string literals: false (method body is empty)']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMemberValuePair', 'ASTAnnotationMemberList', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTBlock', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'ASTAnnotation', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366355895996094
*Get the method signature of the method.* 匹配到的元操作或API：
logic: Get the method signature of the method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9701594114303589
*Get all annotations declared in method signature.* 匹配到的元操作或API：
logic: Get all annotations declared in method signature.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.8623492121696472
*For each annotation, get all parameters.* 匹配到的元操作或API：
query: For each annotation, get all parameters.
most similar API: for each of annotation
cosine Similarity: 0.8292585611343384
*For each parameter in annotations, check whether it is a string literal.* 匹配到的元操作或API：
query: For each parameter in annotations, check whether it is a string literal.
most similar API: Check whether the formal parameter is any annotation present
cosine Similarity: 0.8631657361984253
*Check whether the string literal length is greater than or equal to 3.* 匹配到的元操作或API：
query: Check whether the string literal length is greater than or equal to 3.
most similar API: Check whether the string literal is long literal
cosine Similarity: 0.8259308934211731
*Count the occurrences of each string literal among all method parameters.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of any string literal is greater than or equal to 4.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: AnnotationParams* 匹配到的元操作或API：
logic: Get the name of class: AnnotationParams
most similar meta operation: Get the name of annotation declaration
cosine Similarity: 0.8536898493766785
*Get all methods declared in class: foo* 匹配到的元操作或API：
query: Get all methods declared in class: foo
most similar API: get declared annotations of method
cosine Similarity: 0.8257920145988464
*Get the method signature of the method: foo(Object, String, String, String)* 匹配到的元操作或API：
logic: Get the method signature of the method: foo(Object, String, String, String)
most similar meta operation: Get the signature of method
cosine Similarity: 0.9084391593933105
*Get all annotations declared in method signature: @SuppressWarnings("unused")* 匹配到的元操作或API：
query: Get all annotations declared in method signature: @SuppressWarnings("unused")
most similar API: get declared annotations of method
cosine Similarity: 0.8909916877746582
*For each annotation, get all parameters: unused, unused, unused, unused* 匹配到的元操作或API：
未匹配成功元操作或API
*For each parameter in annotations, check whether it is a string literal: false, true, true, true (the parameters are string literals, but "unused" is not the same as "a", "str2", "str3", "str4")* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the string literal length is greater than or equal to 3: true, true, true, true* 匹配到的元操作或API：
query: Check whether the string literal length is greater than or equal to 3: true, true, true, true
most similar API: Check whether the string literal equals
cosine Similarity: 0.816074788570404
*Count the occurrences of each string literal among all method parameters: unused=4, a=0, str2=0, str3=0, str4=0* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: AnnotationParams* 匹配到的元操作或API：
logic: Get the name of class: AnnotationParams
most similar meta operation: Get the name of annotation declaration
cosine Similarity: 0.8536898493766785
*Get all methods declared in class: foo* 匹配到的元操作或API：
query: Get all methods declared in class: foo
most similar API: get declared annotations of method
cosine Similarity: 0.8257920145988464
*Get the method signature of the method: foo(Object, String, String, String)* 匹配到的元操作或API：
logic: Get the method signature of the method: foo(Object, String, String, String)
most similar meta operation: Get the signature of method
cosine Similarity: 0.9084391593933105
*Get all annotations declared in method signature: @SuppressWarnings("unused")* 匹配到的元操作或API：
query: Get all annotations declared in method signature: @SuppressWarnings("unused")
most similar API: get declared annotations of method
cosine Similarity: 0.8909916877746582
*For each parameter in the method signature, check whether it is a string literal: false, false, false, false (parameters are not string literals)* 匹配到的元操作或API：
query: For each parameter in the method signature, check whether it is a string literal: false, false, false, false (parameters are not string literals)
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8193394541740417
*Check whether the method body contains any string literals: false (method body is empty)* 匹配到的元操作或API：
query: Check whether the method body contains any string literals: false (method body is empty)
most similar API: Check whether the string literal is empty
cosine Similarity: 0.8216431736946106
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class, ASTClassOrInterfaceDeclaration.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        stringLiteralCount.clear();
        for (ASTAnnotation annotation : node.getDeclaredAnnotations()) {
            ASTAnnotationMemberList memberList = annotation.getMemberList();
            if (memberList != null) {
                for (ASTMemberValuePair pair : memberList) {
                    ASTStringLiteral stringLiteral = pair.getFirstChildOfType(ASTStringLiteral.class);
                    if (stringLiteral != null && stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
This checker has passed this negative testcase:
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}


This checker is failed(false negative) on this negative test case:
```
// Duplicated string literals as annotation parameter
public class AnnotationParams {
    public static void foo(@SuppressWarnings("unused") Object str,
                           @SuppressWarnings("unused") String str2,
                           @SuppressWarnings("unused") String str3,
                           @SuppressWarnings("unused") String str4) {}
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'AnnotationParams')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 4)
        ——ASTFormalParameter
          ——ASTModifierList
            ——ASTAnnotation
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTAnnotationMemberList
                ——ASTMemberValuePair
                  ——ASTStringLiteral
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
        ——ASTFormalParameter
          ——ASTModifierList
            ——ASTAnnotation
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTAnnotationMemberList
                ——ASTMemberValuePair
                  ——ASTStringLiteral
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str2')
        ——ASTFormalParameter
          ——ASTModifierList
            ——ASTAnnotation
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTAnnotationMemberList
                ——ASTMemberValuePair
                  ——ASTStringLiteral
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str3')
        ——ASTFormalParameter
          ——ASTModifierList
            ——ASTAnnotation
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTAnnotationMemberList
                ——ASTMemberValuePair
                  ——ASTStringLiteral
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str4')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
4. net.sourceforge.pmd.lang.java.ast.ASTAnnotation: public void forEach(java.util.function.Consumer)
5. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public boolean isAnyAnnotationPresent(java.util.Collection), //Checks whether any annotation is present on this node. @param binaryNames            Collection that contains binary names of annotations.            Note: for now, canonical names are tolerated, this may be changed in PMD 7. @return <code>true</code> if any annotation is present on this node, else <code>false</code>
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isLongLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral long integer literal}.
7. net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration: public java.lang.String getSimpleName()
8. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean equals(java.lang.Object)
9. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
10. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty(), //True if the constant value is empty. Does not necessarily compute the constant value.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTExpressionStatement.class, ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    private Map<String, Integer> stringLiteralCount = new HashMap<>();

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        stringLiteralCount.clear();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpressionStatement node, Object data) {
        ASTMethodCall methodCall = node.getFirstChildOfType(ASTMethodCall.class);
        if (methodCall != null) {
            ASTArgumentList arguments = methodCall.getArguments();
            for (ASTExpression expr : arguments.children(ASTStringLiteral.class)) {
                if (expr instanceof ASTStringLiteral) {
                    ASTStringLiteral stringLiteral = (ASTStringLiteral) expr;
                    if (stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        stringLiteralCount.clear();
        for (ASTAnnotation annotation : node.getDeclaredAnnotations()) {
            ASTAnnotationMemberList memberList = annotation.getMemberList();
            if (memberList != null) {
                for (ASTMemberValuePair pair : memberList) {
                    ASTStringLiteral stringLiteral = pair.getFirstChildOfType(ASTStringLiteral.class);
                    if (stringLiteral != null && stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        for (ASTAnnotation annotation : node.getDeclaredAnnotations()) {
            ASTAnnotationMemberList memberList = annotation.getMemberList();
            if (memberList != null) {
                for (ASTMemberValuePair pair : memberList) {
                    ASTStringLiteral stringLiteral = pair.getFirstChildOfType(ASTStringLiteral.class);
                    if (stringLiteral != null && stringLiteral.length() >= 3) {
                        String value = stringLiteral.getConstValue();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (stringLiteralCount.get(value) == 4) {
                            addViolation(data, stringLiteral);
                        }
                    }
                }
            }
        }

        for (ASTFormalParameter param : node.getFormalParameters()) {
            for (ASTAnnotation annotation : param.getDeclaredAnnotations()) {
                ASTAnnotationMemberList memberList = annotation.getMemberList();
                if (memberList != null) {
                    for (ASTMemberValuePair pair : memberList) {
                        ASTStringLiteral stringLiteral = pair.getFirstChildOfType(ASTStringLiteral.class);
                        if (stringLiteral != null && stringLiteral.length() >= 3) {
                            String value = stringLiteral.getConstValue();
                            stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                            if (stringLiteralCount.get(value) == 4) {
                                addViolation(data, stringLiteral);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        if (astArgumentList.size() > 0) {
            ASTExpression expression = astArgumentList.get(0);
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
True
测试用例全部通过
最终通过 9 个测试用例
正例 3 个
反例 6 个
输入token：842378
输出token：566711
结束

规则执行完毕，时间总花销： 1983.8058228492737 秒
