开始

========================================== Rule LiteralsFirstInComparisonsRule ===========================================
一共 33 个测试用例
正例 22 个
反例 11 个
2084
1665
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the method declaration in class.
        2. Get the name of called method in method body.
        3. Check whether the called method is equals or equalsIgnoreCase or compareTo or compareToIgnoreCase or contentEquals.
        4. Get the number of arguments of called method.
        5. Check whether the number of arguments is 1.
        6. Get the first argument of called method.
        7. Check whether the first argument is a string literal.
        8. Get the type of the first argument.
        9. Check whether the type of the first argument is String.
        10. Get the second argument of called method.
        11. Check whether the second argument is a string literal.
        If the called method in the method body is one of the String comparison methods (equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals) and the number of arguments is 1 and the second argument is not a string literal, then this test case violates the rule.
        
In this specific test case:
- The called method is `equals`.
- The number of arguments is 1.
- The first argument is `x`, which is not a string literal.
- The second argument is `"2"`, which is a string literal.

Since the literal is not the first argument in the `equals` method call, this test case violates the rule. 

To correct this, the literal should be positioned first in the comparison:

```java
public class Foo {
    boolean bar(String x) {
        return "2".equals(x);
    }
}
```
['Get the method declaration in class.', 'Get the name of called method in method body.', 'Check whether the called method is equals or equalsIgnoreCase or compareTo or compareToIgnoreCase or contentEquals.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 1.', 'Get the first argument of called method.', 'Check whether the first argument is a string literal.', 'Get the type of the first argument.', 'Check whether the type of the first argument is String.', 'Get the second argument of called method.', 'Check whether the second argument is a string literal.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the method declaration in class.* 匹配到的元操作或API：
logic: Get the method declaration in class.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9149814248085022
*Get the name of called method in method body.* 匹配到的元操作或API：
logic: Get the name of called method in method body.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9282673001289368
*Check whether the called method is equals or equalsIgnoreCase or compareTo or compareToIgnoreCase or contentEquals.* 匹配到的元操作或API：
query: Check whether the called method is equals or equalsIgnoreCase or compareTo or compareToIgnoreCase or contentEquals.
most similar API: Check whether the method call equals
cosine Similarity: 0.8640614748001099
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of called method.* 匹配到的元操作或API：
logic: Get the first argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9160765409469604
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803800344467163
*Get the type of the first argument.* 匹配到的元操作或API：
logic: Get the type of the first argument.
most similar meta operation: Get the type of argument
cosine Similarity: 0.9078187942504883
*Check whether the type of the first argument is String.* 匹配到的元操作或API：
logic: Check whether the type of the first argument is String.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9387744665145874
*Get the second argument of called method.* 匹配到的元操作或API：
logic: Get the second argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9016816020011902
*Check whether the second argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the second argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8767277002334595
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
The test case corresponding to the rule:
```
// bad, literal comes last in .equals comparison
public class Foo {
    boolean bar(String x) {
        return x.equals("2");
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'boolean')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
3.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
4.  //Get the type of argument
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getMethodCallArgumentType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import java.util.Arrays;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        if (Arrays.asList("equals", "equalsIgnoreCase", "compareTo", "compareToIgnoreCase", "contentEquals").contains(methodName)) {
            if (getArgumentNumber(node) == 2) {
                ASTArgumentList arguments = node.getArguments();
                ASTExpression firstArgument = arguments.get(0);
                ASTExpression secondArgument = arguments.get(1);
                if (secondArgument instanceof ASTStringLiteral && !(firstArgument instanceof ASTStringLiteral)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    private int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    private boolean isMethodCallArgumentStringType(ASTMethodCall node, int argumentIndex) {
        ASTArgumentList astArgumentList = node.getArguments();
        ASTExpression expression = astArgumentList.get(argumentIndex);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Get the type of argument
    private JTypeMirror getMethodCallArgumentType(ASTMethodCall node, int argumentIndex) {
        ASTArgumentList astArgumentList = node.getArguments();
        ASTExpression expression = astArgumentList.get(argumentIndex);
        return expression.getTypeMirror();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of called method.
2. Check whether the called method name is equals.
3. Get the number of arguments of called method.
4. Check whether the number of arguments is 1.
5. Get an argument of called method.
6. Check whether the argument is a string literal.
7. Check whether the argument is not a string literal.
8. Check whether the method caller is an accessed variable.
9. Check whether the accessed variable is not a literal value.
10. Check whether the accessed variable is not a variable value.
11. Check whether the accessed variable is not a final field.
12. Check whether the accessed variable is not a field.
13. Check whether the accessed variable is not a local variable.
14. Check whether the accessed variable is not a formal parameter.
15. Check whether the called method is equalsIgnoreCase.
16. Check whether the called method is compareTo.
17. Check whether the called method is compareToIgnoreCase.
18. Check whether the called method is contentEquals.
19. Check whether the method caller is a string literal.
20. Check whether the method caller is an accessed variable.

In this case:
1. The called method name is equals.
2. The number of arguments is 1.
3. The argument is a string literal.
4. The method caller is an accessed variable (the parameter `x`).
5. The accessed variable is not a literal value.
6. The accessed variable is not a variable value.
7. The accessed variable is not a final field.
8. The accessed variable is not a field.
9. The accessed variable is not a local variable.
10. The accessed variable is a formal parameter.

Since the method caller (`x`) is not a string literal and the string literal is the second argument in the `equals` method call, this test case violates the rule. The string literal should be the first argument to avoid potential `NullPointerExceptions`.
['Get the name of called method.', 'Check whether the called method name is equals.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 1.', 'Get an argument of called method.', 'Check whether the argument is a string literal.', 'Check whether the argument is not a string literal.', 'Check whether the method caller is an accessed variable.', 'Check whether the accessed variable is not a literal value.', 'Check whether the accessed variable is not a variable value.', 'Check whether the accessed variable is not a final field.', 'Check whether the accessed variable is not a field.', 'Check whether the accessed variable is not a local variable.', 'Check whether the accessed variable is not a formal parameter.', 'Check whether the called method is equalsIgnoreCase.', 'Check whether the called method is compareTo.', 'Check whether the called method is compareToIgnoreCase.', 'Check whether the called method is contentEquals.', 'Check whether the method caller is a string literal.', 'Check whether the method caller is an accessed variable.', 'The called method name is equals.', 'The number of arguments is 1.', 'The argument is a string literal.', 'The method caller is an accessed variable (the parameter `x`).', 'The accessed variable is not a literal value.', 'The accessed variable is not a variable value.', 'The accessed variable is not a final field.', 'The accessed variable is not a field.', 'The accessed variable is not a local variable.', 'The accessed variable is a formal parameter.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9280144572257996
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9077174663543701
*Check whether the argument is not a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is not a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8831738829612732
*Check whether the method caller is an accessed variable.* 匹配到的元操作或API：
logic: Check whether the method caller is an accessed variable.
most similar meta operation: Check whether the accessed variable is a local variable
cosine Similarity: 0.8596189618110657
*Check whether the accessed variable is not a literal value.* 匹配到的元操作或API：
logic: Check whether the accessed variable is not a literal value.
most similar meta operation: Check whether the accessed variable is boolean type
cosine Similarity: 0.8683688640594482
*Check whether the accessed variable is not a variable value.* 匹配到的元操作或API：
logic: Check whether the accessed variable is not a variable value.
most similar meta operation: Check whether the accessed variable is a field
cosine Similarity: 0.8686997890472412
*Check whether the accessed variable is not a final field.* 匹配到的元操作或API：
logic: Check whether the accessed variable is not a final field.
most similar meta operation: Check whether the accessed variable is final
cosine Similarity: 0.9192209243774414
*Check whether the accessed variable is not a field.* 匹配到的元操作或API：
logic: Check whether the accessed variable is not a field.
most similar meta operation: Check whether the accessed variable is a field
cosine Similarity: 0.9426469802856445
*Check whether the accessed variable is not a local variable.* 匹配到的元操作或API：
logic: Check whether the accessed variable is not a local variable.
most similar meta operation: Check whether the accessed variable is a local variable
cosine Similarity: 0.9522901177406311
*Check whether the accessed variable is not a formal parameter.* 匹配到的元操作或API：
logic: Check whether the accessed variable is not a formal parameter.
most similar meta operation: Check whether the accessed variable is a formal parameter
cosine Similarity: 0.9380668997764587
*Check whether the called method is equalsIgnoreCase.* 匹配到的元操作或API：
query: Check whether the called method is equalsIgnoreCase.
most similar API: Check whether the method call equals
cosine Similarity: 0.8630307912826538
*Check whether the called method is compareTo.* 匹配到的元操作或API：
query: Check whether the called method is compareTo.
most similar API: Check whether the method call equals
cosine Similarity: 0.8823130130767822
*Check whether the called method is compareToIgnoreCase.* 匹配到的元操作或API：
query: Check whether the called method is compareToIgnoreCase.
most similar API: Check whether the method call equals
cosine Similarity: 0.8374332785606384
*Check whether the called method is contentEquals.* 匹配到的元操作或API：
query: Check whether the called method is contentEquals.
most similar API: Check whether the method call equals
cosine Similarity: 0.8615925312042236
*Check whether the method caller is a string literal.* 匹配到的元操作或API：
logic: Check whether the method caller is a string literal.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.9311873316764832
*Check whether the method caller is an accessed variable.* 匹配到的元操作或API：
logic: Check whether the method caller is an accessed variable.
most similar meta operation: Check whether the accessed variable is a local variable
cosine Similarity: 0.8596189618110657
*The called method name is equals.* 匹配到的元操作或API：
query: The called method name is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.8255528807640076
*The number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*The argument is a string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method caller is an accessed variable (the parameter `x`).* 匹配到的元操作或API：
未匹配成功元操作或API
*The accessed variable is not a literal value.* 匹配到的元操作或API：
未匹配成功元操作或API
*The accessed variable is not a variable value.* 匹配到的元操作或API：
未匹配成功元操作或API
*The accessed variable is not a final field.* 匹配到的元操作或API：
未匹配成功元操作或API
*The accessed variable is not a field.* 匹配到的元操作或API：
未匹配成功元操作或API
*The accessed variable is not a local variable.* 匹配到的元操作或API：
未匹配成功元操作或API
*The accessed variable is a formal parameter.* 匹配到的元操作或API：
logic: The accessed variable is a formal parameter.
most similar meta operation: Check whether the accessed variable is a formal parameter
cosine Similarity: 0.8753835558891296
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
The test case corresponding to the rule:
```
// bad, literal comes last in .equals comparison
public class Foo {
    boolean bar(String x) {
        return x.equals("2");
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'boolean')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
2.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
3.  //Check whether the accessed variable is a local variable
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JLocalVariableSymbol;
public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JLocalVariableSymbol) {
        JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
        return true;
    }
    return false;
}
```
4.  //Check whether the accessed variable is boolean type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isVariableAccessBooleanType(ASTVariableAccess var) {
    return var.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN);
}
```
5.  //Check whether the accessed variable is a field
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;
public boolean isVariableAccessField(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JFieldSymbol) {
        JFieldSymbol fieldSym = (JFieldSymbol) sym;
        return true;
    }
    return false;
}
```
6.  //Check whether the accessed variable is final
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
public boolean isVariableAccessFinal(ASTVariableAccess var){
    JVariableSymbol symbol = var.getReferencedSym();
    if (symbol == null) {
        return false;
    }
    if (var.getReferencedSym().isFinal()) {
        return true;
    }
    return false;
}
```
7.  //Check whether the accessed variable is a formal parameter
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
public boolean isFormalParameter(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if(sym == null)
        return false;
    ASTVariableDeclaratorId varDecl = sym.tryGetNode();
    assert varDecl != null;
    return varDecl.isFormalParameter();
}
```
8.  //Check whether the method caller is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallerStringType(ASTMethodCall node){
    return TypeTestUtil.isA(String.class, node.getQualifier());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        if (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || methodName.equals("contentEquals")) {
            ASTArgumentList arguments = node.getArguments();
            if (getArgumentNumber(node) == 2) {
                ASTExpression firstArgument = arguments.get(0);
                ASTExpression secondArgument = arguments.get(1);

                if (firstArgument instanceof ASTVariableAccess && secondArgument instanceof ASTStringLiteral) {
                    if (isMethodCallerStringType(node) && isVariableAccessLocalVariable((ASTVariableAccess) firstArgument)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the method caller is string type
    public boolean isMethodCallerStringType(ASTMethodCall node) {
        return TypeTestUtil.isA(String.class, node.getQualifier());
    }

    // Check whether the accessed variable is a local variable
    public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym instanceof JLocalVariableSymbol) {
            return true;
        }
        return false;
    }

    // Check whether the accessed variable is boolean type
    public boolean isVariableAccessBooleanType(ASTVariableAccess var) {
        return var.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN);
    }

    // Check whether the accessed variable is a field
    public boolean isVariableAccessField(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym instanceof JFieldSymbol) {
            JFieldSymbol fieldSym = (JFieldSymbol) sym;
            return true;
        }
        return false;
    }

    // Check whether the accessed variable is final
    public boolean isVariableAccessFinal(ASTVariableAccess var) {
        JVariableSymbol symbol = var.getReferencedSym();
        if (symbol == null) {
            return false;
        }
        if (var.getReferencedSym().isFinal()) {
            return true;
        }
        return false;
    }

    // Check whether the accessed variable is a formal parameter
    public boolean isFormalParameter(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym == null)
            return false;
        ASTVariableDeclaratorId varDecl = sym.tryGetNode();
        assert varDecl != null;
        return varDecl.isFormalParameter();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the method declaration from method call.
2. Get the name of called method.
3. Check whether the name is equals.
4. Check whether the called method is equalsIgnoreCase, compareTo, compareToIgnoreCase, or contentEquals.
5. Get the number of arguments of called method.
6. Check whether the number of arguments is 2.
7. Get the first argument of called method.
8. Get the type of first argument.
9. Check whether the type of first argument is String.
10. Get the second argument of called method.
11. Check whether the second argument is a string literal.
12. If the second argument is a string literal, then check whether the first argument is not null.
13. If the called method name is equals and the first argument is not a string literal and the second argument is a string literal, then this test case violates the rule.

In this specific test case:
1. The method declaration from method call is `x.equals("2")`.
2. The name of the called method is `equals`.
3. The number of arguments of the called method is 2.
4. The first argument of the called method is `x`.
5. The type of the first argument is `String`.
6. The second argument of the called method is `"2"`.
7. The second argument is a string literal.
8. Since the second argument is a string literal, we should check whether the first argument is not null, but the rule specifically states to position literals first, which is not the case here.

Based on the rule and the test case provided:
1. The called method name is `equals`.
2. The first argument is not a string literal.
3. The second argument is a string literal.

Therefore, this test case violates the rule.
['Get the method declaration from method call.', 'Get the name of called method.', 'Check whether the name is equals.', 'Check whether the called method is equalsIgnoreCase, compareTo, compareToIgnoreCase, or contentEquals.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 2.', 'Get the first argument of called method.', 'Get the type of first argument.', 'Check whether the type of first argument is String.', 'Get the second argument of called method.', 'Check whether the second argument is a string literal.', 'If the second argument is a string literal, then check whether the first argument is not null.', 'If the called method name is equals and the first argument is not a string literal and the second argument is a string literal, then this test case violates the rule.', 'The method declaration from method call is `x.equals("2")`.', 'The name of the called method is `equals`.', 'The number of arguments of the called method is 2.', 'The first argument of the called method is `x`.', 'The type of the first argument is `String`.', 'The second argument of the called method is `"2"`.', 'The second argument is a string literal.', 'Since the second argument is a string literal, we should check whether the first argument is not null, but the rule specifically states to position literals first, which is not the case here.', 'The called method name is `equals`.', 'The first argument is not a string literal.', 'The second argument is a string literal.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the method declaration from method call.* 匹配到的元操作或API：
logic: Get the method declaration from method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9787436127662659
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the name is equals.* 匹配到的元操作或API：
query: Check whether the name is equals.
most similar API: Check whether is equals method
cosine Similarity: 0.8145301938056946
*Check whether the called method is equalsIgnoreCase, compareTo, compareToIgnoreCase, or contentEquals.* 匹配到的元操作或API：
query: Check whether the called method is equalsIgnoreCase, compareTo, compareToIgnoreCase, or contentEquals.
most similar API: Check whether the method call equals
cosine Similarity: 0.8473517894744873
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 2.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of called method.* 匹配到的元操作或API：
logic: Get the first argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9160765409469604
*Get the type of first argument.* 匹配到的元操作或API：
logic: Get the type of first argument.
most similar meta operation: Get the type of argument
cosine Similarity: 0.916989803314209
*Check whether the type of first argument is String.* 匹配到的元操作或API：
logic: Check whether the type of first argument is String.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9403924942016602
*Get the second argument of called method.* 匹配到的元操作或API：
logic: Get the second argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9016816020011902
*Check whether the second argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the second argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8767277002334595
*If the second argument is a string literal, then check whether the first argument is not null.* 匹配到的元操作或API：
query: If the second argument is a string literal, then check whether the first argument is not null.
most similar API: Check whether the string literal is null literal
cosine Similarity: 0.882207453250885
*If the called method name is equals and the first argument is not a string literal and the second argument is a string literal, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method declaration from method call is `x.equals("2")`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The name of the called method is `equals`.* 匹配到的元操作或API：
query: The name of the called method is `equals`.
most similar API: Check whether the method call equals
cosine Similarity: 0.8214161396026611
*The number of arguments of the called method is 2.* 匹配到的元操作或API：
未匹配成功元操作或API
*The first argument of the called method is `x`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The type of the first argument is `String`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The second argument of the called method is `"2"`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The second argument is a string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Since the second argument is a string literal, we should check whether the first argument is not null, but the rule specifically states to position literals first, which is not the case here.* 匹配到的元操作或API：
未匹配成功元操作或API
*The called method name is `equals`.* 匹配到的元操作或API：
query: The called method name is `equals`.
most similar API: Check whether is equals method
cosine Similarity: 0.8391321897506714
*The first argument is not a string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*The second argument is a string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
The test case corresponding to the rule:
```
// bad, literal comes last in .equals comparison
public class Foo {
    boolean bar(String x) {
        return x.equals("2");
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'boolean')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isEqualsMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isNullLiteral(), //Returns true if this is the {@linkplain ASTNullLiteral null literal}.

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
3.  //Get the type of argument
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getMethodCallArgumentType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror();
}
```
4.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        if (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || methodName.equals("contentEquals")) {
            ASTArgumentList arguments = node.getArguments();
            if (getArgumentNumber(node) == 2) {
                ASTExpression firstArgument = arguments.get(0);
                ASTExpression secondArgument = arguments.get(1);
                if (firstArgument instanceof ASTVariableAccess && secondArgument instanceof ASTStringLiteral) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the method declaration from method call.
        2. Get the name of called method.
        3. Check whether the name of called method is 'equals' or 'equalsIgnoreCase' or 'compareTo' or 'compareToIgnoreCase' or 'contentEquals'.
        4. Get the number of arguments of called method.
        5. Check whether the number of arguments is 1.
        6. Get the first argument of the called method.
        7. Check whether the first argument is a string literal.
        8. Get the second argument of the called method.
        9. Check whether the second argument is a string literal.
        If the method is a String comparison method and the first argument is not a string literal, then this test case violates the rule.

Given the test case, the granularity checks would be:

1. Get the method declaration from method call.
        2. Get the name of called method.
        3. Check whether the name of called method is 'equals'.
        4. Get the number of arguments of called method.
        5. Check whether the number of arguments is 1.
        6. Get the first argument of the called method.
        7. Check whether the first argument is a string literal.
        8. Get the second argument of the called method.
        9. Check whether the second argument is a string literal.

In this case, the called method is 'equals', it has 1 argument, the first argument is not a string literal, and the second argument is a string literal. Therefore, this test case violates the rule.
['Get the method declaration from method call.', 'Get the name of called method.', "Check whether the name of called method is 'equals' or 'equalsIgnoreCase' or 'compareTo' or 'compareToIgnoreCase' or 'contentEquals'.", 'Get the number of arguments of called method.', 'Check whether the number of arguments is 1.', 'Get the first argument of the called method.', 'Check whether the first argument is a string literal.', 'Get the second argument of the called method.', 'Check whether the second argument is a string literal.', 'Get the method declaration from method call.', 'Get the name of called method.', "Check whether the name of called method is 'equals'.", 'Get the number of arguments of called method.', 'Check whether the number of arguments is 1.', 'Get the first argument of the called method.', 'Check whether the first argument is a string literal.', 'Get the second argument of the called method.', 'Check whether the second argument is a string literal.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the method declaration from method call.* 匹配到的元操作或API：
logic: Get the method declaration from method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9787436127662659
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the name of called method is 'equals' or 'equalsIgnoreCase' or 'compareTo' or 'compareToIgnoreCase' or 'contentEquals'.* 匹配到的元操作或API：
query: Check whether the name of called method is 'equals' or 'equalsIgnoreCase' or 'compareTo' or 'compareToIgnoreCase' or 'contentEquals'.
most similar API: Check whether the method call equals
cosine Similarity: 0.8548876643180847
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of the called method.* 匹配到的元操作或API：
logic: Get the first argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9071929454803467
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803800344467163
*Get the second argument of the called method.* 匹配到的元操作或API：
logic: Get the second argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8917081952095032
*Check whether the second argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the second argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8767277002334595
*Get the method declaration from method call.* 匹配到的元操作或API：
logic: Get the method declaration from method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9787436127662659
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the name of called method is 'equals'.* 匹配到的元操作或API：
query: Check whether the name of called method is 'equals'.
most similar API: Check whether the method call equals
cosine Similarity: 0.9171410202980042
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of the called method.* 匹配到的元操作或API：
logic: Get the first argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9071929454803467
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803800344467163
*Get the second argument of the called method.* 匹配到的元操作或API：
logic: Get the second argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8917081952095032
*Check whether the second argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the second argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8767277002334595
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
The test case corresponding to the rule:
```
// bad, literal comes last in .equals comparison
public class Foo {
    boolean bar(String x) {
        return x.equals("2");
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'boolean')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
3.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.bestpractices;

import java.util.List;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        List<ASTExpression> arguments = node.getArguments().getArguments();

        if (arguments.size() == 2 && isComparisonMethod(methodName) && 
            !isMethodCallArgumentStringType(node, 0) && isMethodCallArgumentStringType(node, 1)) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    private boolean isComparisonMethod(String methodName) {
        return methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
               methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
               methodName.equals("contentEquals");
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node, int index) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.getArguments().get(index);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Get method declaration from method call
    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method) {
        JMethodSymbol symbol = (JMethodSymbol) method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of called method.
2. Check whether the name is equals.
3. Check whether the called method is equalsIgnoreCase.
4. Check whether the name is compareTo.
5. Check whether the called method is compareToIgnoreCase.
6. Check whether the name is contentEquals.
7. Get the number of arguments of called method.
8. Check whether the number of arguments is 1.
9. Get an argument of called method.
10. Check whether the argument is a string literal.
11. Get the method caller.
12. Check whether the method caller is a string literal.
13. Check whether the method caller is a variable.

To determine if the test case violates the rule:
- If the called method is one of the specified string comparison methods (equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals) and the number of arguments is 1:
  - Check whether the argument is a string literal (Step 10).
  - If the argument is not a string literal and the method caller is a string literal (Step 12), the test case does not violate the rule.
  - If the argument is not a string literal and the method caller is a variable (Step 13), the test case violates the rule.
  - If the method caller is a string literal, the test case does not violate the rule regardless of the argument.

In this test case:
1. The called method name is equals (Step 1 and Step 2).
2. The number of arguments is 1 (Step 7 and Step 8).
3. The argument is not a string literal (Step 9 and Step 10).
4. The method caller is a variable (Step 11 and Step 13).
Thus, the test case violates the rule (bad 1).
['Get the name of called method.', 'Check whether the name is equals.', 'Check whether the called method is equalsIgnoreCase.', 'Check whether the name is compareTo.', 'Check whether the called method is compareToIgnoreCase.', 'Check whether the name is contentEquals.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 1.', 'Get an argument of called method.', 'Check whether the argument is a string literal.', 'Get the method caller.', 'Check whether the method caller is a string literal.', 'Check whether the method caller is a variable.', 'The called method name is equals (Step 1 and Step 2).', 'The number of arguments is 1 (Step 7 and Step 8).', 'The argument is not a string literal (Step 9 and Step 10).', 'The method caller is a variable (Step 11 and Step 13).']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the name is equals.* 匹配到的元操作或API：
query: Check whether the name is equals.
most similar API: Check whether is equals method
cosine Similarity: 0.8145301938056946
*Check whether the called method is equalsIgnoreCase.* 匹配到的元操作或API：
query: Check whether the called method is equalsIgnoreCase.
most similar API: Check whether the method call equals
cosine Similarity: 0.8630307912826538
*Check whether the name is compareTo.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the called method is compareToIgnoreCase.* 匹配到的元操作或API：
query: Check whether the called method is compareToIgnoreCase.
most similar API: Check whether the method call equals
cosine Similarity: 0.8374332785606384
*Check whether the name is contentEquals.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9077174663543701
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796929359436035
*Check whether the method caller is a string literal.* 匹配到的元操作或API：
logic: Check whether the method caller is a string literal.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.9311873316764832
*Check whether the method caller is a variable.* 匹配到的元操作或API：
query: Check whether the method caller is a variable.
most similar API: Check whether the method call equals
cosine Similarity: 0.8110104203224182
*The called method name is equals (Step 1 and Step 2).* 匹配到的元操作或API：
未匹配成功元操作或API
*The number of arguments is 1 (Step 7 and Step 8).* 匹配到的元操作或API：
未匹配成功元操作或API
*The argument is not a string literal (Step 9 and Step 10).* 匹配到的元操作或API：
未匹配成功元操作或API
*The method caller is a variable (Step 11 and Step 13).* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
The test case corresponding to the rule:
```
// bad, literal comes last in .equals comparison
public class Foo {
    boolean bar(String x) {
        return x.equals("2");
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'boolean')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isEqualsMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
2.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
3.  //Check whether the method caller is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallerStringType(ASTMethodCall node){
    return TypeTestUtil.isA(String.class, node.getQualifier());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        if ((methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || methodName.equals("contentEquals")) && getArgumentNumber(node) == 1) {
            ASTArgumentList arguments = node.getArguments();
            ASTExpression firstArgument = arguments.get(0);
            if (firstArgument instanceof ASTStringLiteral && !isMethodCallerStringType(node)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the method caller is string type
    public boolean isMethodCallerStringType(ASTMethodCall node) {
        return TypeTestUtil.isA(String.class, node.getQualifier());
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 1
2469
1985
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
Let's analyze the provided test case to determine whether it adheres to the rule or not:

1. Get the name of the class.
2. Get all methods declared in the class.
3. Get the name of a method.
4. Get the content of the method.
5. Get all assignment expressions in the method.
6. Get all method calls in the method.
7. Get the name of the called method.
8. Check whether the called method is equals.
9. Get the number of arguments of the called method.
10. Check whether the number of arguments is 2.
11. Get the first argument of the called method.
12. Get the second argument of the called method.
13. Check whether the second argument is a string literal.
14. Check whether the first argument is a string literal.
15. Check whether the second argument is a null check.
16. Get the return type of the called method.
17. Check whether the return type of the called method is boolean type.

For the `bar` method in the `Foo` class, let's go through each `equals` method call to check the adherence to the rule:

1. Get the name of the method: bar
2. Get the content of the method.
3. Get all method calls in the method.
4. Get the name of the called method: equals
5. Check whether the called method is equals: true
6. Get the number of arguments of the called method: 2
7. Get the first argument of the called method: str
8. Get the second argument of the called method: ""
9. Check whether the second argument is a string literal: true
10. Check whether the first argument is a string literal: false
11. Check whether the second argument is a null check: false
12. Get the return type of the called method: boolean
13. Check whether the return type of the called method is boolean type: true

Since the second argument of the `equals` method call is a string literal and not null, and the first argument is not a string literal, this violates the rule.

Repeat the above checks for all `equals` method calls in the `bar` method (4 total):

1. Get the first argument of the called method: str
2. Get the second argument of the called method: ""
3. Check whether the second argument is a string literal: true
4. Check whether the first argument is a string literal: false
5. Check whether the second argument is a null check: false

Each of the 4 `equals` method calls in the `bar` method violates the rule.

Thus, the number of violating the rule in this test case is indeed 4.
['Get the name of the class.', 'Get all methods declared in the class.', 'Get the name of a method.', 'Get the content of the method.', 'Get all assignment expressions in the method.', 'Get all method calls in the method.', 'Get the name of the called method.', 'Check whether the called method is equals.', 'Get the number of arguments of the called method.', 'Check whether the number of arguments is 2.', 'Get the first argument of the called method.', 'Get the second argument of the called method.', 'Check whether the second argument is a string literal.', 'Check whether the first argument is a string literal.', 'Check whether the second argument is a null check.', 'Get the return type of the called method.', 'Check whether the return type of the called method is boolean type.', 'Get the name of the method: bar', 'Get the content of the method.', 'Get all method calls in the method.', 'Get the name of the called method: equals', 'Check whether the called method is equals: true', 'Get the number of arguments of the called method: 2', 'Get the first argument of the called method: str', 'Get the second argument of the called method: ""', 'Check whether the second argument is a string literal: true', 'Check whether the first argument is a string literal: false', 'Check whether the second argument is a null check: false', 'Get the return type of the called method: boolean', 'Check whether the return type of the called method is boolean type: true', 'Get the first argument of the called method: str', 'Get the second argument of the called method: ""', 'Check whether the second argument is a string literal: true', 'Check whether the first argument is a string literal: false', 'Check whether the second argument is a null check: false']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTExpressionStatement', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTIfStatement', 'ASTNullLiteral', 'ASTMethodDeclaration', 'ASTAssignmentExpression', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTInfixExpression']
*Get the name of the class.* 匹配到的元操作或API：
logic: Get the name of the class.
most similar meta operation: Get the name of class
cosine Similarity: 0.968898594379425
*Get all methods declared in the class.* 匹配到的元操作或API：
query: Get all methods declared in the class.
most similar API: get declared annotations of method
cosine Similarity: 0.8373103141784668
*Get the name of a method.* 匹配到的元操作或API：
logic: Get the name of a method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9760956764221191
*Get the content of the method.* 匹配到的元操作或API：
query: Get the content of the method.
most similar API: get text of method
cosine Similarity: 0.889632523059845
*Get all assignment expressions in the method.* 匹配到的元操作或API：
query: Get all assignment expressions in the method.
most similar API: get text of assignment expression
cosine Similarity: 0.8497307300567627
*Get all method calls in the method.* 匹配到的元操作或API：
query: Get all method calls in the method.
most similar API: get method name of method call
cosine Similarity: 0.8326440453529358
*Get the name of the called method.* 匹配到的元操作或API：
logic: Get the name of the called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9750091433525085
*Check whether the called method is equals.* 匹配到的元操作或API：
query: Check whether the called method is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9604323506355286
*Get the number of arguments of the called method.* 匹配到的元操作或API：
logic: Get the number of arguments of the called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9801274538040161
*Check whether the number of arguments is 2.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of the called method.* 匹配到的元操作或API：
logic: Get the first argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9071929454803467
*Get the second argument of the called method.* 匹配到的元操作或API：
logic: Get the second argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8917081952095032
*Check whether the second argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the second argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8767277002334595
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803800344467163
*Check whether the second argument is a null check.* 匹配到的元操作或API：
query: Check whether the second argument is a null check.
most similar API: Check whether is null check
cosine Similarity: 0.8612234592437744
*Get the return type of the called method.* 匹配到的元操作或API：
logic: Get the return type of the called method.
most similar meta operation: Get the return type of called method
cosine Similarity: 0.9767905473709106
*Check whether the return type of the called method is boolean type.* 匹配到的元操作或API：
logic: Check whether the return type of the called method is boolean type.
most similar meta operation: Check whether the return type of called method is boolean type
cosine Similarity: 0.9832226037979126
*Get the name of the method: bar* 匹配到的元操作或API：
logic: Get the name of the method: bar
most similar meta operation: Get the name of method
cosine Similarity: 0.8826972246170044
*Get the content of the method.* 匹配到的元操作或API：
query: Get the content of the method.
most similar API: get text of method
cosine Similarity: 0.889632523059845
*Get all method calls in the method.* 匹配到的元操作或API：
query: Get all method calls in the method.
most similar API: get method name of method call
cosine Similarity: 0.8326440453529358
*Get the name of the called method: equals* 匹配到的元操作或API：
logic: Get the name of the called method: equals
most similar meta operation: Get the name of called method
cosine Similarity: 0.8829482793807983
*Check whether the called method is equals: true* 匹配到的元操作或API：
query: Check whether the called method is equals: true
most similar API: Check whether the method call equals
cosine Similarity: 0.940230131149292
*Get the number of arguments of the called method: 2* 匹配到的元操作或API：
logic: Get the number of arguments of the called method: 2
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9710367918014526
*Get the first argument of the called method: str* 匹配到的元操作或API：
logic: Get the first argument of the called method: str
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8798302412033081
*Get the second argument of the called method: ""* 匹配到的元操作或API：
logic: Get the second argument of the called method: ""
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9060987830162048
*Check whether the second argument is a string literal: true* 匹配到的元操作或API：
logic: Check whether the second argument is a string literal: true
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8703451156616211
*Check whether the first argument is a string literal: false* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal: false
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8656289577484131
*Check whether the second argument is a null check: false* 匹配到的元操作或API：
query: Check whether the second argument is a null check: false
most similar API: Check whether is null check
cosine Similarity: 0.8473545908927917
*Get the return type of the called method: boolean* 匹配到的元操作或API：
logic: Get the return type of the called method: boolean
most similar meta operation: Check whether the return type of called method is boolean type
cosine Similarity: 0.9331100583076477
*Check whether the return type of the called method is boolean type: true* 匹配到的元操作或API：
logic: Check whether the return type of the called method is boolean type: true
most similar meta operation: Check whether the return type of called method is boolean type
cosine Similarity: 0.9865631461143494
*Get the first argument of the called method: str* 匹配到的元操作或API：
logic: Get the first argument of the called method: str
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8798302412033081
*Get the second argument of the called method: ""* 匹配到的元操作或API：
logic: Get the second argument of the called method: ""
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9060987830162048
*Check whether the second argument is a string literal: true* 匹配到的元操作或API：
logic: Check whether the second argument is a string literal: true
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8703451156616211
*Check whether the first argument is a string literal: false* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal: false
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8656289577484131
*Check whether the second argument is a null check: false* 匹配到的元操作或API：
query: Check whether the second argument is a null check: false
most similar API: Check whether is null check
cosine Similarity: 0.8473545908927917
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
The test case corresponding to the rule:
```
// ok, empty literal in .equals comparison
public class Foo {
    void bar(String str) {
        if ((str == null) || (str.equals(""))) {
            str = "snafu";
        }
        if (str == null || str.equals("")) {
            str = "snafu";
        }
        if ((str != null) && (str.equals(""))) {
            str = "snafu";
        }
        if (str != null && str.equals("")) {
            str = "snafu";
        }
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 4

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTArgumentList (size = 1)
                ——ASTStringLiteral
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTAssignmentExpression
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTStringLiteral
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTArgumentList (size = 1)
                ——ASTStringLiteral
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTAssignmentExpression
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTStringLiteral
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTArgumentList (size = 1)
                ——ASTStringLiteral
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTAssignmentExpression
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTStringLiteral
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTArgumentList (size = 1)
                ——ASTStringLiteral
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTAssignmentExpression
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTStringLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.document.Chars getText()
5. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.document.Chars getText()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
7. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
8. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
9. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullCheck(net.sourceforge.pmd.lang.java.ast.ASTExpression, net.sourceforge.pmd.lang.java.rule.internal.StablePathMatcher)

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
2.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
3.  //Get the return type of called method
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.JMethodSig;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getReturnType(ASTMethodCall call) {
    JMethodSig m = call.getMethodType();
    return m.getReturnType();
}
```
4.  //Check whether the return type of called method is boolean type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.JMethodSig;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnBooleanType(ASTMethodCall call) {
    JMethodSig m = call.getMethodType();
    return m.getReturnType().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN);
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        if (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || methodName.equals("contentEquals")) {
            ASTArgumentList arguments = node.getArguments();
            if (arguments.size() == 1 && !isFirstArgumentStringLiteral(arguments)) {
                ASTExpression receiver = node.getFirstChildOfType(ASTExpression.class);
                if (receiver instanceof ASTVariableAccess) {
                    ASTInfixExpression parentInfix = (ASTInfixExpression) node.getParent();
                    if (parentInfix != null && (parentInfix.getOperator().getImage().equals("==") || parentInfix.getOperator().getImage().equals("!="))) {
                        if (!(parentInfix.getLeftOperand() instanceof ASTNullLiteral && parentInfix.getRightOperand() instanceof ASTVariableAccess) &&
                            !(parentInfix.getLeftOperand() instanceof ASTVariableAccess && parentInfix.getRightOperand() instanceof ASTNullLiteral)) {
                            addViolation(data, node);
                        }
                    } else {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isFirstArgumentStringLiteral(ASTArgumentList arguments) {
        ASTExpression expr = arguments.get(0);
        return expr instanceof ASTStringLiteral;
    }

    //Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node){
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    //Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        //select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    //Get the return type of called method
    public JMethodSig getReturnType(ASTMethodCall call) {
        return call.getMethodType();
    }

    //Check whether the return type of called method is boolean type
    public boolean isReturnBooleanType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
Let's analyze the test case step-by-step to ascertain its adherence to the rule:

1. Get the number of formal parameters of method.
2. Get the type of formal parameter.
3. Check whether the formal parameter is a String type.
4. Get all method calls inside method.
5. Get the name of called method.
6. Check whether the called method name is equals.
7. Check whether the called method name is equalsIgnoreCase.
8. Check whether the called method name is compareTo.
9. Check whether the called method name is compareToIgnoreCase.
10. Check whether the called method name is contentEquals.
11. Get the number of arguments of called method.
12. Check whether the number of arguments is 1.
13. Get an argument of called method.
14. Check whether the argument is a string literal.
15. Get the method caller.
16. Check whether the method caller is the formal parameter.
17. Check whether the second argument is null.
18. If the second argument is not null, check whether the string literal is first in the arguments list.
19. Repeat steps 4-18 for each method call inside method.

For the provided test case:

- Method `bar` has one formal parameter `str` of type `String`.

- There are four method calls to `equals` inside `bar`:
  1. `str.equals("")`
  2. `str.equals("")`
  3. `str.equals("")`
  4. `str.equals("")`

- For each `equals` method call:
  5. The called method name is `equals`.
  6. The number of arguments is 1.
  7. The argument is a string literal `""`.
  8. The method caller is the formal parameter `str`.

- Since the string literal `""` is the first argument in all four `equals` method calls, the rule is not violated in this test case. The provided description "bad 2" and the number of violations (4) seem incorrect based on the rule and the given test case.

The correct number of violations for this test case is 0, as the string literal is already positioned first in all `equals` method calls.
['Get the number of formal parameters of method.', 'Get the type of formal parameter.', 'Check whether the formal parameter is a String type.', 'Get all method calls inside method.', 'Get the name of called method.', 'Check whether the called method name is equals.', 'Check whether the called method name is equalsIgnoreCase.', 'Check whether the called method name is compareTo.', 'Check whether the called method name is compareToIgnoreCase.', 'Check whether the called method name is contentEquals.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 1.', 'Get an argument of called method.', 'Check whether the argument is a string literal.', 'Get the method caller.', 'Check whether the method caller is the formal parameter.', 'Check whether the second argument is null.', 'If the second argument is not null, check whether the string literal is first in the arguments list.', 'Repeat steps 4-18 for each method call inside method.', '`str.equals("")`', '`str.equals("")`', '`str.equals("")`', '`str.equals("")`', 'The called method name is `equals`.', 'The number of arguments is 1.', 'The argument is a string literal `""`.', 'The method caller is the formal parameter `str`.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTExpressionStatement', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTIfStatement', 'ASTNullLiteral', 'ASTMethodDeclaration', 'ASTAssignmentExpression', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTInfixExpression']
*Get the number of formal parameters of method.* 匹配到的元操作或API：
logic: Get the number of formal parameters of method.
most similar meta operation: Get the number of formal parameters of method
cosine Similarity: 0.9860841035842896
*Get the type of formal parameter.* 匹配到的元操作或API：
logic: Get the type of formal parameter.
most similar meta operation: Get the type of formal parameter
cosine Similarity: 0.985480785369873
*Check whether the formal parameter is a String type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is a String type.
most similar meta operation: Check whether the formal parameter is string type
cosine Similarity: 0.9867483377456665
*Get all method calls inside method.* 匹配到的元操作或API：
query: Get all method calls inside method.
most similar API: get method name of method call
cosine Similarity: 0.8236055374145508
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9280144572257996
*Check whether the called method name is equalsIgnoreCase.* 匹配到的元操作或API：
query: Check whether the called method name is equalsIgnoreCase.
most similar API: Check whether the method call equals
cosine Similarity: 0.8475643396377563
*Check whether the called method name is compareTo.* 匹配到的元操作或API：
query: Check whether the called method name is compareTo.
most similar API: Check whether the method call equals
cosine Similarity: 0.8681850433349609
*Check whether the called method name is compareToIgnoreCase.* 匹配到的元操作或API：
query: Check whether the called method name is compareToIgnoreCase.
most similar API: Check whether the method call equals
cosine Similarity: 0.8260899186134338
*Check whether the called method name is contentEquals.* 匹配到的元操作或API：
query: Check whether the called method name is contentEquals.
most similar API: Check whether the method call equals
cosine Similarity: 0.8419468402862549
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9077174663543701
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796929359436035
*Check whether the method caller is the formal parameter.* 匹配到的元操作或API：
query: Check whether the method caller is the formal parameter.
most similar API: Check whether the formal parameter equals
cosine Similarity: 0.8454272747039795
*Check whether the second argument is null.* 匹配到的元操作或API：
query: Check whether the second argument is null.
most similar API: Check whether is null check
cosine Similarity: 0.8355708122253418
*If the second argument is not null, check whether the string literal is first in the arguments list.* 匹配到的元操作或API：
query: If the second argument is not null, check whether the string literal is first in the arguments list.
most similar API: Check whether the null literal is string literal
cosine Similarity: 0.8410788774490356
*Repeat steps 4-18 for each method call inside method.* 匹配到的元操作或API：
未匹配成功元操作或API
*`str.equals("")`* 匹配到的元操作或API：
未匹配成功元操作或API
*`str.equals("")`* 匹配到的元操作或API：
未匹配成功元操作或API
*`str.equals("")`* 匹配到的元操作或API：
未匹配成功元操作或API
*`str.equals("")`* 匹配到的元操作或API：
未匹配成功元操作或API
*The called method name is `equals`.* 匹配到的元操作或API：
query: The called method name is `equals`.
most similar API: Check whether is equals method
cosine Similarity: 0.8391321897506714
*The number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*The argument is a string literal `""`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method caller is the formal parameter `str`.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
The test case corresponding to the rule:
```
// ok, empty literal in .equals comparison
public class Foo {
    void bar(String str) {
        if ((str == null) || (str.equals(""))) {
            str = "snafu";
        }
        if (str == null || str.equals("")) {
            str = "snafu";
        }
        if ((str != null) && (str.equals(""))) {
            str = "snafu";
        }
        if (str != null && str.equals("")) {
            str = "snafu";
        }
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 4

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTArgumentList (size = 1)
                ——ASTStringLiteral
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTAssignmentExpression
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTStringLiteral
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTArgumentList (size = 1)
                ——ASTStringLiteral
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTAssignmentExpression
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTStringLiteral
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTArgumentList (size = 1)
                ——ASTStringLiteral
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTAssignmentExpression
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTStringLiteral
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTArgumentList (size = 1)
                ——ASTStringLiteral
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTAssignmentExpression
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTStringLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()
6. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public boolean equals(java.lang.Object)
7. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullCheck(net.sourceforge.pmd.lang.java.ast.ASTExpression, net.sourceforge.pmd.lang.java.rule.internal.StablePathMatcher)
8. net.sourceforge.pmd.lang.java.ast.ASTNullLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
9. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isEqualsMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)

1.  //Get the number of formal parameters of method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTMethodDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```
2.  //Check whether the formal parameter is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFormalParameterStringType(ASTFormalParameter node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```
3.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
4.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if (getArgumentNumber(node) == 1 && 
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {

            ASTExpression arg = arguments.get(0);
            if (!(qualifier instanceof ASTStringLiteral) && arg instanceof ASTStringLiteral) {
                if (!(qualifier instanceof ASTNullLiteral) && 
                    !JavaRuleUtil.isNullCheck(qualifier, JavaRuleUtil.STABLE_PATH_MATCHER)) {
                    addViolation(data, node);
                }
            }
        }

        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
To analyze the adherence of the provided test case to the rule, we need to focus on the `equals` method calls and check whether the literal is the first argument. Here are the granular checks:

1. Get the name of the class.
2. Get the method named bar.
3. Get all method calls within bar.
4. Check whether the called method is equals.
5. Get the number of arguments of the called method.
6. Check whether the number of arguments is 2.
7. Get the first argument of the called method.
8. Check whether the first argument is a string literal.
9. Get the second argument of the called method.
10. Check whether the second argument is a string literal.
11. If the second argument is not a string literal, check whether it is null.
12. Get the first argument of the called method.
13. Check whether the first argument is a string literal.
14. Get the second argument of the called method.
15. Check whether the second argument is a string literal.
16. If the second argument is not a string literal, check whether it is null.
17. Get the first argument of the called method.
18. Check whether the first argument is a string literal.
19. Get the second argument of the called method.
20. Check whether the second argument is a string literal.
21. If the second argument is not a string literal, check whether it is null.
22. Get the first argument of the called method.
23. Check whether the first argument is a string literal.
24. Get the second argument of the called method.
25. Check whether the second argument is a string literal.
26. If the second argument is not a string literal, check whether it is null.

Let's apply these checks to each `equals` method call in the `bar` method:

### First `equals` Call: `(str == null) || (str.equals(""))`
3. Get the first method call within bar: `str.equals("")`.
4. Check whether the called method is equals: true.
5. Get the number of arguments of the called method: 1.
6. Check whether the number of arguments is 2: false. (Skip to next method call)
7. Get the first method call within bar: `(str == null) || (str.equals(""))`.
8. Check whether the called method is equals: true.
9. Get the number of arguments of the called method: 1.
10. Check whether the number of arguments is 2: false. (Skip to next method call)

### Second `equals` Call: `str.equals("")`
4. Check whether the called method is equals: true.
5. Get the number of arguments of the called method: 1.
6. Check whether the number of arguments is 2: false. (Skip to next method call)
7. Get the second method call within bar: `str.equals("")`.
8. Check whether the called method is equals: true.
9. Get the number of arguments of the called method: 1.
10. Check whether the number of arguments is 2: false. (Skip to next method call)

### Third `equals` Call: `(str != null) && (str.equals(""))`
3. Get the third method call within bar: `str.equals("")`.
4. Check whether the called method is equals: true.
5. Get the number of arguments of the called method: 1.
6. Check whether the number of arguments is 2: false. (Skip to next method call)
7. Get the third method call within bar: `(str != null) && (str.equals(""))`.
8. Check whether the called method is equals: true.
9. Get the number of arguments of the called method: 1.
10. Check whether the number of arguments is 2: false. (Skip to next method call)

### Fourth `equals` Call: `str.equals("")`
4. Check whether the called method is equals: true.
5. Get the number of arguments of the called method: 1.
6. Check whether the number of arguments is 2: false. (Skip to next method call)
7. Get the fourth method call within bar: `str.equals("")`.
8. Check whether the called method is equals: true.
9. Get the number of arguments of the called method: 1.
10. Check whether the number of arguments is 2: false. (Skip to next method call)

### Revisiting the Test Case with Correct Method Signatures
Let's assume the test case actually contains `str.equals("")` with two arguments, which is incorrect since `equals` only takes one argument. However, if we hypothetically consider a test case with `str.equals("", str)`:

1. Get the first method call within bar: `str.equals("", str)`.
2. Check whether the called method is equals: true.
3. Get the number of arguments of the called method: 2.
4. Check whether the number of arguments is 2: true.
5. Get the first argument of the called method: `""`.
6. Check whether the first argument is a string literal: true.
7. Get the second argument of the called method: `str`.
8. Check whether the second argument is a string literal: false.
9. Check whether the second argument is null: false.
10. Get the first argument of the called method: `""`.
11. Check whether the first argument is a string literal: true.
12. Get the second argument of the called method: `str`.
13. Check whether the second argument is a string literal: false.
14. Check whether the second argument is null: false.
15. Get the first argument of the called method: `""`.
16. Check whether the first argument is a string literal: true.
17. Get the second argument of the called method: `str`.
18. Check whether the second argument is a string literal: false.
19. Check whether the second argument is null: false.
20. Get the first argument of the called method: `""`.
21. Check whether the first argument is a string literal: true.
22. Get the second argument of the called method: `str`.
23. Check whether the second argument is a string literal: false.
24. Check whether the second argument is null: false.

Since the actual test case provided uses `str.equals("")` with one argument, the rule is not violated in the provided test case. The rule requires checking the positions of arguments in `equals` method calls with two arguments, which is not the case here.

However, if we hypothetically consider a test case with `str.equals(str, "")`:

1. Get the first method call within bar: `str.equals(str, "")`.
2. Check whether the called method is equals: true.
3. Get the number of arguments of the called method: 2.
4. Check whether the number of arguments is 2: true.
5. Get the first argument of the called method: `str`.
6. Check whether the first argument is a string literal: false.
7. Get the second argument of the called method: `""`.
8. Check whether the second argument is a string literal: true.
9. Check whether the second argument is null: false.
10. Get the second argument of the called method: `""`.
11. Check whether the second argument is a string literal: true.
12. Get the first argument of the called method: `str`.
13. Check whether the first argument is a string literal: false.
14. Check whether the first argument is null: false.
15. Get the second argument of the called method: `""`.
16. Check whether the second argument is a string literal: true.
17. Get the first argument of the called method: `str`.
18. Check whether the first argument is a string literal: false.
19. Check whether the first argument is null: false.
20. Get the second argument of the called method: `""`.
21. Check whether the second argument is a string literal: true.
22. Get the first argument of the called method: `str`.
23. Check whether the first argument is a string literal: false.
24. Check whether the first argument is null: false.
25. Get the second argument of the called method: `""`.
26. Check whether the second argument is a string literal: true.
27. Get the first argument of the called method: `str`.
28. Check whether the first argument is a string literal: false.
29. Check whether the first argument is null: false.
30. Get the second argument of the called method: `""`.
31. Check whether the second argument is a string literal: true.

In this hypothetical case, the rule is violated because the literal is the second argument in the `equals` method call.

Since the provided test case does not have any `equals` method calls with two arguments, it does not violate the rule. However, the description suggests there are four violations, which implies the test case should have had four `equals` method calls with the literal as the second argument. Let's assume that was the intended scenario:

### Hypothetical Correct Test Case
```java
public class Foo {
    void bar(String str) {
        if ((str == null) || (str.equals(str, ""))) {
            str = "snafu";
        }
        if (str == null || str.equals(str, "")) {
            str = "snafu";
        }
        if ((str != null) && (str.equals(str, ""))) {
            str = "snafu";
        }
        if (str != null && str.equals(str, "")) {
            str = "snafu";
        }
    }
}
```

### Hypothetical Correct Granular Checks
1. Get the first method call within bar: `str.equals(str, "")`.
2. Check whether the called method is equals: true.
3. Get the number of arguments of the called method: 2.
4. Check whether the number of arguments is 2: true.
5. Get the first argument of the called method: `str`.
6. Check whether the first argument is a string literal: false.
7. Get the second argument of the called method: `""`.
8. Check whether the second argument is a string literal: true.
9. Check whether the second argument is null: false.
10. Get the second method call within bar: `str.equals(str, "")`.
11. Check whether the called method is equals: true.
12. Get the number of arguments of the called method: 2.
13. Check whether the number of arguments is 2: true.
14. Get the first argument of the called method: `str`.
15. Check whether the first argument is a string literal: false.
16. Get the second argument of the called method: `""`.
17. Check whether the second argument is a string literal: true.
18. Check whether the second argument is null: false.
19. Get the third method call within bar: `str.equals(str, "")`.
20. Check whether the called method is equals: true.
21. Get the number of arguments of the called method: 2.
22. Check whether the number of arguments is 2: true.
23. Get the first argument of the called method: `str`.
24. Check whether the first argument is a string literal: false.
25. Get the second argument of the called method: `""`.
26. Check whether the second argument is a string literal: true.
27. Check whether the second argument is null: false.
28. Get the fourth method call within bar: `str.equals(str, "")`.
29. Check whether the called method is equals: true.
30. Get the number of arguments of the called method: 2.
31. Check whether the number of arguments is 2: true.
32. Get the first argument of the called method: `str`.
33. Check whether the first argument is a string literal: false.
34. Get the second argument of the called method: `""`.
35. Check whether the second argument is a string literal: true.
36. Check whether the second argument is null: false.

In the hypothetical correct test case, each `equals` method call violates the rule because the literal is the second argument.
['Get the name of the class.', 'Get the method named bar.', 'Get all method calls within bar.', 'Check whether the called method is equals.', 'Get the number of arguments of the called method.', 'Check whether the number of arguments is 2.', 'Get the first argument of the called method.', 'Check whether the first argument is a string literal.', 'Get the second argument of the called method.', 'Check whether the second argument is a string literal.', 'If the second argument is not a string literal, check whether it is null.', 'Get the first argument of the called method.', 'Check whether the first argument is a string literal.', 'Get the second argument of the called method.', 'Check whether the second argument is a string literal.', 'If the second argument is not a string literal, check whether it is null.', 'Get the first argument of the called method.', 'Check whether the first argument is a string literal.', 'Get the second argument of the called method.', 'Check whether the second argument is a string literal.', 'If the second argument is not a string literal, check whether it is null.', 'Get the first argument of the called method.', 'Check whether the first argument is a string literal.', 'Get the second argument of the called method.', 'Check whether the second argument is a string literal.', 'If the second argument is not a string literal, check whether it is null.', 'Get the first method call within bar: `str.equals("")`.', 'Check whether the called method is equals: true.', 'Get the number of arguments of the called method: 1.', 'Check whether the number of arguments is 2: false. (Skip to next method call)', 'Get the first method call within bar: `(str == null) || (str.equals(""))`.', 'Check whether the called method is equals: true.', 'Get the number of arguments of the called method: 1.', 'Check whether the number of arguments is 2: false. (Skip to next method call)', 'Check whether the called method is equals: true.', 'Get the number of arguments of the called method: 1.', 'Check whether the number of arguments is 2: false. (Skip to next method call)', 'Get the second method call within bar: `str.equals("")`.', 'Check whether the called method is equals: true.', 'Get the number of arguments of the called method: 1.', 'Check whether the number of arguments is 2: false. (Skip to next method call)', 'Get the third method call within bar: `str.equals("")`.', 'Check whether the called method is equals: true.', 'Get the number of arguments of the called method: 1.', 'Check whether the number of arguments is 2: false. (Skip to next method call)', 'Get the third method call within bar: `(str != null) && (str.equals(""))`.', 'Check whether the called method is equals: true.', 'Get the number of arguments of the called method: 1.', 'Check whether the number of arguments is 2: false. (Skip to next method call)', 'Check whether the called method is equals: true.', 'Get the number of arguments of the called method: 1.', 'Check whether the number of arguments is 2: false. (Skip to next method call)', 'Get the fourth method call within bar: `str.equals("")`.', 'Check whether the called method is equals: true.', 'Get the number of arguments of the called method: 1.', 'Check whether the number of arguments is 2: false. (Skip to next method call)', 'Get the first method call within bar: `str.equals("", str)`.', 'Check whether the called method is equals: true.', 'Get the number of arguments of the called method: 2.', 'Check whether the number of arguments is 2: true.', 'Get the first argument of the called method: `""`.', 'Check whether the first argument is a string literal: true.', 'Get the second argument of the called method: `str`.', 'Check whether the second argument is a string literal: false.', 'Check whether the second argument is null: false.', 'Get the first argument of the called method: `""`.', 'Check whether the first argument is a string literal: true.', 'Get the second argument of the called method: `str`.', 'Check whether the second argument is a string literal: false.', 'Check whether the second argument is null: false.', 'Get the first argument of the called method: `""`.', 'Check whether the first argument is a string literal: true.', 'Get the second argument of the called method: `str`.', 'Check whether the second argument is a string literal: false.', 'Check whether the second argument is null: false.', 'Get the first argument of the called method: `""`.', 'Check whether the first argument is a string literal: true.', 'Get the second argument of the called method: `str`.', 'Check whether the second argument is a string literal: false.', 'Check whether the second argument is null: false.', 'Get the first method call within bar: `str.equals(str, "")`.', 'Check whether the called method is equals: true.', 'Get the number of arguments of the called method: 2.', 'Check whether the number of arguments is 2: true.', 'Get the first argument of the called method: `str`.', 'Check whether the first argument is a string literal: false.', 'Get the second argument of the called method: `""`.', 'Check whether the second argument is a string literal: true.', 'Check whether the second argument is null: false.', 'Get the second argument of the called method: `""`.', 'Check whether the second argument is a string literal: true.', 'Get the first argument of the called method: `str`.', 'Check whether the first argument is a string literal: false.', 'Check whether the first argument is null: false.', 'Get the second argument of the called method: `""`.', 'Check whether the second argument is a string literal: true.', 'Get the first argument of the called method: `str`.', 'Check whether the first argument is a string literal: false.', 'Check whether the first argument is null: false.', 'Get the second argument of the called method: `""`.', 'Check whether the second argument is a string literal: true.', 'Get the first argument of the called method: `str`.', 'Check whether the first argument is a string literal: false.', 'Check whether the first argument is null: false.', 'Get the second argument of the called method: `""`.', 'Check whether the second argument is a string literal: true.', 'Get the first argument of the called method: `str`.', 'Check whether the first argument is a string literal: false.', 'Check whether the first argument is null: false.', 'Get the second argument of the called method: `""`.', 'Check whether the second argument is a string literal: true.', 'Get the first method call within bar: `str.equals(str, "")`.', 'Check whether the called method is equals: true.', 'Get the number of arguments of the called method: 2.', 'Check whether the number of arguments is 2: true.', 'Get the first argument of the called method: `str`.', 'Check whether the first argument is a string literal: false.', 'Get the second argument of the called method: `""`.', 'Check whether the second argument is a string literal: true.', 'Check whether the second argument is null: false.', 'Get the second method call within bar: `str.equals(str, "")`.', 'Check whether the called method is equals: true.', 'Get the number of arguments of the called method: 2.', 'Check whether the number of arguments is 2: true.', 'Get the first argument of the called method: `str`.', 'Check whether the first argument is a string literal: false.', 'Get the second argument of the called method: `""`.', 'Check whether the second argument is a string literal: true.', 'Check whether the second argument is null: false.', 'Get the third method call within bar: `str.equals(str, "")`.', 'Check whether the called method is equals: true.', 'Get the number of arguments of the called method: 2.', 'Check whether the number of arguments is 2: true.', 'Get the first argument of the called method: `str`.', 'Check whether the first argument is a string literal: false.', 'Get the second argument of the called method: `""`.', 'Check whether the second argument is a string literal: true.', 'Check whether the second argument is null: false.', 'Get the fourth method call within bar: `str.equals(str, "")`.', 'Check whether the called method is equals: true.', 'Get the number of arguments of the called method: 2.', 'Check whether the number of arguments is 2: true.', 'Get the first argument of the called method: `str`.', 'Check whether the first argument is a string literal: false.', 'Get the second argument of the called method: `""`.', 'Check whether the second argument is a string literal: true.', 'Check whether the second argument is null: false.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTExpressionStatement', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTIfStatement', 'ASTNullLiteral', 'ASTMethodDeclaration', 'ASTAssignmentExpression', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTInfixExpression']
*Get the name of the class.* 匹配到的元操作或API：
logic: Get the name of the class.
most similar meta operation: Get the name of class
cosine Similarity: 0.968898594379425
*Get the method named bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all method calls within bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the called method is equals.* 匹配到的元操作或API：
query: Check whether the called method is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9604323506355286
*Get the number of arguments of the called method.* 匹配到的元操作或API：
logic: Get the number of arguments of the called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9801274538040161
*Check whether the number of arguments is 2.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of the called method.* 匹配到的元操作或API：
logic: Get the first argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9071929454803467
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803800344467163
*Get the second argument of the called method.* 匹配到的元操作或API：
logic: Get the second argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8917081952095032
*Check whether the second argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the second argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8767277002334595
*If the second argument is not a string literal, check whether it is null.* 匹配到的元操作或API：
query: If the second argument is not a string literal, check whether it is null.
most similar API: Check whether the string literal is null literal
cosine Similarity: 0.8896151185035706
*Get the first argument of the called method.* 匹配到的元操作或API：
logic: Get the first argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9071929454803467
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803800344467163
*Get the second argument of the called method.* 匹配到的元操作或API：
logic: Get the second argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8917081952095032
*Check whether the second argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the second argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8767277002334595
*If the second argument is not a string literal, check whether it is null.* 匹配到的元操作或API：
query: If the second argument is not a string literal, check whether it is null.
most similar API: Check whether the string literal is null literal
cosine Similarity: 0.8896151185035706
*Get the first argument of the called method.* 匹配到的元操作或API：
logic: Get the first argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9071929454803467
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803800344467163
*Get the second argument of the called method.* 匹配到的元操作或API：
logic: Get the second argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8917081952095032
*Check whether the second argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the second argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8767277002334595
*If the second argument is not a string literal, check whether it is null.* 匹配到的元操作或API：
query: If the second argument is not a string literal, check whether it is null.
most similar API: Check whether the string literal is null literal
cosine Similarity: 0.8896151185035706
*Get the first argument of the called method.* 匹配到的元操作或API：
logic: Get the first argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9071929454803467
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803800344467163
*Get the second argument of the called method.* 匹配到的元操作或API：
logic: Get the second argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8917081952095032
*Check whether the second argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the second argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8767277002334595
*If the second argument is not a string literal, check whether it is null.* 匹配到的元操作或API：
query: If the second argument is not a string literal, check whether it is null.
most similar API: Check whether the string literal is null literal
cosine Similarity: 0.8896151185035706
*Get the first method call within bar: `str.equals("")`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the called method is equals: true.* 匹配到的元操作或API：
query: Check whether the called method is equals: true.
most similar API: Check whether the method call equals
cosine Similarity: 0.9226872324943542
*Get the number of arguments of the called method: 1.* 匹配到的元操作或API：
logic: Get the number of arguments of the called method: 1.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.94288569688797
*Check whether the number of arguments is 2: false. (Skip to next method call)* 匹配到的元操作或API：
query: Check whether the number of arguments is 2: false. (Skip to next method call)
most similar API: Check whether the argument list equals
cosine Similarity: 0.8012657165527344
*Get the first method call within bar: `(str == null) || (str.equals(""))`.* 匹配到的元操作或API：
query: Get the first method call within bar: `(str == null) || (str.equals(""))`.
most similar API: get first token of method call
cosine Similarity: 0.8062047958374023
*Check whether the called method is equals: true.* 匹配到的元操作或API：
query: Check whether the called method is equals: true.
most similar API: Check whether the method call equals
cosine Similarity: 0.9226872324943542
*Get the number of arguments of the called method: 1.* 匹配到的元操作或API：
logic: Get the number of arguments of the called method: 1.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.94288569688797
*Check whether the number of arguments is 2: false. (Skip to next method call)* 匹配到的元操作或API：
query: Check whether the number of arguments is 2: false. (Skip to next method call)
most similar API: Check whether the argument list equals
cosine Similarity: 0.8012657165527344
*Check whether the called method is equals: true.* 匹配到的元操作或API：
query: Check whether the called method is equals: true.
most similar API: Check whether the method call equals
cosine Similarity: 0.9226872324943542
*Get the number of arguments of the called method: 1.* 匹配到的元操作或API：
logic: Get the number of arguments of the called method: 1.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.94288569688797
*Check whether the number of arguments is 2: false. (Skip to next method call)* 匹配到的元操作或API：
query: Check whether the number of arguments is 2: false. (Skip to next method call)
most similar API: Check whether the argument list equals
cosine Similarity: 0.8012657165527344
*Get the second method call within bar: `str.equals("")`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the called method is equals: true.* 匹配到的元操作或API：
query: Check whether the called method is equals: true.
most similar API: Check whether the method call equals
cosine Similarity: 0.9226872324943542
*Get the number of arguments of the called method: 1.* 匹配到的元操作或API：
logic: Get the number of arguments of the called method: 1.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.94288569688797
*Check whether the number of arguments is 2: false. (Skip to next method call)* 匹配到的元操作或API：
query: Check whether the number of arguments is 2: false. (Skip to next method call)
most similar API: Check whether the argument list equals
cosine Similarity: 0.8012657165527344
*Get the third method call within bar: `str.equals("")`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the called method is equals: true.* 匹配到的元操作或API：
query: Check whether the called method is equals: true.
most similar API: Check whether the method call equals
cosine Similarity: 0.9226872324943542
*Get the number of arguments of the called method: 1.* 匹配到的元操作或API：
logic: Get the number of arguments of the called method: 1.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.94288569688797
*Check whether the number of arguments is 2: false. (Skip to next method call)* 匹配到的元操作或API：
query: Check whether the number of arguments is 2: false. (Skip to next method call)
most similar API: Check whether the argument list equals
cosine Similarity: 0.8012657165527344
*Get the third method call within bar: `(str != null) && (str.equals(""))`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the called method is equals: true.* 匹配到的元操作或API：
query: Check whether the called method is equals: true.
most similar API: Check whether the method call equals
cosine Similarity: 0.9226872324943542
*Get the number of arguments of the called method: 1.* 匹配到的元操作或API：
logic: Get the number of arguments of the called method: 1.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.94288569688797
*Check whether the number of arguments is 2: false. (Skip to next method call)* 匹配到的元操作或API：
query: Check whether the number of arguments is 2: false. (Skip to next method call)
most similar API: Check whether the argument list equals
cosine Similarity: 0.8012657165527344
*Check whether the called method is equals: true.* 匹配到的元操作或API：
query: Check whether the called method is equals: true.
most similar API: Check whether the method call equals
cosine Similarity: 0.9226872324943542
*Get the number of arguments of the called method: 1.* 匹配到的元操作或API：
logic: Get the number of arguments of the called method: 1.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.94288569688797
*Check whether the number of arguments is 2: false. (Skip to next method call)* 匹配到的元操作或API：
query: Check whether the number of arguments is 2: false. (Skip to next method call)
most similar API: Check whether the argument list equals
cosine Similarity: 0.8012657165527344
*Get the fourth method call within bar: `str.equals("")`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the called method is equals: true.* 匹配到的元操作或API：
query: Check whether the called method is equals: true.
most similar API: Check whether the method call equals
cosine Similarity: 0.9226872324943542
*Get the number of arguments of the called method: 1.* 匹配到的元操作或API：
logic: Get the number of arguments of the called method: 1.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.94288569688797
*Check whether the number of arguments is 2: false. (Skip to next method call)* 匹配到的元操作或API：
query: Check whether the number of arguments is 2: false. (Skip to next method call)
most similar API: Check whether the argument list equals
cosine Similarity: 0.8012657165527344
*Get the first method call within bar: `str.equals("", str)`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the called method is equals: true.* 匹配到的元操作或API：
query: Check whether the called method is equals: true.
most similar API: Check whether the method call equals
cosine Similarity: 0.9226872324943542
*Get the number of arguments of the called method: 2.* 匹配到的元操作或API：
logic: Get the number of arguments of the called method: 2.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.938377857208252
*Check whether the number of arguments is 2: true.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of the called method: `""`.* 匹配到的元操作或API：
logic: Get the first argument of the called method: `""`.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8923133015632629
*Check whether the first argument is a string literal: true.* 匹配到的元操作或API：
query: Check whether the first argument is a string literal: true.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8777529001235962
*Get the second argument of the called method: `str`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the second argument is a string literal: false.* 匹配到的元操作或API：
query: Check whether the second argument is a string literal: false.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8679952025413513
*Check whether the second argument is null: false.* 匹配到的元操作或API：
query: Check whether the second argument is null: false.
most similar API: Check whether is null check
cosine Similarity: 0.8154923915863037
*Get the first argument of the called method: `""`.* 匹配到的元操作或API：
logic: Get the first argument of the called method: `""`.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8923133015632629
*Check whether the first argument is a string literal: true.* 匹配到的元操作或API：
query: Check whether the first argument is a string literal: true.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8777529001235962
*Get the second argument of the called method: `str`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the second argument is a string literal: false.* 匹配到的元操作或API：
query: Check whether the second argument is a string literal: false.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8679952025413513
*Check whether the second argument is null: false.* 匹配到的元操作或API：
query: Check whether the second argument is null: false.
most similar API: Check whether is null check
cosine Similarity: 0.8154923915863037
*Get the first argument of the called method: `""`.* 匹配到的元操作或API：
logic: Get the first argument of the called method: `""`.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8923133015632629
*Check whether the first argument is a string literal: true.* 匹配到的元操作或API：
query: Check whether the first argument is a string literal: true.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8777529001235962
*Get the second argument of the called method: `str`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the second argument is a string literal: false.* 匹配到的元操作或API：
query: Check whether the second argument is a string literal: false.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8679952025413513
*Check whether the second argument is null: false.* 匹配到的元操作或API：
query: Check whether the second argument is null: false.
most similar API: Check whether is null check
cosine Similarity: 0.8154923915863037
*Get the first argument of the called method: `""`.* 匹配到的元操作或API：
logic: Get the first argument of the called method: `""`.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8923133015632629
*Check whether the first argument is a string literal: true.* 匹配到的元操作或API：
query: Check whether the first argument is a string literal: true.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8777529001235962
*Get the second argument of the called method: `str`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the second argument is a string literal: false.* 匹配到的元操作或API：
query: Check whether the second argument is a string literal: false.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8679952025413513
*Check whether the second argument is null: false.* 匹配到的元操作或API：
query: Check whether the second argument is null: false.
most similar API: Check whether is null check
cosine Similarity: 0.8154923915863037
*Get the first method call within bar: `str.equals(str, "")`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the called method is equals: true.* 匹配到的元操作或API：
query: Check whether the called method is equals: true.
most similar API: Check whether the method call equals
cosine Similarity: 0.9226872324943542
*Get the number of arguments of the called method: 2.* 匹配到的元操作或API：
logic: Get the number of arguments of the called method: 2.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.938377857208252
*Check whether the number of arguments is 2: true.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of the called method: `str`.* 匹配到的元操作或API：
query: Get the first argument of the called method: `str`.
most similar API: get arguments of method call
cosine Similarity: 0.8152102828025818
*Check whether the first argument is a string literal: false.* 匹配到的元操作或API：
query: Check whether the first argument is a string literal: false.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8712241649627686
*Get the second argument of the called method: `""`.* 匹配到的元操作或API：
logic: Get the second argument of the called method: `""`.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8774833679199219
*Check whether the second argument is a string literal: true.* 匹配到的元操作或API：
query: Check whether the second argument is a string literal: true.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8762274384498596
*Check whether the second argument is null: false.* 匹配到的元操作或API：
query: Check whether the second argument is null: false.
most similar API: Check whether is null check
cosine Similarity: 0.8154923915863037
*Get the second argument of the called method: `""`.* 匹配到的元操作或API：
logic: Get the second argument of the called method: `""`.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8774833679199219
*Check whether the second argument is a string literal: true.* 匹配到的元操作或API：
query: Check whether the second argument is a string literal: true.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8762274384498596
*Get the first argument of the called method: `str`.* 匹配到的元操作或API：
query: Get the first argument of the called method: `str`.
most similar API: get arguments of method call
cosine Similarity: 0.8152102828025818
*Check whether the first argument is a string literal: false.* 匹配到的元操作或API：
query: Check whether the first argument is a string literal: false.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8712241649627686
*Check whether the first argument is null: false.* 匹配到的元操作或API：
query: Check whether the first argument is null: false.
most similar API: Check whether is null check
cosine Similarity: 0.82399982213974
*Get the second argument of the called method: `""`.* 匹配到的元操作或API：
logic: Get the second argument of the called method: `""`.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8774833679199219
*Check whether the second argument is a string literal: true.* 匹配到的元操作或API：
query: Check whether the second argument is a string literal: true.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8762274384498596
*Get the first argument of the called method: `str`.* 匹配到的元操作或API：
query: Get the first argument of the called method: `str`.
most similar API: get arguments of method call
cosine Similarity: 0.8152102828025818
*Check whether the first argument is a string literal: false.* 匹配到的元操作或API：
query: Check whether the first argument is a string literal: false.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8712241649627686
*Check whether the first argument is null: false.* 匹配到的元操作或API：
query: Check whether the first argument is null: false.
most similar API: Check whether is null check
cosine Similarity: 0.82399982213974
*Get the second argument of the called method: `""`.* 匹配到的元操作或API：
logic: Get the second argument of the called method: `""`.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8774833679199219
*Check whether the second argument is a string literal: true.* 匹配到的元操作或API：
query: Check whether the second argument is a string literal: true.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8762274384498596
*Get the first argument of the called method: `str`.* 匹配到的元操作或API：
query: Get the first argument of the called method: `str`.
most similar API: get arguments of method call
cosine Similarity: 0.8152102828025818
*Check whether the first argument is a string literal: false.* 匹配到的元操作或API：
query: Check whether the first argument is a string literal: false.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8712241649627686
*Check whether the first argument is null: false.* 匹配到的元操作或API：
query: Check whether the first argument is null: false.
most similar API: Check whether is null check
cosine Similarity: 0.82399982213974
*Get the second argument of the called method: `""`.* 匹配到的元操作或API：
logic: Get the second argument of the called method: `""`.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8774833679199219
*Check whether the second argument is a string literal: true.* 匹配到的元操作或API：
query: Check whether the second argument is a string literal: true.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8762274384498596
*Get the first argument of the called method: `str`.* 匹配到的元操作或API：
query: Get the first argument of the called method: `str`.
most similar API: get arguments of method call
cosine Similarity: 0.8152102828025818
*Check whether the first argument is a string literal: false.* 匹配到的元操作或API：
query: Check whether the first argument is a string literal: false.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8712241649627686
*Check whether the first argument is null: false.* 匹配到的元操作或API：
query: Check whether the first argument is null: false.
most similar API: Check whether is null check
cosine Similarity: 0.82399982213974
*Get the second argument of the called method: `""`.* 匹配到的元操作或API：
logic: Get the second argument of the called method: `""`.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8774833679199219
*Check whether the second argument is a string literal: true.* 匹配到的元操作或API：
query: Check whether the second argument is a string literal: true.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8762274384498596
*Get the first method call within bar: `str.equals(str, "")`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the called method is equals: true.* 匹配到的元操作或API：
query: Check whether the called method is equals: true.
most similar API: Check whether the method call equals
cosine Similarity: 0.9226872324943542
*Get the number of arguments of the called method: 2.* 匹配到的元操作或API：
logic: Get the number of arguments of the called method: 2.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.938377857208252
*Check whether the number of arguments is 2: true.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of the called method: `str`.* 匹配到的元操作或API：
query: Get the first argument of the called method: `str`.
most similar API: get arguments of method call
cosine Similarity: 0.8152102828025818
*Check whether the first argument is a string literal: false.* 匹配到的元操作或API：
query: Check whether the first argument is a string literal: false.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8712241649627686
*Get the second argument of the called method: `""`.* 匹配到的元操作或API：
logic: Get the second argument of the called method: `""`.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8774833679199219
*Check whether the second argument is a string literal: true.* 匹配到的元操作或API：
query: Check whether the second argument is a string literal: true.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8762274384498596
*Check whether the second argument is null: false.* 匹配到的元操作或API：
query: Check whether the second argument is null: false.
most similar API: Check whether is null check
cosine Similarity: 0.8154923915863037
*Get the second method call within bar: `str.equals(str, "")`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the called method is equals: true.* 匹配到的元操作或API：
query: Check whether the called method is equals: true.
most similar API: Check whether the method call equals
cosine Similarity: 0.9226872324943542
*Get the number of arguments of the called method: 2.* 匹配到的元操作或API：
logic: Get the number of arguments of the called method: 2.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.938377857208252
*Check whether the number of arguments is 2: true.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of the called method: `str`.* 匹配到的元操作或API：
query: Get the first argument of the called method: `str`.
most similar API: get arguments of method call
cosine Similarity: 0.8152102828025818
*Check whether the first argument is a string literal: false.* 匹配到的元操作或API：
query: Check whether the first argument is a string literal: false.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8712241649627686
*Get the second argument of the called method: `""`.* 匹配到的元操作或API：
logic: Get the second argument of the called method: `""`.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8774833679199219
*Check whether the second argument is a string literal: true.* 匹配到的元操作或API：
query: Check whether the second argument is a string literal: true.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8762274384498596
*Check whether the second argument is null: false.* 匹配到的元操作或API：
query: Check whether the second argument is null: false.
most similar API: Check whether is null check
cosine Similarity: 0.8154923915863037
*Get the third method call within bar: `str.equals(str, "")`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the called method is equals: true.* 匹配到的元操作或API：
query: Check whether the called method is equals: true.
most similar API: Check whether the method call equals
cosine Similarity: 0.9226872324943542
*Get the number of arguments of the called method: 2.* 匹配到的元操作或API：
logic: Get the number of arguments of the called method: 2.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.938377857208252
*Check whether the number of arguments is 2: true.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of the called method: `str`.* 匹配到的元操作或API：
query: Get the first argument of the called method: `str`.
most similar API: get arguments of method call
cosine Similarity: 0.8152102828025818
*Check whether the first argument is a string literal: false.* 匹配到的元操作或API：
query: Check whether the first argument is a string literal: false.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8712241649627686
*Get the second argument of the called method: `""`.* 匹配到的元操作或API：
logic: Get the second argument of the called method: `""`.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8774833679199219
*Check whether the second argument is a string literal: true.* 匹配到的元操作或API：
query: Check whether the second argument is a string literal: true.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8762274384498596
*Check whether the second argument is null: false.* 匹配到的元操作或API：
query: Check whether the second argument is null: false.
most similar API: Check whether is null check
cosine Similarity: 0.8154923915863037
*Get the fourth method call within bar: `str.equals(str, "")`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the called method is equals: true.* 匹配到的元操作或API：
query: Check whether the called method is equals: true.
most similar API: Check whether the method call equals
cosine Similarity: 0.9226872324943542
*Get the number of arguments of the called method: 2.* 匹配到的元操作或API：
logic: Get the number of arguments of the called method: 2.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.938377857208252
*Check whether the number of arguments is 2: true.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of the called method: `str`.* 匹配到的元操作或API：
query: Get the first argument of the called method: `str`.
most similar API: get arguments of method call
cosine Similarity: 0.8152102828025818
*Check whether the first argument is a string literal: false.* 匹配到的元操作或API：
query: Check whether the first argument is a string literal: false.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8712241649627686
*Get the second argument of the called method: `""`.* 匹配到的元操作或API：
logic: Get the second argument of the called method: `""`.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8774833679199219
*Check whether the second argument is a string literal: true.* 匹配到的元操作或API：
query: Check whether the second argument is a string literal: true.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8762274384498596
*Check whether the second argument is null: false.* 匹配到的元操作或API：
query: Check whether the second argument is null: false.
most similar API: Check whether is null check
cosine Similarity: 0.8154923915863037
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
The test case corresponding to the rule:
```
// ok, empty literal in .equals comparison
public class Foo {
    void bar(String str) {
        if ((str == null) || (str.equals(""))) {
            str = "snafu";
        }
        if (str == null || str.equals("")) {
            str = "snafu";
        }
        if ((str != null) && (str.equals(""))) {
            str = "snafu";
        }
        if (str != null && str.equals("")) {
            str = "snafu";
        }
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 4

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTArgumentList (size = 1)
                ——ASTStringLiteral
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTAssignmentExpression
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTStringLiteral
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTArgumentList (size = 1)
                ——ASTStringLiteral
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTAssignmentExpression
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTStringLiteral
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTArgumentList (size = 1)
                ——ASTStringLiteral
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTAssignmentExpression
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTStringLiteral
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTArgumentList (size = 1)
                ——ASTStringLiteral
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTAssignmentExpression
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTStringLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isNullLiteral(), //Returns true if this is the {@linkplain ASTNullLiteral null literal}.
5. net.sourceforge.pmd.lang.java.ast.ASTArgumentList: public boolean equals(java.lang.Object)
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.ast.impl.javacc.JavaccToken getFirstToken()
7. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
8. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullCheck(net.sourceforge.pmd.lang.java.ast.ASTExpression, net.sourceforge.pmd.lang.java.rule.internal.StablePathMatcher)

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
2.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import java.util.Arrays;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public LiteralsFirstInComparisonsRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        NodeStream<ASTMethodCall> methodCalls = node.descendants(ASTMethodCall.class);
        methodCalls.forEach(methodCall -> {
            String methodName = methodCall.getName();
            if (Arrays.asList("equals", "equalsIgnoreCase", "compareTo", "compareToIgnoreCase", "contentEquals").contains(methodName)) {
                int argumentNumber = getArgumentNumber(methodCall);
                if (argumentNumber == 1) {
                    ASTExpression argument = methodCall.getArguments().get(0);
                    if (!argument.isStringLiteral() && methodCall.getParent().getPreviousSibling() == null) {
                        ASTExpression receiver = methodCall.getFirstChild();
                        if (receiver.isStringLiteral() || receiver.isA(String.class)) {
                            addViolation(data, methodCall);
                        }
                    } else if (argument.isStringLiteral()) {
                        ASTExpression receiver = methodCall.getFirstChild();
                        if (!receiver.isStringLiteral() && !isMethodCallArgumentStringType(methodCall)) {
                            addViolation(data, methodCall);
                        }
                    }
                }
            }
        });
        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
It seems there is a misunderstanding in your test case description. The test case provided actually adheres to the rule of positioning literals first in all String comparison methods. However, if you intended to provide a test case that violates the rule, here is a corrected version of the test case with violations:

```java
// bad, non-literal first in .equals comparison
public class Foo {
    void bar(String str) {
        if (str.equals("")) { // violation
            str = "snafu";
        }
        if (str.equalsIgnoreCase("")) { // violation
            str = "snafu";
        }
        if (str.compareTo("") == 0) { // violation
            str = "snafu";
        }
        if (str.compareToIgnoreCase("") == 0) { // violation
            str = "snafu";
        }
        if (str.contentEquals("")) { // violation
            str = "snafu";
        }
    }
}
```

Now, let's perform the granular checks on this test case:

1. Get the method call where the method name is equals.
2. Get the first argument of the called method.
3. Check whether the first argument is a string literal.
4. Check whether the method caller is a string type.
5. Get the method call where the method name is equalsIgnoreCase.
6. Get the first argument of the called method.
7. Check whether the first argument is a string literal.
8. Check whether the method caller is a string type.
9. Get the method call where the method name is compareTo.
10. Get the first argument of the called method.
11. Check whether the first argument is a string literal.
12. Check whether the method caller is a string type.
13. Get the method call where the method name is compareToIgnoreCase.
14. Get the first argument of the called method.
15. Check whether the first argument is a string literal.
16. Check whether the method caller is a string type.
17. Get the method call where the method name is contentEquals.
18. Get the first argument of the called method.
19. Check whether the first argument is a string literal.
20. Check whether the method caller is a string type.

Each of these checks will reveal that the first argument of the method calls is not a string literal, thus violating the rule. The rule states that literals should be positioned first in String comparison methods to avoid NullPointerExceptions. The provided test case positions the non-literal `str` first in the comparison methods, which is incorrect according to the rule.
['Get the method call where the method name is equals.', 'Get the first argument of the called method.', 'Check whether the first argument is a string literal.', 'Check whether the method caller is a string type.', 'Get the method call where the method name is equalsIgnoreCase.', 'Get the first argument of the called method.', 'Check whether the first argument is a string literal.', 'Check whether the method caller is a string type.', 'Get the method call where the method name is compareTo.', 'Get the first argument of the called method.', 'Check whether the first argument is a string literal.', 'Check whether the method caller is a string type.', 'Get the method call where the method name is compareToIgnoreCase.', 'Get the first argument of the called method.', 'Check whether the first argument is a string literal.', 'Check whether the method caller is a string type.', 'Get the method call where the method name is contentEquals.', 'Get the first argument of the called method.', 'Check whether the first argument is a string literal.', 'Check whether the method caller is a string type.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTExpressionStatement', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTIfStatement', 'ASTNullLiteral', 'ASTMethodDeclaration', 'ASTAssignmentExpression', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTInfixExpression']
*Get the method call where the method name is equals.* 匹配到的元操作或API：
query: Get the method call where the method name is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.8683843612670898
*Get the first argument of the called method.* 匹配到的元操作或API：
logic: Get the first argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9071929454803467
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803800344467163
*Check whether the method caller is a string type.* 匹配到的元操作或API：
logic: Check whether the method caller is a string type.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.9876717925071716
*Get the method call where the method name is equalsIgnoreCase.* 匹配到的元操作或API：
query: Get the method call where the method name is equalsIgnoreCase.
most similar API: Check whether the method call equals
cosine Similarity: 0.8097028136253357
*Get the first argument of the called method.* 匹配到的元操作或API：
logic: Get the first argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9071929454803467
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803800344467163
*Check whether the method caller is a string type.* 匹配到的元操作或API：
logic: Check whether the method caller is a string type.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.9876717925071716
*Get the method call where the method name is compareTo.* 匹配到的元操作或API：
query: Get the method call where the method name is compareTo.
most similar API: get method name of method call
cosine Similarity: 0.8270139694213867
*Get the first argument of the called method.* 匹配到的元操作或API：
logic: Get the first argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9071929454803467
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803800344467163
*Check whether the method caller is a string type.* 匹配到的元操作或API：
logic: Check whether the method caller is a string type.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.9876717925071716
*Get the method call where the method name is compareToIgnoreCase.* 匹配到的元操作或API：
query: Get the method call where the method name is compareToIgnoreCase.
most similar API: get method name of method call
cosine Similarity: 0.8069533705711365
*Get the first argument of the called method.* 匹配到的元操作或API：
logic: Get the first argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9071929454803467
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803800344467163
*Check whether the method caller is a string type.* 匹配到的元操作或API：
logic: Check whether the method caller is a string type.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.9876717925071716
*Get the method call where the method name is contentEquals.* 匹配到的元操作或API：
query: Get the method call where the method name is contentEquals.
most similar API: get method name of method call
cosine Similarity: 0.8008782267570496
*Get the first argument of the called method.* 匹配到的元操作或API：
logic: Get the first argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9071929454803467
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803800344467163
*Check whether the method caller is a string type.* 匹配到的元操作或API：
logic: Check whether the method caller is a string type.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.9876717925071716
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
The test case corresponding to the rule:
```
// ok, empty literal in .equals comparison
public class Foo {
    void bar(String str) {
        if ((str == null) || (str.equals(""))) {
            str = "snafu";
        }
        if (str == null || str.equals("")) {
            str = "snafu";
        }
        if ((str != null) && (str.equals(""))) {
            str = "snafu";
        }
        if (str != null && str.equals("")) {
            str = "snafu";
        }
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 4

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTArgumentList (size = 1)
                ——ASTStringLiteral
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTAssignmentExpression
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTStringLiteral
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTArgumentList (size = 1)
                ——ASTStringLiteral
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTAssignmentExpression
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTStringLiteral
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTArgumentList (size = 1)
                ——ASTStringLiteral
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTAssignmentExpression
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTStringLiteral
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTArgumentList (size = 1)
                ——ASTStringLiteral
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTAssignmentExpression
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTStringLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()

1.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
2.  //Check whether the method caller is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallerStringType(ASTMethodCall node){
    return TypeTestUtil.isA(String.class, node.getQualifier());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.bestpractices;

import java.util.Arrays;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        if (Arrays.asList("equals", "equalsIgnoreCase", "compareTo", "compareToIgnoreCase", "contentEquals").contains(methodName)) {
            ASTArgumentList arguments = node.getArguments();
            if (arguments.getNumChildren() == 1) {
                ASTExpression firstArgument = arguments.getFirstChild();
                if (firstArgument instanceof ASTVariableAccess && isMethodCallerStringType(node)) {
                    ASTExpression secondArgument = arguments.get(0);
                    if (secondArgument instanceof ASTStringLiteral) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    // Check whether the method caller is string type
    public boolean isMethodCallerStringType(ASTMethodCall node) {
        return TypeTestUtil.isA(String.class, node.getQualifier());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
Let's perform granular checks on each line of the given test case to ascertain adherence to the rule.

1. Check whether the called method name is equals.
2. Get the number of arguments of called method.
3. Get an argument of called method.
4. Check whether the argument is a literal.
5. Get the method caller.
6. Check whether the method caller is null.
7. Get the number of arguments of called method.
8. Get an argument of called method.
9. Check whether the argument is a literal.

Let's break down each line:

Line 1: `if ((str == null) || (str.equals(""))) {`
1. Check whether the called method name is equals.
   - The called method name is equals.
2. Get the number of arguments of called method.
   - The number of arguments is 1.
3. Get an argument of called method.
   - The argument is "".
4. Check whether the argument is a literal.
   - The argument is a string literal.
5. Get the method caller.
   - The method caller is str.
6. Check whether the method caller is null.
   - The method caller is not null here, but its null check is done in the same condition.

Line 2: `if (str == null || str.equals("")) {`
1. Check whether the called method name is equals.
   - The called method name is equals.
2. Get the number of arguments of called method.
   - The number of arguments is 1.
3. Get an argument of called method.
   - The argument is "".
4. Check whether the argument is a literal.
   - The argument is a string literal.
5. Get the method caller.
   - The method caller is str.
6. Check whether the method caller is null.
   - The method caller is not null here, but its null check is done in the same condition.

Line 3: `if ((str != null) && (str.equals(""))) {`
1. Check whether the called method name is equals.
   - The called method name is equals.
2. Get the number of arguments of called method.
   - The number of arguments is 1.
3. Get an argument of called method.
   - The argument is "".
4. Check whether the argument is a literal.
   - The argument is a string literal.
5. Get the method caller.
   - The method caller is str.
6. Check whether the method caller is null.
   - The method caller is not null here, but its null check is done in the same condition.

Line 4: `if (str != null && str.equals("")) {`
1. Check whether the called method name is equals.
   - The called method name is equals.
2. Get the number of arguments of called method.
   - The number of arguments is 1.
3. Get an argument of called method.
   - The argument is "".
4. Check whether the argument is a literal.
   - The argument is a string literal.
5. Get the method caller.
   - The method caller is str.
6. Check whether the method caller is null.
   - The method caller is not null here, but its null check is done in the same condition.

None of the lines in the test case violate the rule because the literal `""` is always placed as the second argument in the `equals` method call and is not reassigned. Additionally, the `null` check is handled correctly to avoid `NullPointerException`.

However, if the rule description means that the literal should be placed first in the method signature, then we need to check the method call structure:

Line 1: `if ((str == null) || (str.equals(""))) {`
1. Check whether the called method name is equals.
   - The called method name is equals.
2. Get the number of arguments of called method.
   - The number of arguments is 1.
3. Get an argument of called method.
   - The argument is "".
4. Get the method caller.
   - The method caller is str.
5. Check whether the argument is a literal.
   - The argument is a string literal.
6. Check whether the literal is the first argument in the method call.
   - The literal is the second argument in the method call, which violates the rule.

Line 2: `if (str == null || str.equals("")) {`
1. Check whether the called method name is equals.
   - The called method name is equals.
2. Get the number of arguments of called method.
   - The number of arguments is 1.
3. Get an argument of called method.
   - The argument is "".
4. Get the method caller.
   - The method caller is str.
5. Check whether the argument is a literal.
   - The argument is a string literal.
6. Check whether the literal is the first argument in the method call.
   - The literal is the second argument in the method call, which violates the rule.

Line 3: `if ((str != null) && (str.equals(""))) {`
1. Check whether the called method name is equals.
   - The called method name is equals.
2. Get the number of arguments of called method.
   - The number of arguments is 1.
3. Get an argument of called method.
   - The argument is "".
4. Get the method caller.
   - The method caller is str.
5. Check whether the argument is a literal.
   - The argument is a string literal.
6. Check whether the literal is the first argument in the method call.
   - The literal is the second argument in the method call, which violates the rule.

Line 4: `if (str != null && str.equals("")) {`
1. Check whether the called method name is equals.
   - The called method name is equals.
2. Get the number of arguments of called method.
   - The number of arguments is 1.
3. Get an argument of called method.
   - The argument is "".
4. Get the method caller.
   - The method caller is str.
5. Check whether the argument is a literal.
   - The argument is a string literal.
6. Check whether the literal is the first argument in the method call.
   - The literal is the second argument in the method call, which violates the rule.

Upon reviewing these granular checks, we can see that all lines in the test case violate the rule because the literal `""` is not placed as the first argument in the `equals` method calls.
['Check whether the called method name is equals.', 'Get the number of arguments of called method.', 'Get an argument of called method.', 'Check whether the argument is a literal.', 'Get the method caller.', 'Check whether the method caller is null.', 'Get the number of arguments of called method.', 'Get an argument of called method.', 'Check whether the argument is a literal.', 'Check whether the called method name is equals.', 'Get the number of arguments of called method.', 'Get an argument of called method.', 'Check whether the argument is a literal.', 'Get the method caller.', 'Check whether the method caller is null.', 'Check whether the called method name is equals.', 'Get the number of arguments of called method.', 'Get an argument of called method.', 'Check whether the argument is a literal.', 'Get the method caller.', 'Check whether the method caller is null.', 'Check whether the called method name is equals.', 'Get the number of arguments of called method.', 'Get an argument of called method.', 'Check whether the argument is a literal.', 'Get the method caller.', 'Check whether the method caller is null.', 'Check whether the called method name is equals.', 'Get the number of arguments of called method.', 'Get an argument of called method.', 'Check whether the argument is a literal.', 'Get the method caller.', 'Check whether the method caller is null.', 'Check whether the called method name is equals.', 'Get the number of arguments of called method.', 'Get an argument of called method.', 'Get the method caller.', 'Check whether the argument is a literal.', 'Check whether the literal is the first argument in the method call.', 'Check whether the called method name is equals.', 'Get the number of arguments of called method.', 'Get an argument of called method.', 'Get the method caller.', 'Check whether the argument is a literal.', 'Check whether the literal is the first argument in the method call.', 'Check whether the called method name is equals.', 'Get the number of arguments of called method.', 'Get an argument of called method.', 'Get the method caller.', 'Check whether the argument is a literal.', 'Check whether the literal is the first argument in the method call.', 'Check whether the called method name is equals.', 'Get the number of arguments of called method.', 'Get an argument of called method.', 'Get the method caller.', 'Check whether the argument is a literal.', 'Check whether the literal is the first argument in the method call.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTExpressionStatement', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTIfStatement', 'ASTNullLiteral', 'ASTMethodDeclaration', 'ASTAssignmentExpression', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTInfixExpression']
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9280144572257996
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a literal.* 匹配到的元操作或API：
query: Check whether the argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8468949198722839
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796929359436035
*Check whether the method caller is null.* 匹配到的元操作或API：
query: Check whether the method caller is null.
most similar API: Check whether is null check
cosine Similarity: 0.8236193656921387
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a literal.* 匹配到的元操作或API：
query: Check whether the argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8468949198722839
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9280144572257996
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a literal.* 匹配到的元操作或API：
query: Check whether the argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8468949198722839
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796929359436035
*Check whether the method caller is null.* 匹配到的元操作或API：
query: Check whether the method caller is null.
most similar API: Check whether is null check
cosine Similarity: 0.8236193656921387
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9280144572257996
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a literal.* 匹配到的元操作或API：
query: Check whether the argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8468949198722839
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796929359436035
*Check whether the method caller is null.* 匹配到的元操作或API：
query: Check whether the method caller is null.
most similar API: Check whether is null check
cosine Similarity: 0.8236193656921387
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9280144572257996
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a literal.* 匹配到的元操作或API：
query: Check whether the argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8468949198722839
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796929359436035
*Check whether the method caller is null.* 匹配到的元操作或API：
query: Check whether the method caller is null.
most similar API: Check whether is null check
cosine Similarity: 0.8236193656921387
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9280144572257996
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a literal.* 匹配到的元操作或API：
query: Check whether the argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8468949198722839
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796929359436035
*Check whether the method caller is null.* 匹配到的元操作或API：
query: Check whether the method caller is null.
most similar API: Check whether is null check
cosine Similarity: 0.8236193656921387
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9280144572257996
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796929359436035
*Check whether the argument is a literal.* 匹配到的元操作或API：
query: Check whether the argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8468949198722839
*Check whether the literal is the first argument in the method call.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9280144572257996
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796929359436035
*Check whether the argument is a literal.* 匹配到的元操作或API：
query: Check whether the argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8468949198722839
*Check whether the literal is the first argument in the method call.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9280144572257996
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796929359436035
*Check whether the argument is a literal.* 匹配到的元操作或API：
query: Check whether the argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8468949198722839
*Check whether the literal is the first argument in the method call.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9280144572257996
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796929359436035
*Check whether the argument is a literal.* 匹配到的元操作或API：
query: Check whether the argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8468949198722839
*Check whether the literal is the first argument in the method call.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
The test case corresponding to the rule:
```
// ok, empty literal in .equals comparison
public class Foo {
    void bar(String str) {
        if ((str == null) || (str.equals(""))) {
            str = "snafu";
        }
        if (str == null || str.equals("")) {
            str = "snafu";
        }
        if ((str != null) && (str.equals(""))) {
            str = "snafu";
        }
        if (str != null && str.equals("")) {
            str = "snafu";
        }
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 4

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTArgumentList (size = 1)
                ——ASTStringLiteral
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTAssignmentExpression
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTStringLiteral
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTArgumentList (size = 1)
                ——ASTStringLiteral
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTAssignmentExpression
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTStringLiteral
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTArgumentList (size = 1)
                ——ASTStringLiteral
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTAssignmentExpression
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTStringLiteral
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTArgumentList (size = 1)
                ——ASTStringLiteral
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTAssignmentExpression
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTStringLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
3. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isBooleanLiteral(net.sourceforge.pmd.lang.java.ast.JavaNode), //Returns true if the node is a boolean literal with any value.
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()
5. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullCheck(net.sourceforge.pmd.lang.java.ast.ASTExpression, net.sourceforge.pmd.lang.java.rule.internal.StablePathMatcher)

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        if (isStringComparisonMethod(node)) {
            ASTArgumentList arguments = node.getArguments();
            // Use the getArgumentNumber method to get the number of arguments
            int argumentNumber = getArgumentNumber(node);
            if (argumentNumber == 1 && arguments.getFirstChild() instanceof ASTVariableAccess) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    private boolean isStringComparisonMethod(ASTMethodCall node) {
        String methodName = node.getName();
        if ("equals".equals(methodName) || "equalsIgnoreCase".equals(methodName) ||
            "compareTo".equals(methodName) || "compareToIgnoreCase".equals(methodName) ||
            "contentEquals".equals(methodName)) {
            JType qualifierType = node.getQualifier().getType();
            return qualifierType != null && qualifierType.isSubtypeOf(String.class);
        }
        return false;
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node){
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 2
2084
1665
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of called method.
2. Check whether the called method name is equalsIgnoreCase.
3. Get the number of arguments of called method.
4. Check whether the number of arguments is 1.
5. Get the first argument of called method.
6. Check whether the first argument is a string literal.
7. Check whether the first argument is an accessed variable.
8. Get the type of accessed variable.
9. Check whether the accessed variable is string type.
10. If the called method name is equalsIgnoreCase and the number of arguments is 1, check whether the first argument is a string literal or if the first argument is an accessed variable of string type and if it's not the literal, then it violates the rule.

In this specific test case:
11. The called method name is equalsIgnoreCase.
12. The number of arguments is 1.
13. The argument is x, which is an accessed variable.
14. The type of accessed variable x is string type.
15. Since the argument is not a string literal, this test case violates the rule.
            
['Get the name of called method.', 'Check whether the called method name is equalsIgnoreCase.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 1.', 'Get the first argument of called method.', 'Check whether the first argument is a string literal.', 'Check whether the first argument is an accessed variable.', 'Get the type of accessed variable.', 'Check whether the accessed variable is string type.', "If the called method name is equalsIgnoreCase and the number of arguments is 1, check whether the first argument is a string literal or if the first argument is an accessed variable of string type and if it's not the literal, then it violates the rule.", 'The called method name is equalsIgnoreCase.', 'The number of arguments is 1.', 'The argument is x, which is an accessed variable.', 'The type of accessed variable x is string type.', 'Since the argument is not a string literal, this test case violates the rule.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the called method name is equalsIgnoreCase.* 匹配到的元操作或API：
query: Check whether the called method name is equalsIgnoreCase.
most similar API: Check whether the method call equals
cosine Similarity: 0.8475643396377563
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of called method.* 匹配到的元操作或API：
logic: Get the first argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9160765409469604
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803800344467163
*Check whether the first argument is an accessed variable.* 匹配到的元操作或API：
logic: Check whether the first argument is an accessed variable.
most similar meta operation: Check whether the accessed variable is a local variable
cosine Similarity: 0.8743626475334167
*Get the type of accessed variable.* 匹配到的元操作或API：
logic: Get the type of accessed variable.
most similar meta operation: Get the type of accessed variable
cosine Similarity: 0.9871194362640381
*Check whether the accessed variable is string type.* 匹配到的元操作或API：
logic: Check whether the accessed variable is string type.
most similar meta operation: Check whether the accessed variable is string type
cosine Similarity: 0.9884957075119019
*If the called method name is equalsIgnoreCase and the number of arguments is 1, check whether the first argument is a string literal or if the first argument is an accessed variable of string type and if it's not the literal, then it violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*The called method name is equalsIgnoreCase.* 匹配到的元操作或API：
未匹配成功元操作或API
*The number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*The argument is x, which is an accessed variable.* 匹配到的元操作或API：
未匹配成功元操作或API
*The type of accessed variable x is string type.* 匹配到的元操作或API：
未匹配成功元操作或API
*Since the argument is not a string literal, this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
The test case corresponding to the rule:
```
// bad, literal comes last in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'boolean')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTMethodCall (called method name = 'equalsIgnoreCase')
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
4. net.sourceforge.pmd.lang.java.ast.ASTVariableAccess: public net.sourceforge.pmd.lang.java.types.JTypeMirror getTypeMirror()

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
2.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
3.  //Check whether the accessed variable is a local variable
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JLocalVariableSymbol;
public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JLocalVariableSymbol) {
        JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
        return true;
    }
    return false;
}
```
4.  //Check whether the accessed variable is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTVariableAccess var){
    return TypeTestUtil.isA(String.class, var.getTypeMirror());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        if (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || methodName.equals("contentEquals")) {
            ASTArgumentList arguments = node.getArguments();
            if (getArgumentNumber(node) == 2) {
                ASTExpression firstArgument = arguments.get(0);
                ASTExpression secondArgument = arguments.get(1);
                if (firstArgument instanceof ASTVariableAccess && secondArgument instanceof ASTStringLiteral) {
                    if (isVariableAccessStringType((ASTVariableAccess) firstArgument)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var) {
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Get the signature of method.
3. Check whether the method has a return type of boolean.
4. Get all the method calls within the method.
5. Check whether the name of called method is equals.
6. Check whether the name of called method is equalsIgnoreCase.
7. Check whether the name of called method is compareTo.
8. Check whether the name of called method is compareToIgnoreCase.
9. Check whether the name of called method is contentEquals.
10. If the called method name is equalsIgnoreCase, get the argument list.
11. Get the size of the argument list.
12. Check whether the size of the argument list is 2.
13. Get the first argument of the called method.
14. Get the second argument of the called method.
15. Check whether the second argument is a string literal.
16. If the second argument is not a string literal, check whether the second argument is null.
17. If the second argument is a string literal, check whether the first argument is a string literal.
18. If the first argument is not a string literal, then this test case might violate the rule.
19. If the first argument is not a string literal and the second argument is not null, then this test case violates the rule.

In your specific test case:
- The called method name is equalsIgnoreCase.
- The size of the argument list is 2.
- The first argument is `x` (not a string literal).
- The second argument is `"2"` (a string literal).

Since the second argument is a string literal and the first argument is not, your test case does not violate the rule as described. However, based on your description, it seems you want to check if the string literal is the second argument, which is not the case here. Therefore, your test case does not violate the rule according to the provided rule description. If you intended to check whether the literal is first, then the current test case would not be a violation because `"2"` is not the first argument.

If you want to enforce that the literal should be the first argument, the steps would be:
- Check whether the first argument is a string literal.
- Check whether the second argument is not a string literal.
- If both conditions are true, then the test case violates the rule.

In this specific test case:
- The first argument is not a string literal.
- The second argument is a string literal.

These conditions do not match the intended rule to position literals first. Therefore, there is no violation in your test case based on the provided rule description.
['Get the name of method.', 'Get the signature of method.', 'Check whether the method has a return type of boolean.', 'Get all the method calls within the method.', 'Check whether the name of called method is equals.', 'Check whether the name of called method is equalsIgnoreCase.', 'Check whether the name of called method is compareTo.', 'Check whether the name of called method is compareToIgnoreCase.', 'Check whether the name of called method is contentEquals.', 'If the called method name is equalsIgnoreCase, get the argument list.', 'Get the size of the argument list.', 'Check whether the size of the argument list is 2.', 'Get the first argument of the called method.', 'Get the second argument of the called method.', 'Check whether the second argument is a string literal.', 'If the second argument is not a string literal, check whether the second argument is null.', 'If the second argument is a string literal, check whether the first argument is a string literal.', 'If the first argument is not a string literal, then this test case might violate the rule.', 'If the first argument is not a string literal and the second argument is not null, then this test case violates the rule.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827433228492737
*Check whether the method has a return type of boolean.* 匹配到的元操作或API：
logic: Check whether the method has a return type of boolean.
most similar meta operation: Check whether the return type of method is boolean
cosine Similarity: 0.9742351770401001
*Get all the method calls within the method.* 匹配到的元操作或API：
query: Get all the method calls within the method.
most similar API: get method name of method call
cosine Similarity: 0.8143250942230225
*Check whether the name of called method is equals.* 匹配到的元操作或API：
query: Check whether the name of called method is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9213377833366394
*Check whether the name of called method is equalsIgnoreCase.* 匹配到的元操作或API：
query: Check whether the name of called method is equalsIgnoreCase.
most similar API: Check whether the method call equals
cosine Similarity: 0.8542208671569824
*Check whether the name of called method is compareTo.* 匹配到的元操作或API：
query: Check whether the name of called method is compareTo.
most similar API: Check whether the method call equals
cosine Similarity: 0.8606489300727844
*Check whether the name of called method is compareToIgnoreCase.* 匹配到的元操作或API：
query: Check whether the name of called method is compareToIgnoreCase.
most similar API: Check whether the method call equals
cosine Similarity: 0.8259355425834656
*Check whether the name of called method is contentEquals.* 匹配到的元操作或API：
query: Check whether the name of called method is contentEquals.
most similar API: Check whether the method call equals
cosine Similarity: 0.8393856287002563
*If the called method name is equalsIgnoreCase, get the argument list.* 匹配到的元操作或API：
query: If the called method name is equalsIgnoreCase, get the argument list.
most similar API: get arguments of method call
cosine Similarity: 0.807245671749115
*Get the size of the argument list.* 匹配到的元操作或API：
query: Get the size of the argument list.
most similar API: size of argument list
cosine Similarity: 0.9323437213897705
*Check whether the size of the argument list is 2.* 匹配到的元操作或API：
query: Check whether the size of the argument list is 2.
most similar API: size of argument list
cosine Similarity: 0.8580411076545715
*Get the first argument of the called method.* 匹配到的元操作或API：
logic: Get the first argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9071929454803467
*Get the second argument of the called method.* 匹配到的元操作或API：
logic: Get the second argument of the called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8917081952095032
*Check whether the second argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the second argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8767277002334595
*If the second argument is not a string literal, check whether the second argument is null.* 匹配到的元操作或API：
query: If the second argument is not a string literal, check whether the second argument is null.
most similar API: Check whether the string literal is null literal
cosine Similarity: 0.8717223405838013
*If the second argument is a string literal, check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: If the second argument is a string literal, check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8704115152359009
*If the first argument is not a string literal, then this test case might violate the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the first argument is not a string literal and the second argument is not null, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
The test case corresponding to the rule:
```
// bad, literal comes last in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'boolean')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTMethodCall (called method name = 'equalsIgnoreCase')
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
5. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
6. net.sourceforge.pmd.lang.java.ast.ASTArgumentList: public int size(), //Returns the number of nodes in this list. This must be the number of nodes yielded by the {@link #iterator()}.
7. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isNullLiteral(), //Returns true if this is the {@linkplain ASTNullLiteral null literal}.

1.  //Check whether the return type of method is boolean
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueBooleanType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN)) {
        return true;
    }
    return false;
}
```
2.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        if (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || methodName.equals("contentEquals")) {
            ASTArgumentList argumentList = node.getArguments();
            if (argumentList.size() == 2) {
                ASTExpression firstArg = argumentList.get(0);
                ASTExpression secondArg = argumentList.get(1);
                if (TypeTestUtil.isA(String.class, secondArg.getTypeMirror()) && secondArg instanceof ASTStringLiteral && !((ASTStringLiteral) secondArg).isNullLiteral()) {
                    if (!(firstArg instanceof ASTStringLiteral)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    // Check whether the return type of method is boolean
    public boolean isReturnValueBooleanType(ASTMethodDeclaration method) {
        if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN)) {
            return true;
        }
        return false;
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the name of method is bar.
3. Get the return expression in return statement.
4. Check whether the return expression is a method call.
5. Get the name of called method.
6. Check whether the called method name is equalsIgnoreCase.
7. Get the number of arguments of called method.
8. Check whether the number of arguments is 1.
9. Get the argument of called method.
10. Check whether the argument is an accessed variable.
11. Get the type of accessed variable.
12. Check whether the type of accessed variable is String.
13. Get the literal value that the accessed variable is initialized to.
14. Check whether the literal value is null.
15. Get the type of the second argument of called method.
16. Check whether the type of the second argument is String literal.
17. Check whether the second argument is a literal value.
18. Get the literal value that the second argument is.
19. Check whether the literal value is not null.

Based on the test case provided:
1. Get the name of method.
2. Check whether the name of method is bar.
3. Get the return expression in return statement.
4. Check whether the return expression is a method call.
5. Get the name of called method.
6. Check whether the called method name is equalsIgnoreCase.
7. Get the number of arguments of called method.
8. Check whether the number of arguments is 1.
9. Get the argument of called method.
10. Check whether the argument is an accessed variable.
11. Get the type of accessed variable.
12. Check whether the type of accessed variable is String.
13. Check whether the accessed variable is being read.
14. Check whether the accessed variable is a formal parameter.
15. Get the type of the second argument of called method.
16. Check whether the type of the second argument is String literal.
17. Check whether the second argument is a literal value.
18. Get the literal value that the second argument is.
19. Check whether the literal value is not null.

In this test case:
- The method name is bar.
- The return expression is a method call.
- The called method name is equalsIgnoreCase.
- The number of arguments is 1.
- The argument is an accessed variable.
- The accessed variable is a formal parameter of type String.
- The argument is also a String literal, which is "2" and is not null.

Since the literal "2" is the second argument and not the first, this test case violates the rule. However, the rule description suggests that literals should be the first argument, and the second argument can be null to avoid NullPointerExceptions. In this case, the literal is not the first argument, so it does violate the rule. If the literal were the first argument, it would not violate the rule.
            
['Get the name of method.', 'Check whether the name of method is bar.', 'Get the return expression in return statement.', 'Check whether the return expression is a method call.', 'Get the name of called method.', 'Check whether the called method name is equalsIgnoreCase.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 1.', 'Get the argument of called method.', 'Check whether the argument is an accessed variable.', 'Get the type of accessed variable.', 'Check whether the type of accessed variable is String.', 'Get the literal value that the accessed variable is initialized to.', 'Check whether the literal value is null.', 'Get the type of the second argument of called method.', 'Check whether the type of the second argument is String literal.', 'Check whether the second argument is a literal value.', 'Get the literal value that the second argument is.', 'Check whether the literal value is not null.', 'Get the name of method.', 'Check whether the name of method is bar.', 'Get the return expression in return statement.', 'Check whether the return expression is a method call.', 'Get the name of called method.', 'Check whether the called method name is equalsIgnoreCase.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 1.', 'Get the argument of called method.', 'Check whether the argument is an accessed variable.', 'Get the type of accessed variable.', 'Check whether the type of accessed variable is String.', 'Check whether the accessed variable is being read.', 'Check whether the accessed variable is a formal parameter.', 'Get the type of the second argument of called method.', 'Check whether the type of the second argument is String literal.', 'Check whether the second argument is a literal value.', 'Get the literal value that the second argument is.', 'Check whether the literal value is not null.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the name of method is bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the return expression in return statement.* 匹配到的元操作或API：
logic: Get the return expression in return statement.
most similar meta operation: Get the return expression in return statement
cosine Similarity: 0.9881545901298523
*Check whether the return expression is a method call.* 匹配到的元操作或API：
query: Check whether the return expression is a method call.
most similar API: Check whether the method call is expression
cosine Similarity: 0.9155341386795044
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the called method name is equalsIgnoreCase.* 匹配到的元操作或API：
query: Check whether the called method name is equalsIgnoreCase.
most similar API: Check whether the method call equals
cosine Similarity: 0.8475643396377563
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the argument of called method.* 匹配到的元操作或API：
logic: Get the argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.97557133436203
*Check whether the argument is an accessed variable.* 匹配到的元操作或API：
logic: Check whether the argument is an accessed variable.
most similar meta operation: Check whether the accessed variable is a local variable
cosine Similarity: 0.8832410573959351
*Get the type of accessed variable.* 匹配到的元操作或API：
logic: Get the type of accessed variable.
most similar meta operation: Get the type of accessed variable
cosine Similarity: 0.9871194362640381
*Check whether the type of accessed variable is String.* 匹配到的元操作或API：
logic: Check whether the type of accessed variable is String.
most similar meta operation: Check whether the accessed variable is string type
cosine Similarity: 0.9779624342918396
*Get the literal value that the accessed variable is initialized to.* 匹配到的元操作或API：
logic: Get the literal value that the accessed variable is initialized to.
most similar meta operation: Get the literal value that the local variable is initialized to
cosine Similarity: 0.9277672171592712
*Check whether the literal value is null.* 匹配到的元操作或API：
query: Check whether the literal value is null.
most similar API: Check whether is null literal
cosine Similarity: 0.93576979637146
*Get the type of the second argument of called method.* 匹配到的元操作或API：
logic: Get the type of the second argument of called method.
most similar meta operation: Get the type of argument
cosine Similarity: 0.8669592142105103
*Check whether the type of the second argument is String literal.* 匹配到的元操作或API：
logic: Check whether the type of the second argument is String literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9083579778671265
*Check whether the second argument is a literal value.* 匹配到的元操作或API：
query: Check whether the second argument is a literal value.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8121298551559448
*Get the literal value that the second argument is.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the literal value is not null.* 匹配到的元操作或API：
query: Check whether the literal value is not null.
most similar API: Check whether is null literal
cosine Similarity: 0.9146169424057007
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the name of method is bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the return expression in return statement.* 匹配到的元操作或API：
logic: Get the return expression in return statement.
most similar meta operation: Get the return expression in return statement
cosine Similarity: 0.9881545901298523
*Check whether the return expression is a method call.* 匹配到的元操作或API：
query: Check whether the return expression is a method call.
most similar API: Check whether the method call is expression
cosine Similarity: 0.9155341386795044
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the called method name is equalsIgnoreCase.* 匹配到的元操作或API：
query: Check whether the called method name is equalsIgnoreCase.
most similar API: Check whether the method call equals
cosine Similarity: 0.8475643396377563
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the argument of called method.* 匹配到的元操作或API：
logic: Get the argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.97557133436203
*Check whether the argument is an accessed variable.* 匹配到的元操作或API：
logic: Check whether the argument is an accessed variable.
most similar meta operation: Check whether the accessed variable is a local variable
cosine Similarity: 0.8832410573959351
*Get the type of accessed variable.* 匹配到的元操作或API：
logic: Get the type of accessed variable.
most similar meta operation: Get the type of accessed variable
cosine Similarity: 0.9871194362640381
*Check whether the type of accessed variable is String.* 匹配到的元操作或API：
logic: Check whether the type of accessed variable is String.
most similar meta operation: Check whether the accessed variable is string type
cosine Similarity: 0.9779624342918396
*Check whether the accessed variable is being read.* 匹配到的元操作或API：
logic: Check whether the accessed variable is being read.
most similar meta operation: Check whether the accessed variable is being read
cosine Similarity: 0.9878707528114319
*Check whether the accessed variable is a formal parameter.* 匹配到的元操作或API：
logic: Check whether the accessed variable is a formal parameter.
most similar meta operation: Check whether the accessed variable is a formal parameter
cosine Similarity: 0.9881145358085632
*Get the type of the second argument of called method.* 匹配到的元操作或API：
logic: Get the type of the second argument of called method.
most similar meta operation: Get the type of argument
cosine Similarity: 0.8669592142105103
*Check whether the type of the second argument is String literal.* 匹配到的元操作或API：
logic: Check whether the type of the second argument is String literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9083579778671265
*Check whether the second argument is a literal value.* 匹配到的元操作或API：
query: Check whether the second argument is a literal value.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8121298551559448
*Get the literal value that the second argument is.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the literal value is not null.* 匹配到的元操作或API：
query: Check whether the literal value is not null.
most similar API: Check whether is null literal
cosine Similarity: 0.9146169424057007
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
The test case corresponding to the rule:
```
// bad, literal comes last in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'boolean')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTMethodCall (called method name = 'equalsIgnoreCase')
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getExpr()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
7. net.sourceforge.pmd.lang.java.ast.ASTVariableAccess: public net.sourceforge.pmd.lang.java.types.JTypeMirror getTypeMirror()
8. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isNullLiteral(net.sourceforge.pmd.lang.java.ast.ASTExpression)
9. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isBooleanLiteral(net.sourceforge.pmd.lang.java.ast.JavaNode), //Returns true if the node is a boolean literal with any value.

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
2.  //Check whether the accessed variable is a local variable
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JLocalVariableSymbol;
public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JLocalVariableSymbol) {
        JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
        return true;
    }
    return false;
}
```
3.  //Check whether the accessed variable is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTVariableAccess var){
    return TypeTestUtil.isA(String.class, var.getTypeMirror());
}
```
4.  //Get the literal value that the local variable is initialized to
```java
import net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTLiteral;
import net.sourceforge.pmd.lang.ast.NodeStream;
public ASTLiteral getInitializedValue(ASTLocalVariableDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a local declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTLiteral) {
                    return (ASTLiteral)init;
                }
            }
        }
    }
    return null;
}
```
5.  //Get the type of argument
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getMethodCallArgumentType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror();
}
```
6.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
7.  //Check whether the accessed variable is being read
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr;
public boolean variableIsBeingRead(ASTVariableAccess var) {
    if(var.getAccessType() == ASTAssignableExpr.AccessType.READ){
        return true;
    }
    return false;
}
```
8.  //Check whether the accessed variable is a formal parameter
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
public boolean isFormalParameter(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if(sym == null)
        return false;
    ASTVariableDeclaratorId varDecl = sym.tryGetNode();
    assert varDecl != null;
    return varDecl.isFormalParameter();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import java.util.Arrays;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        if (Arrays.asList("equals", "equalsIgnoreCase", "compareTo", "compareToIgnoreCase", "contentEquals").contains(methodName)) {
            ASTArgumentList arguments = node.getArguments();
            if (arguments.size() == 2) {
                ASTExpression firstArg = arguments.get(0);
                ASTExpression secondArg = arguments.get(1);

                if (isFormalParameter(node, firstArg) && secondArg instanceof ASTLiteral) {
                    addViolation(data, node);
                }
            } else if (arguments.size() == 1) {
                ASTExpression firstArg = arguments.get(0);
                if (isFormalParameter(node, firstArg) && !(firstArg instanceof ASTLiteral)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    private int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the accessed variable is a local variable
    private boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym instanceof JLocalVariableSymbol) {
            return true;
        }
        return false;
    }

    // Check whether the accessed variable is string type
    private boolean isVariableAccessStringType(ASTVariableAccess var) {
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }

    // Get the type of argument
    private JTypeMirror getMethodCallArgumentType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return expression.getTypeMirror();
    }

    // Check whether the argument is string type
    private boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is being read
    private boolean variableIsBeingRead(ASTVariableAccess var) {
        if (var.getAccessType() == ASTVariableAccess.AccessType.READ) {
            return true;
        }
        return false;
    }

    // Check whether the accessed variable is a formal parameter
    private boolean isFormalParameter(ASTMethodCall node, ASTExpression nodeExpression) {
        if (nodeExpression instanceof ASTVariableAccess) {
            ASTVariableAccess varAccess = (ASTVariableAccess) nodeExpression;
            JVariableSymbol sym = varAccess.getReferencedSym();
            if (sym instanceof JLocalVariableSymbol) {
                return false;
            }
            return sym != null && sym.tryGetNode() != null && sym.tryGetNode().isFormalParameter();
        }
        return false;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the method declaration from method call.
        2. Get the name of called method.
        3. Check whether the called method name is equalsIgnoreCase.
        4. Get the number of arguments of called method.
        5. Check whether the number of arguments is 1.
        6. Get the first argument of called method.
        7. Check whether the first argument is a string literal.
        8. Get the method caller.
        9. Check whether the method caller is an accessed variable.
        10. Check whether the accessed variable is of type String.
        If the called method name is equalsIgnoreCase, the number of arguments is 1, the first argument is not a string literal, and the method caller is an accessed variable of type String, then this test case violates the rule.
['Get the method declaration from method call.', 'Get the name of called method.', 'Check whether the called method name is equalsIgnoreCase.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 1.', 'Get the first argument of called method.', 'Check whether the first argument is a string literal.', 'Get the method caller.', 'Check whether the method caller is an accessed variable.', 'Check whether the accessed variable is of type String.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the method declaration from method call.* 匹配到的元操作或API：
logic: Get the method declaration from method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9787436127662659
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the called method name is equalsIgnoreCase.* 匹配到的元操作或API：
query: Check whether the called method name is equalsIgnoreCase.
most similar API: Check whether the method call equals
cosine Similarity: 0.8475643396377563
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of called method.* 匹配到的元操作或API：
logic: Get the first argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9160765409469604
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803800344467163
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796929359436035
*Check whether the method caller is an accessed variable.* 匹配到的元操作或API：
logic: Check whether the method caller is an accessed variable.
most similar meta operation: Check whether the accessed variable is a local variable
cosine Similarity: 0.8596189618110657
*Check whether the accessed variable is of type String.* 匹配到的元操作或API：
logic: Check whether the accessed variable is of type String.
most similar meta operation: Check whether the accessed variable is string type
cosine Similarity: 0.9785377979278564
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
The test case corresponding to the rule:
```
// bad, literal comes last in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'boolean')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTMethodCall (called method name = 'equalsIgnoreCase')
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
3.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
4.  //Check whether the accessed variable is a local variable
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JLocalVariableSymbol;
public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JLocalVariableSymbol) {
        JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
        return true;
    }
    return false;
}
```
5.  //Check whether the accessed variable is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTVariableAccess var){
    return TypeTestUtil.isA(String.class, var.getTypeMirror());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            (qualifier instanceof ASTVariableAccess) &&
            isVariableAccessStringType((ASTVariableAccess) qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Get method declaration from method call
    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method) {
        JMethodSymbol symbol = (JMethodSymbol) method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is a local variable
    public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym instanceof JLocalVariableSymbol) {
            JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
            return true;
        }
        return false;
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var) {
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
True
此测试用例生成了first checker: bad 3


======================接下来开始迭代=====================
[ERROR]   "ok 3" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
To perform granular checks on the provided test case, let's break down the specific method call and analyze it according to the rule:

1. Get the name of called method.
2. Check whether the name is equals.
3. Check whether the called method is the non-overloaded `boolean equals(Object o)` method.
4. Get the number of arguments of called method.
5. Get the first argument of called method.
6. Check whether the first argument is a literal.
7. Get the second argument of called method.
8. Check whether the second argument is a literal.
9. If the called method is `equals` and the second argument is not a literal, then the test case may violate the rule.

Let's apply these checks to the specific method call `str.equals(getAnotherString("abc"))`:

1. Get the name of called method.
        The name of the called method is `equals`.

2. Check whether the name is equals.
        The name is indeed `equals`.

3. Check whether the called method is the non-overloaded `boolean equals(Object o)` method.
        The method is indeed the non-overloaded `boolean equals(Object o)` method.

4. Get the number of arguments of called method.
        The number of arguments is 1.

5. Get the first argument of called method.
        The first argument is `getAnotherString("abc")`.

6. Check whether the first argument is a literal.
        The first argument is not a literal; it is a method call.

7. Get the second argument of called method.
        There is no second argument in this method call. The method `equals` in `String` class takes only one argument.

8. Check whether the second argument is a literal.
        Since there is no second argument, this check is not applicable.

Given the analysis, the method call `str.equals(getAnotherString("abc"))` does not violate the rule because the second argument is not a literal. Therefore, the number of violations in this test case is indeed 0.

However, there are other method calls that need to be checked:

1. Get the name of called method.
        The name of the called method is `getAnotherString`.

2. Check whether the name is equals.
        The name is not `equals`.

3. Check whether the called method is the non-overloaded `boolean equals(Object o)` method.
        The method is not `equals`.

Since the method call `getAnotherString("abc")` does not involve any `String` comparison methods, it does not need to be checked further for this rule.

To summarize the checks for the entire test case:
- The method call `str.equals(getAnotherString("abc"))` does not violate the rule because the second argument is not a literal.
- The method call `getAnotherString("abc")` is not relevant to the rule as it does not involve any `String` comparison methods. 

Thus, the test case does not violate the rule.
['Get the name of called method.', 'Check whether the name is equals.', 'Check whether the called method is the non-overloaded `boolean equals(Object o)` method.', 'Get the number of arguments of called method.', 'Get the first argument of called method.', 'Check whether the first argument is a literal.', 'Get the second argument of called method.', 'Check whether the second argument is a literal.', 'If the called method is `equals` and the second argument is not a literal, then the test case may violate the rule.', 'Get the name of called method.', 'Check whether the name is equals.', 'Check whether the called method is the non-overloaded `boolean equals(Object o)` method.', 'Get the number of arguments of called method.', 'Get the first argument of called method.', 'Check whether the first argument is a literal.', 'Get the second argument of called method.', 'Check whether the second argument is a literal.', 'Get the name of called method.', 'Check whether the name is equals.', 'Check whether the called method is the non-overloaded `boolean equals(Object o)` method.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTIfStatement', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the name is equals.* 匹配到的元操作或API：
query: Check whether the name is equals.
most similar API: Check whether is equals method
cosine Similarity: 0.8145301938056946
*Check whether the called method is the non-overloaded `boolean equals(Object o)` method.* 匹配到的元操作或API：
query: Check whether the called method is the non-overloaded `boolean equals(Object o)` method.
most similar API: Check whether the method call equals
cosine Similarity: 0.8480122685432434
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Get the first argument of called method.* 匹配到的元操作或API：
logic: Get the first argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9160765409469604
*Check whether the first argument is a literal.* 匹配到的元操作或API：
query: Check whether the first argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8155132532119751
*Get the second argument of called method.* 匹配到的元操作或API：
logic: Get the second argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9016816020011902
*Check whether the second argument is a literal.* 匹配到的元操作或API：
query: Check whether the second argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8142394423484802
*If the called method is `equals` and the second argument is not a literal, then the test case may violate the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the name is equals.* 匹配到的元操作或API：
query: Check whether the name is equals.
most similar API: Check whether is equals method
cosine Similarity: 0.8145301938056946
*Check whether the called method is the non-overloaded `boolean equals(Object o)` method.* 匹配到的元操作或API：
query: Check whether the called method is the non-overloaded `boolean equals(Object o)` method.
most similar API: Check whether the method call equals
cosine Similarity: 0.8480122685432434
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Get the first argument of called method.* 匹配到的元操作或API：
logic: Get the first argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9160765409469604
*Check whether the first argument is a literal.* 匹配到的元操作或API：
query: Check whether the first argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8155132532119751
*Get the second argument of called method.* 匹配到的元操作或API：
logic: Get the second argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9016816020011902
*Check whether the second argument is a literal.* 匹配到的元操作或API：
query: Check whether the second argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8142394423484802
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the name is equals.* 匹配到的元操作或API：
query: Check whether the name is equals.
most similar API: Check whether is equals method
cosine Similarity: 0.8145301938056946
*Check whether the called method is the non-overloaded `boolean equals(Object o)` method.* 匹配到的元操作或API：
query: Check whether the called method is the non-overloaded `boolean equals(Object o)` method.
most similar API: Check whether the method call equals
cosine Similarity: 0.8480122685432434
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            (qualifier instanceof ASTVariableAccess) &&
            isVariableAccessStringType((ASTVariableAccess) qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Get method declaration from method call
    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method) {
        JMethodSymbol symbol = (JMethodSymbol) method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is a local variable
    public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym instanceof JLocalVariableSymbol) {
            JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
            return true;
        }
        return false;
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var) {
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}


This checker is failed(false positive) on this positive test case:
```
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (str.equals(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testMethod')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'str')
            ——ASTArgumentList (size = 1)
              ——ASTMethodCall (called method name = 'getAnotherString')
                ——ASTArgumentList (size = 1)
                  ——ASTStringLiteral
          ——ASTBlock
    ——ASTMethodDeclaration (method name = 'getAnotherString')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isEqualsMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
5. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isBooleanLiteral(net.sourceforge.pmd.lang.java.ast.JavaNode), //Returns true if the node is a boolean literal with any value.

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            (qualifier instanceof ASTVariableAccess) &&
            isVariableAccessStringType((ASTVariableAccess) qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            if (!isLiteral(arguments.get(0))) {
                addViolation(data, node);
            }
        }

        return super.visit(node, data);
    }

    // Get method declaration from method call
    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method) {
        JMethodSymbol symbol = (JMethodSymbol) method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is a local variable
    public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym instanceof JLocalVariableSymbol) {
            JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
            return true;
        }
        return false;
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var) {
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }

    // Check whether the expression is a literal
    public boolean isLiteral(ASTExpression expression) {
        return expression instanceof ASTStringLiteral;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}, {'error_rules_info': '[ERROR]   "ok 3" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
To determine whether the test case violates the rule, let's perform the following granular checks:

1. Get the method call in the if statement.
2. Get the name of called method.
3. Get the number of arguments of called method.
4. Get the first argument of called method.
5. Check whether the first argument is a string literal.
6. Get the second argument of called method.
7. Check whether the second argument is an accessed variable.
8. Check whether the accessed variable is the result of a method call.
9. Get the method call from the accessed variable.
10. Get the name of the called method from the accessed variable.
11. Check whether the name of the called method is getAnotherString.
12. Get the parameter list of the called method getAnotherString.
13. Get the size of the parameter list of the called method getAnotherString.
14. Check whether the size of the parameter list of the called method getAnotherString is 1.
15. Get the first parameter of the called method getAnotherString.
16. Check whether the first parameter of the called method getAnotherString is a string literal.

Given the above checks, let's evaluate the test case:

1. The method call in the if statement is `str.equals(getAnotherString("abc"))`.
2. The name of the called method is `equals`.
3. The number of arguments of the called method `equals` is 1.
4. The first argument of the called method `equals` is `getAnotherString("abc")`.
5. The first argument is not a string literal (it's a method call).
6. The second argument of the called method `equals` is `getAnotherString("abc")`.
7. The second argument is the result of a method call.
8. The method call from the accessed variable is `getAnotherString("abc")`.
9. The name of the called method from the accessed variable is `getAnotherString`.
10. The name of the called method is indeed `getAnotherString`.
11. The size of the parameter list of the called method `getAnotherString` is 1.
12. The first parameter of the called method `getAnotherString` is `"abc"`.
13. The first parameter of the called method `getAnotherString` is a string literal.

From these checks, we can conclude that the test case violates the rule because the literal `"abc"` is not positioned first in the `equals` method call. The correct way to position the literal first would be `getAnotherString("abc").equals(str)`. However, since the provided test case is evaluated to have 0 violations, it seems the rule checker might be ignoring method calls when checking for the position of literals.

The correct checks based on the provided test case evaluation would be:

1. The method call in the if statement is `str.equals(getAnotherString("abc"))`.
2. The name of the called method is `equals`.
3. The number of arguments of the called method `equals` is 1.
4. The first argument of the called method `equals` is `getAnotherString("abc")`.
5. The first argument is not a string literal (it's a method call).
6. The second argument of the called method `equals` is `getAnotherString("abc")`.
7. The second argument is the result of a method call.
8. The method call from the accessed variable is `getAnotherString("abc")`.
9. The name of the called method from the accessed variable is `getAnotherString`.
10. The size of the parameter list of the called method `getAnotherString` is 1.
11. The first parameter of the called method `getAnotherString` is `"abc"`.
12. The first parameter of the called method `getAnotherString` is a string literal.

Despite the above checks indicating a violation, the rule checker seems to have evaluated the test case as having 0 violations. This could be due to the rule checker's specific implementation or logic that might not catch this scenario.
['Get the method call in the if statement.', 'Get the name of called method.', 'Get the number of arguments of called method.', 'Get the first argument of called method.', 'Check whether the first argument is a string literal.', 'Get the second argument of called method.', 'Check whether the second argument is an accessed variable.', 'Check whether the accessed variable is the result of a method call.', 'Get the method call from the accessed variable.', 'Get the name of the called method from the accessed variable.', 'Check whether the name of the called method is getAnotherString.', 'Get the parameter list of the called method getAnotherString.', 'Get the size of the parameter list of the called method getAnotherString.', 'Check whether the size of the parameter list of the called method getAnotherString is 1.', 'Get the first parameter of the called method getAnotherString.', 'Check whether the first parameter of the called method getAnotherString is a string literal.', 'The method call in the if statement is `str.equals(getAnotherString("abc"))`.', 'The name of the called method is `equals`.', 'The number of arguments of the called method `equals` is 1.', 'The first argument of the called method `equals` is `getAnotherString("abc")`.', "The first argument is not a string literal (it's a method call).", 'The second argument of the called method `equals` is `getAnotherString("abc")`.', 'The second argument is the result of a method call.', 'The method call from the accessed variable is `getAnotherString("abc")`.', 'The name of the called method from the accessed variable is `getAnotherString`.', 'The name of the called method is indeed `getAnotherString`.', 'The size of the parameter list of the called method `getAnotherString` is 1.', 'The first parameter of the called method `getAnotherString` is `"abc"`.', 'The first parameter of the called method `getAnotherString` is a string literal.', 'The method call in the if statement is `str.equals(getAnotherString("abc"))`.', 'The name of the called method is `equals`.', 'The number of arguments of the called method `equals` is 1.', 'The first argument of the called method `equals` is `getAnotherString("abc")`.', "The first argument is not a string literal (it's a method call).", 'The second argument of the called method `equals` is `getAnotherString("abc")`.', 'The second argument is the result of a method call.', 'The method call from the accessed variable is `getAnotherString("abc")`.', 'The name of the called method from the accessed variable is `getAnotherString`.', 'The size of the parameter list of the called method `getAnotherString` is 1.', 'The first parameter of the called method `getAnotherString` is `"abc"`.', 'The first parameter of the called method `getAnotherString` is a string literal.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTIfStatement', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the method call in the if statement.* 匹配到的元操作或API：
query: Get the method call in the if statement.
most similar API: get method name of method call
cosine Similarity: 0.8458374738693237
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Get the first argument of called method.* 匹配到的元操作或API：
logic: Get the first argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9160765409469604
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803800344467163
*Get the second argument of called method.* 匹配到的元操作或API：
logic: Get the second argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9016816020011902
*Check whether the second argument is an accessed variable.* 匹配到的元操作或API：
logic: Check whether the second argument is an accessed variable.
most similar meta operation: Check whether the accessed variable is a local variable
cosine Similarity: 0.8713794946670532
*Check whether the accessed variable is the result of a method call.* 匹配到的元操作或API：
logic: Check whether the accessed variable is the result of a method call.
most similar meta operation: Check whether the accessed variable is a local variable
cosine Similarity: 0.864219069480896
*Get the method call from the accessed variable.* 匹配到的元操作或API：
query: Get the method call from the accessed variable.
most similar API: get method name of method call
cosine Similarity: 0.833855152130127
*Get the name of the called method from the accessed variable.* 匹配到的元操作或API：
logic: Get the name of the called method from the accessed variable.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9053640365600586
*Check whether the name of the called method is getAnotherString.* 匹配到的元操作或API：
query: Check whether the name of the called method is getAnotherString.
most similar API: get method name of method call
cosine Similarity: 0.8209150433540344
*Get the parameter list of the called method getAnotherString.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the size of the parameter list of the called method getAnotherString.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the size of the parameter list of the called method getAnotherString is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first parameter of the called method getAnotherString.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the first parameter of the called method getAnotherString is a string literal.* 匹配到的元操作或API：
query: Check whether the first parameter of the called method getAnotherString is a string literal.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8368654847145081
*The method call in the if statement is `str.equals(getAnotherString("abc"))`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The name of the called method is `equals`.* 匹配到的元操作或API：
query: The name of the called method is `equals`.
most similar API: Check whether the method call equals
cosine Similarity: 0.8214161396026611
*The number of arguments of the called method `equals` is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*The first argument of the called method `equals` is `getAnotherString("abc")`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The first argument is not a string literal (it's a method call).* 匹配到的元操作或API：
未匹配成功元操作或API
*The second argument of the called method `equals` is `getAnotherString("abc")`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The second argument is the result of a method call.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method call from the accessed variable is `getAnotherString("abc")`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The name of the called method from the accessed variable is `getAnotherString`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The name of the called method is indeed `getAnotherString`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The size of the parameter list of the called method `getAnotherString` is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*The first parameter of the called method `getAnotherString` is `"abc"`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The first parameter of the called method `getAnotherString` is a string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method call in the if statement is `str.equals(getAnotherString("abc"))`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The name of the called method is `equals`.* 匹配到的元操作或API：
query: The name of the called method is `equals`.
most similar API: Check whether the method call equals
cosine Similarity: 0.8214161396026611
*The number of arguments of the called method `equals` is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*The first argument of the called method `equals` is `getAnotherString("abc")`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The first argument is not a string literal (it's a method call).* 匹配到的元操作或API：
未匹配成功元操作或API
*The second argument of the called method `equals` is `getAnotherString("abc")`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The second argument is the result of a method call.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method call from the accessed variable is `getAnotherString("abc")`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The name of the called method from the accessed variable is `getAnotherString`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The size of the parameter list of the called method `getAnotherString` is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*The first parameter of the called method `getAnotherString` is `"abc"`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The first parameter of the called method `getAnotherString` is a string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            (qualifier instanceof ASTVariableAccess) &&
            isVariableAccessStringType((ASTVariableAccess) qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Get method declaration from method call
    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method) {
        JMethodSymbol symbol = (JMethodSymbol) method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is a local variable
    public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym instanceof JLocalVariableSymbol) {
            JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
            return true;
        }
        return false;
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var) {
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}


This checker is failed(false positive) on this positive test case:
```
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (str.equals(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testMethod')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'str')
            ——ASTArgumentList (size = 1)
              ——ASTMethodCall (called method name = 'getAnotherString')
                ——ASTArgumentList (size = 1)
                  ——ASTStringLiteral
          ——ASTBlock
    ——ASTMethodDeclaration (method name = 'getAnotherString')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
2.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
3.  //Check whether the accessed variable is a local variable
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JLocalVariableSymbol;
public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JLocalVariableSymbol) {
        JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
        return true;
    }
    return false;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            (qualifier instanceof ASTVariableAccess) &&
            isVariableAccessStringType((ASTVariableAccess) qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals")) &&
            !isFirstArgumentStringLiteral(node)) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    public boolean isFirstArgumentStringLiteral(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        ASTExpression expression = astArgumentList.get(0);
        return expression instanceof ASTStringLiteral;
    }

    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    public boolean isVariableAccessStringType(ASTVariableAccess var) {
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}, {'error_rules_info': '[ERROR]   "ok 3" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
To ascertain whether the test case adheres to the rule, we will perform a series of granular checks on the method call within the `if` statement.

1. Get the name of called method.
2. Check whether the name is equals.
3. Get the number of arguments of called method.
4. Check whether the number of arguments is 1.
5. Get an argument of called method.
6. Check whether the argument is a string literal.
7. Check whether the argument is a method call.
8. If the argument is a method call, get the name of the called method.
9. If the argument is a method call, check whether the second argument of the called method is null.
10. If the argument is not a string literal and not a method call that returns null, check the position of the string literal in the method call.

Let's perform these checks:

1. Get the name of called method.
   - The method name is `equals`.

2. Check whether the name is equals.
   - The condition is true; the method name is `equals`.

3. Get the number of arguments of called method.
   - The number of arguments is 1.

4. Check whether the number of arguments is 1.
   - The condition is true; there is one argument.

5. Get an argument of called method.
   - The argument is `getAnotherString("abc")`.

6. Check whether the argument is a string literal.
   - The condition is false; the argument is a method call.

7. Check whether the argument is a method call.
   - The condition is true; the argument is indeed a method call.

8. If the argument is a method call, get the name of the called method.
   - The name of the called method is `getAnotherString`.

9. If the argument is a method call, check whether the second argument of the called method is null.
   - The condition is false; the second argument is `"abc"`, not `null`.

10. If the argument is not a string literal and not a method call that returns null, check the position of the string literal in the method call.
    - The string literal `"abc"` is not the first argument in the `equals` method call; it is the argument passed to `getAnotherString`.

Since the string literal `"abc"` is not the first argument in the `equals` method call and the second argument of `getAnotherString` is not `null`, the test case does not violate the rule. Therefore, the number of violations in this test case is indeed 0.
['Get the name of called method.', 'Check whether the name is equals.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 1.', 'Get an argument of called method.', 'Check whether the argument is a string literal.', 'Check whether the argument is a method call.', 'If the argument is a method call, get the name of the called method.', 'If the argument is a method call, check whether the second argument of the called method is null.', 'If the argument is not a string literal and not a method call that returns null, check the position of the string literal in the method call.', 'Get the name of called method.', 'Check whether the name is equals.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 1.', 'Get an argument of called method.', 'Check whether the argument is a string literal.', 'Check whether the argument is a method call.', 'If the argument is a method call, get the name of the called method.', 'If the argument is a method call, check whether the second argument of the called method is null.', 'If the argument is not a string literal and not a method call that returns null, check the position of the string literal in the method call.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTIfStatement', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the name is equals.* 匹配到的元操作或API：
query: Check whether the name is equals.
most similar API: Check whether is equals method
cosine Similarity: 0.8145301938056946
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9077174663543701
*Check whether the argument is a method call.* 匹配到的元操作或API：
query: Check whether the argument is a method call.
most similar API: Check whether the method call equals
cosine Similarity: 0.8476557731628418
*If the argument is a method call, get the name of the called method.* 匹配到的元操作或API：
logic: If the argument is a method call, get the name of the called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9150580167770386
*If the argument is a method call, check whether the second argument of the called method is null.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the argument is not a string literal and not a method call that returns null, check the position of the string literal in the method call.* 匹配到的元操作或API：
query: If the argument is not a string literal and not a method call that returns null, check the position of the string literal in the method call.
most similar API: Check whether the string literal is null literal
cosine Similarity: 0.8435624837875366
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the name is equals.* 匹配到的元操作或API：
query: Check whether the name is equals.
most similar API: Check whether is equals method
cosine Similarity: 0.8145301938056946
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9077174663543701
*Check whether the argument is a method call.* 匹配到的元操作或API：
query: Check whether the argument is a method call.
most similar API: Check whether the method call equals
cosine Similarity: 0.8476557731628418
*If the argument is a method call, get the name of the called method.* 匹配到的元操作或API：
logic: If the argument is a method call, get the name of the called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9150580167770386
*If the argument is a method call, check whether the second argument of the called method is null.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the argument is not a string literal and not a method call that returns null, check the position of the string literal in the method call.* 匹配到的元操作或API：
query: If the argument is not a string literal and not a method call that returns null, check the position of the string literal in the method call.
most similar API: Check whether the string literal is null literal
cosine Similarity: 0.8435624837875366
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            (qualifier instanceof ASTVariableAccess) &&
            isVariableAccessStringType((ASTVariableAccess) qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Get method declaration from method call
    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method) {
        JMethodSymbol symbol = (JMethodSymbol) method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is a local variable
    public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym instanceof JLocalVariableSymbol) {
            JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
            return true;
        }
        return false;
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var) {
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}


This checker is failed(false positive) on this positive test case:
```
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (str.equals(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testMethod')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'str')
            ——ASTArgumentList (size = 1)
              ——ASTMethodCall (called method name = 'getAnotherString')
                ——ASTArgumentList (size = 1)
                  ——ASTStringLiteral
          ——ASTBlock
    ——ASTMethodDeclaration (method name = 'getAnotherString')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isEqualsMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isNullLiteral(), //Returns true if this is the {@linkplain ASTNullLiteral null literal}.

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
2.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            (qualifier instanceof ASTVariableAccess) &&
            isVariableAccessStringType((ASTVariableAccess) qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {

            ASTExpression firstArgument = arguments.get(0);
            if (!(firstArgument instanceof ASTStringLiteral)) {
                addViolation(data, node);
            }
        }

        return super.visit(node, data);
    }

    // Get method declaration from method call
    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method) {
        JMethodSymbol symbol = (JMethodSymbol) method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is a local variable
    public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym instanceof JLocalVariableSymbol) {
            JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
            return true;
        }
        return false;
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var) {
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}, {'error_rules_info': '[ERROR]   "ok 3" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
To ensure the test case adheres to the rule, we need to check the following granular operations:

1. Get the name of the called method.
2. Check whether the name of the called method is equals.
3. Get the number of arguments of called method.
4. Check whether the number of arguments is 1.
5. Get the first argument of called method.
6. Check whether the first argument is a literal.
7. Get the second argument of called method.
8. Check whether the second argument is a method call.
9. Check whether the second argument method call can return null.

Let's go through these checks:

1. Get the name of the called method.
   - The called method is `equals`.

2. Check whether the name of the called method is equals.
   - The name is indeed `equals`.

3. Get the number of arguments of called method.
   - The number of arguments is 1.

4. Check whether the number of arguments is 1.
   - The number of arguments is indeed 1, so this check is valid.

5. Get the first argument of called method.
   - The first argument is `getAnotherString("abc")`.

6. Check whether the first argument is a literal.
   - The first argument is not a literal, it is a method call.

7. Get the second argument of called method.
   - The second argument is not applicable here as there is only one argument.

8. Check whether the second argument is a method call.
   - The first argument is a method call, but we need to check if the method can return null.

9. Check whether the second argument method call can return null.
   - The method `getAnotherString` returns a string literal "xyz" which will never be null, so this check does not indicate a violation.

Since the `equals` method is called with a method call as its argument and the method call does not return null, the test case does not violate the rule. Therefore, the number of violations is indeed 0.
['Get the name of the called method.', 'Check whether the name of the called method is equals.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 1.', 'Get the first argument of called method.', 'Check whether the first argument is a literal.', 'Get the second argument of called method.', 'Check whether the second argument is a method call.', 'Check whether the second argument method call can return null.', 'Get the name of the called method.', 'Check whether the name of the called method is equals.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 1.', 'Get the first argument of called method.', 'Check whether the first argument is a literal.', 'Get the second argument of called method.', 'Check whether the second argument is a method call.', 'Check whether the second argument method call can return null.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTIfStatement', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the name of the called method.* 匹配到的元操作或API：
logic: Get the name of the called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9750091433525085
*Check whether the name of the called method is equals.* 匹配到的元操作或API：
query: Check whether the name of the called method is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9173132181167603
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of called method.* 匹配到的元操作或API：
logic: Get the first argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9160765409469604
*Check whether the first argument is a literal.* 匹配到的元操作或API：
query: Check whether the first argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8155132532119751
*Get the second argument of called method.* 匹配到的元操作或API：
logic: Get the second argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9016816020011902
*Check whether the second argument is a method call.* 匹配到的元操作或API：
query: Check whether the second argument is a method call.
most similar API: Check whether the method call equals
cosine Similarity: 0.8365625739097595
*Check whether the second argument method call can return null.* 匹配到的元操作或API：
query: Check whether the second argument method call can return null.
most similar API: Check whether is null check
cosine Similarity: 0.8165327310562134
*Get the name of the called method.* 匹配到的元操作或API：
logic: Get the name of the called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9750091433525085
*Check whether the name of the called method is equals.* 匹配到的元操作或API：
query: Check whether the name of the called method is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9173132181167603
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of called method.* 匹配到的元操作或API：
logic: Get the first argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9160765409469604
*Check whether the first argument is a literal.* 匹配到的元操作或API：
query: Check whether the first argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8155132532119751
*Get the second argument of called method.* 匹配到的元操作或API：
logic: Get the second argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9016816020011902
*Check whether the second argument is a method call.* 匹配到的元操作或API：
query: Check whether the second argument is a method call.
most similar API: Check whether the method call equals
cosine Similarity: 0.8365625739097595
*Check whether the second argument method call can return null.* 匹配到的元操作或API：
query: Check whether the second argument method call can return null.
most similar API: Check whether is null check
cosine Similarity: 0.8165327310562134
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            (qualifier instanceof ASTVariableAccess) &&
            isVariableAccessStringType((ASTVariableAccess) qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Get method declaration from method call
    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method) {
        JMethodSymbol symbol = (JMethodSymbol) method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is a local variable
    public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym instanceof JLocalVariableSymbol) {
            JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
            return true;
        }
        return false;
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var) {
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}


This checker is failed(false positive) on this positive test case:
```
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (str.equals(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testMethod')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'str')
            ——ASTArgumentList (size = 1)
              ——ASTMethodCall (called method name = 'getAnotherString')
                ——ASTArgumentList (size = 1)
                  ——ASTStringLiteral
          ——ASTBlock
    ——ASTMethodDeclaration (method name = 'getAnotherString')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
4. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isBooleanLiteral(net.sourceforge.pmd.lang.java.ast.JavaNode), //Returns true if the node is a boolean literal with any value.
5. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullCheck(net.sourceforge.pmd.lang.java.ast.ASTExpression, net.sourceforge.pmd.lang.java.rule.internal.StablePathMatcher)

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if (arguments.size() == 1 && 
            qualifier instanceof ASTVariableAccess &&
            isVariableAccessStringType((ASTVariableAccess) qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {

            ASTExpression argument = arguments.get(0);
            if (!(argument instanceof ASTStringLiteral) && !(argument instanceof ASTNullLiteral)) {
                addViolation(data, node);
            }
        }

        return super.visit(node, data);
    }

    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method) {
        JMethodSymbol symbol = (JMethodSymbol) method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }

    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym instanceof JLocalVariableSymbol) {
            return true;
        }
        return false;
    }

    public boolean isVariableAccessStringType(ASTVariableAccess var) {
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}, {'error_rules_info': '[ERROR]   "ok 3" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
To perform granular checks on the provided test case to ascertain its adherence to the rule, we can break down the relevant parts:

1. Get the method call from the testMethod.
2. Get the name of called method.
3. Check whether the called method name is equals.
4. Get the number of arguments of called method.
5. Check whether the number of arguments is 2.
6. Get the first argument of called method.
7. Check whether the first argument is a string literal.
8. Get the second argument of called method.
9. Check whether the second argument is a method call.
10. Check whether the method call can return null.
11. If the called method name is equals, the number of arguments is 2, and the second argument can return null, then check whether the first argument is a string literal.
12. If the first argument is not a string literal, then this test case violates the rule.

Let's apply these checks to the provided code:

1. Get the method call from the testMethod.
        - The method call in the testMethod is `str.equals(getAnotherString("abc"))`.

2. Get the name of called method.
        - The name of the called method is `equals`.

3. Check whether the called method name is equals.
        - The called method name `equals` matches.

4. Get the number of arguments of called method.
        - The number of arguments is 1 (the second argument is part of the method call itself, not a separate argument).

5. Check whether the number of arguments is 2.
        - The number of arguments is not 2, it is 1. The method call `getAnotherString("abc")` is passed as a single argument to `equals`.

6. Get the first argument of called method.
        - The first argument of the called method is `getAnotherString("abc")`.

7. Check whether the first argument is a string literal.
        - The first argument is a method call, not a string literal.

8. Get the second argument of called method.
        - Not applicable as the number of arguments is 1.

9. Check whether the second argument is a method call.
        - Not applicable as the number of arguments is 1.

10. Check whether the method call can return null.
        - The method `getAnotherString(String str)` returns a string literal `"xyz"`, which cannot be null.

11. If the called method name is equals, the number of arguments is 2, and the second argument can return null, then check whether the first argument is a string literal.
        - Not applicable as the number of arguments is not 2.

12. If the first argument is not a string literal, then this test case violates the rule.
        - The first argument is not a string literal, but since the number of arguments is not 2, the rule does not apply to this specific case.

Given the description of the rule and the test case, the test case does not violate the rule because the `equals` method call does not have the required number of arguments to be checked. The rule specifically targets cases where there are two arguments and the second argument might be null, to avoid `NullPointerException`. In this case, the `equals` method is called with a single argument, which is a method call that cannot return null.

Thus, the number of violations in this test case is 0, as correctly stated.
['Get the method call from the testMethod.', 'Get the name of called method.', 'Check whether the called method name is equals.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 2.', 'Get the first argument of called method.', 'Check whether the first argument is a string literal.', 'Get the second argument of called method.', 'Check whether the second argument is a method call.', 'Check whether the method call can return null.', 'If the called method name is equals, the number of arguments is 2, and the second argument can return null, then check whether the first argument is a string literal.', 'If the first argument is not a string literal, then this test case violates the rule.', 'Get the method call from the testMethod.', 'Get the name of called method.', 'Check whether the called method name is equals.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 2.', 'Get the first argument of called method.', 'Check whether the first argument is a string literal.', 'Get the second argument of called method.', 'Check whether the second argument is a method call.', 'Check whether the method call can return null.', 'If the called method name is equals, the number of arguments is 2, and the second argument can return null, then check whether the first argument is a string literal.', 'If the first argument is not a string literal, then this test case violates the rule.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTIfStatement', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil']
*Get the method call from the testMethod.* 匹配到的元操作或API：
query: Get the method call from the testMethod.
most similar API: get text of method call
cosine Similarity: 0.8549950122833252
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9280144572257996
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 2.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of called method.* 匹配到的元操作或API：
logic: Get the first argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9160765409469604
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803800344467163
*Get the second argument of called method.* 匹配到的元操作或API：
logic: Get the second argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9016816020011902
*Check whether the second argument is a method call.* 匹配到的元操作或API：
query: Check whether the second argument is a method call.
most similar API: Check whether the method call equals
cosine Similarity: 0.8365625739097595
*Check whether the method call can return null.* 匹配到的元操作或API：
query: Check whether the method call can return null.
most similar API: Check whether is null check
cosine Similarity: 0.8574075102806091
*If the called method name is equals, the number of arguments is 2, and the second argument can return null, then check whether the first argument is a string literal.* 匹配到的元操作或API：
query: If the called method name is equals, the number of arguments is 2, and the second argument can return null, then check whether the first argument is a string literal.
most similar API: Check whether the string literal is null literal
cosine Similarity: 0.8139874935150146
*If the first argument is not a string literal, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the method call from the testMethod.* 匹配到的元操作或API：
query: Get the method call from the testMethod.
most similar API: get text of method call
cosine Similarity: 0.8549950122833252
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9280144572257996
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 2.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of called method.* 匹配到的元操作或API：
logic: Get the first argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9160765409469604
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803800344467163
*Get the second argument of called method.* 匹配到的元操作或API：
logic: Get the second argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9016816020011902
*Check whether the second argument is a method call.* 匹配到的元操作或API：
query: Check whether the second argument is a method call.
most similar API: Check whether the method call equals
cosine Similarity: 0.8365625739097595
*Check whether the method call can return null.* 匹配到的元操作或API：
query: Check whether the method call can return null.
most similar API: Check whether is null check
cosine Similarity: 0.8574075102806091
*If the called method name is equals, the number of arguments is 2, and the second argument can return null, then check whether the first argument is a string literal.* 匹配到的元操作或API：
query: If the called method name is equals, the number of arguments is 2, and the second argument can return null, then check whether the first argument is a string literal.
most similar API: Check whether the string literal is null literal
cosine Similarity: 0.8139874935150146
*If the first argument is not a string literal, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            (qualifier instanceof ASTVariableAccess) &&
            isVariableAccessStringType((ASTVariableAccess) qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Get method declaration from method call
    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method) {
        JMethodSymbol symbol = (JMethodSymbol) method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is a local variable
    public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym instanceof JLocalVariableSymbol) {
            JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
            return true;
        }
        return false;
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var) {
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}


This checker is failed(false positive) on this positive test case:
```
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (str.equals(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testMethod')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'str')
            ——ASTArgumentList (size = 1)
              ——ASTMethodCall (called method name = 'getAnotherString')
                ——ASTArgumentList (size = 1)
                  ——ASTStringLiteral
          ——ASTBlock
    ——ASTMethodDeclaration (method name = 'getAnotherString')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.document.Chars getText()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
5. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullCheck(net.sourceforge.pmd.lang.java.ast.ASTExpression, net.sourceforge.pmd.lang.java.rule.internal.StablePathMatcher)
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isNullLiteral(), //Returns true if this is the {@linkplain ASTNullLiteral null literal}.

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
2.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            (qualifier instanceof ASTVariableAccess) &&
            isVariableAccessStringType((ASTVariableAccess) qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals")) &&
            !isArgumentStringLiteral(arguments.get(0))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    public boolean isArgumentStringLiteral(ASTExpression expression) {
        return expression instanceof ASTStringLiteral;
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var) {
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 3
[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
84
70
116
101
83
69
=========================error_testcase_logics=========================
1. Get the signature of method.
2. Get the name of method.
3. Check whether the name of method is bar.
4. Get the return expression in return statement.
5. Check whether the return expression is a method call.
6. Get the name of called method.
7. Check whether the called method name is equals.
8. Get the number of arguments of called method.
9. Check whether the number of arguments of called method is 2.
10. Get the first argument of called method.
11. Check whether the argument is a method call.
12. Get the second argument of called method.
13. Check whether the second argument is a string literal.
14. If the called method name is equals and the second argument is a string literal, then check whether the first argument is a literal.
15. If the first argument is not a literal, then check whether the first argument is a method call.

Based on these checks, the test case violates the rule because the first argument of the `equals` method is a method call (`f.getParent()`) and not a literal, while the second argument is a string literal (`"testStr"`). To adhere to the rule, the literal should be the first argument in the `equals` method. 

The specific violating step is:
13. Check whether the second argument is a string literal.
14. If the called method name is equals and the second argument is a string literal, then check whether the first argument is a literal.
            
['Get the signature of method.', 'Get the name of method.', 'Check whether the name of method is bar.', 'Get the return expression in return statement.', 'Check whether the return expression is a method call.', 'Get the name of called method.', 'Check whether the called method name is equals.', 'Get the number of arguments of called method.', 'Check whether the number of arguments of called method is 2.', 'Get the first argument of called method.', 'Check whether the argument is a method call.', 'Get the second argument of called method.', 'Check whether the second argument is a string literal.', 'If the called method name is equals and the second argument is a string literal, then check whether the first argument is a literal.', 'If the first argument is not a literal, then check whether the first argument is a method call.', 'Check whether the second argument is a string literal.', 'If the called method name is equals and the second argument is a string literal, then check whether the first argument is a literal.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTImportDeclaration', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827433228492737
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the name of method is bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the return expression in return statement.* 匹配到的元操作或API：
logic: Get the return expression in return statement.
most similar meta operation: Get the return expression in return statement
cosine Similarity: 0.9881545901298523
*Check whether the return expression is a method call.* 匹配到的元操作或API：
query: Check whether the return expression is a method call.
most similar API: Check whether the method call is expression
cosine Similarity: 0.9155341386795044
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9280144572257996
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments of called method is 2.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of called method.* 匹配到的元操作或API：
logic: Get the first argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9160765409469604
*Check whether the argument is a method call.* 匹配到的元操作或API：
query: Check whether the argument is a method call.
most similar API: Check whether the method call equals
cosine Similarity: 0.8476557731628418
*Get the second argument of called method.* 匹配到的元操作或API：
logic: Get the second argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9016816020011902
*Check whether the second argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the second argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8767277002334595
*If the called method name is equals and the second argument is a string literal, then check whether the first argument is a literal.* 匹配到的元操作或API：
query: If the called method name is equals and the second argument is a string literal, then check whether the first argument is a literal.
most similar API: Check whether the method call equals
cosine Similarity: 0.8473622798919678
*If the first argument is not a literal, then check whether the first argument is a method call.* 匹配到的元操作或API：
query: If the first argument is not a literal, then check whether the first argument is a method call.
most similar API: Check whether the method call is expression
cosine Similarity: 0.8161652088165283
*Check whether the second argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the second argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8767277002334595
*If the called method name is equals and the second argument is a string literal, then check whether the first argument is a literal.* 匹配到的元操作或API：
query: If the called method name is equals and the second argument is a string literal, then check whether the first argument is a literal.
most similar API: Check whether the method call equals
cosine Similarity: 0.8473622798919678
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            (qualifier instanceof ASTVariableAccess) &&
            isVariableAccessStringType((ASTVariableAccess) qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Get method declaration from method call
    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method) {
        JMethodSymbol symbol = (JMethodSymbol) method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is a local variable
    public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym instanceof JLocalVariableSymbol) {
            JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
            return true;
        }
        return false;
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var) {
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}


This checker is failed(false negative) on this negative test case:
```
// bad, testing false negative at the end of a chain
import java.io.File;
public class Foo {
    public boolean bar() {
        File f;
        return f.getParent().equals("testStr");
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'boolean')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'f')
        ——ASTReturnStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTMethodCall (called method name = 'getParent')
              ——ASTVariableAccess (referenced variable name = 'f')
              ——ASTArgumentList (size = 0)
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
3. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getExpr()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
5. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
7. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
2.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is a local variable
    public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym instanceof JLocalVariableSymbol) {
            JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
            return true;
        }
        return false;
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var) {
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "bad 9" resulted in wrong number of failures, ==> expected: <2> but was: <0>不通过
111
94
84
70
91
75
116
101
89
74
95
78
83
69
=========================error_testcase_logics=========================
To check whether the test case adheres to the rule, we need to analyze the `String` comparison methods and ensure literals are positioned first. Let's go through the test case method by method:

1. Get the method call from `assertTrue(hasMap.getMap().get("foo").equals("bar"));`
2. Get the name of called method.
3. Check whether the name is equals.
4. Get the number of arguments of called method.
5. Check whether the number of arguments is 1.
6. Get an argument of called method.
7. Check whether the argument is a string literal.
8. Get the method caller.
9. Check whether the method caller is an accessed variable.
10. Get the type of accessed variable.
11. Check whether the type of accessed variable is String.
12. If the called method is `equals` and the argument is a string literal and the method caller is an accessed variable of type String, check whether the string literal is the first argument.
13. Get the method call from `assertTrue(hasMap.getMap().get("fi").equals("fum"));`
14. Get the name of called method.
15. Check whether the name is equals.
16. Get the number of arguments of called method.
17. Check whether the number of arguments is 1.
18. Get an argument of called method.
19. Check whether the argument is a string literal.
20. Get the method caller.
21. Check whether the method caller is an accessed variable.
22. Get the type of accessed variable.
23. Check whether the type of accessed variable is String.
24. If the called method is `equals` and the argument is a string literal and the method caller is an accessed variable of type String, check whether the string literal is the first argument.

Based on the test case provided, we need to check the following:

### Check `assertTrue(hasMap.getMap().get("foo").equals("bar"));`
1. The called method is `equals`.
2. The number of arguments is 1.
3. The argument is a string literal `"bar"`.
4. The method caller is an accessed variable `hasMap.getMap().get("foo")`.
5. The type of this accessed variable is assumed to be `String` (from the context of the method).
6. The string literal `"bar"` is the second argument in the method call, which violates the rule.

### Check `assertTrue(hasMap.getMap().get("fi").equals("fum"));`
1. The called method is `equals`.
2. The number of arguments is 1.
3. The argument is a string literal `"fum"`.
4. The method caller is an accessed variable `hasMap.getMap().get("fi")`.
5. The type of this accessed variable is assumed to be `String` (from the context of the method).
6. The string literal `"fum"` is the second argument in the method call, which violates the rule.

### Check `assertTrue(hasMap.getMap().get("fa") == null);`
1. This is not a method call to `equals`, `equalsIgnoreCase`, `compareTo`, `compareToIgnoreCase`, or `contentEquals`, but a comparison using the `==` operator.
2. Therefore, this does not violate the rule.

Based on the analysis, there are indeed 2 violations of the rule in the provided test case. The string literals `"bar"` and `"fum"` are not positioned first in the `equals` method calls.
['Get the method call from `assertTrue(hasMap.getMap().get("foo").equals("bar"));`', 'Get the name of called method.', 'Check whether the name is equals.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 1.', 'Get an argument of called method.', 'Check whether the argument is a string literal.', 'Get the method caller.', 'Check whether the method caller is an accessed variable.', 'Get the type of accessed variable.', 'Check whether the type of accessed variable is String.', 'If the called method is `equals` and the argument is a string literal and the method caller is an accessed variable of type String, check whether the string literal is the first argument.', 'Get the method call from `assertTrue(hasMap.getMap().get("fi").equals("fum"));`', 'Get the name of called method.', 'Check whether the name is equals.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 1.', 'Get an argument of called method.', 'Check whether the argument is a string literal.', 'Get the method caller.', 'Check whether the method caller is an accessed variable.', 'Get the type of accessed variable.', 'Check whether the type of accessed variable is String.', 'If the called method is `equals` and the argument is a string literal and the method caller is an accessed variable of type String, check whether the string literal is the first argument.', 'The called method is `equals`.', 'The number of arguments is 1.', 'The argument is a string literal `"bar"`.', 'The method caller is an accessed variable `hasMap.getMap().get("foo")`.', 'The type of this accessed variable is assumed to be `String` (from the context of the method).', 'The string literal `"bar"` is the second argument in the method call, which violates the rule.', 'The called method is `equals`.', 'The number of arguments is 1.', 'The argument is a string literal `"fum"`.', 'The method caller is an accessed variable `hasMap.getMap().get("fi")`.', 'The type of this accessed variable is assumed to be `String` (from the context of the method).', 'The string literal `"fum"` is the second argument in the method call, which violates the rule.', 'This is not a method call to `equals`, `equalsIgnoreCase`, `compareTo`, `compareToIgnoreCase`, or `contentEquals`, but a comparison using the `==` operator.', 'Therefore, this does not violate the rule.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'ASTNumericLiteral', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTExpressionStatement', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTImportDeclaration', 'ASTFormalParameters', 'ASTCastExpression', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTNullLiteral', 'ASTMethodDeclaration', 'AstImplUtil', 'ASTVoidType', 'TypesFromReflection', 'ASTLocalVariableDeclaration', 'ASTThisExpression', 'SymbolicValueHelper', 'ASTFieldAccess', 'SymbolResolutionPass', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTInfixExpression', 'ASTVariableDeclarator']
*Get the method call from `assertTrue(hasMap.getMap().get("foo").equals("bar"));`* 匹配到的元操作或API：
query: Get the method call from `assertTrue(hasMap.getMap().get("foo").equals("bar"));`
most similar API: Check whether the method call equals
cosine Similarity: 0.8038671612739563
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the name is equals.* 匹配到的元操作或API：
query: Check whether the name is equals.
most similar API: Check whether is equals method
cosine Similarity: 0.8145301938056946
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9077174663543701
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796929359436035
*Check whether the method caller is an accessed variable.* 匹配到的元操作或API：
logic: Check whether the method caller is an accessed variable.
most similar meta operation: Check whether the accessed variable is a local variable
cosine Similarity: 0.8596189618110657
*Get the type of accessed variable.* 匹配到的元操作或API：
logic: Get the type of accessed variable.
most similar meta operation: Get the type of accessed variable
cosine Similarity: 0.9871194362640381
*Check whether the type of accessed variable is String.* 匹配到的元操作或API：
logic: Check whether the type of accessed variable is String.
most similar meta operation: Check whether the accessed variable is string type
cosine Similarity: 0.9779624342918396
*If the called method is `equals` and the argument is a string literal and the method caller is an accessed variable of type String, check whether the string literal is the first argument.* 匹配到的元操作或API：
query: If the called method is `equals` and the argument is a string literal and the method caller is an accessed variable of type String, check whether the string literal is the first argument.
most similar API: Check whether the string literal equals
cosine Similarity: 0.828514039516449
*Get the method call from `assertTrue(hasMap.getMap().get("fi").equals("fum"));`* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the name is equals.* 匹配到的元操作或API：
query: Check whether the name is equals.
most similar API: Check whether is equals method
cosine Similarity: 0.8145301938056946
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9077174663543701
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796929359436035
*Check whether the method caller is an accessed variable.* 匹配到的元操作或API：
logic: Check whether the method caller is an accessed variable.
most similar meta operation: Check whether the accessed variable is a local variable
cosine Similarity: 0.8596189618110657
*Get the type of accessed variable.* 匹配到的元操作或API：
logic: Get the type of accessed variable.
most similar meta operation: Get the type of accessed variable
cosine Similarity: 0.9871194362640381
*Check whether the type of accessed variable is String.* 匹配到的元操作或API：
logic: Check whether the type of accessed variable is String.
most similar meta operation: Check whether the accessed variable is string type
cosine Similarity: 0.9779624342918396
*If the called method is `equals` and the argument is a string literal and the method caller is an accessed variable of type String, check whether the string literal is the first argument.* 匹配到的元操作或API：
query: If the called method is `equals` and the argument is a string literal and the method caller is an accessed variable of type String, check whether the string literal is the first argument.
most similar API: Check whether the string literal equals
cosine Similarity: 0.828514039516449
*The called method is `equals`.* 匹配到的元操作或API：
query: The called method is `equals`.
most similar API: Check whether is equals method
cosine Similarity: 0.8601488471031189
*The number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*The argument is a string literal `"bar"`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method caller is an accessed variable `hasMap.getMap().get("foo")`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The type of this accessed variable is assumed to be `String` (from the context of the method).* 匹配到的元操作或API：
未匹配成功元操作或API
*The string literal `"bar"` is the second argument in the method call, which violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*The called method is `equals`.* 匹配到的元操作或API：
query: The called method is `equals`.
most similar API: Check whether is equals method
cosine Similarity: 0.8601488471031189
*The number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*The argument is a string literal `"fum"`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method caller is an accessed variable `hasMap.getMap().get("fi")`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The type of this accessed variable is assumed to be `String` (from the context of the method).* 匹配到的元操作或API：
未匹配成功元操作或API
*The string literal `"fum"` is the second argument in the method call, which violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*This is not a method call to `equals`, `equalsIgnoreCase`, `compareTo`, `compareToIgnoreCase`, or `contentEquals`, but a comparison using the `==` operator.* 匹配到的元操作或API：
未匹配成功元操作或API
*Therefore, this does not violate the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is a local variable
    public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym instanceof JLocalVariableSymbol) {
            JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
            return true;
        }
        return false;
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var) {
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
This checker has passed this negative testcase:
import java.io.File;
public class Foo {
    public boolean bar() {
        File f;
        return f.getParent().equals("testStr");
    }
}


This checker is failed(false negative) on this negative test case:
```
// FN with unresolved types
import java.util.Map;
import my.Unknown;
class Foo {
    public void testObjectArray(Unknown uk) {
        Unknown hasMap = (Unknown) this.beanFactory.getBean("literalMap");
        assertTrue(hasMap.getMap().size() == 3);
        assertTrue(hasMap.getMap().get("foo").equals("bar"));
        assertTrue(hasMap.getMap().get("fi").equals("fum"));
        assertTrue(hasMap.getMap().get("fa") == null);
    }
}
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testObjectArray')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'uk')
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'hasMap')
            ——ASTCastExpression
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTMethodCall (called method name = 'getBean')
                ——ASTFieldAccess
                  ——ASTThisExpression
                ——ASTArgumentList (size = 1)
                  ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'assertTrue')
            ——ASTArgumentList (size = 1)
              ——ASTInfixExpression
                ——ASTMethodCall (called method name = 'size')
                  ——ASTMethodCall (called method name = 'getMap')
                    ——ASTVariableAccess (referenced variable name = 'hasMap')
                    ——ASTArgumentList (size = 0)
                  ——ASTArgumentList (size = 0)
                ——ASTNumericLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'assertTrue')
            ——ASTArgumentList (size = 1)
              ——ASTMethodCall (called method name = 'equals')
                ——ASTMethodCall (called method name = 'get')
                  ——ASTMethodCall (called method name = 'getMap')
                    ——ASTVariableAccess (referenced variable name = 'hasMap')
                    ——ASTArgumentList (size = 0)
                  ——ASTArgumentList (size = 1)
                    ——ASTStringLiteral
                ——ASTArgumentList (size = 1)
                  ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'assertTrue')
            ——ASTArgumentList (size = 1)
              ——ASTMethodCall (called method name = 'equals')
                ——ASTMethodCall (called method name = 'get')
                  ——ASTMethodCall (called method name = 'getMap')
                    ——ASTVariableAccess (referenced variable name = 'hasMap')
                    ——ASTArgumentList (size = 0)
                  ——ASTArgumentList (size = 1)
                    ——ASTStringLiteral
                ——ASTArgumentList (size = 1)
                  ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'assertTrue')
            ——ASTArgumentList (size = 1)
              ——ASTInfixExpression
                ——ASTMethodCall (called method name = 'get')
                  ——ASTMethodCall (called method name = 'getMap')
                    ——ASTVariableAccess (referenced variable name = 'hasMap')
                    ——ASTArgumentList (size = 0)
                  ——ASTArgumentList (size = 1)
                    ——ASTStringLiteral
                ——ASTNullLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
3. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isEqualsMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()
6. net.sourceforge.pmd.lang.java.ast.ASTVariableAccess: public net.sourceforge.pmd.lang.java.types.JTypeMirror getTypeMirror()
7. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean equals(java.lang.Object)

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
2.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
3.  //Check whether the accessed variable is a local variable
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JLocalVariableSymbol;
public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JLocalVariableSymbol) {
        JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
        return true;
    }
    return false;
}
```
4.  //Check whether the accessed variable is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTVariableAccess var){
    return TypeTestUtil.isA(String.class, var.getTypeMirror());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "ok 16" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
117
102
83
69
=========================error_testcase_logics=========================
1. Get the name of called method.
2. Check whether the name is equals.
3. Check whether the name is equalsIgnoreCase.
4. Check whether the name is compareTo.
5. Check whether the name is compareToIgnoreCase.
6. Check whether the name is contentEquals.
7. Get the method caller.
8. Get the number of arguments of called method.
9. Check whether the number of arguments is 1.
10. Get the first argument of called method.
11. Check whether the first argument is a literal.

Given the test case:

- The called method is `equals`.
- The method caller is `someString`, which is not a literal.
- The first argument is `TEST_CONSTANT`, which is not a literal.

Since the called method is a String comparison method (`equals`), and the first argument (`someString`) is not a literal, the test case does not violate the rule.

The number of violating the rule in this test case is: 0.
['Get the name of called method.', 'Check whether the name is equals.', 'Check whether the name is equalsIgnoreCase.', 'Check whether the name is compareTo.', 'Check whether the name is compareToIgnoreCase.', 'Check whether the name is contentEquals.', 'Get the method caller.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 1.', 'Get the first argument of called method.', 'Check whether the first argument is a literal.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the name is equals.* 匹配到的元操作或API：
query: Check whether the name is equals.
most similar API: Check whether the field equals
cosine Similarity: 0.8173664212226868
*Check whether the name is equalsIgnoreCase.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the name is compareTo.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the name is compareToIgnoreCase.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the name is contentEquals.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796929359436035
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of called method.* 匹配到的元操作或API：
logic: Get the first argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9160765409469604
*Check whether the first argument is a literal.* 匹配到的元操作或API：
query: Check whether the first argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8155132532119751
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
This checker has passed this negative testcase:
import java.io.File;
public class Foo {
    public boolean bar() {
        File f;
        return f.getParent().equals("testStr");
    }
}
This checker has passed this negative testcase:
import java.util.Map;
import my.Unknown;
class Foo {
    public void testObjectArray(Unknown uk) {
        Unknown hasMap = (Unknown) this.beanFactory.getBean("literalMap");
        assertTrue(hasMap.getMap().size() == 3);
        assertTrue(hasMap.getMap().get("foo").equals("bar"));
        assertTrue(hasMap.getMap().get("fi").equals("fum"));
        assertTrue(hasMap.getMap().get("fa") == null);
    }
}


This checker is failed(false positive) on this positive test case:
```
// #575 LiteralsFirstInComparisons must not trigger if the field is not final
public class Foo {
    private static String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'TEST_CONSTANT')
        ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'test')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'boolean')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'someString')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'someString')
            ——ASTArgumentList (size = 1)
              ——ASTVariableAccess (referenced variable name = 'TEST_CONSTANT')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
5. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isBooleanLiteral(net.sourceforge.pmd.lang.java.ast.JavaNode), //Returns true if the node is a boolean literal with any value.

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier) && !isFieldFinal(qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }

    // Check whether the variable access is a final field
    private boolean isFieldFinal(ASTExpression expression) {
        if (expression instanceof ASTVariableAccess) {
            ASTVariableAccess varAccess = (ASTVariableAccess) expression;
            NodeStream<ASTFieldDeclaration> fieldDeclarations = varAccess.getScope().getDeclarations(ASTFieldDeclaration.class).filter(fd -> fd.hasName(varAccess.getName()));
            return fieldDeclarations.anyMatch(fd -> fd.isFinal());
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of called method.
2. Check whether the called method is `equals`.
3. Check whether the called method is `equalsIgnoreCase`.
4. Check whether the called method is `compareTo`.
5. Check whether the called method is `compareToIgnoreCase`.
6. Check whether the called method is `contentEquals`.
7. If any of the above checks are true, get the number of arguments of called method.
8. Check whether the number of arguments is 2.
9. Get an argument of called method at index 0.
10. Check whether the argument is a literal.
11. Get an argument of called method at index 1.
12. Check whether the argument is a literal.
13. If the first argument is not a literal and the second argument is a literal, the rule is violated.
14. If the first argument is a literal and the second argument is not a literal, the rule is not violated.
15. Check whether the second argument is a field.
16. If the second argument is a field, check whether the field is final.
17. If the second argument is a field and the field is not final, the rule is not violated.

Based on the test case:
1. Get the name of called method. The method name is `equals`.
2. Check whether the called method is `equals`. This is true.
3. Get the number of arguments of called method. The number of arguments is 2.
4. Get an argument of called method at index 0. The argument is `someString`.
5. Check whether the argument is a literal. This is false.
6. Get an argument of called method at index 1. The argument is `TEST_CONSTANT`.
7. Check whether the argument is a literal. This is false.
8. Check whether the second argument is a field. This is true.
9. Check whether the field is final. This is false.

Since the second argument is a field and it is not final, the rule is not violated.
The number of violations in this test case is: 0
['Get the name of called method.', 'Check whether the called method is `equals`.', 'Check whether the called method is `equalsIgnoreCase`.', 'Check whether the called method is `compareTo`.', 'Check whether the called method is `compareToIgnoreCase`.', 'Check whether the called method is `contentEquals`.', 'If any of the above checks are true, get the number of arguments of called method.', 'Check whether the number of arguments is 2.', 'Get an argument of called method at index 0.', 'Check whether the argument is a literal.', 'Get an argument of called method at index 1.', 'Check whether the argument is a literal.', 'If the first argument is not a literal and the second argument is a literal, the rule is violated.', 'If the first argument is a literal and the second argument is not a literal, the rule is not violated.', 'Check whether the second argument is a field.', 'If the second argument is a field, check whether the field is final.', 'If the second argument is a field and the field is not final, the rule is not violated.', 'Get the name of called method. The method name is `equals`.', 'Check whether the called method is `equals`. This is true.', 'Get the number of arguments of called method. The number of arguments is 2.', 'Get an argument of called method at index 0. The argument is `someString`.', 'Check whether the argument is a literal. This is false.', 'Get an argument of called method at index 1. The argument is `TEST_CONSTANT`.', 'Check whether the argument is a literal. This is false.', 'Check whether the second argument is a field. This is true.', 'Check whether the field is final. This is false.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the called method is `equals`.* 匹配到的元操作或API：
query: Check whether the called method is `equals`.
most similar API: Check whether the method call equals
cosine Similarity: 0.9475967884063721
*Check whether the called method is `equalsIgnoreCase`.* 匹配到的元操作或API：
query: Check whether the called method is `equalsIgnoreCase`.
most similar API: Check whether the method call equals
cosine Similarity: 0.8622065782546997
*Check whether the called method is `compareTo`.* 匹配到的元操作或API：
query: Check whether the called method is `compareTo`.
most similar API: Check whether the method call equals
cosine Similarity: 0.8749629855155945
*Check whether the called method is `compareToIgnoreCase`.* 匹配到的元操作或API：
query: Check whether the called method is `compareToIgnoreCase`.
most similar API: Check whether the method call equals
cosine Similarity: 0.8348910212516785
*Check whether the called method is `contentEquals`.* 匹配到的元操作或API：
query: Check whether the called method is `contentEquals`.
most similar API: Check whether the method call equals
cosine Similarity: 0.8517297506332397
*If any of the above checks are true, get the number of arguments of called method.* 匹配到的元操作或API：
logic: If any of the above checks are true, get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9197521209716797
*Check whether the number of arguments is 2.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get an argument of called method at index 0.* 匹配到的元操作或API：
logic: Get an argument of called method at index 0.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8842777013778687
*Check whether the argument is a literal.* 匹配到的元操作或API：
query: Check whether the argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8468949198722839
*Get an argument of called method at index 1.* 匹配到的元操作或API：
logic: Get an argument of called method at index 1.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9059028029441833
*Check whether the argument is a literal.* 匹配到的元操作或API：
query: Check whether the argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8468949198722839
*If the first argument is not a literal and the second argument is a literal, the rule is violated.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the first argument is a literal and the second argument is not a literal, the rule is not violated.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the second argument is a field.* 匹配到的元操作或API：
query: Check whether the second argument is a field.
most similar API: Check whether the field is syntactically abstract
cosine Similarity: 0.8110605478286743
*If the second argument is a field, check whether the field is final.* 匹配到的元操作或API：
logic: If the second argument is a field, check whether the field is final.
most similar meta operation: Check whether the field is final
cosine Similarity: 0.9177929162979126
*If the second argument is a field and the field is not final, the rule is not violated.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of called method. The method name is `equals`.* 匹配到的元操作或API：
logic: Get the name of called method. The method name is `equals`.
most similar meta operation: Get the name of called method
cosine Similarity: 0.876717746257782
*Check whether the called method is `equals`. This is true.* 匹配到的元操作或API：
query: Check whether the called method is `equals`. This is true.
most similar API: Check whether the method call equals
cosine Similarity: 0.9295824766159058
*Get the number of arguments of called method. The number of arguments is 2.* 匹配到的元操作或API：
logic: Get the number of arguments of called method. The number of arguments is 2.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9483803510665894
*Get an argument of called method at index 0. The argument is `someString`.* 匹配到的元操作或API：
logic: Get an argument of called method at index 0. The argument is `someString`.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8607191443443298
*Check whether the argument is a literal. This is false.* 匹配到的元操作或API：
query: Check whether the argument is a literal. This is false.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8454094529151917
*Get an argument of called method at index 1. The argument is `TEST_CONSTANT`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the argument is a literal. This is false.* 匹配到的元操作或API：
query: Check whether the argument is a literal. This is false.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8454094529151917
*Check whether the second argument is a field. This is true.* 匹配到的元操作或API：
query: Check whether the second argument is a field. This is true.
most similar API: Check whether the field is syntactically abstract
cosine Similarity: 0.8050561547279358
*Check whether the field is final. This is false.* 匹配到的元操作或API：
logic: Check whether the field is final. This is false.
most similar meta operation: Check whether the field is final
cosine Similarity: 0.9635826945304871
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
This checker has passed this negative testcase:
import java.io.File;
public class Foo {
    public boolean bar() {
        File f;
        return f.getParent().equals("testStr");
    }
}
This checker has passed this negative testcase:
import java.util.Map;
import my.Unknown;
class Foo {
    public void testObjectArray(Unknown uk) {
        Unknown hasMap = (Unknown) this.beanFactory.getBean("literalMap");
        assertTrue(hasMap.getMap().size() == 3);
        assertTrue(hasMap.getMap().get("foo").equals("bar"));
        assertTrue(hasMap.getMap().get("fi").equals("fum"));
        assertTrue(hasMap.getMap().get("fa") == null);
    }
}


This checker is failed(false positive) on this positive test case:
```
// #575 LiteralsFirstInComparisons must not trigger if the field is not final
public class Foo {
    private static String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'TEST_CONSTANT')
        ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'test')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'boolean')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'someString')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'someString')
            ——ASTArgumentList (size = 1)
              ——ASTVariableAccess (referenced variable name = 'TEST_CONSTANT')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
4. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isBooleanLiteral(net.sourceforge.pmd.lang.java.ast.JavaNode), //Returns true if the node is a boolean literal with any value.
5. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isSyntacticallyAbstract()
6. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isFinal()

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier) && !isFinalField((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }

    // Check whether the variable access is a final field
    public boolean isFinalField(ASTVariableAccess var) {
        ASTFieldDeclaration fieldDeclaration = var.getReferencedFieldDeclaration();
        return fieldDeclaration != null && fieldDeclaration.isFinal();
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the method declaration from method call.
        2. Get the name of called method.
        3. Check whether the name is equals.
        4. Check whether the name is equalsIgnoreCase.
        5. Check whether the name is compareTo.
        6. Check whether the name is compareToIgnoreCase.
        7. Check whether the name is contentEquals.
        8. If the called method name is one of the above, get the argument list of the method.
        9. Get the size of the argument list.
        10. Check whether the size of the argument list is 1.
        11. Get the type of the first argument.
        12. Check whether the type of the first argument is String.
        13. Get the type of the second argument.
        14. Check whether the type of the second argument is String.
        15. If the second argument is a String, check whether the first argument is a literal.
        16. If the second argument is a String, check whether the second argument is a literal.
        17. If the second argument is not a literal, check whether the second argument is null.
        If the called method name is one of the specified String comparison methods, the first argument is a String, and the second argument is a String that is not a literal and not null, then this test case violates the rule.
        In this test case:
        18. Get the name of the second argument.
        19. Check whether the name of the second argument is TEST_CONSTANT.
        20. Check whether the TEST_CONSTANT field is final.
        Since the second argument is not a literal and the TEST_CONSTANT field is not final, this test case does not violate the rule.
['Get the method declaration from method call.', 'Get the name of called method.', 'Check whether the name is equals.', 'Check whether the name is equalsIgnoreCase.', 'Check whether the name is compareTo.', 'Check whether the name is compareToIgnoreCase.', 'Check whether the name is contentEquals.', 'If the called method name is one of the above, get the argument list of the method.', 'Get the size of the argument list.', 'Check whether the size of the argument list is 1.', 'Get the type of the first argument.', 'Check whether the type of the first argument is String.', 'Get the type of the second argument.', 'Check whether the type of the second argument is String.', 'If the second argument is a String, check whether the first argument is a literal.', 'If the second argument is a String, check whether the second argument is a literal.', 'If the second argument is not a literal, check whether the second argument is null.', 'Get the name of the second argument.', 'Check whether the name of the second argument is TEST_CONSTANT.', 'Check whether the TEST_CONSTANT field is final.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the method declaration from method call.* 匹配到的元操作或API：
logic: Get the method declaration from method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9787436127662659
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the name is equals.* 匹配到的元操作或API：
query: Check whether the name is equals.
most similar API: Check whether the field equals
cosine Similarity: 0.8173664212226868
*Check whether the name is equalsIgnoreCase.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the name is compareTo.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the name is compareToIgnoreCase.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the name is contentEquals.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the called method name is one of the above, get the argument list of the method.* 匹配到的元操作或API：
logic: If the called method name is one of the above, get the argument list of the method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8603870868682861
*Get the size of the argument list.* 匹配到的元操作或API：
query: Get the size of the argument list.
most similar API: size of argument list
cosine Similarity: 0.9323437213897705
*Check whether the size of the argument list is 1.* 匹配到的元操作或API：
query: Check whether the size of the argument list is 1.
most similar API: size of argument list
cosine Similarity: 0.8514926433563232
*Get the type of the first argument.* 匹配到的元操作或API：
logic: Get the type of the first argument.
most similar meta operation: Get the type of argument
cosine Similarity: 0.9078187942504883
*Check whether the type of the first argument is String.* 匹配到的元操作或API：
logic: Check whether the type of the first argument is String.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9387744665145874
*Get the type of the second argument.* 匹配到的元操作或API：
logic: Get the type of the second argument.
most similar meta operation: Get the type of argument
cosine Similarity: 0.9059659242630005
*Check whether the type of the second argument is String.* 匹配到的元操作或API：
logic: Check whether the type of the second argument is String.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9355405569076538
*If the second argument is a String, check whether the first argument is a literal.* 匹配到的元操作或API：
logic: If the second argument is a String, check whether the first argument is a literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8528046607971191
*If the second argument is a String, check whether the second argument is a literal.* 匹配到的元操作或API：
logic: If the second argument is a String, check whether the second argument is a literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.851813793182373
*If the second argument is not a literal, check whether the second argument is null.* 匹配到的元操作或API：
query: If the second argument is not a literal, check whether the second argument is null.
most similar API: Check whether is null literal
cosine Similarity: 0.8410201072692871
*Get the name of the second argument.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the name of the second argument is TEST_CONSTANT.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the TEST_CONSTANT field is final.* 匹配到的元操作或API：
logic: Check whether the TEST_CONSTANT field is final.
most similar meta operation: Check whether the field is final
cosine Similarity: 0.8871498703956604
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
This checker has passed this negative testcase:
import java.io.File;
public class Foo {
    public boolean bar() {
        File f;
        return f.getParent().equals("testStr");
    }
}
This checker has passed this negative testcase:
import java.util.Map;
import my.Unknown;
class Foo {
    public void testObjectArray(Unknown uk) {
        Unknown hasMap = (Unknown) this.beanFactory.getBean("literalMap");
        assertTrue(hasMap.getMap().size() == 3);
        assertTrue(hasMap.getMap().get("foo").equals("bar"));
        assertTrue(hasMap.getMap().get("fi").equals("fum"));
        assertTrue(hasMap.getMap().get("fa") == null);
    }
}


This checker is failed(false positive) on this positive test case:
```
// #575 LiteralsFirstInComparisons must not trigger if the field is not final
public class Foo {
    private static String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'TEST_CONSTANT')
        ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'test')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'boolean')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'someString')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'someString')
            ——ASTArgumentList (size = 1)
              ——ASTVariableAccess (referenced variable name = 'TEST_CONSTANT')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
4. net.sourceforge.pmd.lang.java.ast.ASTArgumentList: public int size(), //Returns the number of nodes in this list. This must be the number of nodes yielded by the {@link #iterator()}.
5. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isNullLiteral(net.sourceforge.pmd.lang.java.ast.ASTExpression)
6. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isFinal()

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```
2.  //Get the type of argument
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getMethodCallArgumentType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror();
}
```
3.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier)) {
                if (!isFinalVariableAccess((ASTVariableAccess) qualifier)) {
                    addViolation(data, node);
                }
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }

    // Check whether the accessed variable is final
    public boolean isFinalVariableAccess(ASTVariableAccess var) {
        JVariableSymbol symbol = (JVariableSymbol) var.getVariableSymbol();
        return symbol != null && symbol.isFinal();
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the method declaration from the method call.
2. Get the name of called method.
3. Check whether the called method is equals.
4. Get the number of arguments of called method.
5. Get the type of second argument.
6. Check whether the type of second argument is String.
7. Check whether the second argument is a literal.
8. Check whether the second argument is a final field.
9. Check whether the second argument is null.
10. If the called method is one of the comparison methods (equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals) and the second argument is of type String and is not a literal and is not null, then this test case violates the rule.
In this test case, the called method is 'equals', the second argument is 'TEST_CONSTANT', which is a String but it is not a literal and it is not null. However, the rule specifies that it should not trigger if the field is not final. Since 'TEST_CONSTANT' is not final, this test case does not violate the rule.
['Get the method declaration from the method call.', 'Get the name of called method.', 'Check whether the called method is equals.', 'Get the number of arguments of called method.', 'Get the type of second argument.', 'Check whether the type of second argument is String.', 'Check whether the second argument is a literal.', 'Check whether the second argument is a final field.', 'Check whether the second argument is null.', 'If the called method is one of the comparison methods (equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals) and the second argument is of type String and is not a literal and is not null, then this test case violates the rule.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the method declaration from the method call.* 匹配到的元操作或API：
logic: Get the method declaration from the method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9715674519538879
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the called method is equals.* 匹配到的元操作或API：
query: Check whether the called method is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9604323506355286
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Get the type of second argument.* 匹配到的元操作或API：
logic: Get the type of second argument.
most similar meta operation: Get the type of argument
cosine Similarity: 0.9132068753242493
*Check whether the type of second argument is String.* 匹配到的元操作或API：
logic: Check whether the type of second argument is String.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9374277591705322
*Check whether the second argument is a literal.* 匹配到的元操作或API：
query: Check whether the second argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8142394423484802
*Check whether the second argument is a final field.* 匹配到的元操作或API：
logic: Check whether the second argument is a final field.
most similar meta operation: Check whether the field is final
cosine Similarity: 0.9039234519004822
*Check whether the second argument is null.* 匹配到的元操作或API：
query: Check whether the second argument is null.
most similar API: Check whether is null check
cosine Similarity: 0.8355708122253418
*If the called method is one of the comparison methods (equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals) and the second argument is of type String and is not a literal and is not null, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
This checker has passed this negative testcase:
import java.io.File;
public class Foo {
    public boolean bar() {
        File f;
        return f.getParent().equals("testStr");
    }
}
This checker has passed this negative testcase:
import java.util.Map;
import my.Unknown;
class Foo {
    public void testObjectArray(Unknown uk) {
        Unknown hasMap = (Unknown) this.beanFactory.getBean("literalMap");
        assertTrue(hasMap.getMap().size() == 3);
        assertTrue(hasMap.getMap().get("foo").equals("bar"));
        assertTrue(hasMap.getMap().get("fi").equals("fum"));
        assertTrue(hasMap.getMap().get("fa") == null);
    }
}


This checker is failed(false positive) on this positive test case:
```
// #575 LiteralsFirstInComparisons must not trigger if the field is not final
public class Foo {
    private static String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'TEST_CONSTANT')
        ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'test')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'boolean')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'someString')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'someString')
            ——ASTArgumentList (size = 1)
              ——ASTVariableAccess (referenced variable name = 'TEST_CONSTANT')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isBooleanLiteral(net.sourceforge.pmd.lang.java.ast.JavaNode), //Returns true if the node is a boolean literal with any value.
4. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isFinal()
5. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullCheck(net.sourceforge.pmd.lang.java.ast.ASTExpression, net.sourceforge.pmd.lang.java.rule.internal.StablePathMatcher)

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
3.  //Get the type of argument
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getMethodCallArgumentType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror();
}
```
4.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && !isFinalVariableAccess((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }

    // Check whether the variable access is final
    public boolean isFinalVariableAccess(ASTVariableAccess varAccess) {
        ASTFieldDeclaration fieldDeclaration = varAccess.getDeclaringField();
        return fieldDeclaration != null && fieldDeclaration.isFinal();
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of method.
        2. Check whether the method is named `equals`, `equalsIgnoreCase`, `compareTo`, `compareToIgnoreCase`, or `contentEquals`.
        3. Get the argument list of method.
        4. Get the size of argument list.
        5. Check whether the size of argument list is 1.
        6. Check whether the called method is a String method.
        7. Get the left operand of the method call.
        8. Check whether the left operand is a string literal.
        9. Get the right operand of the method call.
        10. Check whether the right operand is an accessed field.
        11. Check whether the accessed field is final.
        12. Check whether the right operand is null.

If the method call is one of the String comparison methods and the left operand is not a string literal, and the right operand is a final field or null, then it violates the rule. In this case:

- The method `equals` is being called.
- It is a String method.
- The left operand `someString` is not a string literal.
- The right operand `TEST_CONSTANT` is a field, but it is not final.
- Therefore, this test case does not violate the rule.
['Get the name of method.', 'Check whether the method is named `equals`, `equalsIgnoreCase`, `compareTo`, `compareToIgnoreCase`, or `contentEquals`.', 'Get the argument list of method.', 'Get the size of argument list.', 'Check whether the size of argument list is 1.', 'Check whether the called method is a String method.', 'Get the left operand of the method call.', 'Check whether the left operand is a string literal.', 'Get the right operand of the method call.', 'Check whether the right operand is an accessed field.', 'Check whether the accessed field is final.', 'Check whether the right operand is null.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is named `equals`, `equalsIgnoreCase`, `compareTo`, `compareToIgnoreCase`, or `contentEquals`.* 匹配到的元操作或API：
query: Check whether the method is named `equals`, `equalsIgnoreCase`, `compareTo`, `compareToIgnoreCase`, or `contentEquals`.
most similar API: Check whether the method equals
cosine Similarity: 0.8323230743408203
*Get the argument list of method.* 匹配到的元操作或API：
logic: Get the argument list of method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8603730797767639
*Get the size of argument list.* 匹配到的元操作或API：
query: Get the size of argument list.
most similar API: size of argument list
cosine Similarity: 0.9362417459487915
*Check whether the size of argument list is 1.* 匹配到的元操作或API：
query: Check whether the size of argument list is 1.
most similar API: size of argument list
cosine Similarity: 0.856735110282898
*Check whether the called method is a String method.* 匹配到的元操作或API：
logic: Check whether the called method is a String method.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.9245907664299011
*Get the left operand of the method call.* 匹配到的元操作或API：
logic: Get the left operand of the method call.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8822497129440308
*Check whether the left operand is a string literal.* 匹配到的元操作或API：
query: Check whether the left operand is a string literal.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8731948733329773
*Get the right operand of the method call.* 匹配到的元操作或API：
logic: Get the right operand of the method call.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.8626012802124023
*Check whether the right operand is an accessed field.* 匹配到的元操作或API：
logic: Check whether the right operand is an accessed field.
most similar meta operation: Check whether the accessed variable is a field
cosine Similarity: 0.8615913987159729
*Check whether the accessed field is final.* 匹配到的元操作或API：
logic: Check whether the accessed field is final.
most similar meta operation: Check whether the field is final
cosine Similarity: 0.9394946098327637
*Check whether the right operand is null.* 匹配到的元操作或API：
query: Check whether the right operand is null.
most similar API: Check whether is null check
cosine Similarity: 0.8312555551528931
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
This checker has passed this negative testcase:
import java.io.File;
public class Foo {
    public boolean bar() {
        File f;
        return f.getParent().equals("testStr");
    }
}
This checker has passed this negative testcase:
import java.util.Map;
import my.Unknown;
class Foo {
    public void testObjectArray(Unknown uk) {
        Unknown hasMap = (Unknown) this.beanFactory.getBean("literalMap");
        assertTrue(hasMap.getMap().size() == 3);
        assertTrue(hasMap.getMap().get("foo").equals("bar"));
        assertTrue(hasMap.getMap().get("fi").equals("fum"));
        assertTrue(hasMap.getMap().get("fa") == null);
    }
}


This checker is failed(false positive) on this positive test case:
```
// #575 LiteralsFirstInComparisons must not trigger if the field is not final
public class Foo {
    private static String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'TEST_CONSTANT')
        ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'test')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'boolean')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'someString')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'someString')
            ——ASTArgumentList (size = 1)
              ——ASTVariableAccess (referenced variable name = 'TEST_CONSTANT')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
4. net.sourceforge.pmd.lang.java.ast.ASTArgumentList: public int size(), //Returns the number of nodes in this list. This must be the number of nodes yielded by the {@link #iterator()}.
5. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr getLeftOperand()
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
7. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
8. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isFinal()
9. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullCheck(net.sourceforge.pmd.lang.java.ast.ASTExpression, net.sourceforge.pmd.lang.java.rule.internal.StablePathMatcher)

1.  //Check whether the method caller is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallerStringType(ASTMethodCall node){
    return TypeTestUtil.isA(String.class, node.getQualifier());
}
```
2.  //Check whether the accessed variable is a field
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;
public boolean isVariableAccessField(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JFieldSymbol) {
        JFieldSymbol fieldSym = (JFieldSymbol) sym;
        return true;
    }
    return false;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) &&
            isStringType(qualifier) &&
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") ||
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") ||
             methodName.equals("contentEquals"))) {

            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier) && !isFinalField((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) &&
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") ||
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") ||
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var) {
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }

    // Check whether the accessed variable is a field
    public boolean isVariableAccessField(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym instanceof JFieldSymbol) {
            JFieldSymbol fieldSym = (JFieldSymbol) sym;
            return true;
        }
        return false;
    }

    // Check whether the field is final
    public boolean isFinalField(ASTVariableAccess node) {
        if (isVariableAccessField(node)) {
            JVariableSymbol sym = node.getReferencedSym();
            JFieldSymbol fieldSym = (JFieldSymbol) sym;
            return fieldSym.isFinal();
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 16" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 16" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 16
[ERROR]   "ok 17" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
117
102
83
69
=========================error_testcase_logics=========================
1. Get the method declaration from method call.
        2. Get the name of called method.
        3. Check whether the called method is 'equals'.
        4. Check whether the called method is 'equalsIgnoreCase'.
        5. Check whether the called method is 'compareTo'.
        6. Check whether the called method is 'compareToIgnoreCase'.
        7. Check whether the called method is 'contentEquals'.
        8. Get the number of arguments of called method.
        9. Check whether the number of arguments is 2.
        10. Get the first argument of called method.
        11. Check whether the first argument is a literal.
        12. Get the second argument of called method.
        13. Check whether the second argument is a literal.
        14. Check whether the second argument is an accessed field.
        15. Check whether the accessed field is static.
        16. Check whether the second argument is a constant (final).
        17. Check whether the second argument is null.

In this test case:
- The called method name is 'equals'.
- The number of arguments is 1.
- The first argument `someString` is not a literal.
- The second argument `TEST_CONSTANT` is a literal.
- The second argument `TEST_CONSTANT` is an accessed field.
- The accessed field `TEST_CONSTANT` is final.
- The accessed field `TEST_CONSTANT` is not static.

Since the number of arguments is 1, the rule checks for literals in the second argument do not apply. Additionally, the field `TEST_CONSTANT` is final, but not static, and the rule specifically states that it should not trigger if the field is not static.

Thus, the number of violations in this test case is indeed 0.
['Get the method declaration from method call.', 'Get the name of called method.', "Check whether the called method is 'equals'.", "Check whether the called method is 'equalsIgnoreCase'.", "Check whether the called method is 'compareTo'.", "Check whether the called method is 'compareToIgnoreCase'.", "Check whether the called method is 'contentEquals'.", 'Get the number of arguments of called method.', 'Check whether the number of arguments is 2.', 'Get the first argument of called method.', 'Check whether the first argument is a literal.', 'Get the second argument of called method.', 'Check whether the second argument is a literal.', 'Check whether the second argument is an accessed field.', 'Check whether the accessed field is static.', 'Check whether the second argument is a constant (final).', 'Check whether the second argument is null.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the method declaration from method call.* 匹配到的元操作或API：
logic: Get the method declaration from method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9787436127662659
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the called method is 'equals'.* 匹配到的元操作或API：
query: Check whether the called method is 'equals'.
most similar API: Check whether the method call equals
cosine Similarity: 0.9493668675422668
*Check whether the called method is 'equalsIgnoreCase'.* 匹配到的元操作或API：
query: Check whether the called method is 'equalsIgnoreCase'.
most similar API: Check whether the method call equals
cosine Similarity: 0.8622845411300659
*Check whether the called method is 'compareTo'.* 匹配到的元操作或API：
query: Check whether the called method is 'compareTo'.
most similar API: Check whether the method call equals
cosine Similarity: 0.8789836168289185
*Check whether the called method is 'compareToIgnoreCase'.* 匹配到的元操作或API：
query: Check whether the called method is 'compareToIgnoreCase'.
most similar API: Check whether the method call equals
cosine Similarity: 0.8353525996208191
*Check whether the called method is 'contentEquals'.* 匹配到的元操作或API：
query: Check whether the called method is 'contentEquals'.
most similar API: Check whether the method call equals
cosine Similarity: 0.8520155549049377
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 2.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of called method.* 匹配到的元操作或API：
logic: Get the first argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9160765409469604
*Check whether the first argument is a literal.* 匹配到的元操作或API：
query: Check whether the first argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8155132532119751
*Get the second argument of called method.* 匹配到的元操作或API：
logic: Get the second argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9016816020011902
*Check whether the second argument is a literal.* 匹配到的元操作或API：
query: Check whether the second argument is a literal.
most similar API: Check whether is boolean literal
cosine Similarity: 0.8142394423484802
*Check whether the second argument is an accessed field.* 匹配到的元操作或API：
logic: Check whether the second argument is an accessed field.
most similar meta operation: Check whether the accessed variable is a field
cosine Similarity: 0.8689169883728027
*Check whether the accessed field is static.* 匹配到的元操作或API：
logic: Check whether the accessed field is static.
most similar meta operation: Check whether the field is static
cosine Similarity: 0.9319617748260498
*Check whether the second argument is a constant (final).* 匹配到的元操作或API：
query: Check whether the second argument is a constant (final).
most similar API: Check whether the formal parameter is final
cosine Similarity: 0.8015555739402771
*Check whether the second argument is null.* 匹配到的元操作或API：
query: Check whether the second argument is null.
most similar API: Check whether is null check
cosine Similarity: 0.8355708122253418
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
This checker has passed this negative testcase:
import java.io.File;
public class Foo {
    public boolean bar() {
        File f;
        return f.getParent().equals("testStr");
    }
}
This checker has passed this negative testcase:
import java.util.Map;
import my.Unknown;
class Foo {
    public void testObjectArray(Unknown uk) {
        Unknown hasMap = (Unknown) this.beanFactory.getBean("literalMap");
        assertTrue(hasMap.getMap().size() == 3);
        assertTrue(hasMap.getMap().get("foo").equals("bar"));
        assertTrue(hasMap.getMap().get("fi").equals("fum"));
        assertTrue(hasMap.getMap().get("fa") == null);
    }
}


This checker is failed(false positive) on this positive test case:
```
// #575 LiteralsFirstInComparisons must not trigger if the field is not static
public class Foo {
    private final String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'TEST_CONSTANT')
        ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'test')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'boolean')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'someString')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'someString')
            ——ASTArgumentList (size = 1)
              ——ASTVariableAccess (referenced variable name = 'TEST_CONSTANT')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
4. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isBooleanLiteral(net.sourceforge.pmd.lang.java.ast.JavaNode), //Returns true if the node is a boolean literal with any value.
5. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isStatic()
6. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public boolean isFinal(), //Returns true if this variable, method or class is final (even implicitly).
7. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullCheck(net.sourceforge.pmd.lang.java.ast.ASTExpression, net.sourceforge.pmd.lang.java.rule.internal.StablePathMatcher)

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
3.  //Check whether the accessed variable is a field
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;
public boolean isVariableAccessField(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JFieldSymbol) {
        JFieldSymbol fieldSym = (JFieldSymbol) sym;
        return true;
    }
    return false;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier) && !isStaticField(node)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }

    // Check whether the accessed variable is a static field
    public boolean isStaticField(ASTMethodCall node) {
        ASTExpression qualifier = node.getQualifier();
        if (qualifier instanceof ASTVariableAccess) {
            ASTVariableAccess varAccess = (ASTVariableAccess) qualifier;
            JVariableSymbol sym = varAccess.getReferencedSym();
            if (sym instanceof JFieldSymbol) {
                return ((JFieldSymbol) sym).isStatic();
            }
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 17" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 17" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
To perform the granular checks to ascertain the test case's adherence to the rule, we need to analyze the method call within the `test` method of the `Foo` class.

1. Get the name of called method.
2. Check whether the name is equals.
3. Get the argument list of method.
4. Get the size of argument list.
5. Check whether the size of argument list is 2.
6. Get the first argument of the method.
7. Check whether the first argument is an accessed variable.
8. Check whether the accessed variable is a field.
9. Check whether the accessed variable is static.
10. Get the second argument of the method.
11. Check whether the second argument is a string literal.
12. Get the type of the accessed variable.
13. Check whether the type of the accessed variable is String.
14. Check whether the second argument is an accessed variable.
15. Check whether the accessed variable is a field.
16. Check whether the accessed variable is static.
17. Check whether the method has any signature that takes a single argument.

From the test case provided:
- The called method is `equals`.
- The argument list has a size of 2.
- The first argument is `someString`, which is not a static field.
- The second argument is `TEST_CONSTANT`, which is an accessed field but not static.

Since the second argument in the method call `someString.equals(TEST_CONSTANT)` is not a string literal and the field `TEST_CONSTANT` is not static, the test case does not violate the rule. The number of violations is indeed 0.
['Get the name of called method.', 'Check whether the name is equals.', 'Get the argument list of method.', 'Get the size of argument list.', 'Check whether the size of argument list is 2.', 'Get the first argument of the method.', 'Check whether the first argument is an accessed variable.', 'Check whether the accessed variable is a field.', 'Check whether the accessed variable is static.', 'Get the second argument of the method.', 'Check whether the second argument is a string literal.', 'Get the type of the accessed variable.', 'Check whether the type of the accessed variable is String.', 'Check whether the second argument is an accessed variable.', 'Check whether the accessed variable is a field.', 'Check whether the accessed variable is static.', 'Check whether the method has any signature that takes a single argument.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the name is equals.* 匹配到的元操作或API：
query: Check whether the name is equals.
most similar API: Check whether the field equals
cosine Similarity: 0.8173664212226868
*Get the argument list of method.* 匹配到的元操作或API：
logic: Get the argument list of method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8603730797767639
*Get the size of argument list.* 匹配到的元操作或API：
query: Get the size of argument list.
most similar API: size of argument list
cosine Similarity: 0.9362417459487915
*Check whether the size of argument list is 2.* 匹配到的元操作或API：
query: Check whether the size of argument list is 2.
most similar API: size of argument list
cosine Similarity: 0.8619639277458191
*Get the first argument of the method.* 匹配到的元操作或API：
logic: Get the first argument of the method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8637899160385132
*Check whether the first argument is an accessed variable.* 匹配到的元操作或API：
logic: Check whether the first argument is an accessed variable.
most similar meta operation: Check whether the accessed variable is a local variable
cosine Similarity: 0.8743626475334167
*Check whether the accessed variable is a field.* 匹配到的元操作或API：
logic: Check whether the accessed variable is a field.
most similar meta operation: Check whether the accessed variable is a field
cosine Similarity: 0.989909291267395
*Check whether the accessed variable is static.* 匹配到的元操作或API：
logic: Check whether the accessed variable is static.
most similar meta operation: Check whether the accessed variable is static
cosine Similarity: 0.9874663352966309
*Get the second argument of the method.* 匹配到的元操作或API：
query: Get the second argument of the method.
most similar API: get arguments of method call
cosine Similarity: 0.818292498588562
*Check whether the second argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the second argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8767277002334595
*Get the type of the accessed variable.* 匹配到的元操作或API：
logic: Get the type of the accessed variable.
most similar meta operation: Get the type of accessed variable
cosine Similarity: 0.9793802499771118
*Check whether the type of the accessed variable is String.* 匹配到的元操作或API：
logic: Check whether the type of the accessed variable is String.
most similar meta operation: Check whether the accessed variable is string type
cosine Similarity: 0.9721906185150146
*Check whether the second argument is an accessed variable.* 匹配到的元操作或API：
logic: Check whether the second argument is an accessed variable.
most similar meta operation: Check whether the accessed variable is a local variable
cosine Similarity: 0.8713794946670532
*Check whether the accessed variable is a field.* 匹配到的元操作或API：
logic: Check whether the accessed variable is a field.
most similar meta operation: Check whether the accessed variable is a field
cosine Similarity: 0.989909291267395
*Check whether the accessed variable is static.* 匹配到的元操作或API：
logic: Check whether the accessed variable is static.
most similar meta operation: Check whether the accessed variable is static
cosine Similarity: 0.9874663352966309
*Check whether the method has any signature that takes a single argument.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
This checker has passed this negative testcase:
import java.io.File;
public class Foo {
    public boolean bar() {
        File f;
        return f.getParent().equals("testStr");
    }
}
This checker has passed this negative testcase:
import java.util.Map;
import my.Unknown;
class Foo {
    public void testObjectArray(Unknown uk) {
        Unknown hasMap = (Unknown) this.beanFactory.getBean("literalMap");
        assertTrue(hasMap.getMap().size() == 3);
        assertTrue(hasMap.getMap().get("foo").equals("bar"));
        assertTrue(hasMap.getMap().get("fi").equals("fum"));
        assertTrue(hasMap.getMap().get("fa") == null);
    }
}


This checker is failed(false positive) on this positive test case:
```
// #575 LiteralsFirstInComparisons must not trigger if the field is not static
public class Foo {
    private final String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'TEST_CONSTANT')
        ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'test')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'boolean')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'someString')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'someString')
            ——ASTArgumentList (size = 1)
              ——ASTVariableAccess (referenced variable name = 'TEST_CONSTANT')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
4. net.sourceforge.pmd.lang.java.ast.ASTArgumentList: public int size(), //Returns the number of nodes in this list. This must be the number of nodes yielded by the {@link #iterator()}.
5. net.sourceforge.pmd.lang.java.ast.ASTVariableAccess: public net.sourceforge.pmd.lang.java.types.JTypeMirror getTypeMirror()

1.  //Check whether the accessed variable is a local variable
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JLocalVariableSymbol;
public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JLocalVariableSymbol) {
        JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
        return true;
    }
    return false;
}
```
2.  //Check whether the accessed variable is a field
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;
public boolean isVariableAccessField(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JFieldSymbol) {
        JFieldSymbol fieldSym = (JFieldSymbol) sym;
        return true;
    }
    return false;
}
```
3.  //Check whether the accessed variable is static
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.ast.JModifier;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
public boolean isVariableAccessStatic(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym.tryGetNode().hasModifiers(JModifier.STATIC)) {
        return true;
    }
    return false;
}
```
4.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
5.  //Check whether the accessed variable is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTVariableAccess var){
    return TypeTestUtil.isA(String.class, var.getTypeMirror());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier)) {
                JVariableSymbol sym = ((ASTVariableAccess) qualifier).getReferencedSym();
                if (sym instanceof JFieldSymbol && ((JFieldSymbol) sym).tryGetNode().hasModifiers(JModifier.STATIC)) {
                    addViolation(data, node);
                } else if (sym instanceof JLocalVariableSymbol) {
                    addViolation(data, node);
                }
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is a field
    public boolean isVariableAccessField(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym instanceof JFieldSymbol) {
            return true;
        }
        return false;
    }

    // Check whether the accessed variable is static
    public boolean isVariableAccessStatic(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym.tryGetNode().hasModifiers(JModifier.STATIC)) {
            return true;
        }
        return false;
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of called method.
2. Check whether the called method name is equals.
3. Get the number of arguments of called method.
4. Check whether the number of arguments is 2.
5. Get the second argument of called method.
6. Check whether the second argument is a string literal.
7. Check whether the second argument is an accessed variable.
8. Check whether the accessed variable is static.
9. If the second argument is an accessed variable, check whether it is static.
10. If the second argument is not a string literal and is an accessed variable that is not static, this test case does not violate the rule.

In this specific test case:
- The called method name is `equals`.
- The number of arguments is 2.
- The second argument is `TEST_CONSTANT`, which is an accessed variable.
- `TEST_CONSTANT` is a final field, but it is not static.
- Therefore, the test case does not violate the rule.
            
['Get the name of called method.', 'Check whether the called method name is equals.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 2.', 'Get the second argument of called method.', 'Check whether the second argument is a string literal.', 'Check whether the second argument is an accessed variable.', 'Check whether the accessed variable is static.', 'If the second argument is an accessed variable, check whether it is static.', 'If the second argument is not a string literal and is an accessed variable that is not static, this test case does not violate the rule.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9280144572257996
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 2.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the second argument of called method.* 匹配到的元操作或API：
logic: Get the second argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9016816020011902
*Check whether the second argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the second argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8767277002334595
*Check whether the second argument is an accessed variable.* 匹配到的元操作或API：
logic: Check whether the second argument is an accessed variable.
most similar meta operation: Check whether the accessed variable is a local variable
cosine Similarity: 0.8713794946670532
*Check whether the accessed variable is static.* 匹配到的元操作或API：
logic: Check whether the accessed variable is static.
most similar meta operation: Check whether the accessed variable is static
cosine Similarity: 0.9874663352966309
*If the second argument is an accessed variable, check whether it is static.* 匹配到的元操作或API：
logic: If the second argument is an accessed variable, check whether it is static.
most similar meta operation: Check whether the accessed variable is static
cosine Similarity: 0.9349341988563538
*If the second argument is not a string literal and is an accessed variable that is not static, this test case does not violate the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
This checker has passed this negative testcase:
import java.io.File;
public class Foo {
    public boolean bar() {
        File f;
        return f.getParent().equals("testStr");
    }
}
This checker has passed this negative testcase:
import java.util.Map;
import my.Unknown;
class Foo {
    public void testObjectArray(Unknown uk) {
        Unknown hasMap = (Unknown) this.beanFactory.getBean("literalMap");
        assertTrue(hasMap.getMap().size() == 3);
        assertTrue(hasMap.getMap().get("foo").equals("bar"));
        assertTrue(hasMap.getMap().get("fi").equals("fum"));
        assertTrue(hasMap.getMap().get("fa") == null);
    }
}


This checker is failed(false positive) on this positive test case:
```
// #575 LiteralsFirstInComparisons must not trigger if the field is not static
public class Foo {
    private final String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'TEST_CONSTANT')
        ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'test')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'boolean')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'someString')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'someString')
            ——ASTArgumentList (size = 1)
              ——ASTVariableAccess (referenced variable name = 'TEST_CONSTANT')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
2.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
3.  //Check whether the accessed variable is a local variable
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JLocalVariableSymbol;
public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JLocalVariableSymbol) {
        JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
        return true;
    }
    return false;
}
```
4.  //Check whether the accessed variable is static
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.ast.JModifier;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
public boolean isVariableAccessStatic(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym.tryGetNode().hasModifiers(JModifier.STATIC)) {
        return true;
    }
    return false;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            if (qualifier instanceof ASTVariableAccess && !isVariableAccessStatic((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }

    // Check whether the accessed variable is static
    public boolean isVariableAccessStatic(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym.tryGetNode().hasModifiers(JModifier.STATIC)) {
            return true;
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 17" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 17" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the name of method.
        2. Check whether the method is a String comparison method (equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals).
        3. Get the number of formal parameters of method.
        4. Check whether the number of formal parameters is 1.
        5. Get the signature of method.
        6. Get the argument of called method.
        7. Check whether the argument is a string literal.
        8. Get the method caller.
        9. Check whether the method caller is a field.
        10. Check whether the field is static.
        If the method is a String comparison method and the number of formal parameters is 1 and the argument is not a string literal and the method caller is a field and the field is not static, then this test case does not violate the rule. 

In this specific test case:
11. The method name is `test`.
12. The method `test` calls `equals` on `someString`.
13. The `equals` method is a String comparison method.
14. The `equals` method has 1 formal parameter.
15. The argument passed to `equals` is `TEST_CONSTANT`.
16. `TEST_CONSTANT` is a field.
17. `TEST_CONSTANT` is not static.

Therefore, the number of violations of the rule in this test case is indeed 0.
['Get the name of method.', 'Check whether the method is a String comparison method (equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals).', 'Get the number of formal parameters of method.', 'Check whether the number of formal parameters is 1.', 'Get the signature of method.', 'Get the argument of called method.', 'Check whether the argument is a string literal.', 'Get the method caller.', 'Check whether the method caller is a field.', 'Check whether the field is static.', 'The method name is `test`.', 'The method `test` calls `equals` on `someString`.', 'The `equals` method is a String comparison method.', 'The `equals` method has 1 formal parameter.', 'The argument passed to `equals` is `TEST_CONSTANT`.', '`TEST_CONSTANT` is a field.', '`TEST_CONSTANT` is not static.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is a String comparison method (equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals).* 匹配到的元操作或API：
query: Check whether the method is a String comparison method (equals, equalsIgnoreCase, compareTo, compareToIgnoreCase, contentEquals).
most similar API: Check whether the method equals
cosine Similarity: 0.8322538733482361
*Get the number of formal parameters of method.* 匹配到的元操作或API：
logic: Get the number of formal parameters of method.
most similar meta operation: Get the number of formal parameters of method
cosine Similarity: 0.9860841035842896
*Check whether the number of formal parameters is 1.* 匹配到的元操作或API：
query: Check whether the number of formal parameters is 1.
most similar API: Check whether the formal parameters equals
cosine Similarity: 0.8373569250106812
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827433228492737
*Get the argument of called method.* 匹配到的元操作或API：
logic: Get the argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.97557133436203
*Check whether the argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9077174663543701
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796929359436035
*Check whether the method caller is a field.* 匹配到的元操作或API：
logic: Check whether the method caller is a field.
most similar meta operation: Check whether the method caller is record type
cosine Similarity: 0.8503206372261047
*Check whether the field is static.* 匹配到的元操作或API：
logic: Check whether the field is static.
most similar meta operation: Check whether the field is static
cosine Similarity: 0.985234260559082
*The method name is `test`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method `test` calls `equals` on `someString`.* 匹配到的元操作或API：
query: The method `test` calls `equals` on `someString`.
most similar API: Check whether is equals method
cosine Similarity: 0.8049777746200562
*The `equals` method is a String comparison method.* 匹配到的元操作或API：
query: The `equals` method is a String comparison method.
most similar API: Check whether is equals method
cosine Similarity: 0.8552064895629883
*The `equals` method has 1 formal parameter.* 匹配到的元操作或API：
query: The `equals` method has 1 formal parameter.
most similar API: Check whether the formal parameter equals
cosine Similarity: 0.8166959285736084
*The argument passed to `equals` is `TEST_CONSTANT`.* 匹配到的元操作或API：
未匹配成功元操作或API
*`TEST_CONSTANT` is a field.* 匹配到的元操作或API：
未匹配成功元操作或API
*`TEST_CONSTANT` is not static.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
This checker has passed this negative testcase:
import java.io.File;
public class Foo {
    public boolean bar() {
        File f;
        return f.getParent().equals("testStr");
    }
}
This checker has passed this negative testcase:
import java.util.Map;
import my.Unknown;
class Foo {
    public void testObjectArray(Unknown uk) {
        Unknown hasMap = (Unknown) this.beanFactory.getBean("literalMap");
        assertTrue(hasMap.getMap().size() == 3);
        assertTrue(hasMap.getMap().get("foo").equals("bar"));
        assertTrue(hasMap.getMap().get("fi").equals("fum"));
        assertTrue(hasMap.getMap().get("fa") == null);
    }
}


This checker is failed(false positive) on this positive test case:
```
// #575 LiteralsFirstInComparisons must not trigger if the field is not static
public class Foo {
    private final String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'TEST_CONSTANT')
        ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'test')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'boolean')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'someString')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'someString')
            ——ASTArgumentList (size = 1)
              ——ASTVariableAccess (referenced variable name = 'TEST_CONSTANT')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTFormalParameters: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()
7. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isStatic()
8. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isEqualsMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
9. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public boolean equals(java.lang.Object)

1.  //Get the number of formal parameters of method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTMethodDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```
2.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
3.  //Check whether the method caller is record type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isMethodCallerEnumType(ASTMethodCall node){
    if(node.getQualifier() != null){
        return node.getQualifier().getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) node.getQualifier().getTypeMirror().getSymbol()).isRecord();
    }
    return false;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            if (qualifier instanceof ASTVariableAccess && !isVariableAccessStatic((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }

    // Check whether the variable access is static
    public boolean isVariableAccessStatic(ASTVariableAccess var) {
        JFieldSymbol fieldSymbol = var.getReferencedFieldSymbol();
        return fieldSymbol != null && fieldSymbol.isStatic();
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method is test.
3. Get the signature of method.
4. Get the number of formal parameters of method.
5. Get the type of formal parameter.
6. Check whether the formal parameter is String type.
7. Get all expressions in method.
8. Check whether the expression is a method call.
9. Get the name of called method.
10. Check whether the called method is equals.
11. Get the number of arguments of called method.
12. Get an argument of called method.
13. Check whether the argument is an accessed variable.
14. Check whether the accessed variable is static.
15. Check whether the accessed variable is a field.
16. Get the type of accessed variable.
17. Check whether the accessed variable is String type.
18. Get the other argument of called method.
19. Check whether the other argument is a string literal.

In this test case:
- The method is named "test".
- It has one formal parameter of type String.
- The method contains a method call to "equals".
- The first argument of "equals" is not a string literal, it is a formal parameter.
- The second argument of "equals" is an accessed variable, "TEST_CONSTANT".
- The accessed variable "TEST_CONSTANT" is not static.
- The accessed variable "TEST_CONSTANT" is a field.
- The accessed variable "TEST_CONSTANT" is of type String.

Since the second argument of the `equals` method is not a string literal and is not static, it does not violate the rule. Thus, the number of violations in this test case is 0.
['Get the name of method.', 'Check whether the method is test.', 'Get the signature of method.', 'Get the number of formal parameters of method.', 'Get the type of formal parameter.', 'Check whether the formal parameter is String type.', 'Get all expressions in method.', 'Check whether the expression is a method call.', 'Get the name of called method.', 'Check whether the called method is equals.', 'Get the number of arguments of called method.', 'Get an argument of called method.', 'Check whether the argument is an accessed variable.', 'Check whether the accessed variable is static.', 'Check whether the accessed variable is a field.', 'Get the type of accessed variable.', 'Check whether the accessed variable is String type.', 'Get the other argument of called method.', 'Check whether the other argument is a string literal.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is test.* 匹配到的元操作或API：
logic: Check whether the method is test.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.8680266737937927
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827433228492737
*Get the number of formal parameters of method.* 匹配到的元操作或API：
logic: Get the number of formal parameters of method.
most similar meta operation: Get the number of formal parameters of method
cosine Similarity: 0.9860841035842896
*Get the type of formal parameter.* 匹配到的元操作或API：
logic: Get the type of formal parameter.
most similar meta operation: Get the type of formal parameter
cosine Similarity: 0.985480785369873
*Check whether the formal parameter is String type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is String type.
most similar meta operation: Check whether the formal parameter is string type
cosine Similarity: 0.9882044792175293
*Get all expressions in method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the expression is a method call.* 匹配到的元操作或API：
query: Check whether the expression is a method call.
most similar API: Check whether the method call is expression
cosine Similarity: 0.9520691633224487
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817376732826233
*Check whether the called method is equals.* 匹配到的元操作或API：
query: Check whether the called method is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9604323506355286
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is an accessed variable.* 匹配到的元操作或API：
logic: Check whether the argument is an accessed variable.
most similar meta operation: Check whether the accessed variable is a local variable
cosine Similarity: 0.8832410573959351
*Check whether the accessed variable is static.* 匹配到的元操作或API：
logic: Check whether the accessed variable is static.
most similar meta operation: Check whether the accessed variable is static
cosine Similarity: 0.9874663352966309
*Check whether the accessed variable is a field.* 匹配到的元操作或API：
logic: Check whether the accessed variable is a field.
most similar meta operation: Check whether the accessed variable is a field
cosine Similarity: 0.989909291267395
*Get the type of accessed variable.* 匹配到的元操作或API：
logic: Get the type of accessed variable.
most similar meta operation: Get the type of accessed variable
cosine Similarity: 0.9871194362640381
*Check whether the accessed variable is String type.* 匹配到的元操作或API：
logic: Check whether the accessed variable is String type.
most similar meta operation: Check whether the accessed variable is string type
cosine Similarity: 0.9884957075119019
*Get the other argument of called method.* 匹配到的元操作或API：
logic: Get the other argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9193195104598999
*Check whether the other argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the other argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8889642953872681
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
This checker has passed this negative testcase:
import java.io.File;
public class Foo {
    public boolean bar() {
        File f;
        return f.getParent().equals("testStr");
    }
}
This checker has passed this negative testcase:
import java.util.Map;
import my.Unknown;
class Foo {
    public void testObjectArray(Unknown uk) {
        Unknown hasMap = (Unknown) this.beanFactory.getBean("literalMap");
        assertTrue(hasMap.getMap().size() == 3);
        assertTrue(hasMap.getMap().get("foo").equals("bar"));
        assertTrue(hasMap.getMap().get("fi").equals("fum"));
        assertTrue(hasMap.getMap().get("fa") == null);
    }
}


This checker is failed(false positive) on this positive test case:
```
// #575 LiteralsFirstInComparisons must not trigger if the field is not static
public class Foo {
    private final String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'TEST_CONSTANT')
        ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'test')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'boolean')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'someString')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'someString')
            ——ASTArgumentList (size = 1)
              ——ASTVariableAccess (referenced variable name = 'TEST_CONSTANT')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
4. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
7. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
8. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
9. net.sourceforge.pmd.lang.java.ast.ASTVariableAccess: public net.sourceforge.pmd.lang.java.types.JTypeMirror getTypeMirror()

1.  //Get the number of formal parameters of method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTMethodDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```
2.  //Check whether the formal parameter is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFormalParameterStringType(ASTFormalParameter node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```
3.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
4.  //Check whether the accessed variable is a local variable
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JLocalVariableSymbol;
public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JLocalVariableSymbol) {
        JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
        return true;
    }
    return false;
}
```
5.  //Check whether the accessed variable is static
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.ast.JModifier;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
public boolean isVariableAccessStatic(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym.tryGetNode().hasModifiers(JModifier.STATIC)) {
        return true;
    }
    return false;
}
```
6.  //Check whether the accessed variable is a field
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;
public boolean isVariableAccessField(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JFieldSymbol) {
        JFieldSymbol fieldSym = (JFieldSymbol) sym;
        return true;
    }
    return false;
}
```
7.  //Check whether the accessed variable is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTVariableAccess var){
    return TypeTestUtil.isA(String.class, var.getTypeMirror());
}
```
8.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier) && !isVariableAccessStatic((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }

    // Check whether the accessed variable is static
    public boolean isVariableAccessStatic(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym.tryGetNode().hasModifiers(JModifier.STATIC)) {
            return true;
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 17" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 17" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 17
[ERROR]   "ok 19" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
111
94
117
102
83
69
=========================error_testcase_logics=========================
1. Get the method declaration from method call.
        2. Get the name of the called method.
        3. Check whether the called method name is equals.
        4. Check whether the called method name is equalsIgnoreCase.
        5. Check whether the called method name is compareTo.
        6. Check whether the called method name is compareToIgnoreCase.
        7. Check whether the called method name is contentEquals.
        8. Get the number of formal parameters of the called method.
        9. Check whether the number of formal parameters is 1.
        10. Get an argument of called method.
        11. Check whether the argument is a string literal.
        12. Get the method caller.
        13. Check whether the method caller is a field.
        14. Check whether the field is a constant.

In this test case:
1. The method declaration from method call is `Q.equals(type)`.
2. The name of the called method is `equals`.
3. The called method name is `equals`.
4. The called method name is not `equalsIgnoreCase`.
5. The called method name is not `compareTo`.
6. The called method name is not `compareToIgnoreCase`.
7. The called method name is not `contentEquals`.
8. The number of formal parameters of the called method is 1.
9. The number of formal parameters is 1.
10. The argument of the called method is `type`.
11. The argument is not a string literal.
12. The method caller is `Q`.
13. The method caller is a field.
14. The field `Q` is a constant.

Since the method `equals` is called with a field (`Q`) as the first argument and not a string literal, the rule is not violated in this test case. Therefore, the number of violations is 0.
['Get the method declaration from method call.', 'Get the name of the called method.', 'Check whether the called method name is equals.', 'Check whether the called method name is equalsIgnoreCase.', 'Check whether the called method name is compareTo.', 'Check whether the called method name is compareToIgnoreCase.', 'Check whether the called method name is contentEquals.', 'Get the number of formal parameters of the called method.', 'Check whether the number of formal parameters is 1.', 'Get an argument of called method.', 'Check whether the argument is a string literal.', 'Get the method caller.', 'Check whether the method caller is a field.', 'Check whether the field is a constant.', 'The method declaration from method call is `Q.equals(type)`.', 'The name of the called method is `equals`.', 'The called method name is `equals`.', 'The called method name is not `equalsIgnoreCase`.', 'The called method name is not `compareTo`.', 'The called method name is not `compareToIgnoreCase`.', 'The called method name is not `contentEquals`.', 'The number of formal parameters of the called method is 1.', 'The number of formal parameters is 1.', 'The argument of the called method is `type`.', 'The argument is not a string literal.', 'The method caller is `Q`.', 'The method caller is a field.', 'The field `Q` is a constant.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'ASTNumericLiteral', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTIfStatement', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the method declaration from method call.* 匹配到的元操作或API：
logic: Get the method declaration from method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9787436127662659
*Get the name of the called method.* 匹配到的元操作或API：
logic: Get the name of the called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9750091433525085
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9280144572257996
*Check whether the called method name is equalsIgnoreCase.* 匹配到的元操作或API：
query: Check whether the called method name is equalsIgnoreCase.
most similar API: Check whether the method call equals
cosine Similarity: 0.8475643396377563
*Check whether the called method name is compareTo.* 匹配到的元操作或API：
query: Check whether the called method name is compareTo.
most similar API: Check whether the method call equals
cosine Similarity: 0.8681850433349609
*Check whether the called method name is compareToIgnoreCase.* 匹配到的元操作或API：
query: Check whether the called method name is compareToIgnoreCase.
most similar API: Check whether the method call equals
cosine Similarity: 0.8260899186134338
*Check whether the called method name is contentEquals.* 匹配到的元操作或API：
query: Check whether the called method name is contentEquals.
most similar API: Check whether the method call equals
cosine Similarity: 0.8419468402862549
*Get the number of formal parameters of the called method.* 匹配到的元操作或API：
logic: Get the number of formal parameters of the called method.
most similar meta operation: Get the number of formal parameters of method
cosine Similarity: 0.9577611088752747
*Check whether the number of formal parameters is 1.* 匹配到的元操作或API：
query: Check whether the number of formal parameters is 1.
most similar API: Check whether the formal parameters equals
cosine Similarity: 0.8373569250106812
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9077174663543701
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796929359436035
*Check whether the method caller is a field.* 匹配到的元操作或API：
logic: Check whether the method caller is a field.
most similar meta operation: Check whether the method caller is record type
cosine Similarity: 0.8503206372261047
*Check whether the field is a constant.* 匹配到的元操作或API：
logic: Check whether the field is a constant.
most similar meta operation: Check whether the field is static
cosine Similarity: 0.8558593988418579
*The method declaration from method call is `Q.equals(type)`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The name of the called method is `equals`.* 匹配到的元操作或API：
query: The name of the called method is `equals`.
most similar API: Check whether the method call equals
cosine Similarity: 0.8214161396026611
*The called method name is `equals`.* 匹配到的元操作或API：
query: The called method name is `equals`.
most similar API: Check whether is equals method
cosine Similarity: 0.8391321897506714
*The called method name is not `equalsIgnoreCase`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The called method name is not `compareTo`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The called method name is not `compareToIgnoreCase`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The called method name is not `contentEquals`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The number of formal parameters of the called method is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*The number of formal parameters is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*The argument of the called method is `type`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The argument is not a string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method caller is `Q`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method caller is a field.* 匹配到的元操作或API：
未匹配成功元操作或API
*The field `Q` is a constant.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
This checker has passed this negative testcase:
import java.io.File;
public class Foo {
    public boolean bar() {
        File f;
        return f.getParent().equals("testStr");
    }
}
This checker has passed this negative testcase:
import java.util.Map;
import my.Unknown;
class Foo {
    public void testObjectArray(Unknown uk) {
        Unknown hasMap = (Unknown) this.beanFactory.getBean("literalMap");
        assertTrue(hasMap.getMap().size() == 3);
        assertTrue(hasMap.getMap().get("foo").equals("bar"));
        assertTrue(hasMap.getMap().get("fi").equals("fum"));
        assertTrue(hasMap.getMap().get("fa") == null);
    }
}


This checker is failed(false positive) on this positive test case:
```
// #3236 [java] LiteralsFirstInComparisons should consider constant fields (cont'd)
class DT1 {
                public static final String Q = "q";
                public static int convert2(String type) {
                    if (Q.equals(type)) {
                        return 1;
                    } else {
                        return 3;
                    }
                }
            }
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'DT1')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'Q')
        ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'convert2')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'int')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'type')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'Q')
            ——ASTArgumentList (size = 1)
              ——ASTVariableAccess (referenced variable name = 'type')
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTNumericLiteral
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTFormalParameters: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()
6. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isStatic()
7. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isEqualsMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```
2.  //Get the number of formal parameters of method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTMethodDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```
3.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
4.  //Check whether the method caller is record type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isMethodCallerEnumType(ASTMethodCall node){
    if(node.getQualifier() != null){
        return node.getQualifier().getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) node.getQualifier().getTypeMirror().getSymbol()).isRecord();
    }
    return false;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && !isVariableAccessLiteralOrConstant((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }

    // Check whether the variable access is a literal or a constant field
    private boolean isVariableAccessLiteralOrConstant(ASTVariableAccess var) {
        JVariableSymbol symbol = (JVariableSymbol) var.getVariableType().getSymbol();
        if (symbol != null && symbol.isStatic() && symbol.isFinal()) {
            ASTFieldDeclaration fieldDeclaration = symbol.tryGetNode();
            if (fieldDeclaration != null && fieldDeclaration.getVariables().size() == 1) {
                return fieldDeclaration.getVariables().get(0).getInitializer() instanceof ASTStringLiteral;
            }
        } else if (var.getParent() instanceof ASTLiteral) {
            return true;
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the class name.
2. Get all methods declared in class.
3. Get the method name.
4. Check whether the method name is convert2.
5. Get all statements in the method.
6. Check whether the statement is an if statement.
7. Get the condition of the if statement.
8. Check whether the condition is a method call.
9. Get the name of the called method.
10. Check whether the called method name is equals.
11. Get the number of arguments of called method.
12. Check whether the number of arguments is 1.
13. Get the first argument of called method.
14. Check whether the first argument is an accessed field.
15. Check whether the accessed field is final.
16. Check whether the first argument is a string literal.

Given the test case:
- The method `convert2` contains an `if` statement with a condition `Q.equals(type)`.
- `Q` is a static final field, not a string literal.

Thus, the test case does not violate the rule because `Q` is a final field, not a string literal.

The number of violations in this test case is: 0.
['Get the class name.', 'Get all methods declared in class.', 'Get the method name.', 'Check whether the method name is convert2.', 'Get all statements in the method.', 'Check whether the statement is an if statement.', 'Get the condition of the if statement.', 'Check whether the condition is a method call.', 'Get the name of the called method.', 'Check whether the called method name is equals.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 1.', 'Get the first argument of called method.', 'Check whether the first argument is an accessed field.', 'Check whether the accessed field is final.', 'Check whether the first argument is a string literal.']
['ASTStringLiteral', 'ClassNamesUtil', 'JavaSemanticErrors', 'ASTNumericLiteral', 'JavadocTag', 'ASTModifierList', 'InternalApiBridge', 'ASTMethodCall', 'ASTCompilationUnit', 'ASTClassOrInterfaceBody', 'TypesFromAst', 'JavaRuleUtil', 'TypeConversion', 'TestFrameworksUtil', 'ASTFormalParameters', 'ASTVariableDeclaratorId', 'ASTVariableAccess', 'ASTBlock', 'ASTArgumentList', 'ASTIfStatement', 'ASTMethodDeclaration', 'AstImplUtil', 'TypesFromReflection', 'ASTFieldDeclaration', 'SymbolicValueHelper', 'SymbolResolutionPass', 'TokenUtils', 'ASTPrimitiveType', 'ASTClassOrInterfaceDeclaration', 'ASTClassOrInterfaceType', 'TypeTestUtil', 'CommentAssignmentPass', 'ASTFormalParameter', 'ASTReturnStatement', 'JavaAstUtils', 'JavaPropertyUtil', 'ASTVariableDeclarator']
*Get the class name.* 匹配到的元操作或API：
logic: Get the class name.
most similar meta operation: Get the name of class
cosine Similarity: 0.9495313167572021
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366355895996094
*Get the method name.* 匹配到的元操作或API：
logic: Get the method name.
most similar meta operation: Get the name of method
cosine Similarity: 0.956761360168457
*Check whether the method name is convert2.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the statement is an if statement.* 匹配到的元操作或API：
query: Check whether the statement is an if statement.
most similar API: Check whether the if statement equals
cosine Similarity: 0.899427056312561
*Get the condition of the if statement.* 匹配到的元操作或API：
logic: Get the condition of the if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9738379716873169
*Check whether the condition is a method call.* 匹配到的元操作或API：
query: Check whether the condition is a method call.
most similar API: Check whether the method call is expression
cosine Similarity: 0.8619780540466309
*Get the name of the called method.* 匹配到的元操作或API：
logic: Get the name of the called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9750091433525085
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9280144572257996
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846130609512329
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of called method.* 匹配到的元操作或API：
logic: Get the first argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9160765409469604
*Check whether the first argument is an accessed field.* 匹配到的元操作或API：
logic: Check whether the first argument is an accessed field.
most similar meta operation: Check whether the accessed variable is a field
cosine Similarity: 0.870332658290863
*Check whether the accessed field is final.* 匹配到的元操作或API：
logic: Check whether the accessed field is final.
most similar meta operation: Check whether the field is final
cosine Similarity: 0.9394946098327637
*Check whether the first argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the first argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8803800344467163
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && isVariableAccessStringType((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is string type
    public boolean isVariableAccessStringType(ASTVariableAccess var){
        return TypeTestUtil.isA(String.class, var.getTypeMirror());
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
This checker has passed this negative testcase:
import java.io.File;
public class Foo {
    public boolean bar() {
        File f;
        return f.getParent().equals("testStr");
    }
}
This checker has passed this negative testcase:
import java.util.Map;
import my.Unknown;
class Foo {
    public void testObjectArray(Unknown uk) {
        Unknown hasMap = (Unknown) this.beanFactory.getBean("literalMap");
        assertTrue(hasMap.getMap().size() == 3);
        assertTrue(hasMap.getMap().get("foo").equals("bar"));
        assertTrue(hasMap.getMap().get("fi").equals("fum"));
        assertTrue(hasMap.getMap().get("fa") == null);
    }
}


This checker is failed(false positive) on this positive test case:
```
// #3236 [java] LiteralsFirstInComparisons should consider constant fields (cont'd)
class DT1 {
                public static final String Q = "q";
                public static int convert2(String type) {
                    if (Q.equals(type)) {
                        return 1;
                    } else {
                        return 3;
                    }
                }
            }
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'DT1')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'Q')
        ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'convert2')
      ——ASTModifierList
      ——ASTPrimitiveType (method return type = 'int')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'type')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTMethodCall (called method name = 'equals')
            ——ASTVariableAccess (referenced variable name = 'Q')
            ——ASTArgumentList (size = 1)
              ——ASTVariableAccess (referenced variable name = 'type')
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTNumericLiteral
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
4. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean equals(java.lang.Object)
5. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
7. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
8. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
9. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
10. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isFinal()

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
2.  //Check whether the accessed variable is a field
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;
public boolean isVariableAccessField(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JFieldSymbol) {
        JFieldSymbol fieldSym = (JFieldSymbol) sym;
        return true;
    }
    return false;
}
```
3.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.bestpractices;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        String methodName = node.getMethodName();
        ASTArgumentList arguments = node.getArguments();
        ASTExpression qualifier = node.getQualifier();

        if ((arguments.size() == 1) && 
            isStringType(qualifier) && 
            isMethodCallArgumentStringType(node) &&
            (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
             methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
             methodName.equals("contentEquals"))) {
            
            if (qualifier instanceof ASTVariableAccess && !isVariableAccessConstant((ASTVariableAccess) qualifier)) {
                addViolation(data, node);
            } else if (qualifier instanceof ASTMethodCall) {
                addViolation(data, node);
            }
        } else if ((arguments.size() == 1) && 
                   isStringType(arguments.get(0)) &&
                   (qualifier instanceof ASTVariableAccess || qualifier instanceof ASTMethodCall) &&
                   (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || 
                    methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || 
                    methodName.equals("contentEquals"))) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Check whether the expression is of string type
    public boolean isStringType(ASTExpression expression) {
        return expression != null && TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }

    // Check whether the accessed variable is a constant field
    public boolean isVariableAccessConstant(ASTVariableAccess var) {
        JVariableSymbol sym = var.getReferencedSym();
        if (sym instanceof JFieldSymbol) {
            JFieldSymbol fieldSym = (JFieldSymbol) sym;
            return fieldSym.isFinal() && fieldSym.isStatic();
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
True
测试用例全部通过
最终通过 28 个测试用例
正例 19 个
反例 9 个
输入token：402961
输出token：232883
结束

规则执行完毕，时间总花销： 4425.5373022556305 秒
