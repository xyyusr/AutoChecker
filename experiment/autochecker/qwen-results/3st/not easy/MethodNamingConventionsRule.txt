开始

========================================== Rule MethodNamingConventionsRule ===========================================
一共 12 个测试用例
正例 5 个
反例 7 个
1233
939
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method
2. Check whether the method is an instance method
3. Check whether the method is a static method
4. Check whether the method is a native method
5. Check whether the method is a junit method
6. Check whether the method name matches the regex for instance/static/native/junit method names
   - If the method is an instance method and the name does not match "[a-z][a-zA-Z0-9]*", then it violates the rule.
   - If the method is a static method and the name does not match "[a-z][a-zA-Z0-9]*", then it violates the rule.
   - If the method is a native method and the name does not match "[a-z][a-zA-Z0-9]*", then it violates the rule.
   - If the method is a junit method and the name does not match the corresponding junit regex, then it violates the rule.

In this test case:
- Method name is "Bar"
- Method is an instance method
- Method name does not match the regex "[a-z][a-zA-Z0-9]*" (since it starts with an uppercase character)

Therefore, this test case violates the rule.
['Get the name of method', 'Check whether the method is an instance method', 'Check whether the method is a static method', 'Check whether the method is a native method', 'Check whether the method is a junit method', 'Check whether the method name matches the regex for instance/static/native/junit method names']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method* 匹配到的元操作或API：
logic: Get the name of method
most similar meta operation: Get the name of method
cosine Similarity: 1.0000001192092896
*Check whether the method is an instance method* 匹配到的元操作或API：
query: Check whether the method is an instance method
most similar API: Check whether is test method
cosine Similarity: 0.8599497675895691
*Check whether the method is a static method* 匹配到的元操作或API：
logic: Check whether the method is a static method
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9786330461502075
*Check whether the method is a native method* 匹配到的元操作或API：
logic: Check whether the method is a native method
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9856282472610474
*Check whether the method is a junit method* 匹配到的元操作或API：
logic: Check whether the method is a junit method
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9999999403953552
*Check whether the method name matches the regex for instance/static/native/junit method names* 匹配到的元操作或API：
query: Check whether the method name matches the regex for instance/static/native/junit method names
most similar API: Check whether is junit3 method
cosine Similarity: 0.8035610318183899
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should start with lowercase character
public class Foo {
    void Bar() {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'Bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (TestFrameworksUtil.isJUnit3Method(node)) {
            if (!methodName.matches("test[A-Z0-9][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        } else if (TestFrameworksUtil.isTestMethod(node)) {
            if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        } else if (node.isNative()) {
            if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        } else if (node.isStatic()) {
            if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        } else {
            if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Get the signature of method.
3. Check whether the method has declared annotations.
4. Get a declared annotation of method.
5. Check whether the method has the @Test annotation.
6. Check whether the method is native.
7. Check whether the method is static.
8. Check whether the method is an instance method.
9. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

In this specific test case:
1. The name of the method is "Bar".
2. The signature of the method is "void Bar() {}".
3. The method has no declared annotations.
4. Since there are no declared annotations, this step is not applicable.
5. Since there is no @Test annotation, this step is not applicable.
6. The method is not native.
7. The method is not static.
8. The method is an instance method.
9. The method name "Bar" does not match the regex "[a-z][a-zA-Z0-9]*" because it starts with an uppercase character.

This test case violates the rule for instance method naming as per the provided regex.
['Get the name of method.', 'Get the signature of method.', 'Check whether the method has declared annotations.', 'Get a declared annotation of method.', 'Check whether the method has the @Test annotation.', 'Check whether the method is native.', 'Check whether the method is static.', 'Check whether the method is an instance method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'The name of the method is "Bar".', 'The signature of the method is "void Bar() {}".', 'The method has no declared annotations.', 'Since there are no declared annotations, this step is not applicable.', 'Since there is no @Test annotation, this step is not applicable.', 'The method is not native.', 'The method is not static.', 'The method is an instance method.', 'The method name "Bar" does not match the regex "[a-z][a-zA-Z0-9]*" because it starts with an uppercase character.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Check whether the method has declared annotations.* 匹配到的元操作或API：
logic: Check whether the method has declared annotations.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9820230007171631
*Get a declared annotation of method.* 匹配到的元操作或API：
logic: Get a declared annotation of method.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9867770671844482
*Check whether the method has the @Test annotation.* 匹配到的元操作或API：
query: Check whether the method has the @Test annotation.
most similar API: Check whether the method is annotation present
cosine Similarity: 0.8465760946273804
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is an instance method.* 匹配到的元操作或API：
query: Check whether the method is an instance method.
most similar API: Check whether is test method
cosine Similarity: 0.8555017709732056
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*The name of the method is "Bar".* 匹配到的元操作或API：
未匹配成功元操作或API
*The signature of the method is "void Bar() {}".* 匹配到的元操作或API：
未匹配成功元操作或API
*The method has no declared annotations.* 匹配到的元操作或API：
未匹配成功元操作或API
*Since there are no declared annotations, this step is not applicable.* 匹配到的元操作或API：
未匹配成功元操作或API
*Since there is no @Test annotation, this step is not applicable.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method is not native.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method is not static.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method is an instance method.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method name "Bar" does not match the regex "[a-z][a-zA-Z0-9]*" because it starts with an uppercase character.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should start with lowercase character
public class Foo {
    void Bar() {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'Bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAnnotationPresent(java.lang.Class), //Returns true if an annotation with the given type is applied to this node.
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
7. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.

1.  //Check whether method has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTMethodDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (!TestFrameworksUtil.isTestMethod(node) && !node.isNative()) {
            if (node.isStatic() || !node.isStatic()) {
                if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                    addViolation(data, node);
                }
            }
        } else if (TestFrameworksUtil.isTestMethod(node)) {
            if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Check whether method has declared annotations
    public boolean hasAnnotation(ASTMethodDeclaration node) {
        NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
        return declaredAnnotations.nonEmpty();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is a junit method.
3. Get the regex that applies to the method name based on its kind.
4. Check whether the method name matches the regex.

In this test case:
1. Get the name of method: The method name is "Bar".
2. Check whether the method is a junit method: The method is not a JUnit method.
3. Get the regex that applies to the method name based on its kind: The regex for instance/static method names is "[a-z][a-zA-Z0-9]*".
4. Check whether the method name matches the regex: The method name "Bar" does not match the regex "[a-z][a-zA-Z0-9]*" because it starts with an uppercase character.

This confirms that the description of the test case is "bad 1" and the number of violations is 1.
['Get the name of method.', 'Check whether the method is a junit method.', 'Get the regex that applies to the method name based on its kind.', 'Check whether the method name matches the regex.', 'Get the name of method: The method name is "Bar".', 'Check whether the method is a junit method: The method is not a JUnit method.', 'Get the regex that applies to the method name based on its kind: The regex for instance/static method names is "[a-z][a-zA-Z0-9]*".', 'Check whether the method name matches the regex: The method name "Bar" does not match the regex "[a-z][a-zA-Z0-9]*" because it starts with an uppercase character.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Get the regex that applies to the method name based on its kind.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex.* 匹配到的元操作或API：
query: Check whether the method name matches the regex.
most similar API: Check whether the method equals
cosine Similarity: 0.8188820481300354
*Get the name of method: The method name is "Bar".* 匹配到的元操作或API：
logic: Get the name of method: The method name is "Bar".
most similar meta operation: Get the name of method
cosine Similarity: 0.8984187245368958
*Check whether the method is a junit method: The method is not a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method: The method is not a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.92498779296875
*Get the regex that applies to the method name based on its kind: The regex for instance/static method names is "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex: The method name "Bar" does not match the regex "[a-z][a-zA-Z0-9]*" because it starts with an uppercase character.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should start with lowercase character
public class Foo {
    void Bar() {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'Bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean equals(java.lang.Object)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (!methodName.matches("[a-z][a-zA-Z0-9]*") && !TestFrameworksUtil.isJUnitMethod(node)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is an instance method.
3. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
4. Check whether the method is a static method.
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
6. Check whether the method is a native method.
7. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
8. Check whether the method is a JUnit 3 test method.
9. Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*".
10. Check whether the method is a JUnit 4 test method.
11. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
12. Check whether the method is a JUnit 5 test method.
13. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

In this test case, we can perform the following checks:

1. Get the name of method. (The method name is "Bar")
2. Check whether the method is an instance method. (It is an instance method)
3. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". (The method name "Bar" does not match this regex as it starts with an uppercase character)

Since the method name "Bar" does not match the regex for instance method names, this test case violates the rule.
['Get the name of method.', 'Check whether the method is an instance method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Check whether the method is a static method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Check whether the method is a native method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Check whether the method is a JUnit 3 test method.', 'Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*".', 'Check whether the method is a JUnit 4 test method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Check whether the method is a JUnit 5 test method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method. (The method name is "Bar")', 'Check whether the method is an instance method. (It is an instance method)', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". (The method name "Bar" does not match this regex as it starts with an uppercase character)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is an instance method.* 匹配到的元操作或API：
query: Check whether the method is an instance method.
most similar API: Check whether is test method
cosine Similarity: 0.8555017709732056
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is a static method.* 匹配到的元操作或API：
logic: Check whether the method is a static method.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.959594190120697
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is a native method.* 匹配到的元操作或API：
logic: Check whether the method is a native method.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9731003046035767
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is a JUnit 3 test method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit 3 test method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.917560875415802
*Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is a JUnit 4 test method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit 4 test method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9065175652503967
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is a JUnit 5 test method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit 5 test method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9190863370895386
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. (The method name is "Bar")* 匹配到的元操作或API：
logic: Get the name of method. (The method name is "Bar")
most similar meta operation: Get the name of method
cosine Similarity: 0.9088581800460815
*Check whether the method is an instance method. (It is an instance method)* 匹配到的元操作或API：
query: Check whether the method is an instance method. (It is an instance method)
most similar API: Check whether is test method
cosine Similarity: 0.8489518165588379
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". (The method name "Bar" does not match this regex as it starts with an uppercase character)* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should start with lowercase character
public class Foo {
    void Bar() {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'Bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z][a-zA-Z0-9]*");
    private static final Pattern JUNIT45_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (TestFrameworksUtil.isJUnitMethod(node) && node.getAnnotations().anyMatch(a -> a.getTypeName().equals("Test"))) {
            if (!JUNIT45_TEST_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (TestFrameworksUtil.isTestMethod(node)) {
            if (!JUNIT3_TEST_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (node.isNative()) {
            if (!NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (node.isStatic()) {
            if (!STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else {
            if (!INSTANCE_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is a junit method.
3. Get the signature of method.
4. Check whether the method is static.
5. Check whether the method is instance method.
6. Check whether the method name matches the regex for instance method names.
7. Check whether the method name matches the regex for static method names.
8. Check whether the method name matches the regex for native method names.
9. Check whether the method name matches the regex for JUnit 3 test method names.
10. Check whether the method name matches the regex for JUnit 4 test method names.
11. Check whether the method name matches the regex for JUnit 5 test method names.

For the provided test case:

1. Get the name of method. // "Bar"
2. Check whether the method is a junit method. // False
3. Get the signature of method. // "void Bar()"
4. Check whether the method is static. // False
5. Check whether the method is instance method. // True
6. Check whether the method name matches the regex for instance method names. // False (because "Bar" starts with an uppercase letter)

Since the method is an instance method and its name does not match the regex for instance method names, it violates the rule. The number of violations in this test case is indeed 1.
['Get the name of method.', 'Check whether the method is a junit method.', 'Get the signature of method.', 'Check whether the method is static.', 'Check whether the method is instance method.', 'Check whether the method name matches the regex for instance method names.', 'Check whether the method name matches the regex for static method names.', 'Check whether the method name matches the regex for native method names.', 'Check whether the method name matches the regex for JUnit 3 test method names.', 'Check whether the method name matches the regex for JUnit 4 test method names.', 'Check whether the method name matches the regex for JUnit 5 test method names.', 'Get the name of method. // "Bar"', 'Check whether the method is a junit method. // False', 'Get the signature of method. // "void Bar()"', 'Check whether the method is static. // False', 'Check whether the method is instance method. // True', 'Check whether the method name matches the regex for instance method names. // False (because "Bar" starts with an uppercase letter)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is instance method.* 匹配到的元操作或API：
query: Check whether the method is instance method.
most similar API: Check whether is test method
cosine Similarity: 0.8605937361717224
*Check whether the method name matches the regex for instance method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for static method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for native method names.* 匹配到的元操作或API：
query: Check whether the method name matches the regex for native method names.
most similar API: Check whether the method is native
cosine Similarity: 0.8058077096939087
*Check whether the method name matches the regex for JUnit 3 test method names.* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names.
most similar API: Check whether is junit3 method
cosine Similarity: 0.845057487487793
*Check whether the method name matches the regex for JUnit 4 test method names.* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 4 test method names.
most similar API: Check whether is junit4 method
cosine Similarity: 0.8317020535469055
*Check whether the method name matches the regex for JUnit 5 test method names.* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 5 test method names.
most similar API: Check whether is junit5 method
cosine Similarity: 0.8380166888237
*Get the name of method. // "Bar"* 匹配到的元操作或API：
logic: Get the name of method. // "Bar"
most similar meta operation: Get the name of method
cosine Similarity: 0.8708768486976624
*Check whether the method is a junit method. // False* 匹配到的元操作或API：
logic: Check whether the method is a junit method. // False
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9505062699317932
*Get the signature of method. // "void Bar()"* 匹配到的元操作或API：
logic: Get the signature of method. // "void Bar()"
most similar meta operation: Get the signature of method
cosine Similarity: 0.9128762483596802
*Check whether the method is static. // False* 匹配到的元操作或API：
logic: Check whether the method is static. // False
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9482631087303162
*Check whether the method is instance method. // True* 匹配到的元操作或API：
query: Check whether the method is instance method. // True
most similar API: Check whether is test method
cosine Similarity: 0.8314364552497864
*Check whether the method name matches the regex for instance method names. // False (because "Bar" starts with an uppercase letter)* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should start with lowercase character
public class Foo {
    void Bar() {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'Bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
7. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
8. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit4Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
9. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit5Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (TestFrameworksUtil.isJUnit3Method(node)) {
            if (!methodName.matches("test[A-Z0-9][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        } else if (TestFrameworksUtil.isTestMethod(node) || node.isNative()) {
            if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        } else if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 1
1233
939
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
        2. Check whether the method is static.
        3. Check whether the method is a junit method.
        4. Check whether the method is native.
        5. Get the regex for instance method names.
        6. Check whether the method name matches the regex for instance method names.
        7. Get the regex for static method names.
        8. Check whether the method name matches the regex for static method names.
        9. Get the regex for native method names.
        10. Check whether the method name matches the regex for native method names.
        11. Get the regex for JUnit 3 test method names.
        12. Check whether the method name matches the regex for JUnit 3 test method names.
        13. Get the regex for JUnit 4 test method names.
        14. Check whether the method name matches the regex for JUnit 4 test method names.
        15. Get the regex for JUnit 5 test method names.
        16. Check whether the method name matches the regex for JUnit 5 test method names.

In this test case:
- The method `bar_foo` is not static, not a native method, and not a JUnit test method.
- The method name `bar_foo` does not match the regex for instance method names "[a-z][a-zA-Z0-9]*" because it contains an underscore.

Therefore, this test case violates the rule.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is a junit method.', 'Check whether the method is native.', 'Get the regex for instance method names.', 'Check whether the method name matches the regex for instance method names.', 'Get the regex for static method names.', 'Check whether the method name matches the regex for static method names.', 'Get the regex for native method names.', 'Check whether the method name matches the regex for native method names.', 'Get the regex for JUnit 3 test method names.', 'Check whether the method name matches the regex for JUnit 3 test method names.', 'Get the regex for JUnit 4 test method names.', 'Check whether the method name matches the regex for JUnit 4 test method names.', 'Get the regex for JUnit 5 test method names.', 'Check whether the method name matches the regex for JUnit 5 test method names.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Get the regex for instance method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for instance method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the regex for static method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for static method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the regex for native method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for native method names.* 匹配到的元操作或API：
query: Check whether the method name matches the regex for native method names.
most similar API: Check whether the method is native
cosine Similarity: 0.8058077096939087
*Get the regex for JUnit 3 test method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 3 test method names.* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names.
most similar API: Check whether is junit3 method
cosine Similarity: 0.845057487487793
*Get the regex for JUnit 4 test method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 4 test method names.* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 4 test method names.
most similar API: Check whether is junit4 method
cosine Similarity: 0.8317020535469055
*Get the regex for JUnit 5 test method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 5 test method names.* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 5 test method names.
most similar API: Check whether is junit5 method
cosine Similarity: 0.8380166888237
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should not contain underscores
public class Foo {
    void bar_foo() {}
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar_foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit4Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
7. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit5Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern INSTANCE_STATIC_METHOD_NAME_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_NAME_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_METHOD_NAME_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_METHOD_NAME_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_METHOD_NAME_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (TestFrameworksUtil.isJUnit3Method(node)) {
            if (!JUNIT3_METHOD_NAME_PATTERN.matcher(node.getName()).matches()) {
                addViolation(data, node);
            }
        } else if (TestFrameworksUtil.isJUnit4Method(node)) {
            if (!JUNIT4_METHOD_NAME_PATTERN.matcher(node.getName()).matches()) {
                addViolation(data, node);
            }
        } else if (TestFrameworksUtil.isJUnit5Method(node)) {
            if (!JUNIT5_METHOD_NAME_PATTERN.matcher(node.getName()).matches()) {
                addViolation(data, node);
            }
        } else if (node.isNative()) {
            if (!NATIVE_METHOD_NAME_PATTERN.matcher(node.getName()).matches()) {
                addViolation(data, node);
            }
        } else if (node.isStatic()) {
            if (!INSTANCE_STATIC_METHOD_NAME_PATTERN.matcher(node.getName()).matches()) {
                addViolation(data, node);
            }
        } else {
            if (!INSTANCE_STATIC_METHOD_NAME_PATTERN.matcher(node.getName()).matches()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is a junit method.
3. Get the signature of method.
4. Check whether the method is static.
5. Compare the method name against the regex for instance methods "[a-z][a-zA-Z0-9]*".
6. Compare the method name against the regex for static methods "[a-z][a-zA-Z0-9]*".
7. Compare the method name against the regex for native methods "[a-z][a-zA-Z0-9]*".
8. Compare the method name against the regex for JUnit 3 test methods "test[A-Z0-9][a-zA-Z0-9]*".
9. Compare the method name against the regex for JUnit 4 test methods "[a-z][a-zA-Z0-9]*".
10. Compare the method name against the regex for JUnit 5 test methods "[a-z][a-zA-Z0-9]*".

If the method name does not match any of the applicable regex patterns, then the method violates the rule.

In this test case:
- The method name `bar_foo` does not match the regex pattern "[a-z][a-zA-Z0-9]*" because it contains an underscore.
- The method is not a JUnit method.
- The method is not native.
- The method is not static.

Since the method name `bar_foo` does not match the regex pattern for instance methods and is not a static, native, or JUnit method, it violates the rule. The number of violations is 1.
            
['Get the name of method.', 'Check whether the method is a junit method.', 'Get the signature of method.', 'Check whether the method is static.', 'Compare the method name against the regex for instance methods "[a-z][a-zA-Z0-9]*".', 'Compare the method name against the regex for static methods "[a-z][a-zA-Z0-9]*".', 'Compare the method name against the regex for native methods "[a-z][a-zA-Z0-9]*".', 'Compare the method name against the regex for JUnit 3 test methods "test[A-Z0-9][a-zA-Z0-9]*".', 'Compare the method name against the regex for JUnit 4 test methods "[a-z][a-zA-Z0-9]*".', 'Compare the method name against the regex for JUnit 5 test methods "[a-z][a-zA-Z0-9]*".']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Compare the method name against the regex for instance methods "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Compare the method name against the regex for static methods "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Compare the method name against the regex for native methods "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Compare the method name against the regex for JUnit 3 test methods "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Compare the method name against the regex for JUnit 4 test methods "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Compare the method name against the regex for JUnit 5 test methods "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should not contain underscores
public class Foo {
    void bar_foo() {}
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar_foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (TestFrameworksUtil.isJUnitMethod(node)) {
            if (!methodName.matches("test[A-Z0-9][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        } else if (node.isStatic()) {
            if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        } else if (methodName.contains("_")) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Get the signature of method.
4. Check whether the method is a junit method.
5. Get the regex for instance method names.
6. Check whether the method name matches the instance method name regex.
7. If the method is not static and is not a JUnit method, check whether the method name matches the instance method name regex.

In this test case, the method `bar_foo` is an instance method (not static and not a JUnit method). The name `bar_foo` does not match the instance method name regex `[a-z][a-zA-Z0-9]*` because it contains an underscore. Therefore, this test case violates the rule.
['Get the name of method.', 'Check whether the method is static.', 'Get the signature of method.', 'Check whether the method is a junit method.', 'Get the regex for instance method names.', 'Check whether the method name matches the instance method name regex.', 'If the method is not static and is not a JUnit method, check whether the method name matches the instance method name regex.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Get the regex for instance method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the instance method name regex.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the method is not static and is not a JUnit method, check whether the method name matches the instance method name regex.* 匹配到的元操作或API：
query: If the method is not static and is not a JUnit method, check whether the method name matches the instance method name regex.
most similar API: Check whether is junit3 method
cosine Similarity: 0.8210007548332214
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should not contain underscores
public class Foo {
    void bar_foo() {}
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar_foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


出现语法错误，这一轮舍弃，直接重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method is native.
4. Check whether the method is a junit method.
5. Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".
If the method is not static, not native, not a JUnit method, and the method name does not match the regex for instance method names "[a-z][a-zA-Z0-9]*", then this test case violates the rule.

In the given test case:
1. Get the name of method: `bar_foo`
2. Check whether the method is static: `false`
3. Check whether the method is native: `false`
4. Check whether the method is a junit method: `false`
5. Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": `false` (because it contains an underscore)

This test case violates the rule as the method name `bar_foo` contains an underscore and does not match the specified regex for instance method names.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is native.', 'Check whether the method is a junit method.', 'Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".', 'Get the name of method: `bar_foo`', 'Check whether the method is static: `false`', 'Check whether the method is native: `false`', 'Check whether the method is a junit method: `false`', 'Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": `false` (because it contains an underscore)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: `bar_foo`* 匹配到的元操作或API：
logic: Get the name of method: `bar_foo`
most similar meta operation: Get the name of method
cosine Similarity: 0.8639518022537231
*Check whether the method is static: `false`* 匹配到的元操作或API：
logic: Check whether the method is static: `false`
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9453908801078796
*Check whether the method is native: `false`* 匹配到的元操作或API：
logic: Check whether the method is native: `false`
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9488310813903809
*Check whether the method is a junit method: `false`* 匹配到的元操作或API：
logic: Check whether the method is a junit method: `false`
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9452388286590576
*Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": `false` (because it contains an underscore)* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should not contain underscores
public class Foo {
    void bar_foo() {}
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar_foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (methodName.contains("_")) {
            if (TestFrameworksUtil.isJUnitMethod(node)) {
                if (!methodName.matches("test[A-Z0-9][a-zA-Z0-9]*")) {
                    addViolation(data, node);
                }
            } else if (node.isStatic() || node.isNative()) {
                if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                    addViolation(data, node);
                }
            } else {
                if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is instance method.
3. Get the signature of method.
4. Check whether the method signature matches the regex for instance methods "[a-z][a-zA-Z0-9]*".
If the method name does not match the regex for instance methods, then this test case violates the rule. 

Let's perform the checks:

1. Get the name of method.
   - Method name is `bar_foo`.

2. Check whether the method is instance method.
   - The method `bar_foo` is an instance method.

3. Get the signature of method.
   - The signature of the method `bar_foo` is `void bar_foo()`.

4. Check whether the method signature matches the regex for instance methods "[a-z][a-zA-Z0-9]*".
   - The method name `bar_foo` does not match the regex "[a-z][a-zA-Z0-9]*" because it contains an underscore.

Since the method name `bar_foo` does not match the regex for instance methods, the test case violates the rule.
['Get the name of method.', 'Check whether the method is instance method.', 'Get the signature of method.', 'Check whether the method signature matches the regex for instance methods "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is instance method.', 'Get the signature of method.', 'Check whether the method signature matches the regex for instance methods "[a-z][a-zA-Z0-9]*".']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is instance method.* 匹配到的元操作或API：
query: Check whether the method is instance method.
most similar API: Check whether is test method
cosine Similarity: 0.8605937361717224
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Check whether the method signature matches the regex for instance methods "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method signature matches the regex for instance methods "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method signature
cosine Similarity: 0.8032069206237793
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is instance method.* 匹配到的元操作或API：
query: Check whether the method is instance method.
most similar API: Check whether is test method
cosine Similarity: 0.8605937361717224
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Check whether the method signature matches the regex for instance methods "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method signature matches the regex for instance methods "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method signature
cosine Similarity: 0.8032069206237793
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should not contain underscores
public class Foo {
    void bar_foo() {}
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar_foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJunit3MethodSignature(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Does not check the class (use {@link #isJUnit3Class(ASTAnyTypeDeclaration)}).



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


出现语法错误，这一轮舍弃，直接重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 2
1233
939
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Get the signature of method.
4. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

For the method `foo`:
1. Get the name of method -> "foo"
2. Check whether the method is static -> True
3. Get the signature of method -> "void foo()"
4. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" -> True

For the method `st_whatever`:
1. Get the name of method -> "st_whatever"
2. Check whether the method is static -> True
3. Get the signature of method -> "void st_whatever()"
4. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" -> True

For the method `bar`:
1. Get the name of method -> "bar"
2. Check whether the method is static -> False
3. Get the signature of method -> "void bar()"
4. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" -> True

Given the description "bad 3" and the number of violations being 1, there seems to be a discrepancy in the provided test case as none of the method names violate the provided regex patterns. However, if the intention is to test against a specific JUnit 3 naming convention, we need to ensure that the method is a JUnit test method.

Let's re-evaluate assuming we are checking against JUnit 3 test method names:
1. Check whether the method is a junit method.

For the method `foo`:
1. Get the name of method -> "foo"
2. Check whether the method is static -> True
3. Check whether the method is a junit method -> False (assuming no JUnit annotations or naming convention indicating it's a JUnit test)

For the method `st_whatever`:
1. Get the name of method -> "st_whatever"
2. Check whether the method is static -> True
3. Check whether the method is a junit method -> False (assuming no JUnit annotations or naming convention indicating it's a JUnit test)

For the method `bar`:
1. Get the name of method -> "bar"
2. Check whether the method is static -> False
3. Check whether the method is a junit method -> False (assuming no JUnit annotations or naming convention indicating it's a JUnit test)

If the test case actually includes a JUnit 3 test method that does not match the regex "test[A-Z0-9][a-zA-Z0-9]*", it would look something like this:

```java
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // JUnit 3 test method name does not match the pattern
    void whatever() {
    }
}
```

Re-evaluating with this corrected test case:

For the method `whatever`:
1. Get the name of method -> "whatever"
2. Check whether the method is static -> False
3. Check whether the method is a junit method -> True (assuming some JUnit 3 test naming convention or annotation indicating it's a JUnit test)
4. Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*" -> False

This method would violate the rule as it is a JUnit 3 test method and its name does not match the expected regex pattern.
['Get the name of method.', 'Check whether the method is static.', 'Get the signature of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method -> "foo"', 'Check whether the method is static -> True', 'Get the signature of method -> "void foo()"', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" -> True', 'Get the name of method -> "st_whatever"', 'Check whether the method is static -> True', 'Get the signature of method -> "void st_whatever()"', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" -> True', 'Get the name of method -> "bar"', 'Check whether the method is static -> False', 'Get the signature of method -> "void bar()"', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" -> True', 'Check whether the method is a junit method.', 'Get the name of method -> "foo"', 'Check whether the method is static -> True', "Check whether the method is a junit method -> False (assuming no JUnit annotations or naming convention indicating it's a JUnit test)", 'Get the name of method -> "st_whatever"', 'Check whether the method is static -> True', "Check whether the method is a junit method -> False (assuming no JUnit annotations or naming convention indicating it's a JUnit test)", 'Get the name of method -> "bar"', 'Check whether the method is static -> False', "Check whether the method is a junit method -> False (assuming no JUnit annotations or naming convention indicating it's a JUnit test)", 'Get the name of method -> "whatever"', 'Check whether the method is static -> False', "Check whether the method is a junit method -> True (assuming some JUnit 3 test naming convention or annotation indicating it's a JUnit test)", 'Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*" -> False']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method -> "foo"* 匹配到的元操作或API：
logic: Get the name of method -> "foo"
most similar meta operation: Get the name of method
cosine Similarity: 0.9269973039627075
*Check whether the method is static -> True* 匹配到的元操作或API：
logic: Check whether the method is static -> True
most similar meta operation: Check whether the method is static
cosine Similarity: 0.966212809085846
*Get the signature of method -> "void foo()"* 匹配到的元操作或API：
logic: Get the signature of method -> "void foo()"
most similar meta operation: Get the signature of method
cosine Similarity: 0.9146921634674072
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" -> True* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method -> "st_whatever"* 匹配到的元操作或API：
logic: Get the name of method -> "st_whatever"
most similar meta operation: Get the name of method
cosine Similarity: 0.8732926249504089
*Check whether the method is static -> True* 匹配到的元操作或API：
logic: Check whether the method is static -> True
most similar meta operation: Check whether the method is static
cosine Similarity: 0.966212809085846
*Get the signature of method -> "void st_whatever()"* 匹配到的元操作或API：
logic: Get the signature of method -> "void st_whatever()"
most similar meta operation: Get the signature of method
cosine Similarity: 0.8759191036224365
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" -> True* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method -> "bar"* 匹配到的元操作或API：
logic: Get the name of method -> "bar"
most similar meta operation: Get the name of method
cosine Similarity: 0.8866822123527527
*Check whether the method is static -> False* 匹配到的元操作或API：
logic: Check whether the method is static -> False
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9584746956825256
*Get the signature of method -> "void bar()"* 匹配到的元操作或API：
logic: Get the signature of method -> "void bar()"
most similar meta operation: Get the signature of method
cosine Similarity: 0.892057478427887
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" -> True* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Get the name of method -> "foo"* 匹配到的元操作或API：
logic: Get the name of method -> "foo"
most similar meta operation: Get the name of method
cosine Similarity: 0.9269973039627075
*Check whether the method is static -> True* 匹配到的元操作或API：
logic: Check whether the method is static -> True
most similar meta operation: Check whether the method is static
cosine Similarity: 0.966212809085846
*Check whether the method is a junit method -> False (assuming no JUnit annotations or naming convention indicating it's a JUnit test)* 匹配到的元操作或API：
logic: Check whether the method is a junit method -> False (assuming no JUnit annotations or naming convention indicating it's a JUnit test)
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9309183359146118
*Get the name of method -> "st_whatever"* 匹配到的元操作或API：
logic: Get the name of method -> "st_whatever"
most similar meta operation: Get the name of method
cosine Similarity: 0.8732926249504089
*Check whether the method is static -> True* 匹配到的元操作或API：
logic: Check whether the method is static -> True
most similar meta operation: Check whether the method is static
cosine Similarity: 0.966212809085846
*Check whether the method is a junit method -> False (assuming no JUnit annotations or naming convention indicating it's a JUnit test)* 匹配到的元操作或API：
logic: Check whether the method is a junit method -> False (assuming no JUnit annotations or naming convention indicating it's a JUnit test)
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9309183359146118
*Get the name of method -> "bar"* 匹配到的元操作或API：
logic: Get the name of method -> "bar"
most similar meta operation: Get the name of method
cosine Similarity: 0.8866822123527527
*Check whether the method is static -> False* 匹配到的元操作或API：
logic: Check whether the method is static -> False
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9584746956825256
*Check whether the method is a junit method -> False (assuming no JUnit annotations or naming convention indicating it's a JUnit test)* 匹配到的元操作或API：
logic: Check whether the method is a junit method -> False (assuming no JUnit annotations or naming convention indicating it's a JUnit test)
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9309183359146118
*Get the name of method -> "whatever"* 匹配到的元操作或API：
logic: Get the name of method -> "whatever"
most similar meta operation: Get the name of method
cosine Similarity: 0.9071211814880371
*Check whether the method is static -> False* 匹配到的元操作或API：
logic: Check whether the method is static -> False
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9584746956825256
*Check whether the method is a junit method -> True (assuming some JUnit 3 test naming convention or annotation indicating it's a JUnit test)* 匹配到的元操作或API：
logic: Check whether the method is a junit method -> True (assuming some JUnit 3 test naming convention or annotation indicating it's a JUnit test)
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9293113946914673
*Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*" -> False* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// Static method pattern
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'st_whatever')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT_3_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT_4_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT_5_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();

        if (TestFrameworksUtil.isJUnitMethod(node)) {
            // For simplicity, assuming all JUnit methods are JUnit 4 or 5 as per the rule description
            if (!JUNIT_4_METHOD_PATTERN.matcher(methodName).matches() && !JUNIT_5_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (node.isStatic()) {
            if (!STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (node.isNative()) { // Corrected from getGenericSignature().isNative() to isNative()
            if (!NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else {
            if (!STATIC_METHOD_PATTERN.matcher(methodName).matches()) { // This pattern should be different for non-static methods
                addViolation(data, node);
            }
        }

        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
To verify the adherence of the provided test case to the rule, we need to perform the following granular checks:

1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

Let's perform these checks on each method in the class `Foo`:

1. Get the name of method.
   - Method name: `foo`
2. Check whether the method is static.
   - The method `foo` is static.
3. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
   - The method name `foo` matches the regex "[a-z][a-zA-Z0-9]*".

Repeat for the next method:

1. Get the name of method.
   - Method name: `st_whatever`
2. Check whether the method is static.
   - The method `st_whatever` is static.
3. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
   - The method name `st_whatever` matches the regex "[a-z][a-zA-Z0-9]*".

Repeat for the next method:

1. Get the name of method.
   - Method name: `bar`
2. Check whether the method is static.
   - The method `bar` is not static.
3. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
   - The method name `bar` matches the regex "[a-z][a-zA-Z0-9]*".

Since all the method names match the appropriate patterns based on whether they are static or not, the test case does not violate the rule described.

However, the description provided with the test case states "bad 3" and says there is 1 violation. Given the provided regex for static method names and the method names in the test case, it seems there is a discrepancy between the actual rule implementation and the expected result.

To identify the supposed violation:

1. Get the name of method.
   - Method name: `st_whatever`
2. Check whether the method is static.
   - The method `st_whatever` is static.
3. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
   - The method name `st_whatever` matches the regex "[a-z][a-zA-Z0-9]*".

Since the method name `st_whatever` matches the regex for static method names, there is no violation based on the provided rule description.

Therefore, based on the provided rule description and test case, there is no violation. The test case should be compliant. If the intention was to use a different regex for static methods (e.g., requiring a specific prefix), the rule description should be updated accordingly.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is static.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is static.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is static.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is static.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// Static method pattern
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'st_whatever')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
True
此测试用例生成了first checker: bad 3


======================接下来开始迭代=====================
[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
To ascertain the adherence of the provided test case to the rule, we need to perform the following checks:

1. Get the name of method.
2. Check whether the method is native.
3. Check whether the name of the native method matches the regex pattern "[a-z][a-zA-Z0-9]*".

Let's go through each method in the test case and perform these checks:

1. **Method `foo`**:
    1. Get the name of method.
        - The name of the method is `foo`.
    2. Check whether the method is native.
        - The method `foo` is native.
    3. Check whether the name of the native method matches the regex pattern "[a-z][a-zA-Z0-9]*".
        - The name `foo` matches the regex pattern "[a-z][a-zA-Z0-9]*".

2. **Method `nt_whatever`**:
    1. Get the name of method.
        - The name of the method is `nt_whatever`.
    2. Check whether the method is native.
        - The method `nt_whatever` is native.
    3. Check whether the name of the native method matches the regex pattern "[a-z][a-zA-Z0-9]*".
        - The name `nt_whatever` does not match the regex pattern "[a-z][a-zA-Z0-9]*" because it starts with `nt_`, not a lowercase letter.

3. **Method `bar`**:
    1. Get the name of method.
        - The name of the method is `bar`.
    2. Check whether the method is native.
        - The method `bar` is not native.
    3. Check whether the name of the method matches the regex pattern "[a-z][a-zA-Z0-9]*".
        - The name `bar` matches the regex pattern "[a-z][a-zA-Z0-9]*".

Based on these checks, we can conclude that the method `nt_whatever` is a native method but its name does not match the expected regex pattern for native methods, which is "[a-z][a-zA-Z0-9]*". Therefore, the number of violations in this test case is 1.
['Get the name of method.', 'Check whether the method is native.', 'Check whether the name of the native method matches the regex pattern "[a-z][a-zA-Z0-9]*".', '**Method `foo`**:', 'Get the name of method.', 'Check whether the method is native.', 'Check whether the name of the native method matches the regex pattern "[a-z][a-zA-Z0-9]*".', '**Method `nt_whatever`**:', 'Get the name of method.', 'Check whether the method is native.', 'Check whether the name of the native method matches the regex pattern "[a-z][a-zA-Z0-9]*".', '**Method `bar`**:', 'Get the name of method.', 'Check whether the method is native.', 'Check whether the name of the method matches the regex pattern "[a-z][a-zA-Z0-9]*".']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the name of the native method matches the regex pattern "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the name of the native method matches the regex pattern "[a-z][a-zA-Z0-9]*".
most similar API: Check whether the method is native
cosine Similarity: 0.8001399636268616
***Method `foo`**:* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the name of the native method matches the regex pattern "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the name of the native method matches the regex pattern "[a-z][a-zA-Z0-9]*".
most similar API: Check whether the method is native
cosine Similarity: 0.8001399636268616
***Method `nt_whatever`**:* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the name of the native method matches the regex pattern "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the name of the native method matches the regex pattern "[a-z][a-zA-Z0-9]*".
most similar API: Check whether the method is native
cosine Similarity: 0.8001399636268616
***Method `bar`**:* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the name of the method matches the regex pattern "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// Native method pattern
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'nt_whatever')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
107
91
94
78
84
70
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method is a JUnit method.
3. Check whether the method is a JUnit 3 test method.
4. Get the name of method.
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
6. Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*".

For the first method `testGetBestTeam`:
1. Get the name of method. // "testGetBestTeam"
2. Check whether the method is a JUnit method. // true (since it extends TestCase and follows JUnit 3 naming conventions)
3. Check whether the method is a JUnit 3 test method. // true (follows JUnit 3 test naming conventions)
4. Get the name of method. // "testGetBestTeam"
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // false
6. Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*". // true

For the second method `test_getBestTeam`:
1. Get the name of method. // "test_getBestTeam"
2. Check whether the method is a JUnit method. // true (since it extends TestCase and follows JUnit 3 naming conventions)
3. Check whether the method is a JUnit 3 test method. // true (follows JUnit 3 test naming conventions)
4. Get the name of method. // "test_getBestTeam"
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // false
6. Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*". // false

Only `testGetBestTeam` adheres to the JUnit 3 test method naming convention, so it does not violate the rule. However, `test_getBestTeam` does not match the JUnit 3 test method naming convention ("test[A-Z0-9][a-zA-Z0-9]*"), indicating a violation of the rule.
        
The number of violating the rule in this test case is: 1 (specifically, `test_getBestTeam` violates the rule).
['Get the name of method.', 'Check whether the method is a JUnit method.', 'Check whether the method is a JUnit 3 test method.', 'Get the name of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*".', 'Get the name of method. // "testGetBestTeam"', 'Check whether the method is a JUnit method. // true (since it extends TestCase and follows JUnit 3 naming conventions)', 'Check whether the method is a JUnit 3 test method. // true (follows JUnit 3 test naming conventions)', 'Get the name of method. // "testGetBestTeam"', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // false', 'Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*". // true', 'Get the name of method. // "test_getBestTeam"', 'Check whether the method is a JUnit method. // true (since it extends TestCase and follows JUnit 3 naming conventions)', 'Check whether the method is a JUnit 3 test method. // true (follows JUnit 3 test naming conventions)', 'Get the name of method. // "test_getBestTeam"', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // false', 'Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*". // false']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'ASTExtendsList', 'TypesFromReflection', 'ASTImportDeclaration', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method is a JUnit 3 test method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit 3 test method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.917560875415802
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. // "testGetBestTeam"* 匹配到的元操作或API：
logic: Get the name of method. // "testGetBestTeam"
most similar meta operation: Get the name of method
cosine Similarity: 0.850612223148346
*Check whether the method is a JUnit method. // true (since it extends TestCase and follows JUnit 3 naming conventions)* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method. // true (since it extends TestCase and follows JUnit 3 naming conventions)
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9096843004226685
*Check whether the method is a JUnit 3 test method. // true (follows JUnit 3 test naming conventions)* 匹配到的元操作或API：
logic: Check whether the method is a JUnit 3 test method. // true (follows JUnit 3 test naming conventions)
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.8847947120666504
*Get the name of method. // "testGetBestTeam"* 匹配到的元操作或API：
logic: Get the name of method. // "testGetBestTeam"
most similar meta operation: Get the name of method
cosine Similarity: 0.850612223148346
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // false* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*". // true* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. // "test_getBestTeam"* 匹配到的元操作或API：
logic: Get the name of method. // "test_getBestTeam"
most similar meta operation: Get the name of method
cosine Similarity: 0.8646917343139648
*Check whether the method is a JUnit method. // true (since it extends TestCase and follows JUnit 3 naming conventions)* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method. // true (since it extends TestCase and follows JUnit 3 naming conventions)
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9096843004226685
*Check whether the method is a JUnit 3 test method. // true (follows JUnit 3 test naming conventions)* 匹配到的元操作或API：
logic: Check whether the method is a JUnit 3 test method. // true (follows JUnit 3 test naming conventions)
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.8847947120666504
*Get the name of method. // "test_getBestTeam"* 匹配到的元操作或API：
logic: Get the name of method. // "test_getBestTeam"
most similar meta operation: Get the name of method
cosine Similarity: 0.8646917343139648
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // false* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*". // false* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 3 test detection
import junit.framework.Assert;
import junit.framework.TestCase;

public class TournamentTest extends TestCase {

    public void testGetBestTeam() {
    }

    // this is ok tho
    public void test_getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testGetBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'test_getBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (TestFrameworksUtil.isJUnitMethod(node)) {
            if (!JUNIT3_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class extends TestCase.
3. Get the name of method.
4. Check whether the method is public.
5. Check whether the method is a junit method.
6. Check whether the method is a JUnit 3 test method.
7. Get the method name.
8. Check whether the method name matches the regex for JUnit 3 test method names (i.e., "test[A-Z0-9][a-zA-Z0-9]*").

For the first method `testGetBestTeam`:
9. Check whether the method name matches the regex for JUnit 3 test method names.

For the second method `test_getBestTeam`:
10. Check whether the method name matches the regex for JUnit 3 test method names.

In this case, `testGetBestTeam` matches the JUnit 3 test method name regex, so it does not violate the rule. However, `test_getBestTeam` does not match the JUnit 3 test method name regex, so it violates the rule. Thus, there is 1 violation in this test case.
['Get the name of class.', 'Check whether the class extends TestCase.', 'Get the name of method.', 'Check whether the method is public.', 'Check whether the method is a junit method.', 'Check whether the method is a JUnit 3 test method.', 'Get the method name.', 'Check whether the method name matches the regex for JUnit 3 test method names (i.e., "test[A-Z0-9][a-zA-Z0-9]*").', 'Check whether the method name matches the regex for JUnit 3 test method names.', 'Check whether the method name matches the regex for JUnit 3 test method names.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'ASTExtendsList', 'TypesFromReflection', 'ASTImportDeclaration', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class extends TestCase.* 匹配到的元操作或API：
query: Check whether the class extends TestCase.
most similar API: Check whether is test class
cosine Similarity: 0.8235633373260498
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is public.* 匹配到的元操作或API：
logic: Check whether the method is public.
most similar meta operation: Check whether the method is public
cosine Similarity: 0.982057511806488
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method is a JUnit 3 test method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit 3 test method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.917560875415802
*Get the method name.* 匹配到的元操作或API：
logic: Get the method name.
most similar meta operation: Get the name of method
cosine Similarity: 0.9567613005638123
*Check whether the method name matches the regex for JUnit 3 test method names (i.e., "test[A-Z0-9][a-zA-Z0-9]*").* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names (i.e., "test[A-Z0-9][a-zA-Z0-9]*").
most similar API: Check whether is junit3 method
cosine Similarity: 0.805923342704773
*Check whether the method name matches the regex for JUnit 3 test method names.* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names.
most similar API: Check whether is junit3 method
cosine Similarity: 0.845057487487793
*Check whether the method name matches the regex for JUnit 3 test method names.* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names.
most similar API: Check whether is junit3 method
cosine Similarity: 0.845057487487793
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 3 test detection
import junit.framework.Assert;
import junit.framework.TestCase;

public class TournamentTest extends TestCase {

    public void testGetBestTeam() {
    }

    // this is ok tho
    public void test_getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testGetBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'test_getBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestClass(net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPublic()
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        ASTClassOrInterfaceDeclaration classNode = node.getFirstParentOfType(ASTClassOrInterfaceDeclaration.class);

        if (TestFrameworksUtil.isTestClass(classNode)) {
            if (TestFrameworksUtil.isJUnit3Method(node) && !JUNIT3_TEST_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            } else if ((TestFrameworksUtil.isJUnitMethod(node) || TestFrameworksUtil.isJUnit5Method(node)) && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Check whether the class extends TestCase.
        2. Get the name of method.
        3. Check whether the method is public.
        4. Check whether the method is a junit method.
        5. Get the regex which applies to JUnit 3 test method names.
        6. Check whether the method name matches the JUnit 3 test method name regex.
        7. Repeat steps 2-6 for each method in the class.

In this test case, since the class extends TestCase, it is a JUnit 3 test class. We need to check the method names:
- For the method `testGetBestTeam`:
  - Method name does not match the JUnit 3 test method name regex "[a-z][a-zA-Z0-9]*".
  - Therefore, this method violates the rule.
- For the method `test_getBestTeam`:
  - Method name matches the JUnit 3 test method name regex "[a-z][a-zA-Z0-9]*".
  - Therefore, this method does not violate the rule.

Thus, the number of methods violating the rule in this test case is: 1.
['Check whether the class extends TestCase.', 'Get the name of method.', 'Check whether the method is public.', 'Check whether the method is a junit method.', 'Get the regex which applies to JUnit 3 test method names.', 'Check whether the method name matches the JUnit 3 test method name regex.', 'Repeat steps 2-6 for each method in the class.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'ASTExtendsList', 'TypesFromReflection', 'ASTImportDeclaration', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Check whether the class extends TestCase.* 匹配到的元操作或API：
query: Check whether the class extends TestCase.
most similar API: Check whether is test class
cosine Similarity: 0.8235633373260498
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is public.* 匹配到的元操作或API：
logic: Check whether the method is public.
most similar meta operation: Check whether the method is public
cosine Similarity: 0.982057511806488
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Get the regex which applies to JUnit 3 test method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the JUnit 3 test method name regex.* 匹配到的元操作或API：
query: Check whether the method name matches the JUnit 3 test method name regex.
most similar API: Check whether is junit3 method
cosine Similarity: 0.8509573936462402
*Repeat steps 2-6 for each method in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 3 test detection
import junit.framework.Assert;
import junit.framework.TestCase;

public class TournamentTest extends TestCase {

    public void testGetBestTeam() {
    }

    // this is ok tho
    public void test_getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testGetBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'test_getBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestClass(net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration)
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPublic()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (TestFrameworksUtil.isJUnit3Method(node) && !JUNIT3_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method is a junit method.
3. Get the name of method.
4. Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").
5. Get the name of method.
6. Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").

Let's perform these checks on the provided test case:

1. Get the name of method: testGetBestTeam
2. Check whether the method is a junit method: Yes, because the class extends `TestCase` and it has the `test` prefix.
3. Get the name of method: testGetBestTeam
4. Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*"): Yes, it matches because the method name starts with "test" followed by an uppercase letter "G".
5. Get the name of method: test_getBestTeam
6. Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*"): No, it does not match because the method name contains an underscore "_" which is not allowed by the regex.

In this test case, the method `test_getBestTeam` violates the rule for JUnit 3 test method names. The method `testGetBestTeam` does not violate the rule.
['Get the name of method.', 'Check whether the method is a junit method.', 'Get the name of method.', 'Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").', 'Get the name of method.', 'Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").', 'Get the name of method: testGetBestTeam', 'Check whether the method is a junit method: Yes, because the class extends `TestCase` and it has the `test` prefix.', 'Get the name of method: testGetBestTeam', 'Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*"): Yes, it matches because the method name starts with "test" followed by an uppercase letter "G".', 'Get the name of method: test_getBestTeam', 'Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*"): No, it does not match because the method name contains an underscore "_" which is not allowed by the regex.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'ASTExtendsList', 'TypesFromReflection', 'ASTImportDeclaration', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").
most similar API: Check whether is junit3 method
cosine Similarity: 0.8099056482315063
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").
most similar API: Check whether is junit3 method
cosine Similarity: 0.8099056482315063
*Get the name of method: testGetBestTeam* 匹配到的元操作或API：
query: Get the name of method: testGetBestTeam
most similar API: get name of method
cosine Similarity: 0.8378527164459229
*Check whether the method is a junit method: Yes, because the class extends `TestCase` and it has the `test` prefix.* 匹配到的元操作或API：
logic: Check whether the method is a junit method: Yes, because the class extends `TestCase` and it has the `test` prefix.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.8691893219947815
*Get the name of method: testGetBestTeam* 匹配到的元操作或API：
query: Get the name of method: testGetBestTeam
most similar API: get name of method
cosine Similarity: 0.8378527164459229
*Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*"): Yes, it matches because the method name starts with "test" followed by an uppercase letter "G".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: test_getBestTeam* 匹配到的元操作或API：
query: Get the name of method: test_getBestTeam
most similar API: get name of method
cosine Similarity: 0.8494269847869873
*Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*"): No, it does not match because the method name contains an underscore "_" which is not allowed by the regex.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 3 test detection
import junit.framework.Assert;
import junit.framework.TestCase;

public class TournamentTest extends TestCase {

    public void testGetBestTeam() {
    }

    // this is ok tho
    public void test_getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testGetBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'test_getBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName(), //Returns the simple name of the method.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT45_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (TestFrameworksUtil.isJUnit3Method(node) && !JUNIT3_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (TestFrameworksUtil.isJUnitMethod(node) && !JUNIT45_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class extends TestCase class.
3. Get all methods declared in class.
4. Check whether the method is a junit method.
5. Get the name of method.
6. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" (for JUnit 3 test methods, the regex should be "test[A-Z0-9][a-zA-Z0-9]*").
7. Check whether the method name matches the regex for JUnit 3 test methods "test[A-Z0-9][a-zA-Z0-9]*".
8. Get the name of method.
9. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" (for JUnit 3 test methods, the regex should be "test[A-Z0-9][a-zA-Z0-9]*").
10. Check whether the method name matches the regex for JUnit 3 test methods "test[A-Z0-9][a-zA-Z0-9]*".

The violation occurs in the method named "test_getBestTeam" because it does not match the regex "test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3 test method names.
['Get the name of class.', 'Check whether the class extends TestCase class.', 'Get all methods declared in class.', 'Check whether the method is a junit method.', 'Get the name of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" (for JUnit 3 test methods, the regex should be "test[A-Z0-9][a-zA-Z0-9]*").', 'Check whether the method name matches the regex for JUnit 3 test methods "test[A-Z0-9][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" (for JUnit 3 test methods, the regex should be "test[A-Z0-9][a-zA-Z0-9]*").', 'Check whether the method name matches the regex for JUnit 3 test methods "test[A-Z0-9][a-zA-Z0-9]*".']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'ASTExtendsList', 'TypesFromReflection', 'ASTImportDeclaration', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class extends TestCase class.* 匹配到的元操作或API：
query: Check whether the class extends TestCase class.
most similar API: Check whether is test class
cosine Similarity: 0.8235305547714233
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" (for JUnit 3 test methods, the regex should be "test[A-Z0-9][a-zA-Z0-9]*").* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 3 test methods "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test methods "test[A-Z0-9][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method
cosine Similarity: 0.8242838978767395
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" (for JUnit 3 test methods, the regex should be "test[A-Z0-9][a-zA-Z0-9]*").* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 3 test methods "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test methods "test[A-Z0-9][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method
cosine Similarity: 0.8242838978767395
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 3 test detection
import junit.framework.Assert;
import junit.framework.TestCase;

public class TournamentTest extends TestCase {

    public void testGetBestTeam() {
    }

    // this is ok tho
    public void test_getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testGetBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'test_getBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestClass(net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (TestFrameworksUtil.isTestClass(node.getFirstParentOfType(ASTClassOrInterfaceDeclaration.class)) && TestFrameworksUtil.isJUnit3Method(node) && !JUNIT3_TEST_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 5
[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
107
91
99
82
84
70
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method has declared annotations.
3. Get a declared annotation of method.
4. Check whether the annotation is Test.
5. Get the name of called method.
6. Get the name of method.
7. Check whether the method is static.
8. Get the name of method.
9. Check whether the method is an instance method.
10. Get the name of method.
11. Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".
12. Get the name of method.
13. Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*".
14. Get the name of method.
15. Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".
16. Get the name of method.
17. Check whether the method name matches the regex for JUnit 5 test method names "[a-z][a-zA-Z0-9]*".

In this test case:
- The method name "get_best_team" does not match the regex for instance method names and JUnit 4/5 test method names "[a-z][a-zA-Z0-9]*".
- The method name "getBestTeam" matches the regex for instance method names and JUnit 4/5 test method names "[a-z][a-zA-Z0-9]*".

Since "get_best_team" does not match the appropriate regex, it violates the rule.
['Get the name of method.', 'Check whether the method has declared annotations.', 'Get a declared annotation of method.', 'Check whether the annotation is Test.', 'Get the name of called method.', 'Get the name of method.', 'Check whether the method is static.', 'Get the name of method.', 'Check whether the method is an instance method.', 'Get the name of method.', 'Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method name matches the regex for JUnit 5 test method names "[a-z][a-zA-Z0-9]*".']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTAnnotation', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTImportDeclaration', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method has declared annotations.* 匹配到的元操作或API：
logic: Check whether the method has declared annotations.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9820230007171631
*Get a declared annotation of method.* 匹配到的元操作或API：
logic: Get a declared annotation of method.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9867770671844482
*Check whether the annotation is Test.* 匹配到的元操作或API：
query: Check whether the annotation is Test.
most similar API: Check whether is junit4 test annotation
cosine Similarity: 0.8442186117172241
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is an instance method.* 匹配到的元操作或API：
query: Check whether the method is an instance method.
most similar API: Check whether is test method
cosine Similarity: 0.8555017709732056
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method
cosine Similarity: 0.8107518553733826
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit4 method
cosine Similarity: 0.8056954741477966
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex for JUnit 5 test method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 5 test method names "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit5 method
cosine Similarity: 0.8117830753326416
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 4 test detection without proper auxclasspath
import org.junit.Test; // note: test case uses "useAuxClasspath=false"!!

public class TournamentTest {

    // wrong test name pattern
    @Test
    public void get_best_team() {
    }

    // this is ok
    @Test
    public void getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'get_best_team')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'getBestTeam')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJunit4TestAnnotation(net.sourceforge.pmd.lang.java.ast.ASTAnnotation)
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
7. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
8. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit4Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
9. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit5Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)

1.  //Check whether method has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTMethodDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (TestFrameworksUtil.isJUnit3Method(node) && !JUNIT3_TEST_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (TestFrameworksUtil.isJUnit4Method(node) && !JUNIT4_TEST_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (TestFrameworksUtil.isJUnit5Method(node) && !JUNIT5_TEST_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Check whether the class has declared annotations.
2. Get a declared annotation of class.
3. Check whether the class has x annotation (org.junit.Test).
4. Get all methods declared in class.
5. Check whether method has declared annotations.
6. Get a declared annotation of method.
7. Check whether the method has x annotation (org.junit.Test).
8. Get the name of method.
9. Check whether the method is instance method.
10. Check whether the method is static method.
11. Check whether the method is native method.
12. Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".
13. Check whether the method name matches the regex for static method names "[a-z][a-zA-Z0-9]*".
14. Check whether the method name matches the regex for native method names "[a-z][a-zA-Z0-9]*".
15. Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".

In this test case:
- Method `get_best_team` is an instance method and has the @Test annotation.
- Method `get_best_team` does not match the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*" because it contains an underscore.
- Method `getBestTeam` matches the regex for JUnit 4 test method names.

Thus, the method `get_best_team` violates the rule.
['Check whether the class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the class has x annotation (org.junit.Test).', 'Get all methods declared in class.', 'Check whether method has declared annotations.', 'Get a declared annotation of method.', 'Check whether the method has x annotation (org.junit.Test).', 'Get the name of method.', 'Check whether the method is instance method.', 'Check whether the method is static method.', 'Check whether the method is native method.', 'Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for static method names "[a-z][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for native method names "[a-z][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTAnnotation', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTImportDeclaration', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.987838864326477
*Check whether the class has x annotation (org.junit.Test).* 匹配到的元操作或API：
logic: Check whether the class has x annotation (org.junit.Test).
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9487923979759216
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether method has declared annotations.* 匹配到的元操作或API：
logic: Check whether method has declared annotations.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9891549348831177
*Get a declared annotation of method.* 匹配到的元操作或API：
logic: Get a declared annotation of method.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9867770671844482
*Check whether the method has x annotation (org.junit.Test).* 匹配到的元操作或API：
logic: Check whether the method has x annotation (org.junit.Test).
most similar meta operation: Check whether the method has x annotation
cosine Similarity: 0.9527726173400879
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is instance method.* 匹配到的元操作或API：
query: Check whether the method is instance method.
most similar API: Check whether is test method
cosine Similarity: 0.8605937361717224
*Check whether the method is static method.* 匹配到的元操作或API：
logic: Check whether the method is static method.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9611144065856934
*Check whether the method is native method.* 匹配到的元操作或API：
logic: Check whether the method is native method.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9763295650482178
*Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for static method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for native method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit4 method
cosine Similarity: 0.8056954741477966
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 4 test detection without proper auxclasspath
import org.junit.Test; // note: test case uses "useAuxClasspath=false"!!

public class TournamentTest {

    // wrong test name pattern
    @Test
    public void get_best_team() {
    }

    // this is ok
    @Test
    public void getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'get_best_team')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'getBestTeam')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
8. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
9. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit4Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether method has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTMethodDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (TestFrameworksUtil.isJUnit4Method(node) && !JUNIT4_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get a declared annotation of class.
3. Check whether the class has `@Test` annotation.
4. Get all methods declared in class.
5. Check whether the method has `@Test` annotation.
6. Get the name of method.
7. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

Let's go through the test case:

1. Get the name of class. (The name is `TournamentTest`)
2. Get a declared annotation of class. (No annotations found at class level)
3. Check whether the class has `@Test` annotation. (False, as the annotation is on the method)
4. Get all methods declared in class. (Methods are `get_best_team` and `getBestTeam`)
5. Check whether the method has `@Test` annotation. (True for `get_best_team` and `getBestTeam`)
6. Get the name of method. (Name is `get_best_team`)
7. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". (False, as the method name contains underscores)

Since the method `get_best_team` has a `@Test` annotation and its name does not match the expected regex pattern for JUnit 4 test method names, it violates the rule.

8. Get the name of method. (Name is `getBestTeam`)
9. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". (True, as the method name starts with a lowercase letter and contains only letters and numbers)

The method `getBestTeam` adheres to the rule. Therefore, the number of methods violating the rule is indeed 1.
['Get the name of class.', 'Get a declared annotation of class.', 'Check whether the class has `@Test` annotation.', 'Get all methods declared in class.', 'Check whether the method has `@Test` annotation.', 'Get the name of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of class. (The name is `TournamentTest`)', 'Get a declared annotation of class. (No annotations found at class level)', 'Check whether the class has `@Test` annotation. (False, as the annotation is on the method)', 'Get all methods declared in class. (Methods are `get_best_team` and `getBestTeam`)', 'Check whether the method has `@Test` annotation. (True for `get_best_team` and `getBestTeam`)', 'Get the name of method. (Name is `get_best_team`)', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". (False, as the method name contains underscores)', 'Get the name of method. (Name is `getBestTeam`)', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". (True, as the method name starts with a lowercase letter and contains only letters and numbers)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTAnnotation', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTImportDeclaration', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.987838864326477
*Check whether the class has `@Test` annotation.* 匹配到的元操作或API：
query: Check whether the class has `@Test` annotation.
most similar API: Check whether is expect annotated: Tells if the node contains a @Test annotation with an expected exception.
cosine Similarity: 0.8454126119613647
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether the method has `@Test` annotation.* 匹配到的元操作或API：
logic: Check whether the method has `@Test` annotation.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.8502141833305359
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class. (The name is `TournamentTest`)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get a declared annotation of class. (No annotations found at class level)* 匹配到的元操作或API：
logic: Get a declared annotation of class. (No annotations found at class level)
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.932842493057251
*Check whether the class has `@Test` annotation. (False, as the annotation is on the method)* 匹配到的元操作或API：
query: Check whether the class has `@Test` annotation. (False, as the annotation is on the method)
most similar API: Check whether the method is any annotation present
cosine Similarity: 0.8515479564666748
*Get all methods declared in class. (Methods are `get_best_team` and `getBestTeam`)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method has `@Test` annotation. (True for `get_best_team` and `getBestTeam`)* 匹配到的元操作或API：
query: Check whether the method has `@Test` annotation. (True for `get_best_team` and `getBestTeam`)
most similar API: Check whether the method is any annotation present
cosine Similarity: 0.8000239729881287
*Get the name of method. (Name is `get_best_team`)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". (False, as the method name contains underscores)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. (Name is `getBestTeam`)* 匹配到的元操作或API：
logic: Get the name of method. (Name is `getBestTeam`)
most similar meta operation: Get the name of method
cosine Similarity: 0.9124639630317688
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". (True, as the method name starts with a lowercase letter and contains only letters and numbers)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 4 test detection without proper auxclasspath
import org.junit.Test; // note: test case uses "useAuxClasspath=false"!!

public class TournamentTest {

    // wrong test name pattern
    @Test
    public void get_best_team() {
    }

    // this is ok
    @Test
    public void getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'get_best_team')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'getBestTeam')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isExpectAnnotated(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Tells if the node contains a @Test annotation with an expected exception.
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection), //Checks whether any annotation is present on this node. @param binaryNames            Collection that contains binary names of annotations.            Note: for now, canonical names are tolerated, this may be changed in PMD 7. @return <code>true</code> if any annotation is present on this node, else <code>false</code>

1.  //Check whether method has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTMethodDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;
import java.util.Collection;
import java.util.List;
import java.util.Arrays;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT_TEST_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    private static final Collection<String> TEST_ANNOTATIONS = Arrays.asList("org.junit.Test", "org.junit.jupiter.api.Test");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isAnyAnnotationPresent(TEST_ANNOTATIONS) && !TestFrameworksUtil.isExpectAnnotated(node) && !JUNIT_TEST_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Check whether the method has a declaration.
        2. Get the name of method.
        3. Check whether method has declared annotations.
        4. Get a declared annotation of method.
        5. Check whether the annotation is Test.
        6. Check whether the method is a JUnit 4 test method.
        7. Get the signature of method.
        8. Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".
        If the method has the Test annotation and the method name does not match the JUnit 4 test method name regex, then this method violates the rule. In this case, the method `get_best_team` does not match the regex and hence it violates the rule.
['Check whether the method has a declaration.', 'Get the name of method.', 'Check whether method has declared annotations.', 'Get a declared annotation of method.', 'Check whether the annotation is Test.', 'Check whether the method is a JUnit 4 test method.', 'Get the signature of method.', 'Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTAnnotation', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTImportDeclaration', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Check whether the method has a declaration.* 匹配到的元操作或API：
logic: Check whether the method has a declaration.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.8883677124977112
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether method has declared annotations.* 匹配到的元操作或API：
logic: Check whether method has declared annotations.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9891549348831177
*Get a declared annotation of method.* 匹配到的元操作或API：
logic: Get a declared annotation of method.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9867770671844482
*Check whether the annotation is Test.* 匹配到的元操作或API：
query: Check whether the annotation is Test.
most similar API: Check whether is junit4 test annotation
cosine Similarity: 0.8442186117172241
*Check whether the method is a JUnit 4 test method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit 4 test method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9065175652503967
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit4 method
cosine Similarity: 0.8056954741477966
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 4 test detection without proper auxclasspath
import org.junit.Test; // note: test case uses "useAuxClasspath=false"!!

public class TournamentTest {

    // wrong test name pattern
    @Test
    public void get_best_team() {
    }

    // this is ok
    @Test
    public void getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'get_best_team')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'getBestTeam')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJunit4TestAnnotation(net.sourceforge.pmd.lang.java.ast.ASTAnnotation)
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit4Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)

1.  //Check whether method has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTMethodDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.getDeclaredAnnotations().anyMatch(annotation -> TestFrameworksUtil.isJunit4TestAnnotation(annotation)) && !JUNIT4_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get the name of method.
3. Check whether method has declared annotations.
4. Get a declared annotation of method.
5. Check whether the declared annotation is Test.
6. Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*").

For the method `get_best_team`:

7. Get the name of method (get_best_team).
8. Check whether method has declared annotations (yes, it has @Test).
9. Get a declared annotation of method (@Test).
10. Check whether the declared annotation is Test (yes).
11. Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*") (no, it starts with lowercase but contains an underscore).

For the method `getBestTeam`:

12. Get the name of method (getBestTeam).
13. Check whether method has declared annotations (yes, it has @Test).
14. Get a declared annotation of method (@Test).
15. Check whether the declared annotation is Test (yes).
16. Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*") (yes).

The method `get_best_team` violates the rule because its name does not match the specified regex for JUnit 4 test method names.
['Get the name of class.', 'Get the name of method.', 'Check whether method has declared annotations.', 'Get a declared annotation of method.', 'Check whether the declared annotation is Test.', 'Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*").', 'Get the name of method (get_best_team).', 'Check whether method has declared annotations (yes, it has @Test).', 'Get a declared annotation of method (@Test).', 'Check whether the declared annotation is Test (yes).', 'Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*") (no, it starts with lowercase but contains an underscore).', 'Get the name of method (getBestTeam).', 'Check whether method has declared annotations (yes, it has @Test).', 'Get a declared annotation of method (@Test).', 'Check whether the declared annotation is Test (yes).', 'Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*") (yes).']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTAnnotation', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTImportDeclaration', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether method has declared annotations.* 匹配到的元操作或API：
logic: Check whether method has declared annotations.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9891549348831177
*Get a declared annotation of method.* 匹配到的元操作或API：
logic: Get a declared annotation of method.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9867770671844482
*Check whether the declared annotation is Test.* 匹配到的元操作或API：
logic: Check whether the declared annotation is Test.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.8626705408096313
*Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*").* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*").
most similar API: Check whether is junit4 method
cosine Similarity: 0.8051496148109436
*Get the name of method (get_best_team).* 匹配到的元操作或API：
query: Get the name of method (get_best_team).
most similar API: get name of method
cosine Similarity: 0.809440553188324
*Check whether method has declared annotations (yes, it has @Test).* 匹配到的元操作或API：
logic: Check whether method has declared annotations (yes, it has @Test).
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9369685053825378
*Get a declared annotation of method (@Test).* 匹配到的元操作或API：
logic: Get a declared annotation of method (@Test).
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9266241192817688
*Check whether the declared annotation is Test (yes).* 匹配到的元操作或API：
query: Check whether the declared annotation is Test (yes).
most similar API: Check whether the annotation equals
cosine Similarity: 0.8260498046875
*Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*") (no, it starts with lowercase but contains an underscore).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method (getBestTeam).* 匹配到的元操作或API：
logic: Get the name of method (getBestTeam).
most similar meta operation: Get the name of method
cosine Similarity: 0.9083284735679626
*Check whether method has declared annotations (yes, it has @Test).* 匹配到的元操作或API：
logic: Check whether method has declared annotations (yes, it has @Test).
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9369685053825378
*Get a declared annotation of method (@Test).* 匹配到的元操作或API：
logic: Get a declared annotation of method (@Test).
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9266241192817688
*Check whether the declared annotation is Test (yes).* 匹配到的元操作或API：
query: Check whether the declared annotation is Test (yes).
most similar API: Check whether the annotation equals
cosine Similarity: 0.8260498046875
*Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*") (yes).* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*") (yes).
most similar API: Check whether is junit4 method
cosine Similarity: 0.8040377497673035
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 4 test detection without proper auxclasspath
import org.junit.Test; // note: test case uses "useAuxClasspath=false"!!

public class TournamentTest {

    // wrong test name pattern
    @Test
    public void get_best_team() {
    }

    // this is ok
    @Test
    public void getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'get_best_team')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'getBestTeam')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit4Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName(), //Returns the simple name of the method.
6. net.sourceforge.pmd.lang.java.ast.ASTAnnotation: public boolean equals(java.lang.Object)

1.  //Check whether method has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTMethodDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```
2.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (TestFrameworksUtil.isJUnit4Method(node) && !JUNIT4_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 6
[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the name of method.
2. Get the signature of method.
3. Check whether the method is static.
4. Check whether the method is native.
5. Check whether the method is a junit method.
6. If the method is not static, not native, and not a junit method, check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
7. Repeat steps 1-6 for each method in the class.

For the first method `fooBar`:
1. Get the name of method: fooBar
2. Get the signature of method: public void fooBar()
3. Check whether the method is static: False
4. Check whether the method is native: False
5. Check whether the method is a junit method: False
6. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": True

For the second method `m_fooBar`:
1. Get the name of method: m_fooBar
2. Get the signature of method: public void m_fooBar()
3. Check whether the method is static: False
4. Check whether the method is native: False
5. Check whether the method is a junit method: False
6. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": False

The second method `m_fooBar` violates the rule because its name does not match the regex "[a-z][a-zA-Z0-9]*".
['Get the name of method.', 'Get the signature of method.', 'Check whether the method is static.', 'Check whether the method is native.', 'Check whether the method is a junit method.', 'If the method is not static, not native, and not a junit method, check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Repeat steps 1-6 for each method in the class.', 'Get the name of method: fooBar', 'Get the signature of method: public void fooBar()', 'Check whether the method is static: False', 'Check whether the method is native: False', 'Check whether the method is a junit method: False', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": True', 'Get the name of method: m_fooBar', 'Get the signature of method: public void m_fooBar()', 'Check whether the method is static: False', 'Check whether the method is native: False', 'Check whether the method is a junit method: False', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": False']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*If the method is not static, not native, and not a junit method, check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: If the method is not static, not native, and not a junit method, check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method
cosine Similarity: 0.8175830841064453
*Repeat steps 1-6 for each method in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: fooBar* 匹配到的元操作或API：
logic: Get the name of method: fooBar
most similar meta operation: Get the name of method
cosine Similarity: 0.8897055983543396
*Get the signature of method: public void fooBar()* 匹配到的元操作或API：
logic: Get the signature of method: public void fooBar()
most similar meta operation: Get the signature of method
cosine Similarity: 0.9192356467247009
*Check whether the method is static: False* 匹配到的元操作或API：
logic: Check whether the method is static: False
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9611486196517944
*Check whether the method is native: False* 匹配到的元操作或API：
logic: Check whether the method is native: False
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9489173293113708
*Check whether the method is a junit method: False* 匹配到的元操作或API：
logic: Check whether the method is a junit method: False
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9644191265106201
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": True* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: m_fooBar* 匹配到的元操作或API：
logic: Get the name of method: m_fooBar
most similar meta operation: Get the name of method
cosine Similarity: 0.8615139722824097
*Get the signature of method: public void m_fooBar()* 匹配到的元操作或API：
logic: Get the signature of method: public void m_fooBar()
most similar meta operation: Get the signature of method
cosine Similarity: 0.9097535014152527
*Check whether the method is static: False* 匹配到的元操作或API：
logic: Check whether the method is static: False
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9611486196517944
*Check whether the method is native: False* 匹配到的元操作或API：
logic: Check whether the method is native: False
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9489173293113708
*Check whether the method is a junit method: False* 匹配到的元操作或API：
logic: Check whether the method is a junit method: False
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9644191265106201
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": False* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// Instance method custom convention
public class Foo {

    public void fooBar() {
    }

    public void m_fooBar() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'm_fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT45_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (TestFrameworksUtil.isJUnit3Method(node) && !JUNIT3_TEST_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (TestFrameworksUtil.isJUnitMethod(node) && !JUNIT45_TEST_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (!node.isStatic() && !node.isNative() && !INSTANCE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method is native.
4. Check whether the method is a JUnit method.
5. Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".
6. Get the name of method.
7. Check whether the method is static.
8. Check whether the method is native.
9. Check whether the method is a JUnit method.
10. Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".

For the first method `fooBar`:
1. Get the name of method: `fooBar`
2. Check whether the method is static: `false`
3. Check whether the method is native: `false`
4. Check whether the method is a JUnit method: `false`
5. Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": `true` (does not violate the rule)

For the second method `m_fooBar`:
6. Get the name of method: `m_fooBar`
7. Check whether the method is static: `false`
8. Check whether the method is native: `false`
9. Check whether the method is a JUnit method: `false`
10. Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": `false` (violates the rule)

Since `m_fooBar` does not match the regex for instance method names, it violates the rule. The number of violating the rule in this test case is indeed 1.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is native.', 'Check whether the method is a JUnit method.', 'Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is static.', 'Check whether the method is native.', 'Check whether the method is a JUnit method.', 'Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".', 'Get the name of method: `fooBar`', 'Check whether the method is static: `false`', 'Check whether the method is native: `false`', 'Check whether the method is a JUnit method: `false`', 'Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": `true` (does not violate the rule)', 'Get the name of method: `m_fooBar`', 'Check whether the method is static: `false`', 'Check whether the method is native: `false`', 'Check whether the method is a JUnit method: `false`', 'Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": `false` (violates the rule)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: `fooBar`* 匹配到的元操作或API：
logic: Get the name of method: `fooBar`
most similar meta operation: Get the name of method
cosine Similarity: 0.8852731585502625
*Check whether the method is static: `false`* 匹配到的元操作或API：
logic: Check whether the method is static: `false`
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9453908801078796
*Check whether the method is native: `false`* 匹配到的元操作或API：
logic: Check whether the method is native: `false`
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9488310813903809
*Check whether the method is a JUnit method: `false`* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method: `false`
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9452388286590576
*Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": `true` (does not violate the rule)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: `m_fooBar`* 匹配到的元操作或API：
logic: Get the name of method: `m_fooBar`
most similar meta operation: Get the name of method
cosine Similarity: 0.8571934103965759
*Check whether the method is static: `false`* 匹配到的元操作或API：
logic: Check whether the method is static: `false`
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9453908801078796
*Check whether the method is native: `false`* 匹配到的元操作或API：
logic: Check whether the method is native: `false`
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9488310813903809
*Check whether the method is a JUnit method: `false`* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method: `false`
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9452388286590576
*Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": `false` (violates the rule)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// Instance method custom convention
public class Foo {

    public void fooBar() {
    }

    public void m_fooBar() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'm_fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (TestFrameworksUtil.isJUnitMethod(node)) {
            if (!JUNIT3_METHOD_PATTERN.matcher(methodName).matches() && 
                !JUNIT4_METHOD_PATTERN.matcher(methodName).matches() &&
                !JUNIT5_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (!node.isStatic() && !node.isNative() && !INSTANCE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To ascertain the adherence of the provided test case to the rule, we need to perform the following granular checks:

1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method is a JUnit method.
4. Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".
5. Repeat steps 1-4 for each method in the class.

Let's go through these checks for the methods in the `Foo` class:

### For method `fooBar`

1. Get the name of method: `fooBar`
2. Check whether the method is static: No, it is an instance method.
3. Check whether the method is a JUnit method: No, it does not follow JUnit naming conventions.
4. Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": No, it starts with a lowercase letter followed by an uppercase letter, which does not match the regex.

### For method `m_fooBar`

1. Get the name of method: `m_fooBar`
2. Check whether the method is static: No, it is an instance method.
3. Check whether the method is a JUnit method: No, it does not follow JUnit naming conventions.
4. Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": No, it starts with a lowercase letter followed by an underscore, which does not match the regex.

Based on these checks, both methods violate the rule for instance method naming conventions. Therefore, the number of violations in this test case is indeed 2, not 1. The method `fooBar` matches the standard Java naming convention for methods, but `m_fooBar` does not.

To match the expected result of 1 violation, let's assume the rule should only apply to non-standard naming conventions that clearly do not follow the Camel case pattern.

So, the correct check for this test case is:

### For method `fooBar`

1. Get the name of method: `fooBar`
2. Check whether the method is static: No, it is an instance method.
3. Check whether the method is a JUnit method: No, it does not follow JUnit naming conventions.
4. Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": Yes, it matches the regex (Camel case).

### For method `m_fooBar`

1. Get the name of method: `m_fooBar`
2. Check whether the method is static: No, it is an instance method.
3. Check whether the method is a JUnit method: No, it does not follow JUnit naming conventions.
4. Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": No, it starts with a lowercase letter followed by an underscore, which does not match the regex.

Based on these checks, only `m_fooBar` violates the rule, so the number of violations is 1.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is a JUnit method.', 'Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".', 'Repeat steps 1-4 for each method in the class.', 'Get the name of method: `fooBar`', 'Check whether the method is static: No, it is an instance method.', 'Check whether the method is a JUnit method: No, it does not follow JUnit naming conventions.', 'Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": No, it starts with a lowercase letter followed by an uppercase letter, which does not match the regex.', 'Get the name of method: `m_fooBar`', 'Check whether the method is static: No, it is an instance method.', 'Check whether the method is a JUnit method: No, it does not follow JUnit naming conventions.', 'Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": No, it starts with a lowercase letter followed by an underscore, which does not match the regex.', 'Get the name of method: `fooBar`', 'Check whether the method is static: No, it is an instance method.', 'Check whether the method is a JUnit method: No, it does not follow JUnit naming conventions.', 'Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": Yes, it matches the regex (Camel case).', 'Get the name of method: `m_fooBar`', 'Check whether the method is static: No, it is an instance method.', 'Check whether the method is a JUnit method: No, it does not follow JUnit naming conventions.', 'Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": No, it starts with a lowercase letter followed by an underscore, which does not match the regex.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 1-4 for each method in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: `fooBar`* 匹配到的元操作或API：
logic: Get the name of method: `fooBar`
most similar meta operation: Get the name of method
cosine Similarity: 0.8852731585502625
*Check whether the method is static: No, it is an instance method.* 匹配到的元操作或API：
logic: Check whether the method is static: No, it is an instance method.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9266155958175659
*Check whether the method is a JUnit method: No, it does not follow JUnit naming conventions.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method: No, it does not follow JUnit naming conventions.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.8967795372009277
*Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": No, it starts with a lowercase letter followed by an uppercase letter, which does not match the regex.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: `m_fooBar`* 匹配到的元操作或API：
logic: Get the name of method: `m_fooBar`
most similar meta operation: Get the name of method
cosine Similarity: 0.8571934103965759
*Check whether the method is static: No, it is an instance method.* 匹配到的元操作或API：
logic: Check whether the method is static: No, it is an instance method.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9266155958175659
*Check whether the method is a JUnit method: No, it does not follow JUnit naming conventions.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method: No, it does not follow JUnit naming conventions.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.8967795372009277
*Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": No, it starts with a lowercase letter followed by an underscore, which does not match the regex.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: `fooBar`* 匹配到的元操作或API：
logic: Get the name of method: `fooBar`
most similar meta operation: Get the name of method
cosine Similarity: 0.8852731585502625
*Check whether the method is static: No, it is an instance method.* 匹配到的元操作或API：
logic: Check whether the method is static: No, it is an instance method.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9266155958175659
*Check whether the method is a JUnit method: No, it does not follow JUnit naming conventions.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method: No, it does not follow JUnit naming conventions.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.8967795372009277
*Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": Yes, it matches the regex (Camel case).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: `m_fooBar`* 匹配到的元操作或API：
logic: Get the name of method: `m_fooBar`
most similar meta operation: Get the name of method
cosine Similarity: 0.8571934103965759
*Check whether the method is static: No, it is an instance method.* 匹配到的元操作或API：
logic: Check whether the method is static: No, it is an instance method.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9266155958175659
*Check whether the method is a JUnit method: No, it does not follow JUnit naming conventions.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method: No, it does not follow JUnit naming conventions.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.8967795372009277
*Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*": No, it starts with a lowercase letter followed by an underscore, which does not match the regex.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// Instance method custom convention
public class Foo {

    public void fooBar() {
    }

    public void m_fooBar() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'm_fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT45_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (TestFrameworksUtil.isJUnitMethod(node)) {
            if (node.hasAnnotation("org.junit.Test") || node.hasAnnotation("org.junit.jupiter.api.Test")) {
                if (!JUNIT45_METHOD_PATTERN.matcher(methodName).matches()) {
                    addViolation(data, node);
                }
            } else if (node.getName().startsWith("test")) {
                if (!JUNIT3_METHOD_PATTERN.matcher(methodName).matches()) {
                    addViolation(data, node);
                }
            }
        } else if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (!node.isStatic() && !node.isNative() && !INSTANCE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method is native.
4. Check whether the method is a JUnit method.
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

Let's perform the checks for each method:

For method `fooBar`:
1. Get the name of method: `fooBar`
2. Check whether the method is static: False
3. Check whether the method is native: False
4. Check whether the method is a JUnit method: False
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": True (since it matches the Camel case convention for instance methods)

For method `m_fooBar`:
1. Get the name of method: `m_fooBar`
2. Check whether the method is static: False
3. Check whether the method is native: False
4. Check whether the method is a JUnit method: False
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": False (since it does not start with a lowercase letter)

Based on these checks, the method `m_fooBar` violates the rule by not matching the regex for instance method names. Therefore, the number of violating the rule in this test case is 1.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is native.', 'Check whether the method is a JUnit method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method: `fooBar`', 'Check whether the method is static: False', 'Check whether the method is native: False', 'Check whether the method is a JUnit method: False', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": True (since it matches the Camel case convention for instance methods)', 'Get the name of method: `m_fooBar`', 'Check whether the method is static: False', 'Check whether the method is native: False', 'Check whether the method is a JUnit method: False', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": False (since it does not start with a lowercase letter)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: `fooBar`* 匹配到的元操作或API：
logic: Get the name of method: `fooBar`
most similar meta operation: Get the name of method
cosine Similarity: 0.8852731585502625
*Check whether the method is static: False* 匹配到的元操作或API：
logic: Check whether the method is static: False
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9611486196517944
*Check whether the method is native: False* 匹配到的元操作或API：
logic: Check whether the method is native: False
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9489173293113708
*Check whether the method is a JUnit method: False* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method: False
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9644191265106201
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": True (since it matches the Camel case convention for instance methods)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: `m_fooBar`* 匹配到的元操作或API：
logic: Get the name of method: `m_fooBar`
most similar meta operation: Get the name of method
cosine Similarity: 0.8571934103965759
*Check whether the method is static: False* 匹配到的元操作或API：
logic: Check whether the method is static: False
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9611486196517944
*Check whether the method is native: False* 匹配到的元操作或API：
logic: Check whether the method is native: False
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9489173293113708
*Check whether the method is a JUnit method: False* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method: False
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9644191265106201
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": False (since it does not start with a lowercase letter)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// Instance method custom convention
public class Foo {

    public void fooBar() {
    }

    public void m_fooBar() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'm_fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (TestFrameworksUtil.isJUnitMethod(node)) {
            Pattern junitPattern = JUNIT3_METHOD_PATTERN; // Default to JUnit 3 pattern
            if (node.hasAnnotation("org.junit.jupiter.api.Test")) {
                junitPattern = JUNIT5_METHOD_PATTERN;
            } else if (node.hasAnnotation("org.junit.Test")) {
                junitPattern = JUNIT4_METHOD_PATTERN;
            }
            if (!junitPattern.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (!node.isStatic() && !node.isNative() && !INSTANCE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method is native.
4. Check whether the method is a JUnit method.
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

For method `fooBar`:
1. Get the name of method: fooBar
2. Check whether the method is static: false
3. Check whether the method is native: false
4. Check whether the method is a JUnit method: false
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": true (does not violate the rule)

For method `m_fooBar`:
1. Get the name of method: m_fooBar
2. Check whether the method is static: false
3. Check whether the method is native: false
4. Check whether the method is a JUnit method: false
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": false (violates the rule)

So, the test case violates the rule for the method `m_fooBar`. The number of violations in this test case is: 1.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is native.', 'Check whether the method is a JUnit method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method: fooBar', 'Check whether the method is static: false', 'Check whether the method is native: false', 'Check whether the method is a JUnit method: false', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": true (does not violate the rule)', 'Get the name of method: m_fooBar', 'Check whether the method is static: false', 'Check whether the method is native: false', 'Check whether the method is a JUnit method: false', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": false (violates the rule)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: fooBar* 匹配到的元操作或API：
logic: Get the name of method: fooBar
most similar meta operation: Get the name of method
cosine Similarity: 0.8897055983543396
*Check whether the method is static: false* 匹配到的元操作或API：
logic: Check whether the method is static: false
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9611486196517944
*Check whether the method is native: false* 匹配到的元操作或API：
logic: Check whether the method is native: false
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9489173293113708
*Check whether the method is a JUnit method: false* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method: false
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9644191265106201
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": true (does not violate the rule)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: m_fooBar* 匹配到的元操作或API：
logic: Get the name of method: m_fooBar
most similar meta operation: Get the name of method
cosine Similarity: 0.8615139722824097
*Check whether the method is static: false* 匹配到的元操作或API：
logic: Check whether the method is static: false
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9611486196517944
*Check whether the method is native: false* 匹配到的元操作或API：
logic: Check whether the method is native: false
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9489173293113708
*Check whether the method is a JUnit method: false* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method: false
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9644191265106201
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": false (violates the rule)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// Instance method custom convention
public class Foo {

    public void fooBar() {
    }

    public void m_fooBar() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'm_fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT45_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (TestFrameworksUtil.isJUnitMethod(node)) {
            if (!JUNIT45_TEST_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (!node.isStatic() && !node.isNative() && !INSTANCE_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 7
测试用例全部通过
最终通过 7 个测试用例
正例 5 个
反例 2 个
输入token：521148
输出token：302265
结束

规则执行完毕，时间总花销： 2639.7121407985687 秒
