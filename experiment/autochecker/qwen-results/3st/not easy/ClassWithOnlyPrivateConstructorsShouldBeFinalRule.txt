开始

========================================== Rule ClassWithOnlyPrivateConstructorsShouldBeFinalRule ===========================================
一共 22 个测试用例
正例 15 个
反例 7 个
1117
839
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class
2. Check whether the class is public
3. Get the constructors of the class
4. Check whether the number of constructors is greater than 0
5. Get the first constructor of the class
6. Check whether the constructor is private

If the class is public and all its constructors are private, then this test case violates the rule. In this specific test case:

- The class `Foo` is public.
- It has one constructor.
- The constructor is private.

Therefore, the number of violations is 1.
['Get the name of class', 'Check whether the class is public', 'Get the constructors of the class', 'Check whether the number of constructors is greater than 0', 'Get the first constructor of the class', 'Check whether the constructor is private']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class* 匹配到的元操作或API：
logic: Get the name of class
most similar meta operation: Get the name of class
cosine Similarity: 1.0
*Check whether the class is public* 匹配到的元操作或API：
logic: Check whether the class is public
most similar meta operation: Check whether the class is public
cosine Similarity: 1.0000001192092896
*Get the constructors of the class* 匹配到的元操作或API：
query: Get the constructors of the class
most similar API: get class of constructor
cosine Similarity: 0.8535777926445007
*Check whether the number of constructors is greater than 0* 匹配到的元操作或API：
query: Check whether the number of constructors is greater than 0
most similar API: Check whether the constructor equals
cosine Similarity: 0.8197780847549438
*Get the first constructor of the class* 匹配到的元操作或API：
query: Get the first constructor of the class
most similar API: get first child of constructor
cosine Similarity: 0.8840917944908142
*Check whether the constructor is private* 匹配到的元操作或API：
logic: Check whether the constructor is private
most similar meta operation: Check whether the constructor is private
cosine Similarity: 1.0
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Simple violation
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean equals(java.lang.Object)
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.Node getFirstChild()
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if the class is public and all its constructors are private
        if (node.isPublic() && node.getConstructors().allMatch(ASTConstructorDeclaration::isPrivate)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
        2. Check whether the class has declared annotations.
        3. Get a declared annotation of class.
        4. Check whether the class has x annotation.
        5. Get the javadoc comment of class.
        6. Check whether the class is abstract.
        7. Check whether the class is public.
        8. Check whether the class is private.
        9. Check whether the class is protected.
        10. Check whether the class is default package-private.
        11. Check whether the class is final.
        12. Check whether the class is static.
        13. Get the super class of class.
        14. Check whether the class has extended x class.
        15. Get a implemented interface of class.
        16. Check whether the class has implemented x interface.
        17. Get the name of the package where the class is located.
        18. Check whether the class is interface.
        19. Check whether the class is inner class.
        20. Check whether the class is anonymous class.
        21. Get all constructors declared in class.
        22. Check whether the constructor is private.
        23. Get the number of formal parameters of constructor.
        24. Get a formal parameter of constructor.
        25. Check whether formal parameter has declared annotations.
        26. Get a declared annotation of formal parameter.
        27. Check whether the formal parameter has x annotation.
        28. Check whether the formal parameter is final.
        29. Check whether the constructor is public.
        30. Check whether the constructor is default package-private.
        31. Check whether the constructor is protected.
        32. Get an access of field.
        33. Check whether the field is final.
        34. Check whether the field is private.
        35. Check whether the field is public.
        36. Check whether the field is protected.
        37. Check whether the field is default package-private.
        38. Check whether the field is static.
        39. Check whether the field is volatile.
        40. Check whether the field is transient.
        41. Get the type of field.
        42. Check whether the field is string type.
        43. Check whether the field is boolean type.
        44. Check whether the field is char type.
        45. Check whether the field is byte type.
        46. Check whether the field is short type.
        47. Check whether the field is int type.
        48. Check whether the field is long type.
        49. Check whether the field is float type.
        50. Check whether the field is double type.
        51. Check whether the field is boxed type.
        52. Check whether the field is x class type.
        53. Check whether the field is array type.
        54. Check whether the field is enum type.
        55. Check whether the field is record type.
        56. Check whether field has declared annotations.
        57. Get a declared annotation of field.
        58. Check whether the field has x annotation.
        59. Check whether the field is initialized.
        60. Check whether the field is initialized to literal value.
        61. Check whether the field is initialized to variable value.
        62. Get the literal value that the field is initialized to.
        63. Get an access of field.
        64. Check whether the accessed variable is a field.
        65. Check whether the accessed variable is final.
        66. Check whether the accessed variable is being written.
        67. Check whether the accessed variable is static.

Based on the rule description and the provided test case, the relevant steps to verify adherence to the rule are:

1. Get the name of class.
2. Check whether the class is abstract.
3. Check whether the class is public.
4. Check whether the class is interface.
5. Get all constructors declared in class.
6. Check whether the constructor is private.
7. Get the number of formal parameters of constructor.
8. Check whether the class has any methods.
9. Check whether any method is abstract.

For the specific test case:

1. Get the name of class.
   - The name of the class is Foo.
2. Check whether the class is abstract.
   - The class Foo is not abstract.
3. Check whether the class is public.
   - The class Foo is public.
4. Check whether the class is interface.
   - The class Foo is not an interface.
5. Get all constructors declared in class.
   - There is one constructor declared in class Foo.
6. Check whether the constructor is private.
   - The constructor is private.
7. Get the number of formal parameters of constructor.
   - The number of formal parameters of the constructor is 0.
8. Check whether the class has any methods.
   - The class does not have any methods declared.
9. Check whether any method is abstract.
   - Since there are no methods, none are abstract.

The rule specifically targets classes that cannot be extended from outside their compilation unit because all their constructors are private. However, the test case provided does not violate the rule because the class does not have any methods, and thus, the absence of abstract methods is not a concern. The class itself can be made final, but it does not contain any abstract methods.

To properly verify adherence to the rule, the test case should include at least one method in the class. Here is a revised test case that would violate the rule:

```java
public class Foo {
    private Foo() { }

    public void someMethod() {
        // method implementation
    }
}
```

For this revised test case:

1. Get the name of class.
   - The name of the class is Foo.
2. Check whether the class is abstract.
   - The class Foo is not abstract.
3. Check whether the class is public.
   - The class Foo is public.
4. Check whether the class is interface.
   - The class Foo is not an interface.
5. Get all constructors declared in class.
   - There is one constructor declared in class Foo.
6. Check whether the constructor is private.
   - The constructor is private.
7. Get the number of formal parameters of constructor.
   - The number of formal parameters of the constructor is 0.
8. Check whether the class has any methods.
   - The class has one method declared.
9. Check whether any method is abstract.
   - The method someMethod is not abstract.

This test case would violate the rule because it is a public class with a private constructor and does not contain any abstract methods. Therefore, the class could be made final.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the class has x annotation.', 'Get the javadoc comment of class.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get a implemented interface of class.', 'Check whether the class has implemented x interface.', 'Get the name of the package where the class is located.', 'Check whether the class is interface.', 'Check whether the class is inner class.', 'Check whether the class is anonymous class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get the number of formal parameters of constructor.', 'Get a formal parameter of constructor.', 'Check whether formal parameter has declared annotations.', 'Get a declared annotation of formal parameter.', 'Check whether the formal parameter has x annotation.', 'Check whether the formal parameter is final.', 'Check whether the constructor is public.', 'Check whether the constructor is default package-private.', 'Check whether the constructor is protected.', 'Get an access of field.', 'Check whether the field is final.', 'Check whether the field is private.', 'Check whether the field is public.', 'Check whether the field is protected.', 'Check whether the field is default package-private.', 'Check whether the field is static.', 'Check whether the field is volatile.', 'Check whether the field is transient.', 'Get the type of field.', 'Check whether the field is string type.', 'Check whether the field is boolean type.', 'Check whether the field is char type.', 'Check whether the field is byte type.', 'Check whether the field is short type.', 'Check whether the field is int type.', 'Check whether the field is long type.', 'Check whether the field is float type.', 'Check whether the field is double type.', 'Check whether the field is boxed type.', 'Check whether the field is x class type.', 'Check whether the field is array type.', 'Check whether the field is enum type.', 'Check whether the field is record type.', 'Check whether field has declared annotations.', 'Get a declared annotation of field.', 'Check whether the field has x annotation.', 'Check whether the field is initialized.', 'Check whether the field is initialized to literal value.', 'Check whether the field is initialized to variable value.', 'Get the literal value that the field is initialized to.', 'Get an access of field.', 'Check whether the accessed variable is a field.', 'Check whether the accessed variable is final.', 'Check whether the accessed variable is being written.', 'Check whether the accessed variable is static.', 'Get the name of class.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is interface.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get the number of formal parameters of constructor.', 'Check whether the class has any methods.', 'Check whether any method is abstract.', 'Get the name of class.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is interface.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get the number of formal parameters of constructor.', 'Check whether the class has any methods.', 'Check whether any method is abstract.', 'Get the name of class.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is interface.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get the number of formal parameters of constructor.', 'Check whether the class has any methods.', 'Check whether any method is abstract.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.987838864326477
*Check whether the class has x annotation.* 匹配到的元操作或API：
logic: Check whether the class has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9908236265182495
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844120740890503
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a implemented interface of class.* 匹配到的元操作或API：
logic: Get a implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9851537942886353
*Check whether the class has implemented x interface.* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9905824661254883
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is interface.* 匹配到的元操作或API：
logic: Check whether the class is interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9844173789024353
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.987544596195221
*Check whether the class is anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9849605560302734
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the number of formal parameters of constructor.* 匹配到的元操作或API：
logic: Get the number of formal parameters of constructor.
most similar meta operation: Get the number of formal parameters of constructor
cosine Similarity: 0.9865633845329285
*Get a formal parameter of constructor.* 匹配到的元操作或API：
logic: Get a formal parameter of constructor.
most similar meta operation: Get a formal parameter of constructor
cosine Similarity: 0.98207688331604
*Check whether formal parameter has declared annotations.* 匹配到的元操作或API：
logic: Check whether formal parameter has declared annotations.
most similar meta operation: Check whether formal parameter has declared annotations
cosine Similarity: 0.9899719953536987
*Get a declared annotation of formal parameter.* 匹配到的元操作或API：
logic: Get a declared annotation of formal parameter.
most similar meta operation: Get a declared annotation of formal parameter
cosine Similarity: 0.9871978759765625
*Check whether the formal parameter has x annotation.* 匹配到的元操作或API：
logic: Check whether the formal parameter has x annotation.
most similar meta operation: Check whether the formal parameter has x annotation
cosine Similarity: 0.9898931980133057
*Check whether the formal parameter is final.* 匹配到的元操作或API：
logic: Check whether the formal parameter is final.
most similar meta operation: Check whether the formal parameter is final
cosine Similarity: 0.9881319403648376
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Check whether the constructor is default package-private.* 匹配到的元操作或API：
logic: Check whether the constructor is default package-private.
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.9616611003875732
*Check whether the constructor is protected.* 匹配到的元操作或API：
logic: Check whether the constructor is protected.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9850410223007202
*Get an access of field.* 匹配到的元操作或API：
logic: Get an access of field.
most similar meta operation: Get an access of field
cosine Similarity: 0.9836357831954956
*Check whether the field is final.* 匹配到的元操作或API：
logic: Check whether the field is final.
most similar meta operation: Check whether the field is final
cosine Similarity: 0.9875956177711487
*Check whether the field is private.* 匹配到的元操作或API：
logic: Check whether the field is private.
most similar meta operation: Check whether the field is private
cosine Similarity: 0.9845259785652161
*Check whether the field is public.* 匹配到的元操作或API：
logic: Check whether the field is public.
most similar meta operation: Check whether the field is public
cosine Similarity: 0.9851202964782715
*Check whether the field is protected.* 匹配到的元操作或API：
logic: Check whether the field is protected.
most similar meta operation: Check whether the field is protected
cosine Similarity: 0.9839198589324951
*Check whether the field is default package-private.* 匹配到的元操作或API：
logic: Check whether the field is default package-private.
most similar meta operation: Check whether the field is default package-private
cosine Similarity: 0.9663878083229065
*Check whether the field is static.* 匹配到的元操作或API：
logic: Check whether the field is static.
most similar meta operation: Check whether the field is static
cosine Similarity: 0.9852341413497925
*Check whether the field is volatile.* 匹配到的元操作或API：
logic: Check whether the field is volatile.
most similar meta operation: Check whether the field is volatile
cosine Similarity: 0.9884835481643677
*Check whether the field is transient.* 匹配到的元操作或API：
logic: Check whether the field is transient.
most similar meta operation: Check whether the field is transient
cosine Similarity: 0.9895565509796143
*Get the type of field.* 匹配到的元操作或API：
logic: Get the type of field.
most similar meta operation: Get the type of field
cosine Similarity: 0.9832500219345093
*Check whether the field is string type.* 匹配到的元操作或API：
logic: Check whether the field is string type.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.988373875617981
*Check whether the field is boolean type.* 匹配到的元操作或API：
logic: Check whether the field is boolean type.
most similar meta operation: Check whether the field is boolean type
cosine Similarity: 0.9866046905517578
*Check whether the field is char type.* 匹配到的元操作或API：
logic: Check whether the field is char type.
most similar meta operation: Check whether the field is char type
cosine Similarity: 0.989357590675354
*Check whether the field is byte type.* 匹配到的元操作或API：
logic: Check whether the field is byte type.
most similar meta operation: Check whether the field is byte type
cosine Similarity: 0.9907138347625732
*Check whether the field is short type.* 匹配到的元操作或API：
logic: Check whether the field is short type.
most similar meta operation: Check whether the field is short type
cosine Similarity: 0.9883869886398315
*Check whether the field is int type.* 匹配到的元操作或API：
logic: Check whether the field is int type.
most similar meta operation: Check whether the field is int type
cosine Similarity: 0.9881454706192017
*Check whether the field is long type.* 匹配到的元操作或API：
logic: Check whether the field is long type.
most similar meta operation: Check whether the field is long type
cosine Similarity: 0.9879834055900574
*Check whether the field is float type.* 匹配到的元操作或API：
logic: Check whether the field is float type.
most similar meta operation: Check whether the field is float type
cosine Similarity: 0.9873677492141724
*Check whether the field is double type.* 匹配到的元操作或API：
logic: Check whether the field is double type.
most similar meta operation: Check whether the field is double type
cosine Similarity: 0.9888980388641357
*Check whether the field is boxed type.* 匹配到的元操作或API：
logic: Check whether the field is boxed type.
most similar meta operation: Check whether the field is boxed primitive type
cosine Similarity: 0.9384516477584839
*Check whether the field is x class type.* 匹配到的元操作或API：
logic: Check whether the field is x class type.
most similar meta operation: Check whether the field is a x class type
cosine Similarity: 0.9860230088233948
*Check whether the field is array type.* 匹配到的元操作或API：
logic: Check whether the field is array type.
most similar meta operation: Check whether the field is array type
cosine Similarity: 0.9860299825668335
*Check whether the field is enum type.* 匹配到的元操作或API：
logic: Check whether the field is enum type.
most similar meta operation: Check whether the field is enum type
cosine Similarity: 0.9872546195983887
*Check whether the field is record type.* 匹配到的元操作或API：
logic: Check whether the field is record type.
most similar meta operation: Check whether the field is record type
cosine Similarity: 0.9888904690742493
*Check whether field has declared annotations.* 匹配到的元操作或API：
logic: Check whether field has declared annotations.
most similar meta operation: Check whether field has declared annotations
cosine Similarity: 0.9904201030731201
*Get a declared annotation of field.* 匹配到的元操作或API：
logic: Get a declared annotation of field.
most similar meta operation: Get a declared annotation of field
cosine Similarity: 0.9871520400047302
*Check whether the field has x annotation.* 匹配到的元操作或API：
logic: Check whether the field has x annotation.
most similar meta operation: Check whether the field has x annotation
cosine Similarity: 0.9902318716049194
*Check whether the field is initialized.* 匹配到的元操作或API：
logic: Check whether the field is initialized.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.9865798950195312
*Check whether the field is initialized to literal value.* 匹配到的元操作或API：
logic: Check whether the field is initialized to literal value.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.9092312455177307
*Check whether the field is initialized to variable value.* 匹配到的元操作或API：
logic: Check whether the field is initialized to variable value.
most similar meta operation: Check whether the field is initialized to variable value
cosine Similarity: 0.9891040325164795
*Get the literal value that the field is initialized to.* 匹配到的元操作或API：
logic: Get the literal value that the field is initialized to.
most similar meta operation: Get the literal value that the field is initialized to
cosine Similarity: 0.9854511022567749
*Get an access of field.* 匹配到的元操作或API：
logic: Get an access of field.
most similar meta operation: Get an access of field
cosine Similarity: 0.9836357831954956
*Check whether the accessed variable is a field.* 匹配到的元操作或API：
logic: Check whether the accessed variable is a field.
most similar meta operation: Check whether the accessed variable is a field
cosine Similarity: 0.9899091124534607
*Check whether the accessed variable is final.* 匹配到的元操作或API：
logic: Check whether the accessed variable is final.
most similar meta operation: Check whether the accessed variable is final
cosine Similarity: 0.9882043600082397
*Check whether the accessed variable is being written.* 匹配到的元操作或API：
logic: Check whether the accessed variable is being written.
most similar meta operation: Check whether the accessed variable is being written
cosine Similarity: 0.9890588521957397
*Check whether the accessed variable is static.* 匹配到的元操作或API：
logic: Check whether the accessed variable is static.
most similar meta operation: Check whether the accessed variable is static
cosine Similarity: 0.9874663352966309
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is interface.* 匹配到的元操作或API：
logic: Check whether the class is interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9844173789024353
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the number of formal parameters of constructor.* 匹配到的元操作或API：
logic: Get the number of formal parameters of constructor.
most similar meta operation: Get the number of formal parameters of constructor
cosine Similarity: 0.9865633845329285
*Check whether the class has any methods.* 匹配到的元操作或API：
query: Check whether the class has any methods.
most similar API: Check whether is test method
cosine Similarity: 0.8300475478172302
*Check whether any method is abstract.* 匹配到的元操作或API：
logic: Check whether any method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9592255353927612
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is interface.* 匹配到的元操作或API：
logic: Check whether the class is interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9844173789024353
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the number of formal parameters of constructor.* 匹配到的元操作或API：
logic: Get the number of formal parameters of constructor.
most similar meta operation: Get the number of formal parameters of constructor
cosine Similarity: 0.9865633845329285
*Check whether the class has any methods.* 匹配到的元操作或API：
query: Check whether the class has any methods.
most similar API: Check whether is test method
cosine Similarity: 0.8300475478172302
*Check whether any method is abstract.* 匹配到的元操作或API：
logic: Check whether any method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9592255353927612
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is interface.* 匹配到的元操作或API：
logic: Check whether the class is interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9844173789024353
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the number of formal parameters of constructor.* 匹配到的元操作或API：
logic: Get the number of formal parameters of constructor.
most similar meta operation: Get the number of formal parameters of constructor
cosine Similarity: 0.9865633845329285
*Check whether the class has any methods.* 匹配到的元操作或API：
query: Check whether the class has any methods.
most similar API: Check whether is test method
cosine Similarity: 0.8300475478172302
*Check whether any method is abstract.* 匹配到的元操作或API：
logic: Check whether any method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9592255353927612
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Simple violation
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isProtected()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
11. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
12. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
13. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getSuperInterfaceTypeNodes()
14. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
15. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()
16. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
17. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnonymous()
18. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
19. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
20. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTFormalParameters getFormalParameters()
21. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
22. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public boolean isAnyAnnotationPresent(java.util.Collection)
23. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public boolean isFinal()
24. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()
25. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPackagePrivate()
26. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isProtected()
27. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isFinal()
28. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isPrivate()
29. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isPublic()
30. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isProtected()
31. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isPackagePrivate()
32. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isStatic()
33. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isVolatile()
34. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isTransient()
35. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
36. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
37. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
38. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
39. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```
3.  //Check whether the class has implemented x interface
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node) {
    if (TypeTestUtil.isA(interfaceName.class, node)) {
        return true;
    }
    return false;
}
```
4.  //Get the number of formal parameters of constructor
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTConstructorDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```
5.  //Check whether formal parameter has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotation(ASTFormalParameter node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```
6.  //Get an access of field
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr;
import java.util.List;
public List<ASTAssignableExpr.ASTNamedReferenceExpr> getAUsage(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId var : varIds){
        if(var.getName().equals("x")){
            List<ASTAssignableExpr.ASTNamedReferenceExpr> localUsages = var.getLocalUsages();
            return localUsages;
        }
    }
    return null;
}
```
7.  //Check whether the field is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFieldStringType(ASTFieldDeclaration node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```
8.  //Check whether the field is boolean type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFieldBooleanType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN);
}
```
9.  //Check whether the field is char type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFieldCharType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.CHAR);
}
```
10.  //Check whether the field is byte type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFieldByteType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
}
```
11.  //Check whether the field is short type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFieldShortType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.SHORT);
}
```
12.  //Check whether the field is int type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFieldIntType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.INT);
}
```
13.  //Check whether the field is long type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFieldLongType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.LONG);
}
```
14.  //Check whether the field is float type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFieldFloatType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.FLOAT);
}
```
15.  //Check whether the field is double type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFieldDoubleType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.DOUBLE);
}
```
16.  //Check whether the field is boxed primitive type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public boolean isFieldBoxedPrimitiveType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isBoxedPrimitive();
}
```
17.  //Check whether the field is a x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFieldClassType(ASTFieldDeclaration node) {
    return TypeTestUtil.isA(x.class, node.getTypeNode());
}
```
18.  //Check whether the field is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isFieldArrayType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```
19.  //Check whether the field is enum type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isFieldEnumType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) type.getTypeMirror().getSymbol()).isEnum();
}
```
20.  //Check whether the field is record type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isFieldRecordType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) type.getTypeMirror().getSymbol()).isRecord();
}
```
21.  //Check whether field has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTFieldDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```
22.  //Check whether the field is initialized
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean isInitialized(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                return true;
            }
        }
    }
    return false;
}
```
23.  //Check whether the field is initialized to variable value
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean isInitializedToVariableValue(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
    }
    return false;
}
```
24.  //Get the literal value that the field is initialized to
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTLiteral;
import net.sourceforge.pmd.lang.ast.NodeStream;
public ASTLiteral getInitializedValue(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTLiteral) {
                    return (ASTLiteral)init;
                }
            }
        }
    }
    return null;
}
```
25.  //Check whether the accessed variable is a field
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;
public boolean isVariableAccessField(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JFieldSymbol) {
        JFieldSymbol fieldSym = (JFieldSymbol) sym;
        return true;
    }
    return false;
}
```
26.  //Check whether the accessed variable is final
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
public boolean isVariableAccessFinal(ASTVariableAccess var){
    JVariableSymbol symbol = var.getReferencedSym();
    if (symbol == null) {
        return false;
    }
    if (var.getReferencedSym().isFinal()) {
        return true;
    }
    return false;
}
```
27.  //Check whether the accessed variable is being written
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr;
public boolean variableIsBeingRead(ASTVariableAccess var) {
    if(var.getAccessType() == ASTAssignableExpr.AccessType.WRITE){
        return true;
    }
    return false;
}
```
28.  //Check whether the accessed variable is static
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.ast.JModifier;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
public boolean isVariableAccessStatic(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym.tryGetNode().hasModifiers(JModifier.STATIC)) {
        return true;
    }
    return false;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {

    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isPublic() && !node.isFinal() && !node.isInterface()) {
            NodeStream<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class);
            if (constructors.allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Check whether class has declared annotations
    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }

    // Check whether the class has extended x class
    public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node) {
        ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
        return TypeTestUtil.isA(x.class, classOrInterfaceType);
    }

    // Check whether the class has implemented x interface
    public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node) {
        if (TypeTestUtil.isA(interfaceName.class, node)) {
            return true;
        }
        return false;
    }

    // Get the number of formal parameters of constructor
    public int getFormalParametersNumber(ASTConstructorDeclaration node) {
        ASTFormalParameters formalParameters = node.getFormalParameters();
        return formalParameters.size();
    }

    // Check whether formal parameter has declared annotations
    public boolean hasAnnotation(ASTFormalParameter node) {
        NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
        return declaredAnnotations.nonEmpty();
    }

    // Get an access of field
    public List<ASTVariableDeclaratorId.ASTNamedReferenceExpr> getAUsage(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId var : varIds) {
            if (var.getName().equals("x")) {
                List<ASTVariableDeclaratorId.ASTNamedReferenceExpr> localUsages = var.getLocalUsages();
                return localUsages;
            }
        }
        return null;
    }

    // Check whether the field is string type
    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    // Check whether the field is boolean type
    public boolean isFieldBooleanType(ASTFieldDeclaration node) {
        ASTType type = node.getTypeNode();
        JTypeMirror t = type.getTypeMirror();
        return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN);
    }

    // Check whether the field is char type
    public boolean isFieldCharType(ASTFieldDeclaration node) {
        ASTType type = node.getTypeNode();
        JTypeMirror t = type.getTypeMirror();
        return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.CHAR);
    }

    // Check whether the field is byte type
    public boolean isFieldByteType(ASTFieldDeclaration node) {
        ASTType type = node.getTypeNode();
        JTypeMirror t = type.getTypeMirror();
        return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
    }

    // Check whether the field is short type
    public boolean isFieldShortType(ASTFieldDeclaration node) {
        ASTType type = node.getTypeNode();
        JTypeMirror t = type.getTypeMirror();
        return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.SHORT);
    }

    // Check whether the field is int type
    public boolean isFieldIntType(ASTFieldDeclaration node) {
        ASTType type = node.getTypeNode();
        JTypeMirror t = type.getTypeMirror();
        return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.INT);
    }

    // Check whether the field is long type
    public boolean isFieldLongType(ASTFieldDeclaration node) {
        ASTType type = node.getTypeNode();
        JTypeMirror t = type.getTypeMirror();
        return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.LONG);
    }

    // Check whether the field is float type
    public boolean isFieldFloatType(ASTFieldDeclaration node) {
        ASTType type = node.getTypeNode();
        JTypeMirror t = type.getTypeMirror();
        return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.FLOAT);
    }

    // Check whether the field is double type
    public boolean isFieldDoubleType(ASTFieldDeclaration node) {
        ASTType type = node.getTypeNode();
        JTypeMirror t = type.getTypeMirror();
        return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.DOUBLE);
    }

    // Check whether the field is boxed primitive type
    public boolean isFieldBoxedPrimitiveType(ASTFieldDeclaration node) {
        ASTType type = node.getTypeNode();
        JTypeMirror t = type.getTypeMirror();
        return t.isBoxedPrimitive();
    }

    // Check whether the field is a x class type
    public boolean isFieldClassType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(x.class, node.getTypeNode());
    }

    // Check whether the field is array type
    public boolean isFieldArrayType(ASTFieldDeclaration node) {
        ASTType type = node.getTypeNode();
        return type.getTypeMirror().isArray();
    }

    // Check whether the field is enum type
    public boolean isFieldEnumType(ASTFieldDeclaration node) {
        ASTType type = node.getTypeNode();
        return type.getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) type.getTypeMirror().getSymbol()).isEnum();
    }

    // Check whether the field is record type
    public boolean isFieldRecordType(ASTFieldDeclaration node) {
        ASTType type = node.getTypeNode();
        return type.getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) type.getTypeMirror().getSymbol()).isRecord();
    }

    // Check whether field has declared annotations
    public boolean hasAnnotation(ASTFieldDeclaration node) {
        NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
        return declaredAnnotations.nonEmpty();
    }

    // Check whether the field is initialized
    public boolean isInitialized(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    return true;
                }
            }
        }
        return false;
    }

    // Check whether the field is initialized to variable value
    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    // Get the literal value that the field is initialized to
    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    // Check whether the accessed variable is a field
    public boolean isVariableAccessField(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym instanceof JFieldSymbol) {
            JFieldSymbol fieldSym = (JFieldSymbol) sym;
            return true;
        }
        return false;
    }

    // Check whether the accessed variable is final
    public boolean isVariableAccessFinal(ASTVariableAccess var) {
        JVariableSymbol symbol = var.getReferencedSym();
        if (symbol == null) {
            return false;
        }
        if (var.getReferencedSym().isFinal()) {
            return true;
        }
        return false;
    }

    // Check whether the accessed variable is being written
    public boolean variableIsBeingRead(ASTVariableAccess var) {
        if (var.getAccessType() == ASTAssignableExpr.AccessType.READ) {
            return true;
        }
        return false;
    }

    // Check whether the accessed variable is static
    public boolean isVariableAccessStatic(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym.tryGetNode().hasModifiers(JModifier.STATIC)) {
            return true;
        }
        return false;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether class is public.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. If the class is public and all its constructors are private, then this class may be made final because it cannot be extended from outside its compilation unit.

In this test case:
1. The name of the class is Foo.
2. Check whether the class is public: The class Foo is public.
3. Get all constructors declared in class: There is one constructor declared in the class.
4. Check whether the constructor is private: The constructor is private.
5. Since the class is public and all its constructors are private, this class may be made final because it cannot be extended from outside its compilation unit. This matches the description of the violation, and the number of violations is 1.
['Get the name of class.', 'Check whether class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'If the class is public and all its constructors are private, then this class may be made final because it cannot be extended from outside its compilation unit.', 'The name of the class is Foo.', 'Check whether the class is public: The class Foo is public.', 'Get all constructors declared in class: There is one constructor declared in the class.', 'Check whether the constructor is private: The constructor is private.', 'Since the class is public and all its constructors are private, this class may be made final because it cannot be extended from outside its compilation unit. This matches the description of the violation, and the number of violations is 1.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether class is public.* 匹配到的元操作或API：
logic: Check whether class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9831418991088867
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*If the class is public and all its constructors are private, then this class may be made final because it cannot be extended from outside its compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
*The name of the class is Foo.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is public: The class Foo is public.* 匹配到的元操作或API：
logic: Check whether the class is public: The class Foo is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.926762580871582
*Get all constructors declared in class: There is one constructor declared in the class.* 匹配到的元操作或API：
query: Get all constructors declared in class: There is one constructor declared in the class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8050557374954224
*Check whether the constructor is private: The constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private: The constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9676811099052429
*Since the class is public and all its constructors are private, this class may be made final because it cannot be extended from outside its compilation unit. This matches the description of the violation, and the number of violations is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Simple violation
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isPublic() && !node.hasDescendant(ASTConstructorDeclaration.class)) {
            addViolation(data, node);
        } else if (node.isPublic()) {
            boolean hasPublicConstructor = false;
            boolean hasPrivateConstructor = false;
            for (ASTConstructorDeclaration constructor : node.getChildren(ASTConstructorDeclaration.class)) {
                if (constructor.isPrivate()) {
                    hasPrivateConstructor = true;
                } else {
                    hasPublicConstructor = true;
                }
            }
            if (hasPrivateConstructor && !hasPublicConstructor && !node.isFinal()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class is public.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Count the number of private constructors.
6. Check whether the number of private constructors is equal to the total number of constructors.

If the class is public and all its constructors are private, then it violates the rule.
Based on the provided test case:

1. Get the name of class: Foo
2. Check whether the class is public: True
3. Get all constructors declared in class: private Foo()
4. Check whether the constructor is private: True
5. Count the number of private constructors: 1
6. Check whether the number of private constructors is equal to the total number of constructors: True

The test case violates the rule.
['Get the name of class.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Count the number of private constructors.', 'Check whether the number of private constructors is equal to the total number of constructors.', 'Get the name of class: Foo', 'Check whether the class is public: True', 'Get all constructors declared in class: private Foo()', 'Check whether the constructor is private: True', 'Count the number of private constructors: 1', 'Check whether the number of private constructors is equal to the total number of constructors: True']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Count the number of private constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the number of private constructors is equal to the total number of constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: Foo* 匹配到的元操作或API：
logic: Get the name of class: Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9263077974319458
*Check whether the class is public: True* 匹配到的元操作或API：
logic: Check whether the class is public: True
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9707064628601074
*Get all constructors declared in class: private Foo()* 匹配到的元操作或API：
query: Get all constructors declared in class: private Foo()
most similar API: get declared annotations of constructor
cosine Similarity: 0.8338075280189514
*Check whether the constructor is private: True* 匹配到的元操作或API：
logic: Check whether the constructor is private: True
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9794564843177795
*Count the number of private constructors: 1* 匹配到的元操作或API：
query: Count the number of private constructors: 1
most similar API: Check whether the constructor is private
cosine Similarity: 0.8034011125564575
*Check whether the number of private constructors is equal to the total number of constructors: True* 匹配到的元操作或API：
query: Check whether the number of private constructors is equal to the total number of constructors: True
most similar API: Check whether the constructor equals
cosine Similarity: 0.8075838088989258
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Simple violation
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean equals(java.lang.Object)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isPublic() && !node.isInterfaceDeclaration()) {
            NodeStream<ASTConstructorDeclaration> constructors = node.children(ASTConstructorDeclaration.class);
            if (!constructors.isEmpty() && constructors.allMatch(ASTConstructorDeclaration::isPrivate)) {
                if (!node.hasModifier(ASTModifier.ModifierType.FINAL)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Check whether the class is public.
        2. Get all constructors declared in class.
        3. Check whether the constructor is private.
        If the class is public and all its constructors are private, then this test case violates the rule.
        
Let's perform these checks:

1. Check whether the class is public.
   - The class `Foo` is public.
   
2. Get all constructors declared in class.
   - The class `Foo` has one constructor: `private Foo() {}`.
   
3. Check whether the constructor is private.
   - The constructor `Foo()` is private.
   
Since the class `Foo` is public and its constructor is private, it cannot be extended from outside its compilation unit, and thus it should be made final. This test case violates the rule.
['Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Simple violation
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isPublic() && node.getConstructors().allMatch(ASTConstructorDeclaration::isPrivate)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 1
1117
839
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
        2. Check whether the class is abstract.
        3. Get all constructors declared in class.
        4. Check whether the constructor is private.
        5. Check whether the class has any public or protected constructors.
        If the class is not abstract and all constructors are private, then this test case adheres to the rule, not violates it. However, based on the description provided, if the class is abstract and all constructors are private, it should be reported as a violation. Therefore, the test case violates the rule because it is an abstract class with a private constructor and no other constructors, which means it cannot be extended outside its compilation unit.

Given the description of the test case ("bad 2") and the number of violations (1), it seems like the test case is meant to be a violation. Thus, the correct interpretation and checks are:

1. Get the name of class.
        2. Check whether the class is abstract.
        3. Get all constructors declared in class.
        4. Check whether the constructor is private.
        5. Check whether the class has any public or protected constructors.
        Since the class is abstract and all constructors are private, this test case violates the rule.
['Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has any public or protected constructors.', 'Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has any public or protected constructors.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has any public or protected constructors.* 匹配到的元操作或API：
logic: Check whether the class has any public or protected constructors.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.8995596766471863
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has any public or protected constructors.* 匹配到的元操作或API：
logic: Check whether the class has any public or protected constructors.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.8995596766471863
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// violation for abstract class
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isProtected()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isAbstract()) {
            return data;
        }

        NodeStream<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class);

        if (constructors.noneMatch(ASTConstructorDeclaration::isPrivate)) {
            return data;
        }

        if (constructors.anyMatch(c -> c.isProtected() || !c.isPrivate())) {
            return data;
        }

        if (!node.isFinal()) {
            addViolation(data, node);
        }

        return data;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class is an interface.
3. Check whether the class is final.
4. Get all constructors declared in class.
5. Check whether the constructor is private.
6. If the class is not an interface, is not final, and all its constructors are private, then the class violates the rule.
7. Check whether the class is abstract.
8. If the class is abstract and has a private constructor, it should not be reported as a violation according to the rule description provided.

In this test case:
7. Check whether the class is abstract.
    - The class `Foo` is not abstract, so it should be reported as a violation based on the provided rule description.

However, the description explicitly states that the test case is a "violation for abstract class" which seems to contradict the rule description. Assuming the rule description is correct, the test case should not be a violation. If the test case is meant to be a violation, then the rule description might need to be adjusted to include abstract classes with private constructors.

To align with the provided test case description:
7. Check whether the class is abstract.
    - The class `Foo` is not abstract, but the test case description indicates it should be considered a violation. This discrepancy needs clarification.

If we want to follow the test case description as is:
1. Get the name of class.
2. Check whether the class is an interface.
3. Check whether the class is final.
4. Get all constructors declared in class.
5. Check whether the constructor is private.
6. Check whether the class is abstract.
    - Since the test case description indicates a violation for an abstract class, we should report it as a violation if it were abstract and had a private constructor.

Given the current test case:
1. Get the name of class.
    - Class name is `Foo`.
2. Check whether the class is an interface.
    - `Foo` is not an interface.
3. Check whether the class is final.
    - `Foo` is not final.
4. Get all constructors declared in class.
    - There is one constructor declared in `Foo`.
5. Check whether the constructor is private.
    - The constructor is private.
6. Check whether the class is abstract.
    - `Foo` is not abstract, so it should not be a violation according to the rule description.

Based on the rule description, this test case does not violate the rule as `Foo` is not abstract. If the test case is meant to be a violation, the rule description should be adjusted to include abstract classes with private constructors.
['Get the name of class.', 'Check whether the class is an interface.', 'Check whether the class is final.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'If the class is not an interface, is not final, and all its constructors are private, then the class violates the rule.', 'Check whether the class is abstract.', 'If the class is abstract and has a private constructor, it should not be reported as a violation according to the rule description provided.', 'Check whether the class is abstract.', 'Check whether the class is abstract.', 'Get the name of class.', 'Check whether the class is an interface.', 'Check whether the class is final.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is abstract.', 'Get the name of class.', 'Check whether the class is an interface.', 'Check whether the class is final.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is abstract.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is an interface.* 匹配到的元操作或API：
logic: Check whether the class is an interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9778784513473511
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*If the class is not an interface, is not final, and all its constructors are private, then the class violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*If the class is abstract and has a private constructor, it should not be reported as a violation according to the rule description provided.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is an interface.* 匹配到的元操作或API：
logic: Check whether the class is an interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9778784513473511
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is an interface.* 匹配到的元操作或API：
logic: Check whether the class is an interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9778784513473511
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// violation for abstract class
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal() && !node.isAbstract()) {
            boolean hasOnlyPrivateConstructors = node.findDescendantsOfType(ASTConstructorDeclaration.class)
                    .allMatch(ASTConstructorDeclaration::isPrivate);

            if (hasOnlyPrivateConstructors) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class is abstract.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Count the number of private constructors.

To ascertain adherence to the rule:

1. Get the name of class.
   - The class name is Foo.

2. Check whether the class is abstract.
   - The class is abstract. (Note: Based on the provided test case, this should be false as the class is declared as `public class Foo` without the `abstract` keyword.)

3. Get all constructors declared in class.
   - The constructor declared in class Foo is `private Foo() { }`.

4. Check whether the constructor is private.
   - The constructor is private.

5. Count the number of private constructors.
   - There is 1 private constructor.

Given the rule description and the test case, the class `Foo` should not be abstract for it to violate the rule. However, if the test case were to be:

```java
public class Foo {
    private Foo() { }
}
```

Then the checks would be:

1. Get the name of class.
   - The class name is Foo.

2. Check whether the class is abstract.
   - The class is not abstract.

3. Get all constructors declared in class.
   - The constructor declared in class Foo is `private Foo() { }`.

4. Check whether the constructor is private.
   - The constructor is private.

5. Count the number of private constructors.
   - There is 1 private constructor.

Since the class is not abstract and has a private constructor, it violates the rule as it cannot be extended from outside its compilation unit.
['Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Count the number of private constructors.', 'Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Count the number of private constructors.', 'Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Count the number of private constructors.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Count the number of private constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Count the number of private constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Count the number of private constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// violation for abstract class
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public void apply(NodeStream<? extends ASTClassOrInterfaceDeclaration> nodes, Object ctx) {
        nodes.forEach(node -> {
            if (!node.isAbstract()) {
                boolean hasOnlyPrivateConstructors = node.getDeclaredConstructors()
                                                        .allMatch(ASTConstructorDeclaration::isPrivate);

                if (hasOnlyPrivateConstructors && !node.isFinal()) {
                    addViolation(ctx, node);
                }
            }
        });
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
To ascertain the adherence of the provided test case to the rule, let's perform granular checks step-by-step:

1. Check whether the class is abstract.
2. Check whether the class has declared annotations.
3. Get the name of the class.
4. Get the constructors of the class.
5. Check whether the constructor is private.
6. Check whether the constructor is public.
7. Check whether the constructor is default package-private.
8. Check whether the constructor is protected.

Given the test case:
```java
public class Foo {
    private Foo() { }
}
```

Let's perform the checks:

1. Check whether the class is abstract.
   - The class `Foo` is not declared as abstract.

2. Check whether the class has declared annotations.
   - The class `Foo` does not have any declared annotations.

3. Get the name of the class.
   - The name of the class is `Foo`.

4. Get the constructors of the class.
   - The class `Foo` has one constructor.

5. Check whether the constructor is private.
   - The constructor is private.

6. Check whether the constructor is public.
   - The constructor is not public.

7. Check whether the constructor is default package-private.
   - The constructor is not default package-private.

8. Check whether the constructor is protected.
   - The constructor is not protected.

Since the class is not abstract and it has a private constructor, it cannot be extended from outside its compilation unit. However, the provided rule description specifically mentions abstract classes as a violation scenario, but the test case provided is not abstract. Therefore, the test case does not violate the rule as described.

If the intention is to report classes that are abstract and have private constructors (which cannot be extended from outside anyway), the test case should indeed be a violation. Let's adjust the test case to make it abstract:

```java
// violation for abstract class
public abstract class Foo {
    private Foo() { }
}
```

Now, let's perform the checks again:

1. Check whether the class is abstract.
   - The class `Foo` is declared as abstract.

2. Check whether the class has declared annotations.
   - The class `Foo` does not have any declared annotations.

3. Get the name of the class.
   - The name of the class is `Foo`.

4. Get the constructors of the class.
   - The class `Foo` has one constructor.

5. Check whether the constructor is private.
   - The constructor is private.

6. Check whether the constructor is public.
   - The constructor is not public.

7. Check whether the constructor is default package-private.
   - The constructor is not default package-private.

8. Check whether the constructor is protected.
   - The constructor is not protected.

Given these checks, the test case now violates the rule because it is an abstract class with a private constructor.
['Check whether the class is abstract.', 'Check whether the class has declared annotations.', 'Get the name of the class.', 'Get the constructors of the class.', 'Check whether the constructor is private.', 'Check whether the constructor is public.', 'Check whether the constructor is default package-private.', 'Check whether the constructor is protected.', 'Check whether the class is abstract.', 'Check whether the class has declared annotations.', 'Get the name of the class.', 'Get the constructors of the class.', 'Check whether the constructor is private.', 'Check whether the constructor is public.', 'Check whether the constructor is default package-private.', 'Check whether the constructor is protected.', 'Check whether the class is abstract.', 'Check whether the class has declared annotations.', 'Get the name of the class.', 'Get the constructors of the class.', 'Check whether the constructor is private.', 'Check whether the constructor is public.', 'Check whether the constructor is default package-private.', 'Check whether the constructor is protected.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the name of the class.* 匹配到的元操作或API：
logic: Get the name of the class.
most similar meta operation: Get the name of class
cosine Similarity: 0.968898594379425
*Get the constructors of the class.* 匹配到的元操作或API：
query: Get the constructors of the class.
most similar API: get parents of type of constructor
cosine Similarity: 0.824925422668457
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Check whether the constructor is default package-private.* 匹配到的元操作或API：
logic: Check whether the constructor is default package-private.
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.9616611003875732
*Check whether the constructor is protected.* 匹配到的元操作或API：
logic: Check whether the constructor is protected.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9850410223007202
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the name of the class.* 匹配到的元操作或API：
logic: Get the name of the class.
most similar meta operation: Get the name of class
cosine Similarity: 0.968898594379425
*Get the constructors of the class.* 匹配到的元操作或API：
query: Get the constructors of the class.
most similar API: get parents of type of constructor
cosine Similarity: 0.824925422668457
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Check whether the constructor is default package-private.* 匹配到的元操作或API：
logic: Check whether the constructor is default package-private.
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.9616611003875732
*Check whether the constructor is protected.* 匹配到的元操作或API：
logic: Check whether the constructor is protected.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9850410223007202
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the name of the class.* 匹配到的元操作或API：
logic: Get the name of the class.
most similar meta operation: Get the name of class
cosine Similarity: 0.968898594379425
*Get the constructors of the class.* 匹配到的元操作或API：
query: Get the constructors of the class.
most similar API: get parents of type of constructor
cosine Similarity: 0.824925422668457
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Check whether the constructor is default package-private.* 匹配到的元操作或API：
logic: Check whether the constructor is default package-private.
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.9616611003875732
*Check whether the constructor is protected.* 匹配到的元操作或API：
logic: Check whether the constructor is protected.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9850410223007202
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// violation for abstract class
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.util.List<List<T> getParentsOfType(java.lang.Class)
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPackagePrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isProtected()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isAbstract()) {
            return data;
        }

        boolean hasOnlyPrivateConstructors = node.children(ASTConstructorDeclaration.class).allMatch(ASTConstructorDeclaration::isPrivate);
        boolean hasPublicOrProtectedConstructors = node.children(ASTConstructorDeclaration.class).anyMatch(ASTConstructorDeclaration::isPublic) || node.children(ASTConstructorDeclaration.class).anyMatch(ASTConstructorDeclaration::isProtected);

        if (hasOnlyPrivateConstructors && !hasPublicOrProtectedConstructors && !node.isFinal()) {
            addViolation(data, node);
        }

        return data;
    }

    // Check whether class has declared annotations
    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class is abstract.
3. Check whether the class has declared constructors.
4. Get the declared constructors of class.
5. Get the number of declared constructors of class.
6. Get a constructor of class.
7. Check whether the constructor is private.
8. Check whether the class is public.
9. Check whether the class is package-private (neither public nor private).

To ascertain adherence to the rule:

1. Get the name of class.
        - Result: `Foo`
2. Check whether the class is abstract.
        - Result: `False`
3. Check whether the class has declared constructors.
        - Result: `True`
4. Get the declared constructors of class.
        - Result: `private Foo()`
5. Get the number of declared constructors of class.
        - Result: `1`
6. Get a constructor of class.
        - Result: `private Foo()`
7. Check whether the constructor is private.
        - Result: `True`
8. Check whether the class is public.
        - Result: `True`
9. Check whether the class is package-private (neither public nor private).
        - Result: `False`

Since the class `Foo` is public and has a private constructor, it may be made final because it cannot be extended from outside its compilation unit. However, the rule specifically mentions that abstract classes should be ignored. Since this class is not abstract, it violates the rule. Therefore, the number of violations in this test case is 1.
['Get the name of class.', 'Check whether the class is abstract.', 'Check whether the class has declared constructors.', 'Get the declared constructors of class.', 'Get the number of declared constructors of class.', 'Get a constructor of class.', 'Check whether the constructor is private.', 'Check whether the class is public.', 'Check whether the class is package-private (neither public nor private).', 'Get the name of class.', 'Check whether the class is abstract.', 'Check whether the class has declared constructors.', 'Get the declared constructors of class.', 'Get the number of declared constructors of class.', 'Get a constructor of class.', 'Check whether the constructor is private.', 'Check whether the class is public.', 'Check whether the class is package-private (neither public nor private).']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class has declared constructors.* 匹配到的元操作或API：
logic: Check whether the class has declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.8875755667686462
*Get the declared constructors of class.* 匹配到的元操作或API：
query: Get the declared constructors of class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8529866337776184
*Get the number of declared constructors of class.* 匹配到的元操作或API：
query: Get the number of declared constructors of class.
most similar API: get num children of constructor
cosine Similarity: 0.8092807531356812
*Get a constructor of class.* 匹配到的元操作或API：
query: Get a constructor of class.
most similar API: get class of constructor
cosine Similarity: 0.8336949348449707
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is package-private (neither public nor private).* 匹配到的元操作或API：
logic: Check whether the class is package-private (neither public nor private).
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9033401012420654
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class has declared constructors.* 匹配到的元操作或API：
logic: Check whether the class has declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.8875755667686462
*Get the declared constructors of class.* 匹配到的元操作或API：
query: Get the declared constructors of class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8529866337776184
*Get the number of declared constructors of class.* 匹配到的元操作或API：
query: Get the number of declared constructors of class.
most similar API: get num children of constructor
cosine Similarity: 0.8092807531356812
*Get a constructor of class.* 匹配到的元操作或API：
query: Get a constructor of class.
most similar API: get class of constructor
cosine Similarity: 0.8336949348449707
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is package-private (neither public nor private).* 匹配到的元操作或API：
logic: Check whether the class is package-private (neither public nor private).
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9033401012420654
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// violation for abstract class
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public int getNumChildren()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()

1.  //Check whether constructor has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTConstructorDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }
    
    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isPublic() && !node.isFinal() && !node.isAbstract()) {
            NodeStream<ASTConstructorDeclaration> constructors = node.children(ASTConstructorDeclaration.class);
            if (constructors.nonEmpty() && constructors.all(ASTConstructorDeclaration::isPrivate) && constructors.all(this::hasAnnotation)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
    
    // Check whether constructor has declared annotations
    public boolean hasAnnotation(ASTConstructorDeclaration node){
        NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
        return declaredAnnotations.nonEmpty();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 2
1484
1157
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Get the name of the package where the class is located.
3. Get all constructors declared in class.
4. Check whether each constructor is private.
5. Check whether the class is an inner class.
6. Check whether the inner class is package-private or protected.
7. Check whether the class has any declared annotations.
8. Check whether the class is marked as final.
9. Check whether the class is abstract.

To ascertain the adherence to the rule for the provided test case:

10. Get the name of class `Main209`.
11. Get the name of the package where the class `Main209` is located.
12. Get the inner class `InputBits` declared in `Main209`.
13. Get all constructors declared in inner class `InputBits`.
14. Check whether each constructor in `InputBits` is private.
15. Check whether the inner class `InputBits` is package-private or protected.
16. Check whether the inner class `InputBits` has any declared annotations.
17. Check whether the inner class `InputBits` is marked as final.
18. Check whether the inner class `InputBits` is abstract.

The test case violates the rule because:

- The inner class `InputBits` is declared within `Main209` and all its constructors are private.
- The inner class `InputBits` is not marked as final.
- The inner class `InputBits` is package-private, which means it cannot be extended from outside its compilation unit.

Therefore, the inner class `InputBits` should be marked as final to adhere to the rule.
['Get the name of class.', 'Get the name of the package where the class is located.', 'Get all constructors declared in class.', 'Check whether each constructor is private.', 'Check whether the class is an inner class.', 'Check whether the inner class is package-private or protected.', 'Check whether the class has any declared annotations.', 'Check whether the class is marked as final.', 'Check whether the class is abstract.', 'Get the name of class `Main209`.', 'Get the name of the package where the class `Main209` is located.', 'Get the inner class `InputBits` declared in `Main209`.', 'Get all constructors declared in inner class `InputBits`.', 'Check whether each constructor in `InputBits` is private.', 'Check whether the inner class `InputBits` is package-private or protected.', 'Check whether the inner class `InputBits` has any declared annotations.', 'Check whether the inner class `InputBits` is marked as final.', 'Check whether the inner class `InputBits` is abstract.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether each constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442476630210876
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Check whether the inner class is package-private or protected.* 匹配到的元操作或API：
logic: Check whether the inner class is package-private or protected.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.8833405375480652
*Check whether the class has any declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has any declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9707680344581604
*Check whether the class is marked as final.* 匹配到的元操作或API：
logic: Check whether the class is marked as final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9639718532562256
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get the name of class `Main209`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the package where the class `Main209` is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class `Main209` is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.8805438876152039
*Get the inner class `InputBits` declared in `Main209`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors declared in inner class `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each constructor in `InputBits` is private.* 匹配到的元操作或API：
logic: Check whether each constructor in `InputBits` is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8783042430877686
*Check whether the inner class `InputBits` is package-private or protected.* 匹配到的元操作或API：
query: Check whether the inner class `InputBits` is package-private or protected.
most similar API: Check whether the class or interface is package private
cosine Similarity: 0.8538469672203064
*Check whether the inner class `InputBits` has any declared annotations.* 匹配到的元操作或API：
logic: Check whether the inner class `InputBits` has any declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.8510225415229797
*Check whether the inner class `InputBits` is marked as final.* 匹配到的元操作或API：
logic: Check whether the inner class `InputBits` is marked as final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.8618083596229553
*Check whether the inner class `InputBits` is abstract.* 匹配到的元操作或API：
query: Check whether the inner class `InputBits` is abstract.
most similar API: Check whether the class or interface is syntactically abstract
cosine Similarity: 0.8336200714111328
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// #2536 [java] ClassWithOnlyPrivateConstructorsShouldBeFinal can't detect inner class with only private constructor
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isSyntacticallyAbstract()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal() && !node.isAbstract() && !node.isSyntacticallyAbstract() && !hasAnnotations(node)) {
            boolean allPrivateConstructors = true;
            boolean hasConstructor = false;
            for (ASTConstructorDeclaration constructor : node.children(ASTConstructorDeclaration.class)) {
                hasConstructor = true;
                if (!constructor.isPrivate()) {
                    allPrivateConstructors = false;
                    break;
                }
            }
            if (hasConstructor && allPrivateConstructors) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Check whether class has declared annotations
    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class is an inner class.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Check whether the class has declared annotations.
6. Get the javadoc comment of class.
7. Check whether the class is final.
8. Get the name of the package where the class is located.
9. Check whether the class is public.
10. Check whether the class is private.
11. Check whether the class is protected.
12. Check whether the class is default package-private.
13. Check whether the class is static.
14. Get the super class of class.
15. Check whether the class has extended x class.
16. Get a implemented interface of class.
17. Check whether the class has implemented x interface.

For the provided test case:

1. Get the name of class: Main209
2. Check whether the class is an inner class: No
3. Get all constructors declared in class: Main209 has no constructors.
4. Check whether the constructor is private: Not applicable as Main209 has no constructors.
5. Check whether the class has declared annotations: No
6. Get the javadoc comment of class: None
7. Check whether the class is final: No
8. Get the name of the package where the class is located: Not provided in the test case.
9. Check whether the class is public: Yes
10. Check whether the class is private: No
11. Check whether the class is protected: No
12. Check whether the class is default package-private: No
13. Check whether the class is static: No
14. Get the super class of class: java.lang.Object (default superclass)
15. Check whether the class has extended x class: No
16. Get a implemented interface of class: None
17. Check whether the class has implemented x interface: No

Now, focus on the inner class:

1. Get the name of class: InputBits
2. Check whether the class is an inner class: Yes
3. Get all constructors declared in class: InputBits has one constructor.
4. Check whether the constructor is private: Yes
5. Check whether the class has declared annotations: No
6. Get the javadoc comment of class: None
7. Check whether the class is final: No
8. Get the name of the package where the class is located: Not provided in the test case.
9. Check whether the class is public: No
10. Check whether the class is private: Yes
11. Check whether the class is protected: No
12. Check whether the class is default package-private: No
13. Check whether the class is static: Yes
14. Get the super class of class: java.lang.Object (default superclass)
15. Check whether the class has extended x class: No
16. Get a implemented interface of class: None
17. Check whether the class has implemented x interface: No

The test case violates the rule because the inner class `InputBits` has only a private constructor and is not final.
['Get the name of class.', 'Check whether the class is an inner class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has declared annotations.', 'Get the javadoc comment of class.', 'Check whether the class is final.', 'Get the name of the package where the class is located.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is static.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get a implemented interface of class.', 'Check whether the class has implemented x interface.', 'Get the name of class: Main209', 'Check whether the class is an inner class: No', 'Get all constructors declared in class: Main209 has no constructors.', 'Check whether the constructor is private: Not applicable as Main209 has no constructors.', 'Check whether the class has declared annotations: No', 'Get the javadoc comment of class: None', 'Check whether the class is final: No', 'Get the name of the package where the class is located: Not provided in the test case.', 'Check whether the class is public: Yes', 'Check whether the class is private: No', 'Check whether the class is protected: No', 'Check whether the class is default package-private: No', 'Check whether the class is static: No', 'Get the super class of class: java.lang.Object (default superclass)', 'Check whether the class has extended x class: No', 'Get a implemented interface of class: None', 'Check whether the class has implemented x interface: No', 'Get the name of class: InputBits', 'Check whether the class is an inner class: Yes', 'Get all constructors declared in class: InputBits has one constructor.', 'Check whether the constructor is private: Yes', 'Check whether the class has declared annotations: No', 'Get the javadoc comment of class: None', 'Check whether the class is final: No', 'Get the name of the package where the class is located: Not provided in the test case.', 'Check whether the class is public: No', 'Check whether the class is private: Yes', 'Check whether the class is protected: No', 'Check whether the class is default package-private: No', 'Check whether the class is static: Yes', 'Get the super class of class: java.lang.Object (default superclass)', 'Check whether the class has extended x class: No', 'Get a implemented interface of class: None', 'Check whether the class has implemented x interface: No']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844120740890503
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a implemented interface of class.* 匹配到的元操作或API：
logic: Get a implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9851537942886353
*Check whether the class has implemented x interface.* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9905824661254883
*Get the name of class: Main209* 匹配到的元操作或API：
logic: Get the name of class: Main209
most similar meta operation: Get the name of class
cosine Similarity: 0.8585509061813354
*Check whether the class is an inner class: No* 匹配到的元操作或API：
logic: Check whether the class is an inner class: No
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9571874141693115
*Get all constructors declared in class: Main209 has no constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: Not applicable as Main209 has no constructors.* 匹配到的元操作或API：
logic: Check whether the constructor is private: Not applicable as Main209 has no constructors.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9144967794418335
*Check whether the class has declared annotations: No* 匹配到的元操作或API：
logic: Check whether the class has declared annotations: No
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9471337795257568
*Get the javadoc comment of class: None* 匹配到的元操作或API：
logic: Get the javadoc comment of class: None
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9355194568634033
*Check whether the class is final: No* 匹配到的元操作或API：
logic: Check whether the class is final: No
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9627070426940918
*Get the name of the package where the class is located: Not provided in the test case.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located: Not provided in the test case.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.893361508846283
*Check whether the class is public: Yes* 匹配到的元操作或API：
logic: Check whether the class is public: Yes
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9447720050811768
*Check whether the class is private: No* 匹配到的元操作或API：
logic: Check whether the class is private: No
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9601792693138123
*Check whether the class is protected: No* 匹配到的元操作或API：
logic: Check whether the class is protected: No
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9315000772476196
*Check whether the class is default package-private: No* 匹配到的元操作或API：
logic: Check whether the class is default package-private: No
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9762306213378906
*Check whether the class is static: No* 匹配到的元操作或API：
logic: Check whether the class is static: No
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9411004185676575
*Get the super class of class: java.lang.Object (default superclass)* 匹配到的元操作或API：
logic: Get the super class of class: java.lang.Object (default superclass)
most similar meta operation: Get the super class of class
cosine Similarity: 0.8577468395233154
*Check whether the class has extended x class: No* 匹配到的元操作或API：
logic: Check whether the class has extended x class: No
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9652364253997803
*Get a implemented interface of class: None* 匹配到的元操作或API：
logic: Get a implemented interface of class: None
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9263237118721008
*Check whether the class has implemented x interface: No* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface: No
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9442111849784851
*Get the name of class: InputBits* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is an inner class: Yes* 匹配到的元操作或API：
logic: Check whether the class is an inner class: Yes
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9616652727127075
*Get all constructors declared in class: InputBits has one constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: Yes* 匹配到的元操作或API：
logic: Check whether the constructor is private: Yes
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.958292543888092
*Check whether the class has declared annotations: No* 匹配到的元操作或API：
logic: Check whether the class has declared annotations: No
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9471337795257568
*Get the javadoc comment of class: None* 匹配到的元操作或API：
logic: Get the javadoc comment of class: None
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9355194568634033
*Check whether the class is final: No* 匹配到的元操作或API：
logic: Check whether the class is final: No
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9627070426940918
*Get the name of the package where the class is located: Not provided in the test case.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located: Not provided in the test case.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.893361508846283
*Check whether the class is public: No* 匹配到的元操作或API：
logic: Check whether the class is public: No
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9522130489349365
*Check whether the class is private: Yes* 匹配到的元操作或API：
logic: Check whether the class is private: Yes
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9429656267166138
*Check whether the class is protected: No* 匹配到的元操作或API：
logic: Check whether the class is protected: No
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9315000772476196
*Check whether the class is default package-private: No* 匹配到的元操作或API：
logic: Check whether the class is default package-private: No
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9762306213378906
*Check whether the class is static: Yes* 匹配到的元操作或API：
logic: Check whether the class is static: Yes
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9431560635566711
*Get the super class of class: java.lang.Object (default superclass)* 匹配到的元操作或API：
logic: Get the super class of class: java.lang.Object (default superclass)
most similar meta operation: Get the super class of class
cosine Similarity: 0.8577468395233154
*Check whether the class has extended x class: No* 匹配到的元操作或API：
logic: Check whether the class has extended x class: No
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9652364253997803
*Get a implemented interface of class: None* 匹配到的元操作或API：
logic: Get a implemented interface of class: None
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9263237118721008
*Check whether the class has implemented x interface: No* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface: No
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9442111849784851
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// #2536 [java] ClassWithOnlyPrivateConstructorsShouldBeFinal can't detect inner class with only private constructor
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isProtected()
11. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()
12. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
13. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
14. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getSuperInterfaceTypeNodes()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```
3.  //Check whether the class has implemented x interface
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node) {
    if (TypeTestUtil.isA(interfaceName.class, node)) {
        return true;
    }
    return false;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && node.isStatic() && !node.isFinal() && !node.isPublic() && !node.isPrivate() && !node.isProtected()) {
            boolean allConstructorsPrivate = node.children(ASTConstructorDeclaration.class).allMatch(ASTConstructorDeclaration::isPrivate);
            if (allConstructorsPrivate) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Check whether class has declared annotations
    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }

    // Check whether the class has extended x class
    public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node, Class<?> x) {
        ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
        return TypeTestUtil.isA(x, classOrInterfaceType);
    }

    // Check whether the class has implemented x interface
    public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node, Class<?> interfaceName) {
        return TypeTestUtil.isA(interfaceName, node);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Get the signature of constructor.
3. Check whether the constructor is private.
4. Check whether the class is an inner class.
5. Get all constructors of the class.
6. Check whether all constructors are private.
7. Check whether the class is final.

Given the test case:
1. The name of the class is `Main209`.
2. The class contains an inner class `InputBits`.
3. Get the signature of the constructor of `InputBits`.
4. The constructor `InputBits(int number)` is private.
5. The class `InputBits` is an inner class.
6. Get all constructors of `InputBits`. There is only one constructor, and it is private.
7. Check whether `InputBits` is final. It is not final.

If the class is an inner class with all private constructors and is not final, then it violates the rule. Therefore, the given test case `InputBits` violates the rule.
['Get the name of class.', 'Get the signature of constructor.', 'Check whether the constructor is private.', 'Check whether the class is an inner class.', 'Get all constructors of the class.', 'Check whether all constructors are private.', 'Check whether the class is final.', 'The name of the class is `Main209`.', 'The class contains an inner class `InputBits`.', 'Get the signature of the constructor of `InputBits`.', 'The constructor `InputBits(int number)` is private.', 'The class `InputBits` is an inner class.', 'Get all constructors of `InputBits`. There is only one constructor, and it is private.', 'Check whether `InputBits` is final. It is not final.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828827381134033
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Get all constructors of the class.* 匹配到的元操作或API：
query: Get all constructors of the class.
most similar API: get parents of type of constructor
cosine Similarity: 0.8007241487503052
*Check whether all constructors are private.* 匹配到的元操作或API：
logic: Check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.936521589756012
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*The name of the class is `Main209`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The class contains an inner class `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the signature of the constructor of `InputBits`.* 匹配到的元操作或API：
logic: Get the signature of the constructor of `InputBits`.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.8510262370109558
*The constructor `InputBits(int number)` is private.* 匹配到的元操作或API：
未匹配成功元操作或API
*The class `InputBits` is an inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors of `InputBits`. There is only one constructor, and it is private.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether `InputBits` is final. It is not final.* 匹配到的元操作或API：
query: Check whether `InputBits` is final. It is not final.
most similar API: Check whether the class or interface is final
cosine Similarity: 0.8148733973503113
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// #2536 [java] ClassWithOnlyPrivateConstructorsShouldBeFinal can't detect inner class with only private constructor
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.util.List<List<T> getParentsOfType(java.lang.Class)
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal(), //Returns true if this variable, method or class is final (even implicitly).



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
True
此测试用例生成了first checker: bad 3


======================接下来开始迭代=====================
[ERROR]   "ok 5" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
107
91
94
78
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all constructors declared in class.
3. Check whether the constructor is private.
4. Check whether the class has at least one non-private constructor.
5. Check whether the class has subclasses.
6. Check whether the subclass is declared in the same compilation unit.
7. If the class is abstract, check whether it has any abstract methods.

To break down the test case:

1. Get the name of class: Foo.
2. Get all constructors declared in class: Foo() and Bar() and Barbie().
3. Check whether the constructor is private: Bar() is private, Foo() and Barbie() are not.
4. Check whether the class has at least one non-private constructor: Foo and Barbie have non-private constructors.
5. Check whether the class has subclasses: Foo has a subclass Bar, and Bar has a subclass Barbie.
6. Check whether the subclass is declared in the same compilation unit: Both Bar and Barbie are declared in the same compilation unit as Foo.
7. If the class is abstract, check whether it has any abstract methods: Foo is not abstract.

For the class `Bar`:
1. Get the name of class: Bar.
2. Get all constructors declared in class: Bar().
3. Check whether the constructor is private: Bar() is private.
4. Check whether the class has at least one non-private constructor: No non-private constructors.
5. Check whether the class has subclasses: Bar has a subclass Barbie.
6. Check whether the subclass is declared in the same compilation unit: Barbie is declared in the same compilation unit as Bar.
7. If the class is abstract, check whether it has any abstract methods: Bar is not abstract.

For the class `Barbie`:
1. Get the name of class: Barbie.
2. Get all constructors declared in class: Barbie().
3. Check whether the constructor is private: Barbie() is not private.
4. Check whether the class has at least one non-private constructor: Yes, Barbie() is non-private.
5. Check whether the class has subclasses: No subclasses.
6. Check whether the subclass is declared in the same compilation unit: N/A, as Barbie does not have subclasses.
7. If the class is abstract, check whether it has any abstract methods: Barbie is not abstract.

Based on these checks, the test case does not violate the rule because `Bar` has a private constructor but it has a subclass `Barbie` that is declared in the same compilation unit and can call the super constructor via an instance creation expression or reflection, which is not directly shown in the snippet but is implied by the comment. Since there are no final classes with private constructors that prevent subclassing from outside their compilation unit, the number of violations is 0.
['Get the name of class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has at least one non-private constructor.', 'Check whether the class has subclasses.', 'Check whether the subclass is declared in the same compilation unit.', 'If the class is abstract, check whether it has any abstract methods.', 'Get the name of class: Foo.', 'Get all constructors declared in class: Foo() and Bar() and Barbie().', 'Check whether the constructor is private: Bar() is private, Foo() and Barbie() are not.', 'Check whether the class has at least one non-private constructor: Foo and Barbie have non-private constructors.', 'Check whether the class has subclasses: Foo has a subclass Bar, and Bar has a subclass Barbie.', 'Check whether the subclass is declared in the same compilation unit: Both Bar and Barbie are declared in the same compilation unit as Foo.', 'If the class is abstract, check whether it has any abstract methods: Foo is not abstract.', 'Get the name of class: Bar.', 'Get all constructors declared in class: Bar().', 'Check whether the constructor is private: Bar() is private.', 'Check whether the class has at least one non-private constructor: No non-private constructors.', 'Check whether the class has subclasses: Bar has a subclass Barbie.', 'Check whether the subclass is declared in the same compilation unit: Barbie is declared in the same compilation unit as Bar.', 'If the class is abstract, check whether it has any abstract methods: Bar is not abstract.', 'Get the name of class: Barbie.', 'Get all constructors declared in class: Barbie().', 'Check whether the constructor is private: Barbie() is not private.', 'Check whether the class has at least one non-private constructor: Yes, Barbie() is non-private.', 'Check whether the class has subclasses: No subclasses.', 'Check whether the subclass is declared in the same compilation unit: N/A, as Barbie does not have subclasses.', 'If the class is abstract, check whether it has any abstract methods: Barbie is not abstract.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTExtendsList', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has at least one non-private constructor.* 匹配到的元操作或API：
logic: Check whether the class has at least one non-private constructor.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8706803321838379
*Check whether the class has subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass is declared in the same compilation unit.* 匹配到的元操作或API：
query: Check whether the subclass is declared in the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8679710030555725
*If the class is abstract, check whether it has any abstract methods.* 匹配到的元操作或API：
logic: If the class is abstract, check whether it has any abstract methods.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9112098813056946
*Get the name of class: Foo.* 匹配到的元操作或API：
logic: Get the name of class: Foo.
most similar meta operation: Get the name of class
cosine Similarity: 0.9150534272193909
*Get all constructors declared in class: Foo() and Bar() and Barbie().* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: Bar() is private, Foo() and Barbie() are not.* 匹配到的元操作或API：
logic: Check whether the constructor is private: Bar() is private, Foo() and Barbie() are not.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8989524841308594
*Check whether the class has at least one non-private constructor: Foo and Barbie have non-private constructors.* 匹配到的元操作或API：
query: Check whether the class has at least one non-private constructor: Foo and Barbie have non-private constructors.
most similar API: Check whether the constructor is private
cosine Similarity: 0.8467676639556885
*Check whether the class has subclasses: Foo has a subclass Bar, and Bar has a subclass Barbie.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass is declared in the same compilation unit: Both Bar and Barbie are declared in the same compilation unit as Foo.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the class is abstract, check whether it has any abstract methods: Foo is not abstract.* 匹配到的元操作或API：
logic: If the class is abstract, check whether it has any abstract methods: Foo is not abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.8968143463134766
*Get the name of class: Bar.* 匹配到的元操作或API：
logic: Get the name of class: Bar.
most similar meta operation: Get the name of class
cosine Similarity: 0.8558183908462524
*Get all constructors declared in class: Bar().* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: Bar() is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private: Bar() is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9036549925804138
*Check whether the class has at least one non-private constructor: No non-private constructors.* 匹配到的元操作或API：
logic: Check whether the class has at least one non-private constructor: No non-private constructors.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8548749685287476
*Check whether the class has subclasses: Bar has a subclass Barbie.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass is declared in the same compilation unit: Barbie is declared in the same compilation unit as Bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the class is abstract, check whether it has any abstract methods: Bar is not abstract.* 匹配到的元操作或API：
logic: If the class is abstract, check whether it has any abstract methods: Bar is not abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.8699338436126709
*Get the name of class: Barbie.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors declared in class: Barbie().* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: Barbie() is not private.* 匹配到的元操作或API：
logic: Check whether the constructor is private: Barbie() is not private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9000678658485413
*Check whether the class has at least one non-private constructor: Yes, Barbie() is non-private.* 匹配到的元操作或API：
query: Check whether the class has at least one non-private constructor: Yes, Barbie() is non-private.
most similar API: Check whether the constructor is private
cosine Similarity: 0.8440903425216675
*Check whether the class has subclasses: No subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass is declared in the same compilation unit: N/A, as Barbie does not have subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the class is abstract, check whether it has any abstract methods: Barbie is not abstract.* 匹配到的元操作或API：
logic: If the class is abstract, check whether it has any abstract methods: Barbie is not abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.853810727596283
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor of another subclass
public class Foo {
    public Foo() { }

    public static class Bar {
        private Bar() { }
    }

    public static class Barbie extends Bar {
        public Barbie() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Barbie')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal() && !node.isAbstract()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                if (node.descendants(ASTClassOrInterfaceDeclaration.class).noneMatch(subclass -> subclass.getExtendsClause().stream().anyMatch(extend -> extend.isReferenceToClassSameCompilationUnit()))) {
                    addViolation(data, node);
                }
            }
        }
        return data;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
Let's perform the checks to ascertain whether the provided test case adheres to the rule description.

1. Get the name of class.
2. Check whether the class is abstract.
3. Check whether the class is final.
4. Get all constructors declared in class.
5. Check whether the constructor is private.
6. Check whether the class is an interface.
7. Get the name of the package where the class is located.
8. Get the super class of class.
9. Check whether the class has extended x class.
10. Get a declared annotation of class.
11. Check whether the class has x annotation.
12. Get all inner classes of class.
13. Check whether the inner class is final.
14. Check whether the inner class is abstract.
15. Get all constructors declared in inner class.
16. Check whether the constructor is private.
17. Get the super class of the inner class.
18. Check whether the inner class has extended x class.
19. Get a declared annotation of inner class.
20. Check whether the inner class has x annotation.

### For the outer class `Foo`:
1. Get the name of class: Foo
2. Check whether the class is abstract: No
3. Check whether the class is final: No
4. Get all constructors declared in class: Foo()
5. Check whether the constructor is private: No
6. Check whether the class is an interface: No
7. Get the name of the package where the class is located: (unknown, but it doesn't affect this check)
8. Get the super class of class: Object
9. Check whether the class has extended x class: No (it extends Object by default, which is ignored in this context)
10. Get a declared annotation of class: None
11. Check whether the class has x annotation: No

### For the inner class `Bar`:
12. Get all inner classes of class: Bar, Barbie
13. Check whether the inner class is final: No (Bar is not final)
14. Check whether the inner class is abstract: No (Bar is not abstract)
15. Get all constructors declared in inner class: Bar()
16. Check whether the constructor is private: Yes (Bar() is private)
17. Get the super class of the inner class: Object
18. Check whether the inner class has extended x class: No (Bar extends Object by default, which is ignored in this context)
19. Get a declared annotation of inner class: None
20. Check whether the inner class has x annotation: No

### For the inner class `Barbie`:
13. Check whether the inner class is final: No (Barbie is not final)
14. Check whether the inner class is abstract: No (Barbie is not abstract)
15. Get all constructors declared in inner class: Barbie()
16. Check whether the constructor is private: No (Barbie() is public)
17. Get the super class of the inner class: Bar
18. Check whether the inner class has extended x class: Yes (Barbie extends Bar)
19. Get a declared annotation of inner class: None
20. Check whether the inner class has x annotation: No

### Summary:
- The outer class `Foo` does not have any private constructors, so it can be extended from outside its compilation unit.
- The inner class `Bar` has a private constructor, making it impossible to be extended from outside its compilation unit.
- The inner class `Barbie` can extend `Bar` because it is a subclass within the same compilation unit and has access to `Bar`'s private constructor.

Since `Barbie` can extend `Bar` and there are no other classes with private constructors that prevent them from being extended, the test case does not violate the rule. The number of classes violating the rule in this test case is indeed: 0.
['Get the name of class.', 'Check whether the class is abstract.', 'Check whether the class is final.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is an interface.', 'Get the name of the package where the class is located.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get a declared annotation of class.', 'Check whether the class has x annotation.', 'Get all inner classes of class.', 'Check whether the inner class is final.', 'Check whether the inner class is abstract.', 'Get all constructors declared in inner class.', 'Check whether the constructor is private.', 'Get the super class of the inner class.', 'Check whether the inner class has extended x class.', 'Get a declared annotation of inner class.', 'Check whether the inner class has x annotation.', 'Get the name of class: Foo', 'Check whether the class is abstract: No', 'Check whether the class is final: No', 'Get all constructors declared in class: Foo()', 'Check whether the constructor is private: No', 'Check whether the class is an interface: No', "Get the name of the package where the class is located: (unknown, but it doesn't affect this check)", 'Get the super class of class: Object', 'Check whether the class has extended x class: No (it extends Object by default, which is ignored in this context)', 'Get a declared annotation of class: None', 'Check whether the class has x annotation: No', 'Get all inner classes of class: Bar, Barbie', 'Check whether the inner class is final: No (Bar is not final)', 'Check whether the inner class is abstract: No (Bar is not abstract)', 'Get all constructors declared in inner class: Bar()', 'Check whether the constructor is private: Yes (Bar() is private)', 'Get the super class of the inner class: Object', 'Check whether the inner class has extended x class: No (Bar extends Object by default, which is ignored in this context)', 'Get a declared annotation of inner class: None', 'Check whether the inner class has x annotation: No', 'Check whether the inner class is final: No (Barbie is not final)', 'Check whether the inner class is abstract: No (Barbie is not abstract)', 'Get all constructors declared in inner class: Barbie()', 'Check whether the constructor is private: No (Barbie() is public)', 'Get the super class of the inner class: Bar', 'Check whether the inner class has extended x class: Yes (Barbie extends Bar)', 'Get a declared annotation of inner class: None', 'Check whether the inner class has x annotation: No']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTExtendsList', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is an interface.* 匹配到的元操作或API：
logic: Check whether the class is an interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9778784513473511
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.987838864326477
*Check whether the class has x annotation.* 匹配到的元操作或API：
logic: Check whether the class has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9908236265182495
*Get all inner classes of class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is final.* 匹配到的元操作或API：
logic: Check whether the inner class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9427244663238525
*Check whether the inner class is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9326449036598206
*Get all constructors declared in inner class.* 匹配到的元操作或API：
query: Get all constructors declared in inner class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8095777034759521
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the super class of the inner class.* 匹配到的元操作或API：
logic: Get the super class of the inner class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9249776005744934
*Check whether the inner class has extended x class.* 匹配到的元操作或API：
logic: Check whether the inner class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9668768644332886
*Get a declared annotation of inner class.* 匹配到的元操作或API：
logic: Get a declared annotation of inner class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9325211048126221
*Check whether the inner class has x annotation.* 匹配到的元操作或API：
logic: Check whether the inner class has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9544620513916016
*Get the name of class: Foo* 匹配到的元操作或API：
logic: Get the name of class: Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9263077974319458
*Check whether the class is abstract: No* 匹配到的元操作或API：
logic: Check whether the class is abstract: No
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9449758529663086
*Check whether the class is final: No* 匹配到的元操作或API：
logic: Check whether the class is final: No
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9627070426940918
*Get all constructors declared in class: Foo()* 匹配到的元操作或API：
query: Get all constructors declared in class: Foo()
most similar API: get declared annotations of constructor
cosine Similarity: 0.8273404240608215
*Check whether the constructor is private: No* 匹配到的元操作或API：
logic: Check whether the constructor is private: No
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9724547863006592
*Check whether the class is an interface: No* 匹配到的元操作或API：
logic: Check whether the class is an interface: No
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9390528798103333
*Get the name of the package where the class is located: (unknown, but it doesn't affect this check)* 匹配到的元操作或API：
logic: Get the name of the package where the class is located: (unknown, but it doesn't affect this check)
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.952793300151825
*Get the super class of class: Object* 匹配到的元操作或API：
logic: Get the super class of class: Object
most similar meta operation: Get the super class of class
cosine Similarity: 0.9086419939994812
*Check whether the class has extended x class: No (it extends Object by default, which is ignored in this context)* 匹配到的元操作或API：
logic: Check whether the class has extended x class: No (it extends Object by default, which is ignored in this context)
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9228397607803345
*Get a declared annotation of class: None* 匹配到的元操作或API：
logic: Get a declared annotation of class: None
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9188624620437622
*Check whether the class has x annotation: No* 匹配到的元操作或API：
logic: Check whether the class has x annotation: No
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9457663297653198
*Get all inner classes of class: Bar, Barbie* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is final: No (Bar is not final)* 匹配到的元操作或API：
logic: Check whether the inner class is final: No (Bar is not final)
most similar meta operation: Check whether the class is final
cosine Similarity: 0.8913308382034302
*Check whether the inner class is abstract: No (Bar is not abstract)* 匹配到的元操作或API：
logic: Check whether the inner class is abstract: No (Bar is not abstract)
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.8855552673339844
*Get all constructors declared in inner class: Bar()* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: Yes (Bar() is private)* 匹配到的元操作或API：
logic: Check whether the constructor is private: Yes (Bar() is private)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8836684823036194
*Get the super class of the inner class: Object* 匹配到的元操作或API：
logic: Get the super class of the inner class: Object
most similar meta operation: Get the super class of class
cosine Similarity: 0.8785058856010437
*Check whether the inner class has extended x class: No (Bar extends Object by default, which is ignored in this context)* 匹配到的元操作或API：
logic: Check whether the inner class has extended x class: No (Bar extends Object by default, which is ignored in this context)
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.888867199420929
*Get a declared annotation of inner class: None* 匹配到的元操作或API：
logic: Get a declared annotation of inner class: None
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.8835927844047546
*Check whether the inner class has x annotation: No* 匹配到的元操作或API：
logic: Check whether the inner class has x annotation: No
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9172170758247375
*Check whether the inner class is final: No (Barbie is not final)* 匹配到的元操作或API：
logic: Check whether the inner class is final: No (Barbie is not final)
most similar meta operation: Check whether the class is final
cosine Similarity: 0.8771507740020752
*Check whether the inner class is abstract: No (Barbie is not abstract)* 匹配到的元操作或API：
logic: Check whether the inner class is abstract: No (Barbie is not abstract)
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.8704451322555542
*Get all constructors declared in inner class: Barbie()* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: No (Barbie() is public)* 匹配到的元操作或API：
logic: Check whether the constructor is private: No (Barbie() is public)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8936347961425781
*Get the super class of the inner class: Bar* 匹配到的元操作或API：
logic: Get the super class of the inner class: Bar
most similar meta operation: Get the super class of class
cosine Similarity: 0.888206958770752
*Check whether the inner class has extended x class: Yes (Barbie extends Bar)* 匹配到的元操作或API：
logic: Check whether the inner class has extended x class: Yes (Barbie extends Bar)
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.892115592956543
*Get a declared annotation of inner class: None* 匹配到的元操作或API：
logic: Get a declared annotation of inner class: None
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.8835927844047546
*Check whether the inner class has x annotation: No* 匹配到的元操作或API：
logic: Check whether the inner class has x annotation: No
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9172170758247375
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor of another subclass
public class Foo {
    public Foo() { }

    public static class Bar {
        private Bar() { }
    }

    public static class Barbie extends Bar {
        public Barbie() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Barbie')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)

1.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal() && !node.isInterface() && !node.isAbstract()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                ASTClassOrInterfaceType superClassTypeNode = node.getSuperClassTypeNode();
                if (superClassTypeNode == null || !isSuperClassConstructorAccessibleOutside(node)) {
                    addViolation(data, node);
                }
            }
        }
        return data;
    }

    private boolean isSuperClassConstructorAccessibleOutside(ASTClassOrInterfaceDeclaration node) {
        ASTClassOrInterfaceType superClassTypeNode = node.getSuperClassTypeNode();
        if (superClassTypeNode != null) {
            ASTClassOrInterfaceDeclaration superClassDeclaration = superClassTypeNode.getType().getAstNode();
            if (superClassDeclaration != null && !superClassDeclaration.isNested()) {
                return false;
            }
            for (ASTConstructorDeclaration constructor : superClassDeclaration.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList())) {
                if (!constructor.isPrivate() && (constructor.isPublic() || constructor.isProtected())) {
                    return true;
                }
            }
            return isSuperClassConstructorAccessibleOutside(superClassDeclaration);
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class has declared annotations.
3. Get the name of the package where the class is located.
4. Check whether the class is public.
5. Check whether the class is abstract.
6. Check whether the class is final.
7. Get the super class of class.
8. Check whether the class has extended x class.
9. Get all constructors declared in class.
10. Check whether the constructor is private.
11. Check whether the class is an inner class.
12. Get the name of the inner class.
13. Check whether the inner class is public.
14. Check whether the inner class is abstract.
15. Check whether the inner class is final.
16. Get the super class of inner class.
17. Check whether the inner class has extended x class.
18. Get all constructors declared in inner class.
19. Check whether the constructor is private.
20. Get all inner classes declared in class.
21. Check whether the inner class has extended x class.

For the given test case:

1. Get the name of class: Foo
2. Check whether the class has declared annotations: No
3. Get the name of the package where the class is located: Not specified, but assuming it's in the default package for this example.
4. Check whether the class is public: Yes
5. Check whether the class is abstract: No
6. Check whether the class is final: No
7. Get the super class of class: java.lang.Object
8. Check whether the class has extended x class: No
9. Get all constructors declared in class: One public constructor
10. Check whether the constructor is private: No
11. Check whether the class is an inner class: No
12. Get the name of the inner class: Bar, Barbie
13. Check whether the inner class is public: Yes for both
14. Check whether the inner class is abstract: No for both
15. Check whether the inner class is final: No for both
16. Get the super class of inner class: Foo for both
17. Check whether the inner class has extended x class: No
18. Get all constructors declared in inner class: One private constructor for Bar, one public constructor for Barbie
19. Check whether the constructor is private: Yes for Bar, No for Barbie
20. Get all inner classes declared in class: Bar, Barbie
21. Check whether the inner class has extended x class: Yes, Barbie extends Bar

Based on the checks, Barbie extends Bar. Since Bar has a private constructor and Barbie is declared in the same compilation unit, Barbie can extend Bar. Therefore, Foo does not violate the rule because it has a public constructor and Barbie can still extend it within the same compilation unit. The number of violating the rule in this test case is: 0
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get the name of the package where the class is located.', 'Check whether the class is public.', 'Check whether the class is abstract.', 'Check whether the class is final.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is an inner class.', 'Get the name of the inner class.', 'Check whether the inner class is public.', 'Check whether the inner class is abstract.', 'Check whether the inner class is final.', 'Get the super class of inner class.', 'Check whether the inner class has extended x class.', 'Get all constructors declared in inner class.', 'Check whether the constructor is private.', 'Get all inner classes declared in class.', 'Check whether the inner class has extended x class.', 'Get the name of class: Foo', 'Check whether the class has declared annotations: No', "Get the name of the package where the class is located: Not specified, but assuming it's in the default package for this example.", 'Check whether the class is public: Yes', 'Check whether the class is abstract: No', 'Check whether the class is final: No', 'Get the super class of class: java.lang.Object', 'Check whether the class has extended x class: No', 'Get all constructors declared in class: One public constructor', 'Check whether the constructor is private: No', 'Check whether the class is an inner class: No', 'Get the name of the inner class: Bar, Barbie', 'Check whether the inner class is public: Yes for both', 'Check whether the inner class is abstract: No for both', 'Check whether the inner class is final: No for both', 'Get the super class of inner class: Foo for both', 'Check whether the inner class has extended x class: No', 'Get all constructors declared in inner class: One private constructor for Bar, one public constructor for Barbie', 'Check whether the constructor is private: Yes for Bar, No for Barbie', 'Get all inner classes declared in class: Bar, Barbie', 'Check whether the inner class has extended x class: Yes, Barbie extends Bar']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTExtendsList', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Get the name of the inner class.* 匹配到的元操作或API：
logic: Get the name of the inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.878083348274231
*Check whether the inner class is public.* 匹配到的元操作或API：
logic: Check whether the inner class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9261534214019775
*Check whether the inner class is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9326449036598206
*Check whether the inner class is final.* 匹配到的元操作或API：
logic: Check whether the inner class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9427244663238525
*Get the super class of inner class.* 匹配到的元操作或API：
logic: Get the super class of inner class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9238667488098145
*Check whether the inner class has extended x class.* 匹配到的元操作或API：
logic: Check whether the inner class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9668768644332886
*Get all constructors declared in inner class.* 匹配到的元操作或API：
query: Get all constructors declared in inner class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8095777034759521
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get all inner classes declared in class.* 匹配到的元操作或API：
query: Get all inner classes declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8037846684455872
*Check whether the inner class has extended x class.* 匹配到的元操作或API：
logic: Check whether the inner class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9668768644332886
*Get the name of class: Foo* 匹配到的元操作或API：
logic: Get the name of class: Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9263077974319458
*Check whether the class has declared annotations: No* 匹配到的元操作或API：
logic: Check whether the class has declared annotations: No
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9471337795257568
*Get the name of the package where the class is located: Not specified, but assuming it's in the default package for this example.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located: Not specified, but assuming it's in the default package for this example.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9249157905578613
*Check whether the class is public: Yes* 匹配到的元操作或API：
logic: Check whether the class is public: Yes
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9447720050811768
*Check whether the class is abstract: No* 匹配到的元操作或API：
logic: Check whether the class is abstract: No
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9449758529663086
*Check whether the class is final: No* 匹配到的元操作或API：
logic: Check whether the class is final: No
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9627070426940918
*Get the super class of class: java.lang.Object* 匹配到的元操作或API：
logic: Get the super class of class: java.lang.Object
most similar meta operation: Get the super class of class
cosine Similarity: 0.892085075378418
*Check whether the class has extended x class: No* 匹配到的元操作或API：
logic: Check whether the class has extended x class: No
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9652364253997803
*Get all constructors declared in class: One public constructor* 匹配到的元操作或API：
query: Get all constructors declared in class: One public constructor
most similar API: get declared annotations of constructor
cosine Similarity: 0.8268464207649231
*Check whether the constructor is private: No* 匹配到的元操作或API：
logic: Check whether the constructor is private: No
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9724547863006592
*Check whether the class is an inner class: No* 匹配到的元操作或API：
logic: Check whether the class is an inner class: No
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9571874141693115
*Get the name of the inner class: Bar, Barbie* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is public: Yes for both* 匹配到的元操作或API：
logic: Check whether the inner class is public: Yes for both
most similar meta operation: Check whether the class is public
cosine Similarity: 0.8874101042747498
*Check whether the inner class is abstract: No for both* 匹配到的元操作或API：
logic: Check whether the inner class is abstract: No for both
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.8848683834075928
*Check whether the inner class is final: No for both* 匹配到的元操作或API：
logic: Check whether the inner class is final: No for both
most similar meta operation: Check whether the class is final
cosine Similarity: 0.8823316097259521
*Get the super class of inner class: Foo for both* 匹配到的元操作或API：
logic: Get the super class of inner class: Foo for both
most similar meta operation: Get the super class of class
cosine Similarity: 0.8570906519889832
*Check whether the inner class has extended x class: No* 匹配到的元操作或API：
logic: Check whether the inner class has extended x class: No
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9412108063697815
*Get all constructors declared in inner class: One private constructor for Bar, one public constructor for Barbie* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: Yes for Bar, No for Barbie* 匹配到的元操作或API：
logic: Check whether the constructor is private: Yes for Bar, No for Barbie
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9259656667709351
*Get all inner classes declared in class: Bar, Barbie* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class has extended x class: Yes, Barbie extends Bar* 匹配到的元操作或API：
logic: Check whether the inner class has extended x class: Yes, Barbie extends Bar
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.8929392695426941
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor of another subclass
public class Foo {
    public Foo() { }

    public static class Bar {
        private Bar() { }
    }

    public static class Barbie extends Bar {
        public Barbie() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Barbie')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
8. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal() && !node.isAbstract() && !hasSubClassInSameCompilationUnit(node)) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }

    private boolean hasSubClassInSameCompilationUnit(ASTClassOrInterfaceDeclaration node) {
        String packageName = node.getPackageName();
        String simpleName = node.getSimpleName();
        return node.getRoot().descendants(ASTClassOrInterfaceDeclaration.class)
                .filter(subNode -> packageName.equals(subNode.getPackageName()))
                .anyMatch(subNode -> {
                    ASTClassOrInterfaceType superClassTypeNode = subNode.getSuperClassTypeNode();
                    return superClassTypeNode != null && simpleName.equals(superClassTypeNode.getSimpleName());
                });
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all constructors declared in class.
3. Check whether each constructor is private.
4. If class has no private constructors, get all subclasses of class.
5. Check whether each subclass is located in the same compilation unit as the class.
6. If a subclass is located outside the compilation unit, report the class as violating the rule.

For the provided test case:

1. Get the name of class: Foo
2. Get all constructors declared in class Foo: Foo()
3. Check whether each constructor is private: Foo() is not private.
4. Get all subclasses of class Foo: Bar, Barbie
5. Check whether each subclass is located in the same compilation unit as the class Foo:
   - Bar is a static class inside Foo, so it is in the same compilation unit.
   - Barbie is a static class inside Foo, so it is in the same compilation unit.
6. Since all subclasses of Foo are located in the same compilation unit, Foo does not violate the rule.

For class Bar:

1. Get the name of class: Bar
2. Get all constructors declared in class Bar: Bar()
3. Check whether each constructor is private: Bar() is private.
4. Since Bar has a private constructor, it should not be report as violating the rule even if it has a subclass outside the compilation unit.

For class Barbie:

1. Get the name of class: Barbie
2. Get all constructors declared in class Barbie: Barbie()
3. Check whether each constructor is private: Barbie() is not private.
4. Get all subclasses of class Barbie: No subclasses.
5. Since Barbie has no subclasses, it does not violate the rule.

The number of violating the rule in this test case is indeed: 0
['Get the name of class.', 'Get all constructors declared in class.', 'Check whether each constructor is private.', 'If class has no private constructors, get all subclasses of class.', 'Check whether each subclass is located in the same compilation unit as the class.', 'If a subclass is located outside the compilation unit, report the class as violating the rule.', 'Get the name of class: Foo', 'Get all constructors declared in class Foo: Foo()', 'Check whether each constructor is private: Foo() is not private.', 'Get all subclasses of class Foo: Bar, Barbie', 'Check whether each subclass is located in the same compilation unit as the class Foo:', 'Since all subclasses of Foo are located in the same compilation unit, Foo does not violate the rule.', 'Get the name of class: Bar', 'Get all constructors declared in class Bar: Bar()', 'Check whether each constructor is private: Bar() is private.', 'Since Bar has a private constructor, it should not be report as violating the rule even if it has a subclass outside the compilation unit.', 'Get the name of class: Barbie', 'Get all constructors declared in class Barbie: Barbie()', 'Check whether each constructor is private: Barbie() is not private.', 'Get all subclasses of class Barbie: No subclasses.', 'Since Barbie has no subclasses, it does not violate the rule.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTExtendsList', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether each constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442476630210876
*If class has no private constructors, get all subclasses of class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each subclass is located in the same compilation unit as the class.* 匹配到的元操作或API：
query: Check whether each subclass is located in the same compilation unit as the class.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8416047692298889
*If a subclass is located outside the compilation unit, report the class as violating the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: Foo* 匹配到的元操作或API：
logic: Get the name of class: Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9263077974319458
*Get all constructors declared in class Foo: Foo()* 匹配到的元操作或API：
query: Get all constructors declared in class Foo: Foo()
most similar API: get declared annotations of constructor
cosine Similarity: 0.8324316143989563
*Check whether each constructor is private: Foo() is not private.* 匹配到的元操作或API：
logic: Check whether each constructor is private: Foo() is not private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9156093597412109
*Get all subclasses of class Foo: Bar, Barbie* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each subclass is located in the same compilation unit as the class Foo:* 匹配到的元操作或API：
query: Check whether each subclass is located in the same compilation unit as the class Foo:
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8478686213493347
*Since all subclasses of Foo are located in the same compilation unit, Foo does not violate the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: Bar* 匹配到的元操作或API：
logic: Get the name of class: Bar
most similar meta operation: Get the name of class
cosine Similarity: 0.8756611347198486
*Get all constructors declared in class Bar: Bar()* 匹配到的元操作或API：
query: Get all constructors declared in class Bar: Bar()
most similar API: get declared annotations of constructor
cosine Similarity: 0.8112131357192993
*Check whether each constructor is private: Bar() is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private: Bar() is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8940434455871582
*Since Bar has a private constructor, it should not be report as violating the rule even if it has a subclass outside the compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: Barbie* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors declared in class Barbie: Barbie()* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each constructor is private: Barbie() is not private.* 匹配到的元操作或API：
logic: Check whether each constructor is private: Barbie() is not private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8874448537826538
*Get all subclasses of class Barbie: No subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Since Barbie has no subclasses, it does not violate the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor of another subclass
public class Foo {
    public Foo() { }

    public static class Bar {
        private Bar() { }
    }

    public static class Barbie extends Bar {
        public Barbie() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Barbie')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                ASTCompilationUnit compilationUnit = node.getNthParent(ASTCompilationUnit.class);
                if (compilationUnit != null && !canBeSubclassInSameCompilationUnit(node, compilationUnit)) {
                    addViolation(data, node);
                }
            }
        }
        return data;
    }

    private boolean canBeSubclassInSameCompilationUnit(ASTClassOrInterfaceDeclaration node, ASTCompilationUnit compilationUnit) {
        return compilationUnit.descendants(ASTClassOrInterfaceDeclaration.class)
                .filter(n -> !n.equals(node))
                .anyMatch(n -> {
                    ASTExtendsList extendsList = n.getFirstChildOfType(ASTExtendsList.class);
                    if (extendsList != null) {
                        return extendsList.getFirstChildOfType(ASTClassOrInterfaceType.class).isReferenceToClassSameCompilationUnit();
                    }
                    return false;
                });
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all constructors declared in class.
3. Check whether the constructor is private.
4. Check whether the class has any subclasses.
5. Check whether the subclasses are in the same compilation unit.

Let's perform the checks step-by-step:

1. Get the name of class. // Foo
2. Get all constructors declared in class. // Foo()
3. Check whether the constructor is private. // Foo() is not private, so no violation here.
4. Check whether the class has any subclasses. // Bar and Barbie are subclasses of Foo.
5. Get the name of class. // Bar
2. Get all constructors declared in class. // Bar()
3. Check whether the constructor is private. // Bar() is private.
4. Check whether the class has any subclasses. // Barbie is a subclass of Bar.
5. Check whether the subclasses are in the same compilation unit. // Barbie is in the same compilation unit as Bar, so no violation here.
5. Get the name of class. // Barbie
2. Get all constructors declared in class. // Barbie()
3. Check whether the constructor is private. // Barbie() is not private.
4. Check whether the class has any subclasses. // No subclasses of Barbie.
5. Get the name of class. // Bar
2. Get all constructors declared in class. // Bar()
3. Check whether the constructor is private. // Bar() is private.
4. Check whether the class has any subclasses. // Barbie is a subclass.
5. Check whether the subclasses are in the same compilation unit. // Barbie is in the same compilation unit as Bar, so no violation here.

**Summary of Checks:**
- Foo has a public constructor and no private constructors, so it can be extended from outside its compilation unit.
- Bar has a private constructor, but Barbie extends it within the same compilation unit, so it does not violate the rule.

Thus, the number of violations in this test case is 0.
['Get the name of class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has any subclasses.', 'Check whether the subclasses are in the same compilation unit.', 'Get the name of class. // Foo', 'Get all constructors declared in class. // Foo()', 'Check whether the constructor is private. // Foo() is not private, so no violation here.', 'Check whether the class has any subclasses. // Bar and Barbie are subclasses of Foo.', 'Get the name of class. // Bar', 'Get all constructors declared in class. // Bar()', 'Check whether the constructor is private. // Bar() is private.', 'Check whether the class has any subclasses. // Barbie is a subclass of Bar.', 'Check whether the subclasses are in the same compilation unit. // Barbie is in the same compilation unit as Bar, so no violation here.', 'Get the name of class. // Barbie', 'Get all constructors declared in class. // Barbie()', 'Check whether the constructor is private. // Barbie() is not private.', 'Check whether the class has any subclasses. // No subclasses of Barbie.', 'Get the name of class. // Bar', 'Get all constructors declared in class. // Bar()', 'Check whether the constructor is private. // Bar() is private.', 'Check whether the class has any subclasses. // Barbie is a subclass.', 'Check whether the subclasses are in the same compilation unit. // Barbie is in the same compilation unit as Bar, so no violation here.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTExtendsList', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has any subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclasses are in the same compilation unit.* 匹配到的元操作或API：
query: Check whether the subclasses are in the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8610255122184753
*Get the name of class. // Foo* 匹配到的元操作或API：
logic: Get the name of class. // Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9075836539268494
*Get all constructors declared in class. // Foo()* 匹配到的元操作或API：
query: Get all constructors declared in class. // Foo()
most similar API: get declared annotations of constructor
cosine Similarity: 0.8264087438583374
*Check whether the constructor is private. // Foo() is not private, so no violation here.* 匹配到的元操作或API：
logic: Check whether the constructor is private. // Foo() is not private, so no violation here.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9283985495567322
*Check whether the class has any subclasses. // Bar and Barbie are subclasses of Foo.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class. // Bar* 匹配到的元操作或API：
logic: Get the name of class. // Bar
most similar meta operation: Get the name of class
cosine Similarity: 0.851296067237854
*Get all constructors declared in class. // Bar()* 匹配到的元操作或API：
query: Get all constructors declared in class. // Bar()
most similar API: get declared annotations of constructor
cosine Similarity: 0.8041475415229797
*Check whether the constructor is private. // Bar() is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private. // Bar() is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9099166393280029
*Check whether the class has any subclasses. // Barbie is a subclass of Bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclasses are in the same compilation unit. // Barbie is in the same compilation unit as Bar, so no violation here.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class. // Barbie* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors declared in class. // Barbie()* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private. // Barbie() is not private.* 匹配到的元操作或API：
logic: Check whether the constructor is private. // Barbie() is not private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9074723720550537
*Check whether the class has any subclasses. // No subclasses of Barbie.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class. // Bar* 匹配到的元操作或API：
logic: Get the name of class. // Bar
most similar meta operation: Get the name of class
cosine Similarity: 0.851296067237854
*Get all constructors declared in class. // Bar()* 匹配到的元操作或API：
query: Get all constructors declared in class. // Bar()
most similar API: get declared annotations of constructor
cosine Similarity: 0.8041475415229797
*Check whether the constructor is private. // Bar() is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private. // Bar() is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9099166393280029
*Check whether the class has any subclasses. // Barbie is a subclass.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclasses are in the same compilation unit. // Barbie is in the same compilation unit as Bar, so no violation here.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor of another subclass
public class Foo {
    public Foo() { }

    public static class Bar {
        private Bar() { }
    }

    public static class Barbie extends Bar {
        public Barbie() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Barbie')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                if (node.descendants(ASTClassOrInterfaceType.class).allMatch(ASTClassOrInterfaceType::isReferenceToClassSameCompilationUnit)) {
                    addViolation(data, node);
                }
            }
        }
        return data;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 5
[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is abstract.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Check whether all constructors are private.
6. Check whether the class is public.
7. Check whether the class has declared annotations.
8. Check whether the class is final.
9. Check whether the class has extended x class.
10. Get the super class of class.
11. Check whether the class has implemented x interface.
12. Get a implemented interface of class.
13. Get the name of the package where the class is located.
14. Check whether the class is static.
15. Check whether the class is inner class.
16. Check whether the class is anonymous class.

In this specific test case:
1. Get the name of class - FooUtils.
2. Check whether the class is abstract - True.
3. Get all constructors declared in class - private FooUtils().
4. Check whether the constructor is private - True.
5. Check whether all constructors are private - True (since there is only one constructor and it is private).
6. Check whether the class is public - True.
7. Check whether the class has declared annotations - False (no annotations are declared).
8. Check whether the class is final - False.
9. Check whether the class has extended x class - False (no super class is indicated).
10. Get the super class of class - java.lang.Object (default super class).
11. Check whether the class has implemented x interface - False (no interfaces are indicated).
12. Get a implemented interface of class - None (no interfaces).
13. Get the name of the package where the class is located - Not specified in the test case.
14. Check whether the class is static - False (it is not indicated as static).
15. Check whether the class is inner class - False (it is not nested within another class).
16. Check whether the class is anonymous class - False (it has a name, FooUtils).

Based on the above checks, the class FooUtils is a public abstract class with a private constructor and no superclasses or implemented interfaces, which means it cannot be extended from outside its compilation unit. Therefore, this test case violates the rule as it can be made final.
['Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether all constructors are private.', 'Check whether the class is public.', 'Check whether the class has declared annotations.', 'Check whether the class is final.', 'Check whether the class has extended x class.', 'Get the super class of class.', 'Check whether the class has implemented x interface.', 'Get a implemented interface of class.', 'Get the name of the package where the class is located.', 'Check whether the class is static.', 'Check whether the class is inner class.', 'Check whether the class is anonymous class.', 'Get the name of class - FooUtils.', 'Check whether the class is abstract - True.', 'Get all constructors declared in class - private FooUtils().', 'Check whether the constructor is private - True.', 'Check whether all constructors are private - True (since there is only one constructor and it is private).', 'Check whether the class is public - True.', 'Check whether the class has declared annotations - False (no annotations are declared).', 'Check whether the class is final - False.', 'Check whether the class has extended x class - False (no super class is indicated).', 'Get the super class of class - java.lang.Object (default super class).', 'Check whether the class has implemented x interface - False (no interfaces are indicated).', 'Get a implemented interface of class - None (no interfaces).', 'Get the name of the package where the class is located - Not specified in the test case.', 'Check whether the class is static - False (it is not indicated as static).', 'Check whether the class is inner class - False (it is not nested within another class).', 'Check whether the class is anonymous class - False (it has a name, FooUtils).']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether all constructors are private.* 匹配到的元操作或API：
logic: Check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.936521589756012
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class has implemented x interface.* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9905824661254883
*Get a implemented interface of class.* 匹配到的元操作或API：
logic: Get a implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9851537942886353
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.987544596195221
*Check whether the class is anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9849605560302734
*Get the name of class - FooUtils.* 匹配到的元操作或API：
logic: Get the name of class - FooUtils.
most similar meta operation: Get the name of class
cosine Similarity: 0.8746565580368042
*Check whether the class is abstract - True.* 匹配到的元操作或API：
logic: Check whether the class is abstract - True.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9597710371017456
*Get all constructors declared in class - private FooUtils().* 匹配到的元操作或API：
query: Get all constructors declared in class - private FooUtils().
most similar API: get declared annotations of constructor
cosine Similarity: 0.8125528693199158
*Check whether the constructor is private - True.* 匹配到的元操作或API：
logic: Check whether the constructor is private - True.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9701608419418335
*Check whether all constructors are private - True (since there is only one constructor and it is private).* 匹配到的元操作或API：
logic: Check whether all constructors are private - True (since there is only one constructor and it is private).
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8981084823608398
*Check whether the class is public - True.* 匹配到的元操作或API：
logic: Check whether the class is public - True.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.949048638343811
*Check whether the class has declared annotations - False (no annotations are declared).* 匹配到的元操作或API：
logic: Check whether the class has declared annotations - False (no annotations are declared).
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9336416125297546
*Check whether the class is final - False.* 匹配到的元操作或API：
logic: Check whether the class is final - False.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9450567960739136
*Check whether the class has extended x class - False (no super class is indicated).* 匹配到的元操作或API：
logic: Check whether the class has extended x class - False (no super class is indicated).
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9204477667808533
*Get the super class of class - java.lang.Object (default super class).* 匹配到的元操作或API：
logic: Get the super class of class - java.lang.Object (default super class).
most similar meta operation: Get the super class of class
cosine Similarity: 0.8751655220985413
*Check whether the class has implemented x interface - False (no interfaces are indicated).* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface - False (no interfaces are indicated).
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9339621067047119
*Get a implemented interface of class - None (no interfaces).* 匹配到的元操作或API：
logic: Get a implemented interface of class - None (no interfaces).
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9061991572380066
*Get the name of the package where the class is located - Not specified in the test case.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located - Not specified in the test case.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9153215885162354
*Check whether the class is static - False (it is not indicated as static).* 匹配到的元操作或API：
logic: Check whether the class is static - False (it is not indicated as static).
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9284578561782837
*Check whether the class is inner class - False (it is not nested within another class).* 匹配到的元操作或API：
logic: Check whether the class is inner class - False (it is not nested within another class).
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9066832065582275
*Check whether the class is anonymous class - False (it has a name, FooUtils).* 匹配到的元操作或API：
logic: Check whether the class is anonymous class - False (it has a name, FooUtils).
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.894443929195404
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}


This checker is failed(false negative) on this negative test case:
```
// Abstract outer classes should be flagged #3668
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'FooUtils')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getSuperInterfaceTypeNodes()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
11. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
12. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnonymous()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```
3.  //Check whether the class has implemented x interface
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node) {
    if (TypeTestUtil.isA(interfaceName.class, node)) {
        return true;
    }
    return false;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isFinal() && !hasNonPrivateConstructors(node)) {
            if (node.isNested() || node.getPackageName().isEmpty()) {
                addViolation(data, node);
            } else if (node.isAbstract()) {
                addViolation(data, node);
            }
        }
        return data;
    }

    private boolean hasNonPrivateConstructors(ASTClassOrInterfaceDeclaration node) {
        List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
        return constructors.stream().anyMatch(constructor -> !constructor.isPrivate());
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether class is abstract.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Check whether the class has no declared abstract methods.
6. Check whether the class is public.
7. Check whether the class is package-private.
8. Check whether the class is located in the same compilation unit as all its subclasses.
9. Check whether the class has no subclasses.

If the class is public or package-private, abstract, has no declared abstract methods, and all its constructors are private, then the class can be made final because it cannot be extended from outside its compilation unit. Given the test case:

- The class `FooUtils` is public.
- The class `FooUtils` is abstract.
- The class `FooUtils` has no declared abstract methods.
- The class `FooUtils` has a private constructor.

However, the test case does not provide information about whether `FooUtils` has subclasses or not. Assuming `FooUtils` does not have any subclasses, then the class can be made final, and it violates the rule.

To complete the checks:
10. Check whether the class `FooUtils` has subclasses.
11. Check whether the class `FooUtils` is located in the same compilation unit as its potential subclasses.

Given the assumptions, the test case violates the rule.
['Get the name of class.', 'Check whether class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has no declared abstract methods.', 'Check whether the class is public.', 'Check whether the class is package-private.', 'Check whether the class is located in the same compilation unit as all its subclasses.', 'Check whether the class has no subclasses.', 'Check whether the class `FooUtils` has subclasses.', 'Check whether the class `FooUtils` is located in the same compilation unit as its potential subclasses.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether class is abstract.* 匹配到的元操作或API：
logic: Check whether class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9810292720794678
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has no declared abstract methods.* 匹配到的元操作或API：
logic: Check whether the class has no declared abstract methods.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.8525617718696594
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is package-private.* 匹配到的元操作或API：
logic: Check whether the class is package-private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9225598573684692
*Check whether the class is located in the same compilation unit as all its subclasses.* 匹配到的元操作或API：
query: Check whether the class is located in the same compilation unit as all its subclasses.
most similar API: Check whether the compilation unit equals
cosine Similarity: 0.8271116614341736
*Check whether the class has no subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class `FooUtils` has subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class `FooUtils` is located in the same compilation unit as its potential subclasses.* 匹配到的元操作或API：
query: Check whether the class `FooUtils` is located in the same compilation unit as its potential subclasses.
most similar API: Check whether the compilation unit equals
cosine Similarity: 0.8047434687614441
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}


This checker is failed(false negative) on this negative test case:
```
// Abstract outer classes should be flagged #3668
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'FooUtils')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
8. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if ((!node.isNested() || !node.isFinal()) && !node.isFinal() && !node.isAbstract()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}, {'error_rules_info': '[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is abstract.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Check whether the constructor is static.
6. Check whether the class has any public constructors.
7. Check whether the class has any protected constructors.
8. Check whether the class has any default package-private constructors.

Let's perform these checks on the provided test case:

1. Get the name of class.
   - The name of the class is `FooUtils`.

2. Check whether the class is abstract.
   - `FooUtils` is declared as `abstract`.

3. Get all constructors declared in class.
   - There is one constructor declared in `FooUtils`.

4. Check whether the constructor is private.
   - The constructor is private.

5. Check whether the constructor is static.
   - The constructor is not static.

6. Check whether the class has any public constructors.
   - The class does not have any public constructors.

7. Check whether the class has any protected constructors.
   - The class does not have any protected constructors.

8. Check whether the class has any default package-private constructors.
   - The class does not have any default package-private constructors.

Since the class `FooUtils` is abstract and its constructor is private, it meets the criteria of the rule. Therefore, the number of violations in this test case is indeed 1.
['Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the constructor is static.', 'Check whether the class has any public constructors.', 'Check whether the class has any protected constructors.', 'Check whether the class has any default package-private constructors.', 'Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the constructor is static.', 'Check whether the class has any public constructors.', 'Check whether the class has any protected constructors.', 'Check whether the class has any default package-private constructors.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the constructor is static.* 匹配到的元操作或API：
logic: Check whether the constructor is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9065665602684021
*Check whether the class has any public constructors.* 匹配到的元操作或API：
logic: Check whether the class has any public constructors.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.8860493898391724
*Check whether the class has any protected constructors.* 匹配到的元操作或API：
logic: Check whether the class has any protected constructors.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9192208647727966
*Check whether the class has any default package-private constructors.* 匹配到的元操作或API：
logic: Check whether the class has any default package-private constructors.
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.9417352080345154
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the constructor is static.* 匹配到的元操作或API：
logic: Check whether the constructor is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9065665602684021
*Check whether the class has any public constructors.* 匹配到的元操作或API：
logic: Check whether the class has any public constructors.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.8860493898391724
*Check whether the class has any protected constructors.* 匹配到的元操作或API：
logic: Check whether the class has any protected constructors.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9192208647727966
*Check whether the class has any default package-private constructors.* 匹配到的元操作或API：
logic: Check whether the class has any default package-private constructors.
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.9417352080345154
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}


This checker is failed(false negative) on this negative test case:
```
// Abstract outer classes should be flagged #3668
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'FooUtils')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isProtected()
8. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPackagePrivate()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if ((node.isNested() || !node.isAbstract()) && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}, {'error_rules_info': '[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Check whether the class is abstract.
2. Get all constructors declared in class.
3. Check whether the constructor is private.
4. Check whether the class is public.

If the class is abstract, all its constructors are private, and the class is public, then this class may be made final because it cannot be extended from outside its compilation unit, thus violating the rule.
Based on the test case provided, the checks would be:

1. Check whether the class is abstract. (True, as `FooUtils` is declared as `abstract`)
2. Get all constructors declared in class. (One constructor found)
3. Check whether the constructor is private. (True, as the constructor is declared as `private`)
4. Check whether the class is public. (True, as `FooUtils` is declared as `public`)

Since all conditions are met, this test case violates the rule.
['Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is public.', 'Check whether the class is abstract. (True, as `FooUtils` is declared as `abstract`)', 'Get all constructors declared in class. (One constructor found)', 'Check whether the constructor is private. (True, as the constructor is declared as `private`)', 'Check whether the class is public. (True, as `FooUtils` is declared as `public`)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is abstract. (True, as `FooUtils` is declared as `abstract`)* 匹配到的元操作或API：
logic: Check whether the class is abstract. (True, as `FooUtils` is declared as `abstract`)
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.918623149394989
*Get all constructors declared in class. (One constructor found)* 匹配到的元操作或API：
query: Get all constructors declared in class. (One constructor found)
most similar API: get declared annotations of constructor
cosine Similarity: 0.821816086769104
*Check whether the constructor is private. (True, as the constructor is declared as `private`)* 匹配到的元操作或API：
logic: Check whether the constructor is private. (True, as the constructor is declared as `private`)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9602998495101929
*Check whether the class is public. (True, as `FooUtils` is declared as `public`)* 匹配到的元操作或API：
logic: Check whether the class is public. (True, as `FooUtils` is declared as `public`)
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9134255051612854
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}


This checker is failed(false negative) on this negative test case:
```
// Abstract outer classes should be flagged #3668
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'FooUtils')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if ((node.isNested() || node.isAbstract()) && !node.isFinal() && !node.isPublic()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Check whether the class is abstract.
2. Get the name of class.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Count the number of private constructors.
6. Check whether the number of private constructors is equal to the total number of constructors declared in the class.
7. Check whether the class has declared annotations.
8. Get the name of the package where the class is located.
9. Check whether the class is public.
10. Check whether the class is final.

If the class is abstract, has all constructors as private, and is public, then this class should be flagged as it can be made final. In this test case, the class `FooUtils` is abstract, has one private constructor, and is public. Therefore, this test case violates the rule.
['Check whether the class is abstract.', 'Get the name of class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Count the number of private constructors.', 'Check whether the number of private constructors is equal to the total number of constructors declared in the class.', 'Check whether the class has declared annotations.', 'Get the name of the package where the class is located.', 'Check whether the class is public.', 'Check whether the class is final.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Count the number of private constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the number of private constructors is equal to the total number of constructors declared in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}


This checker is failed(false negative) on this negative test case:
```
// Abstract outer classes should be flagged #3668
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'FooUtils')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class has any declared constructors.
3. Get the first declared constructor of class.
4. Check whether the constructor is private.
5. Check whether the class has more than one declared constructor.
6. If the class has more than one declared constructor, iterate through each constructor.
7. For each additional constructor, check whether it is private.
8. Check whether the class is public.
9. Check whether the class is final.
10. If all constructors are private and the class is public and not final, then this class may be made final.

Applying these checks to the provided test case:

1. Get the name of class.
   - The name of the first class is Example.
   - The name of the second class is Another.

2. Check whether the class has any declared constructors.
   - Example has a declared constructor.
   - Another does not have any declared constructors, so we can skip the further checks for Another.

3. Get the first declared constructor of class.
   - The first declared constructor of Example is private Example().

4. Check whether the constructor is private.
   - The constructor of Example is private.

5. Check whether the class has more than one declared constructor.
   - Example has only one declared constructor.

6. Check whether the class is public.
   - Example is public.

7. Check whether the class is final.
   - Example is not final.

Based on these checks, the class Example has a private constructor, is public, and is not final, which means it should be made final according to the rule description. Therefore, the test case is a false negative for the rule.
['Get the name of class.', 'Check whether the class has any declared constructors.', 'Get the first declared constructor of class.', 'Check whether the constructor is private.', 'Check whether the class has more than one declared constructor.', 'If the class has more than one declared constructor, iterate through each constructor.', 'For each additional constructor, check whether it is private.', 'Check whether the class is public.', 'Check whether the class is final.', 'If all constructors are private and the class is public and not final, then this class may be made final.', 'Get the name of class.', 'Check whether the class has any declared constructors.', 'Get the first declared constructor of class.', 'Check whether the constructor is private.', 'Check whether the class has more than one declared constructor.', 'Check whether the class is public.', 'Check whether the class is final.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has any declared constructors.* 匹配到的元操作或API：
logic: Check whether the class has any declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.872391939163208
*Get the first declared constructor of class.* 匹配到的元操作或API：
query: Get the first declared constructor of class.
most similar API: get first parent of type of constructor
cosine Similarity: 0.8463590145111084
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has more than one declared constructor.* 匹配到的元操作或API：
query: Check whether the class has more than one declared constructor.
most similar API: Check whether is declared in class
cosine Similarity: 0.8205291032791138
*If the class has more than one declared constructor, iterate through each constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each additional constructor, check whether it is private.* 匹配到的元操作或API：
logic: For each additional constructor, check whether it is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9191493988037109
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*If all constructors are private and the class is public and not final, then this class may be made final.* 匹配到的元操作或API：
query: If all constructors are private and the class is public and not final, then this class may be made final.
most similar API: Check whether the constructor is final
cosine Similarity: 0.8305604457855225
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has any declared constructors.* 匹配到的元操作或API：
logic: Check whether the class has any declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.872391939163208
*Get the first declared constructor of class.* 匹配到的元操作或API：
query: Get the first declared constructor of class.
most similar API: get first parent of type of constructor
cosine Similarity: 0.8463590145111084
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has more than one declared constructor.* 匹配到的元操作或API：
query: Check whether the class has more than one declared constructor.
most similar API: Check whether is declared in class
cosine Similarity: 0.8205291032791138
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false negative) on this negative test case:
```
// [java] ClassWithOnlyPrivateConstructorsShouldBeFinal - false negative when a compilation unit contains two class declarations #3851
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Example')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
——ASTClassOrInterfaceDeclaration (class name = 'Another')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public T getFirstParentOfType(java.lang.Class)
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.types.TypeTestUtil: static public boolean isDeclaredInClass(java.lang.Class, net.sourceforge.pmd.lang.java.types.JMethodSig), //Returns true if the signature is that of a method declared in the given class. @param klass Class @param sig   Method signature to test @throws NullPointerException If any argument is null
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isFinal()

1.  //Check whether constructor has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTConstructorDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if ((node.isNested() || node.isPublic()) && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is public.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Check the number of constructors in the class.
6. Check whether all constructors in the class are private.
7. Get the number of violating the rule in this test case.

Based on the provided test case and rule description, here are the granular checks:

1. Get the name of class. // Example
2. Check whether the class is public. // true
3. Get all constructors declared in class. // [Example()]
4. Check whether the constructor is private. // true
5. Check the number of constructors in the class. // 1
6. Check whether all constructors in the class are private. // true (since there's only one constructor and it's private)
7. Get the number of violating the rule in this test case. // 1 (Example class is public and all its constructors are private, but it is not final)

The issue here is that the rule checker is expected to report the `Example` class as a violation since it is not final, but the test case indicates that it is not being reported (false negative). Therefore, the rule checker should include an additional check to report such classes:

8. Check whether the class is final. // false (for the Example class)
9. Check whether the class is inner class. // false (for the Example class)
10. Check whether the class is anonymous class. // false (for the Example class)

If the class is public, all its constructors are private, and it is not final and not an inner or anonymous class, then it should be reported as a violation of the rule.
['Get the name of class.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check the number of constructors in the class.', 'Check whether all constructors in the class are private.', 'Get the number of violating the rule in this test case.', 'Get the name of class. // Example', 'Check whether the class is public. // true', 'Get all constructors declared in class. // [Example()]', 'Check whether the constructor is private. // true', 'Check the number of constructors in the class. // 1', "Check whether all constructors in the class are private. // true (since there's only one constructor and it's private)", 'Get the number of violating the rule in this test case. // 1 (Example class is public and all its constructors are private, but it is not final)', 'Check whether the class is final. // false (for the Example class)', 'Check whether the class is inner class. // false (for the Example class)', 'Check whether the class is anonymous class. // false (for the Example class)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check the number of constructors in the class.* 匹配到的元操作或API：
query: Check the number of constructors in the class.
most similar API: get num children of constructor
cosine Similarity: 0.8092023730278015
*Check whether all constructors in the class are private.* 匹配到的元操作或API：
logic: Check whether all constructors in the class are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9279559254646301
*Get the number of violating the rule in this test case.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class. // Example* 匹配到的元操作或API：
logic: Get the name of class. // Example
most similar meta operation: Get the name of class
cosine Similarity: 0.9158527851104736
*Check whether the class is public. // true* 匹配到的元操作或API：
logic: Check whether the class is public. // true
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9579840302467346
*Get all constructors declared in class. // [Example()]* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private. // true* 匹配到的元操作或API：
logic: Check whether the constructor is private. // true
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9698136448860168
*Check the number of constructors in the class. // 1* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether all constructors in the class are private. // true (since there's only one constructor and it's private)* 匹配到的元操作或API：
logic: Check whether all constructors in the class are private. // true (since there's only one constructor and it's private)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8988738059997559
*Get the number of violating the rule in this test case. // 1 (Example class is public and all its constructors are private, but it is not final)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is final. // false (for the Example class)* 匹配到的元操作或API：
logic: Check whether the class is final. // false (for the Example class)
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9530237317085266
*Check whether the class is inner class. // false (for the Example class)* 匹配到的元操作或API：
logic: Check whether the class is inner class. // false (for the Example class)
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9423022866249084
*Check whether the class is anonymous class. // false (for the Example class)* 匹配到的元操作或API：
logic: Check whether the class is anonymous class. // false (for the Example class)
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9406094551086426
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false negative) on this negative test case:
```
// [java] ClassWithOnlyPrivateConstructorsShouldBeFinal - false negative when a compilation unit contains two class declarations #3851
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Example')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
——ASTClassOrInterfaceDeclaration (class name = 'Another')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public int getNumChildren()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnonymous()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if ((node.isNested() || node.isPublic()) && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is public.
3. Get the number of constructors of class.
4. Get a constructor of class.
5. Check whether the constructor is private.
6. Repeat step 4 and step 5 for all constructors of class.
7. Check whether the class has any non-private constructors.
8. Check whether the class is declared as final.
9. Repeat steps 1 to 8 for all classes declared in the compilation unit.

In this test case:
1. Get the name of class: Example
2. Check whether the class is public: true
3. Get the number of constructors of class: 1
4. Get a constructor of class: private Example()
5. Check whether the constructor is private: true
6. No other constructors to check.
7. Check whether the class has any non-private constructors: false
8. Check whether the class is declared as final: false

Since the class `Example` is public and all its constructors are private, and it is not declared as final, it violates the rule. 

The class `Another` is not public and thus is not relevant to the rule.

Therefore, the number of violating the rule in this test case is 1.
['Get the name of class.', 'Check whether the class is public.', 'Get the number of constructors of class.', 'Get a constructor of class.', 'Check whether the constructor is private.', 'Repeat step 4 and step 5 for all constructors of class.', 'Check whether the class has any non-private constructors.', 'Check whether the class is declared as final.', 'Repeat steps 1 to 8 for all classes declared in the compilation unit.', 'Get the name of class: Example', 'Check whether the class is public: true', 'Get the number of constructors of class: 1', 'Get a constructor of class: private Example()', 'Check whether the constructor is private: true', 'No other constructors to check.', 'Check whether the class has any non-private constructors: false', 'Check whether the class is declared as final: false']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get the number of constructors of class.* 匹配到的元操作或API：
query: Get the number of constructors of class.
most similar API: get num children of constructor
cosine Similarity: 0.8339141607284546
*Get a constructor of class.* 匹配到的元操作或API：
query: Get a constructor of class.
most similar API: get class of constructor
cosine Similarity: 0.8336949348449707
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Repeat step 4 and step 5 for all constructors of class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has any non-private constructors.* 匹配到的元操作或API：
logic: Check whether the class has any non-private constructors.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8846951127052307
*Check whether the class is declared as final.* 匹配到的元操作或API：
logic: Check whether the class is declared as final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.954788088798523
*Repeat steps 1 to 8 for all classes declared in the compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: Example* 匹配到的元操作或API：
logic: Get the name of class: Example
most similar meta operation: Get the name of class
cosine Similarity: 0.9322656989097595
*Check whether the class is public: true* 匹配到的元操作或API：
logic: Check whether the class is public: true
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9707064628601074
*Get the number of constructors of class: 1* 匹配到的元操作或API：
query: Get the number of constructors of class: 1
most similar API: get num children of constructor
cosine Similarity: 0.8422114849090576
*Get a constructor of class: private Example()* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: true* 匹配到的元操作或API：
logic: Check whether the constructor is private: true
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9794564843177795
*No other constructors to check.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has any non-private constructors: false* 匹配到的元操作或API：
logic: Check whether the class has any non-private constructors: false
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8940180540084839
*Check whether the class is declared as final: false* 匹配到的元操作或API：
logic: Check whether the class is declared as final: false
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9134640097618103
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false negative) on this negative test case:
```
// [java] ClassWithOnlyPrivateConstructorsShouldBeFinal - false negative when a compilation unit contains two class declarations #3851
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Example')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
——ASTClassOrInterfaceDeclaration (class name = 'Another')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public int getNumChildren()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && !node.isAbstract() && !node.isFinal()) {
            ASTCompilationUnit compilationUnit = node.getFirstParentOfType(ASTCompilationUnit.class);
            List<ASTClassOrInterfaceDeclaration> classes = compilationUnit.descendants(ASTClassOrInterfaceDeclaration.class).collect(Collectors.toList());
            if (classes.size() == 1) {
                List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
                if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                    addViolation(data, node);
                }
            }
        }
        return data;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Check whether the class is public.
        3. Get all constructors declared in class.
        4. Check whether the constructor is private.
        5. Check whether the class is final.

For the first class `Example`:
1. Get the name of class.
        2. Check whether the class is public. // true for Example
        3. Get all constructors declared in class. // get private Example constructor
        4. Check whether the constructor is private. // true for Example
        5. Check whether the class is final. // false for Example

If a public class has all its constructors declared as private and is not final, then it violates the rule.

For the second class `Another`:
1. Get the name of class.
        2. Check whether the class is public. // false for Another
        3. Get all constructors declared in class. // get default Another constructor (package-private)
        4. Check whether the constructor is private. // false for Another
        5. Check whether the class is final. // false for Another

The second class `Another` does not have a private constructor and is not public, so it does not violate the rule.

The number of violating the rule in this test case is: 1 (only `Example` class violates the rule).
['Get the name of class.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is final.', 'Get the name of class.', 'Check whether the class is public. // true for Example', 'Get all constructors declared in class. // get private Example constructor', 'Check whether the constructor is private. // true for Example', 'Check whether the class is final. // false for Example', 'Get the name of class.', 'Check whether the class is public. // false for Another', 'Get all constructors declared in class. // get default Another constructor (package-private)', 'Check whether the constructor is private. // false for Another', 'Check whether the class is final. // false for Another']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public. // true for Example* 匹配到的元操作或API：
logic: Check whether the class is public. // true for Example
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9532605409622192
*Get all constructors declared in class. // get private Example constructor* 匹配到的元操作或API：
query: Get all constructors declared in class. // get private Example constructor
most similar API: get declared annotations of constructor
cosine Similarity: 0.8005763292312622
*Check whether the constructor is private. // true for Example* 匹配到的元操作或API：
logic: Check whether the constructor is private. // true for Example
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.968124270439148
*Check whether the class is final. // false for Example* 匹配到的元操作或API：
logic: Check whether the class is final. // false for Example
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9660226106643677
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public. // false for Another* 匹配到的元操作或API：
logic: Check whether the class is public. // false for Another
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9439491033554077
*Get all constructors declared in class. // get default Another constructor (package-private)* 匹配到的元操作或API：
query: Get all constructors declared in class. // get default Another constructor (package-private)
most similar API: get declared annotations of constructor
cosine Similarity: 0.8120131492614746
*Check whether the constructor is private. // false for Another* 匹配到的元操作或API：
logic: Check whether the constructor is private. // false for Another
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.963811457157135
*Check whether the class is final. // false for Another* 匹配到的元操作或API：
logic: Check whether the class is final. // false for Another
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9622673988342285
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false negative) on this negative test case:
```
// [java] ClassWithOnlyPrivateConstructorsShouldBeFinal - false negative when a compilation unit contains two class declarations #3851
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Example')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
——ASTClassOrInterfaceDeclaration (class name = 'Another')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        ASTCompilationUnit compilationUnit = node.getFirstParentOfType(ASTCompilationUnit.class);
        List<ASTClassOrInterfaceDeclaration> classesInUnit = compilationUnit.children(ASTClassOrInterfaceDeclaration.class).collect(Collectors.toList());

        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate) && classesInUnit.size() > 1) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}, {'error_rules_info': '[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class has declared annotations.
3. Get the declared annotations of class.
4. Check whether the class is abstract.
5. Get the constructors declared in class.
6. Check whether the constructor is private.
7. Check whether the class is public.
8. Check whether the class is final.
9. Get the number of constructors declared in class.
10. Check whether all constructors are private.

For the `Example` class:
1. Get the name of class. // Example
2. Check whether the class has declared annotations. // false
3. Get the declared annotations of class. // N/A
4. Check whether the class is abstract. // false
5. Get the constructors declared in class. // Constructor Example, private Example()
6. Check whether the constructor is private. // true for Example()
7. Check whether the class is public. // true
8. Check whether the class is final. // false
9. Get the number of constructors declared in class. // 1
10. Check whether all constructors are private. // true

The `Example` class has a public non-final constructor that is private, and since it is the only constructor and it is private, it cannot be extended from outside its compilation unit. Therefore, this test case violates the rule. 

For the `Another` class:
1. Get the name of class. // Another
2. Check whether the class has declared annotations. // false
3. Get the declared annotations of class. // N/A
4. Check whether the class is abstract. // false
5. Get the constructors declared in class. // Constructor Another, default constructor
6. Check whether the constructor is private. // false for default constructor
7. Check whether the class is public. // false
8. Check whether the class is final. // false
9. Get the number of constructors declared in class. // 1 (default constructor)
10. Check whether all constructors are private. // false

The `Another` class does not have a private constructor and is not public, so it does not violate the rule.

Based on the checks, the number of classes violating the rule in this test case is 1, which is the `Example` class.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get the declared annotations of class.', 'Check whether the class is abstract.', 'Get the constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is public.', 'Check whether the class is final.', 'Get the number of constructors declared in class.', 'Check whether all constructors are private.', 'Get the name of class. // Example', 'Check whether the class has declared annotations. // false', 'Get the declared annotations of class. // N/A', 'Check whether the class is abstract. // false', 'Get the constructors declared in class. // Constructor Example, private Example()', 'Check whether the constructor is private. // true for Example()', 'Check whether the class is public. // true', 'Check whether the class is final. // false', 'Get the number of constructors declared in class. // 1', 'Check whether all constructors are private. // true', 'Get the name of class. // Another', 'Check whether the class has declared annotations. // false', 'Get the declared annotations of class. // N/A', 'Check whether the class is abstract. // false', 'Get the constructors declared in class. // Constructor Another, default constructor', 'Check whether the constructor is private. // false for default constructor', 'Check whether the class is public. // false', 'Check whether the class is final. // false', 'Get the number of constructors declared in class. // 1 (default constructor)', 'Check whether all constructors are private. // false']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTBlock', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the declared annotations of class.* 匹配到的元操作或API：
logic: Get the declared annotations of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9313310384750366
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get the constructors declared in class.* 匹配到的元操作或API：
query: Get the constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8616834878921509
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get the number of constructors declared in class.* 匹配到的元操作或API：
query: Get the number of constructors declared in class.
most similar API: get num children of constructor
cosine Similarity: 0.8205664157867432
*Check whether all constructors are private.* 匹配到的元操作或API：
logic: Check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.936521589756012
*Get the name of class. // Example* 匹配到的元操作或API：
logic: Get the name of class. // Example
most similar meta operation: Get the name of class
cosine Similarity: 0.9158527851104736
*Check whether the class has declared annotations. // false* 匹配到的元操作或API：
logic: Check whether the class has declared annotations. // false
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9573260545730591
*Get the declared annotations of class. // N/A* 匹配到的元操作或API：
logic: Get the declared annotations of class. // N/A
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9133481383323669
*Check whether the class is abstract. // false* 匹配到的元操作或API：
logic: Check whether the class is abstract. // false
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.948445737361908
*Get the constructors declared in class. // Constructor Example, private Example()* 匹配到的元操作或API：
query: Get the constructors declared in class. // Constructor Example, private Example()
most similar API: get declared annotations of constructor
cosine Similarity: 0.8120660781860352
*Check whether the constructor is private. // true for Example()* 匹配到的元操作或API：
logic: Check whether the constructor is private. // true for Example()
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9400739073753357
*Check whether the class is public. // true* 匹配到的元操作或API：
logic: Check whether the class is public. // true
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9579840302467346
*Check whether the class is final. // false* 匹配到的元操作或API：
logic: Check whether the class is final. // false
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9634147882461548
*Get the number of constructors declared in class. // 1* 匹配到的元操作或API：
query: Get the number of constructors declared in class. // 1
most similar API: get num children of constructor
cosine Similarity: 0.8142887353897095
*Check whether all constructors are private. // true* 匹配到的元操作或API：
logic: Check whether all constructors are private. // true
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9219534993171692
*Get the name of class. // Another* 匹配到的元操作或API：
logic: Get the name of class. // Another
most similar meta operation: Get the name of class
cosine Similarity: 0.9021028876304626
*Check whether the class has declared annotations. // false* 匹配到的元操作或API：
logic: Check whether the class has declared annotations. // false
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9573260545730591
*Get the declared annotations of class. // N/A* 匹配到的元操作或API：
logic: Get the declared annotations of class. // N/A
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9133481383323669
*Check whether the class is abstract. // false* 匹配到的元操作或API：
logic: Check whether the class is abstract. // false
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.948445737361908
*Get the constructors declared in class. // Constructor Another, default constructor* 匹配到的元操作或API：
query: Get the constructors declared in class. // Constructor Another, default constructor
most similar API: get declared annotations of constructor
cosine Similarity: 0.8192453384399414
*Check whether the constructor is private. // false for default constructor* 匹配到的元操作或API：
logic: Check whether the constructor is private. // false for default constructor
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9572857618331909
*Check whether the class is public. // false* 匹配到的元操作或API：
logic: Check whether the class is public. // false
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9521342515945435
*Check whether the class is final. // false* 匹配到的元操作或API：
logic: Check whether the class is final. // false
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9634147882461548
*Get the number of constructors declared in class. // 1 (default constructor)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether all constructors are private. // false* 匹配到的元操作或API：
logic: Check whether all constructors are private. // false
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9154027700424194
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```

This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false negative) on this negative test case:
```
// [java] ClassWithOnlyPrivateConstructorsShouldBeFinal - false negative when a compilation unit contains two class declarations #3851
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Example')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
——ASTClassOrInterfaceDeclaration (class name = 'Another')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
8. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public int getNumChildren()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}, {'error_rules_info': '[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 7
[ERROR]   "ok 9" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
107
91
94
78
111
94
95
80
94
78
=========================error_testcase_logics=========================
To verify the adherence of the test case to the rule, let's perform granular checks on the given Java code:

1. Get the name of class `Main209`.
2. Get a declared annotation of class `Main209`.
3. Check whether class `Main209` has x annotation.
4. Check whether class `Main209` is abstract.
5. Check whether class `Main209` is public.
6. Check whether class `Main209` is private.
7. Check whether class `Main209` is protected.
8. Check whether class `Main209` is default package-private.
9. Check whether class `Main209` is final.
10. Check whether class `Main209` is static.
11. Get the super class of class `Main209`.
12. Get a declared annotation of class `Main209`.
13. Check whether class `Main209` has x annotation.
14. Get a declared annotation of class `Main209`.
15. Check whether the class has x annotation.
16. Get a declared annotation of class `Main209`.
17. Check whether class `Main209` is interface.
18. Get an implemented interface of class `Main209`.
19. Check whether class `Main209` has implemented x interface.
20. Get the name of inner class `InputBits`.
21. Check whether inner class `InputBits` has declared annotations.
22. Check whether inner class `InputBits` has x annotation.
23. Check whether inner class `InputBits` is abstract.
24. Check whether inner class `InputBits` is public.
25. Check whether inner class `InputBits` is private.
26. Check whether inner class `InputBits` is protected.
27. Check whether inner class `InputBits` is default package-private.
28. Check whether inner class `InputBits` is final.
29. Check whether inner class `InputBits` is static.
30. Get the super class of inner class `InputBits`.
31. Get a declared annotation of inner class `InputBits`.
32. Check whether inner class `InputBits` has x annotation.
33. Get a declared annotation of inner class `InputBits`.
34. Check whether inner class `InputBits` has implemented x interface.
35. Get a declared annotation of inner class `InputBits`.
36. Check whether inner class `InputBits` is interface.
37. Get a constructor of inner class `InputBits`.
38. Check whether the constructor is private.
39. Get the name of inner class `Sub`.
40. Check whether inner class `Sub` has declared annotations.
41. Check whether inner class `Sub` has x annotation.
42. Check whether inner class `Sub` is abstract.
43. Check whether inner class `Sub` is public.
44. Check whether inner class `Sub` is private.
45. Check whether inner class `Sub` is protected.
46. Check whether inner class `Sub` is default package-private.
47. Check whether inner class `Sub` is final.
48. Check whether inner class `Sub` is static.
49. Get the superclass of inner class `Sub`.
50. Check whether super class `InputBits` is in the same compilation unit as `Sub`.

Perform the checks:

1. The name of the class is `Main209`.
2. No annotations are declared on class `Main209`.
3. Class `Main209` does not have any specific annotation.
4. Class `Main209` is not abstract.
5. Class `Main209` is public.
6. Class `Main209` is not private.
7. Class `Main209` is not protected.
8. Class `Main209` is not default package-private.
9. Class `Main209` is not final.
10. Class `Main209` is not static.
11. The super class of `Main209` is `Object`.
12. No annotations are declared on class `Main209`.
13. Class `Main209` does not have any specific annotation.
14. No annotations are declared on class `Main209`.
15. Class `Main209` does not have any specific annotation.
16. No annotations are declared on class `Main209`.
17. Class `Main209` is not an interface.
18. No interfaces are implemented by class `Main209`.
19. Class `Main209` has not implemented any specific interface.
20. The name of inner class is `InputBits`.
21. No annotations are declared on inner class `InputBits`.
22. Inner class `InputBits` does not have any specific annotation.
23. Inner class `InputBits` is not abstract.
24. Inner class `InputBits` is not public.
25. Inner class `InputBits` is private.
26. Inner class `InputBits` is not protected.
27. Inner class `InputBits` is not default package-private.
28. Inner class `InputBits` is not final.
29. Inner class `InputBits` is static.
30. The super class of `InputBits` is `Object`.
31. No annotations are declared on inner class `InputBits`.
32. Inner class `InputBits` does not have any specific annotation.
33. No annotations are declared on inner class `InputBits`.
34. No interfaces are implemented by inner class `InputBits`.
35. Inner class `InputBits` has not implemented any specific interface.
36. Inner class `InputBits` is not an interface.
37. Inner class `InputBits` has a constructor.
38. The constructor of `InputBits` is private.
39. The name of inner class is `Sub`.
40. No annotations are declared on inner class `Sub`.
41. Inner class `Sub` does not have any specific annotation.
42. Inner class `Sub` is not abstract.
43. Inner class `Sub` is public.
44. Inner class `Sub` is not private.
45. Inner class `Sub` is not protected.
46. Inner class `Sub` is not default package-private.
47. Inner class `Sub` is final.
48. Inner class `Sub` is static.
49. The super class of `Sub` is `InputBits`.
50. The superclass `InputBits` is in the same compilation unit as `Sub`.

Since `InputBits` is private and has a private constructor, it cannot be extended from outside its compilation unit. Therefore, `Sub` extending `InputBits` within the same compilation unit does not violate the rule. Additionally, `InputBits` itself does not need to be final because it cannot be extended from outside its compilation unit. Thus, the number of violations in this test case is indeed 0.
['Get the name of class `Main209`.', 'Get a declared annotation of class `Main209`.', 'Check whether class `Main209` has x annotation.', 'Check whether class `Main209` is abstract.', 'Check whether class `Main209` is public.', 'Check whether class `Main209` is private.', 'Check whether class `Main209` is protected.', 'Check whether class `Main209` is default package-private.', 'Check whether class `Main209` is final.', 'Check whether class `Main209` is static.', 'Get the super class of class `Main209`.', 'Get a declared annotation of class `Main209`.', 'Check whether class `Main209` has x annotation.', 'Get a declared annotation of class `Main209`.', 'Check whether the class has x annotation.', 'Get a declared annotation of class `Main209`.', 'Check whether class `Main209` is interface.', 'Get an implemented interface of class `Main209`.', 'Check whether class `Main209` has implemented x interface.', 'Get the name of inner class `InputBits`.', 'Check whether inner class `InputBits` has declared annotations.', 'Check whether inner class `InputBits` has x annotation.', 'Check whether inner class `InputBits` is abstract.', 'Check whether inner class `InputBits` is public.', 'Check whether inner class `InputBits` is private.', 'Check whether inner class `InputBits` is protected.', 'Check whether inner class `InputBits` is default package-private.', 'Check whether inner class `InputBits` is final.', 'Check whether inner class `InputBits` is static.', 'Get the super class of inner class `InputBits`.', 'Get a declared annotation of inner class `InputBits`.', 'Check whether inner class `InputBits` has x annotation.', 'Get a declared annotation of inner class `InputBits`.', 'Check whether inner class `InputBits` has implemented x interface.', 'Get a declared annotation of inner class `InputBits`.', 'Check whether inner class `InputBits` is interface.', 'Get a constructor of inner class `InputBits`.', 'Check whether the constructor is private.', 'Get the name of inner class `Sub`.', 'Check whether inner class `Sub` has declared annotations.', 'Check whether inner class `Sub` has x annotation.', 'Check whether inner class `Sub` is abstract.', 'Check whether inner class `Sub` is public.', 'Check whether inner class `Sub` is private.', 'Check whether inner class `Sub` is protected.', 'Check whether inner class `Sub` is default package-private.', 'Check whether inner class `Sub` is final.', 'Check whether inner class `Sub` is static.', 'Get the superclass of inner class `Sub`.', 'Check whether super class `InputBits` is in the same compilation unit as `Sub`.', 'The name of the class is `Main209`.', 'No annotations are declared on class `Main209`.', 'Class `Main209` does not have any specific annotation.', 'Class `Main209` is not abstract.', 'Class `Main209` is public.', 'Class `Main209` is not private.', 'Class `Main209` is not protected.', 'Class `Main209` is not default package-private.', 'Class `Main209` is not final.', 'Class `Main209` is not static.', 'The super class of `Main209` is `Object`.', 'No annotations are declared on class `Main209`.', 'Class `Main209` does not have any specific annotation.', 'No annotations are declared on class `Main209`.', 'Class `Main209` does not have any specific annotation.', 'No annotations are declared on class `Main209`.', 'Class `Main209` is not an interface.', 'No interfaces are implemented by class `Main209`.', 'Class `Main209` has not implemented any specific interface.', 'The name of inner class is `InputBits`.', 'No annotations are declared on inner class `InputBits`.', 'Inner class `InputBits` does not have any specific annotation.', 'Inner class `InputBits` is not abstract.', 'Inner class `InputBits` is not public.', 'Inner class `InputBits` is private.', 'Inner class `InputBits` is not protected.', 'Inner class `InputBits` is not default package-private.', 'Inner class `InputBits` is not final.', 'Inner class `InputBits` is static.', 'The super class of `InputBits` is `Object`.', 'No annotations are declared on inner class `InputBits`.', 'Inner class `InputBits` does not have any specific annotation.', 'No annotations are declared on inner class `InputBits`.', 'No interfaces are implemented by inner class `InputBits`.', 'Inner class `InputBits` has not implemented any specific interface.', 'Inner class `InputBits` is not an interface.', 'Inner class `InputBits` has a constructor.', 'The constructor of `InputBits` is private.', 'The name of inner class is `Sub`.', 'No annotations are declared on inner class `Sub`.', 'Inner class `Sub` does not have any specific annotation.', 'Inner class `Sub` is not abstract.', 'Inner class `Sub` is public.', 'Inner class `Sub` is not private.', 'Inner class `Sub` is not protected.', 'Inner class `Sub` is not default package-private.', 'Inner class `Sub` is final.', 'Inner class `Sub` is static.', 'The super class of `Sub` is `InputBits`.', 'The superclass `InputBits` is in the same compilation unit as `Sub`.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'ASTExplicitConstructorInvocation', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTExtendsList', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class `Main209`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get a declared annotation of class `Main209`.* 匹配到的元操作或API：
logic: Get a declared annotation of class `Main209`.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.8999205827713013
*Check whether class `Main209` has x annotation.* 匹配到的元操作或API：
logic: Check whether class `Main209` has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9305610060691833
*Check whether class `Main209` is abstract.* 匹配到的元操作或API：
logic: Check whether class `Main209` is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9071685075759888
*Check whether class `Main209` is public.* 匹配到的元操作或API：
logic: Check whether class `Main209` is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9087976217269897
*Check whether class `Main209` is private.* 匹配到的元操作或API：
logic: Check whether class `Main209` is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9067130088806152
*Check whether class `Main209` is protected.* 匹配到的元操作或API：
logic: Check whether class `Main209` is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.8921819925308228
*Check whether class `Main209` is default package-private.* 匹配到的元操作或API：
logic: Check whether class `Main209` is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.938906729221344
*Check whether class `Main209` is final.* 匹配到的元操作或API：
logic: Check whether class `Main209` is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9182958006858826
*Check whether class `Main209` is static.* 匹配到的元操作或API：
logic: Check whether class `Main209` is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.8808242082595825
*Get the super class of class `Main209`.* 匹配到的元操作或API：
logic: Get the super class of class `Main209`.
most similar meta operation: Get the super class of class
cosine Similarity: 0.8535882234573364
*Get a declared annotation of class `Main209`.* 匹配到的元操作或API：
logic: Get a declared annotation of class `Main209`.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.8999205827713013
*Check whether class `Main209` has x annotation.* 匹配到的元操作或API：
logic: Check whether class `Main209` has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9305610060691833
*Get a declared annotation of class `Main209`.* 匹配到的元操作或API：
logic: Get a declared annotation of class `Main209`.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.8999205827713013
*Check whether the class has x annotation.* 匹配到的元操作或API：
logic: Check whether the class has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9908236265182495
*Get a declared annotation of class `Main209`.* 匹配到的元操作或API：
logic: Get a declared annotation of class `Main209`.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.8999205827713013
*Check whether class `Main209` is interface.* 匹配到的元操作或API：
logic: Check whether class `Main209` is interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.8937015533447266
*Get an implemented interface of class `Main209`.* 匹配到的元操作或API：
logic: Get an implemented interface of class `Main209`.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.8971107602119446
*Check whether class `Main209` has implemented x interface.* 匹配到的元操作或API：
logic: Check whether class `Main209` has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9373771548271179
*Get the name of inner class `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether inner class `InputBits` has declared annotations.* 匹配到的元操作或API：
logic: Check whether inner class `InputBits` has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.8608018159866333
*Check whether inner class `InputBits` has x annotation.* 匹配到的元操作或API：
logic: Check whether inner class `InputBits` has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.8744522333145142
*Check whether inner class `InputBits` is abstract.* 匹配到的元操作或API：
query: Check whether inner class `InputBits` is abstract.
most similar API: Check whether the class or interface is syntactically abstract
cosine Similarity: 0.8324155807495117
*Check whether inner class `InputBits` is public.* 匹配到的元操作或API：
query: Check whether inner class `InputBits` is public.
most similar API: Check whether the class or interface is public
cosine Similarity: 0.8292168378829956
*Check whether inner class `InputBits` is private.* 匹配到的元操作或API：
query: Check whether inner class `InputBits` is private.
most similar API: Check whether the class or interface is private
cosine Similarity: 0.8267276883125305
*Check whether inner class `InputBits` is protected.* 匹配到的元操作或API：
query: Check whether inner class `InputBits` is protected.
most similar API: Check whether the class or interface is protected
cosine Similarity: 0.8150290250778198
*Check whether inner class `InputBits` is default package-private.* 匹配到的元操作或API：
logic: Check whether inner class `InputBits` is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.8767026662826538
*Check whether inner class `InputBits` is final.* 匹配到的元操作或API：
logic: Check whether inner class `InputBits` is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.8562084436416626
*Check whether inner class `InputBits` is static.* 匹配到的元操作或API：
query: Check whether inner class `InputBits` is static.
most similar API: Check whether the class or interface is static
cosine Similarity: 0.8118733167648315
*Get the super class of inner class `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get a declared annotation of inner class `InputBits`.* 匹配到的元操作或API：
query: Get a declared annotation of inner class `InputBits`.
most similar API: get declared annotations of class or interface
cosine Similarity: 0.8139389753341675
*Check whether inner class `InputBits` has x annotation.* 匹配到的元操作或API：
logic: Check whether inner class `InputBits` has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.8744522333145142
*Get a declared annotation of inner class `InputBits`.* 匹配到的元操作或API：
query: Get a declared annotation of inner class `InputBits`.
most similar API: get declared annotations of class or interface
cosine Similarity: 0.8139389753341675
*Check whether inner class `InputBits` has implemented x interface.* 匹配到的元操作或API：
logic: Check whether inner class `InputBits` has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.8963501453399658
*Get a declared annotation of inner class `InputBits`.* 匹配到的元操作或API：
query: Get a declared annotation of inner class `InputBits`.
most similar API: get declared annotations of class or interface
cosine Similarity: 0.8139389753341675
*Check whether inner class `InputBits` is interface.* 匹配到的元操作或API：
logic: Check whether inner class `InputBits` is interface.
most similar meta operation: Check whether the interface is inner interface
cosine Similarity: 0.8653053641319275
*Get a constructor of inner class `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the name of inner class `Sub`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether inner class `Sub` has declared annotations.* 匹配到的元操作或API：
logic: Check whether inner class `Sub` has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.8762266635894775
*Check whether inner class `Sub` has x annotation.* 匹配到的元操作或API：
logic: Check whether inner class `Sub` has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.8902726173400879
*Check whether inner class `Sub` is abstract.* 匹配到的元操作或API：
logic: Check whether inner class `Sub` is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.866771399974823
*Check whether inner class `Sub` is public.* 匹配到的元操作或API：
logic: Check whether inner class `Sub` is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.856698751449585
*Check whether inner class `Sub` is private.* 匹配到的元操作或API：
logic: Check whether inner class `Sub` is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.8650683164596558
*Check whether inner class `Sub` is protected.* 匹配到的元操作或API：
query: Check whether inner class `Sub` is protected.
most similar API: Check whether the constructor is protected
cosine Similarity: 0.8134450912475586
*Check whether inner class `Sub` is default package-private.* 匹配到的元操作或API：
logic: Check whether inner class `Sub` is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.912830650806427
*Check whether inner class `Sub` is final.* 匹配到的元操作或API：
logic: Check whether inner class `Sub` is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.8732935786247253
*Check whether inner class `Sub` is static.* 匹配到的元操作或API：
query: Check whether inner class `Sub` is static.
most similar API: Check whether the class or interface is syntactically static
cosine Similarity: 0.8121033906936646
*Get the superclass of inner class `Sub`.* 匹配到的元操作或API：
logic: Get the superclass of inner class `Sub`.
most similar meta operation: Get the super class of class
cosine Similarity: 0.8597245216369629
*Check whether super class `InputBits` is in the same compilation unit as `Sub`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The name of the class is `Main209`.* 匹配到的元操作或API：
未匹配成功元操作或API
*No annotations are declared on class `Main209`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Class `Main209` does not have any specific annotation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Class `Main209` is not abstract.* 匹配到的元操作或API：
未匹配成功元操作或API
*Class `Main209` is public.* 匹配到的元操作或API：
未匹配成功元操作或API
*Class `Main209` is not private.* 匹配到的元操作或API：
未匹配成功元操作或API
*Class `Main209` is not protected.* 匹配到的元操作或API：
未匹配成功元操作或API
*Class `Main209` is not default package-private.* 匹配到的元操作或API：
未匹配成功元操作或API
*Class `Main209` is not final.* 匹配到的元操作或API：
未匹配成功元操作或API
*Class `Main209` is not static.* 匹配到的元操作或API：
未匹配成功元操作或API
*The super class of `Main209` is `Object`.* 匹配到的元操作或API：
未匹配成功元操作或API
*No annotations are declared on class `Main209`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Class `Main209` does not have any specific annotation.* 匹配到的元操作或API：
未匹配成功元操作或API
*No annotations are declared on class `Main209`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Class `Main209` does not have any specific annotation.* 匹配到的元操作或API：
未匹配成功元操作或API
*No annotations are declared on class `Main209`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Class `Main209` is not an interface.* 匹配到的元操作或API：
未匹配成功元操作或API
*No interfaces are implemented by class `Main209`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Class `Main209` has not implemented any specific interface.* 匹配到的元操作或API：
未匹配成功元操作或API
*The name of inner class is `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
*No annotations are declared on inner class `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Inner class `InputBits` does not have any specific annotation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Inner class `InputBits` is not abstract.* 匹配到的元操作或API：
未匹配成功元操作或API
*Inner class `InputBits` is not public.* 匹配到的元操作或API：
未匹配成功元操作或API
*Inner class `InputBits` is private.* 匹配到的元操作或API：
未匹配成功元操作或API
*Inner class `InputBits` is not protected.* 匹配到的元操作或API：
未匹配成功元操作或API
*Inner class `InputBits` is not default package-private.* 匹配到的元操作或API：
未匹配成功元操作或API
*Inner class `InputBits` is not final.* 匹配到的元操作或API：
未匹配成功元操作或API
*Inner class `InputBits` is static.* 匹配到的元操作或API：
未匹配成功元操作或API
*The super class of `InputBits` is `Object`.* 匹配到的元操作或API：
未匹配成功元操作或API
*No annotations are declared on inner class `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Inner class `InputBits` does not have any specific annotation.* 匹配到的元操作或API：
未匹配成功元操作或API
*No annotations are declared on inner class `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
*No interfaces are implemented by inner class `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Inner class `InputBits` has not implemented any specific interface.* 匹配到的元操作或API：
未匹配成功元操作或API
*Inner class `InputBits` is not an interface.* 匹配到的元操作或API：
未匹配成功元操作或API
*Inner class `InputBits` has a constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*The constructor of `InputBits` is private.* 匹配到的元操作或API：
未匹配成功元操作或API
*The name of inner class is `Sub`.* 匹配到的元操作或API：
未匹配成功元操作或API
*No annotations are declared on inner class `Sub`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Inner class `Sub` does not have any specific annotation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Inner class `Sub` is not abstract.* 匹配到的元操作或API：
未匹配成功元操作或API
*Inner class `Sub` is public.* 匹配到的元操作或API：
未匹配成功元操作或API
*Inner class `Sub` is not private.* 匹配到的元操作或API：
未匹配成功元操作或API
*Inner class `Sub` is not protected.* 匹配到的元操作或API：
未匹配成功元操作或API
*Inner class `Sub` is not default package-private.* 匹配到的元操作或API：
未匹配成功元操作或API
*Inner class `Sub` is final.* 匹配到的元操作或API：
未匹配成功元操作或API
*Inner class `Sub` is static.* 匹配到的元操作或API：
未匹配成功元操作或API
*The super class of `Sub` is `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The superclass `InputBits` is in the same compilation unit as `Sub`.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Inner class with only private constructor extended within compilation unit (#2536)
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
    public static final class Sub extends InputBits {
        private Sub() {
            super(1);
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
            ——ASTExplicitConstructorInvocation
              ——ASTArgumentList (size = 1)
                ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isProtected()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
11. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()
12. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getSuperInterfaceTypeNodes()
13. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isSyntacticallyAbstract()
14. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
15. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
16. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isProtected()
17. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isSyntacticallyStatic()

1.  //Check whether the class has implemented x interface
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node) {
    if (TypeTestUtil.isA(interfaceName.class, node)) {
        return true;
    }
    return false;
}
```
2.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate) && !hasSubclassInSameCompilationUnit(node)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate) && !hasSubclassInSameCompilationUnit(node)) {
                addViolation(data, node);
            }
        }
        return data;
    }

    private boolean hasSubclassInSameCompilationUnit(ASTClassOrInterfaceDeclaration node) {
        ASTCompilationUnit compilationUnit = node.getCompilationUnit();
        String className = node.getImage();
        return compilationUnit.descendants(ASTClassOrInterfaceDeclaration.class)
                .anyMatch(subNode -> className.equals(subNode.getSuperClassTypeNode().getImage()));
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get the superclass of class.
3. Check whether the superclass has private constructors.
4. Check whether the class is a top-level class.
5. Check whether the class is an inner class.
6. Get the package name of the class.
7. Get the package name of the superclass.
8. Check whether the class and its superclass are in the same package.
9. Check whether the class is final.
10. Check whether the class has any constructors.
11. Check whether all constructors of the class are private.
12. Check whether the class has any subclasses.
13. Check whether the subclasses are declared within the same compilation unit as the class.

For the provided test case:

1. Get the name of class: Main209.
2. Get the superclass of class: None (Main209 is a top-level class).
3. Check whether the superclass has private constructors: Not applicable (Main209 has no superclass).
4. Check whether the class is a top-level class: Yes.
5. Check whether the class is an inner class: No.
6. Get the package name of the class: Not specified in the test case, but assume it is some package.
7. Get the package name of the superclass: Not applicable (Main209 has no superclass).
8. Check whether the class and its superclass are in the same package: Not applicable (Main209 has no superclass).
9. Check whether the class is final: No.
10. Check whether the class has any constructors: Yes (Default constructor).
11. Check whether all constructors of the class are private: No (Default constructor is not private).
12. Check whether the class has any subclasses: No (Main209 has no subclasses stated in the test case).
13. Check whether the subclasses are declared within the same compilation unit as the class: Not applicable (Main209 has no subclasses).

Now check for the inner class `InputBits`:

1. Get the name of class: InputBits.
2. Get the superclass of class: Object (default superclass for all classes).
3. Check whether the superclass has private constructors: No (Object class does not have private constructors).
4. Check whether the class is a top-level class: No.
5. Check whether the class is an inner class: Yes.
6. Get the package name of the class: Same as Main209 (not specified).
7. Get the package name of the superclass: java.lang (Object class).
8. Check whether the class and its superclass are in the same package: No.
9. Check whether the class is final: No.
10. Check whether the class has any constructors: Yes.
11. Check whether all constructors of the class are private: Yes.
12. Check whether the class has any subclasses: Yes (Sub is a subclass).
13. Check whether the subclasses are declared within the same compilation unit as the class: Yes (Sub is declared within the same file as InputBits).

Now check for the subclass `Sub`:

1. Get the name of class: Sub.
2. Get the superclass of class: InputBits.
3. Check whether the superclass has private constructors: Yes.
4. Check whether the class is a top-level class: No.
5. Check whether the class is an inner class: Yes.
6. Get the package name of the class: Same as Main209 (not specified).
7. Get the package name of the superclass: Same as Main209 (not specified).
8. Check whether the class and its superclass are in the same package: Yes.
9. Check whether the class is final: Yes.
10. Check whether the class has any constructors: Yes.
11. Check whether all constructors of the class are private: Yes.
12. Check whether the class has any subclasses: No (Sub has no subclasses stated in the test case).
13. Check whether the subclasses are declared within the same compilation unit as the class: Not applicable (Sub has no subclasses).

Based on these checks, the `InputBits` class has a private constructor, but it has a subclass `Sub` that extends it within the same compilation unit. Therefore, `InputBits` should not be reported as final. The `Sub` class is final and has a private constructor, but it does not violate the rule as it is already declared final. Thus, the number of classes violating the rule in this test case is indeed 0.
['Get the name of class.', 'Get the superclass of class.', 'Check whether the superclass has private constructors.', 'Check whether the class is a top-level class.', 'Check whether the class is an inner class.', 'Get the package name of the class.', 'Get the package name of the superclass.', 'Check whether the class and its superclass are in the same package.', 'Check whether the class is final.', 'Check whether the class has any constructors.', 'Check whether all constructors of the class are private.', 'Check whether the class has any subclasses.', 'Check whether the subclasses are declared within the same compilation unit as the class.', 'Get the name of class: Main209.', 'Get the superclass of class: None (Main209 is a top-level class).', 'Check whether the superclass has private constructors: Not applicable (Main209 has no superclass).', 'Check whether the class is a top-level class: Yes.', 'Check whether the class is an inner class: No.', 'Get the package name of the class: Not specified in the test case, but assume it is some package.', 'Get the package name of the superclass: Not applicable (Main209 has no superclass).', 'Check whether the class and its superclass are in the same package: Not applicable (Main209 has no superclass).', 'Check whether the class is final: No.', 'Check whether the class has any constructors: Yes (Default constructor).', 'Check whether all constructors of the class are private: No (Default constructor is not private).', 'Check whether the class has any subclasses: No (Main209 has no subclasses stated in the test case).', 'Check whether the subclasses are declared within the same compilation unit as the class: Not applicable (Main209 has no subclasses).', 'Get the name of class: InputBits.', 'Get the superclass of class: Object (default superclass for all classes).', 'Check whether the superclass has private constructors: No (Object class does not have private constructors).', 'Check whether the class is a top-level class: No.', 'Check whether the class is an inner class: Yes.', 'Get the package name of the class: Same as Main209 (not specified).', 'Get the package name of the superclass: java.lang (Object class).', 'Check whether the class and its superclass are in the same package: No.', 'Check whether the class is final: No.', 'Check whether the class has any constructors: Yes.', 'Check whether all constructors of the class are private: Yes.', 'Check whether the class has any subclasses: Yes (Sub is a subclass).', 'Check whether the subclasses are declared within the same compilation unit as the class: Yes (Sub is declared within the same file as InputBits).', 'Get the name of class: Sub.', 'Get the superclass of class: InputBits.', 'Check whether the superclass has private constructors: Yes.', 'Check whether the class is a top-level class: No.', 'Check whether the class is an inner class: Yes.', 'Get the package name of the class: Same as Main209 (not specified).', 'Get the package name of the superclass: Same as Main209 (not specified).', 'Check whether the class and its superclass are in the same package: Yes.', 'Check whether the class is final: Yes.', 'Check whether the class has any constructors: Yes.', 'Check whether all constructors of the class are private: Yes.', 'Check whether the class has any subclasses: No (Sub has no subclasses stated in the test case).', 'Check whether the subclasses are declared within the same compilation unit as the class: Not applicable (Sub has no subclasses).']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'ASTExplicitConstructorInvocation', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTExtendsList', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the superclass of class.* 匹配到的元操作或API：
logic: Get the superclass of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9612455368041992
*Check whether the superclass has private constructors.* 匹配到的元操作或API：
logic: Check whether the superclass has private constructors.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8828073740005493
*Check whether the class is a top-level class.* 匹配到的元操作或API：
query: Check whether the class is a top-level class.
most similar API: Check whether the class or interface is top level
cosine Similarity: 0.9125426411628723
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Get the package name of the class.* 匹配到的元操作或API：
logic: Get the package name of the class.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9218399524688721
*Get the package name of the superclass.* 匹配到的元操作或API：
logic: Get the package name of the superclass.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.8635619282722473
*Check whether the class and its superclass are in the same package.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class has any constructors.* 匹配到的元操作或API：
query: Check whether the class has any constructors.
most similar API: Check whether the constructor is any annotation present
cosine Similarity: 0.8688066601753235
*Check whether all constructors of the class are private.* 匹配到的元操作或API：
logic: Check whether all constructors of the class are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9245820045471191
*Check whether the class has any subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclasses are declared within the same compilation unit as the class.* 匹配到的元操作或API：
query: Check whether the subclasses are declared within the same compilation unit as the class.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8543986082077026
*Get the name of class: Main209.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the superclass of class: None (Main209 is a top-level class).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the superclass has private constructors: Not applicable (Main209 has no superclass).* 匹配到的元操作或API：
query: Check whether the superclass has private constructors: Not applicable (Main209 has no superclass).
most similar API: Check whether the constructor is private
cosine Similarity: 0.8360254168510437
*Check whether the class is a top-level class: Yes.* 匹配到的元操作或API：
query: Check whether the class is a top-level class: Yes.
most similar API: Check whether the class or interface is top level
cosine Similarity: 0.8598243594169617
*Check whether the class is an inner class: No.* 匹配到的元操作或API：
logic: Check whether the class is an inner class: No.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9266457557678223
*Get the package name of the class: Not specified in the test case, but assume it is some package.* 匹配到的元操作或API：
logic: Get the package name of the class: Not specified in the test case, but assume it is some package.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.8626210689544678
*Get the package name of the superclass: Not applicable (Main209 has no superclass).* 匹配到的元操作或API：
query: Get the package name of the superclass: Not applicable (Main209 has no superclass).
most similar API: get package name of class or interface: Returns the name of the package in which this class is declared.
cosine Similarity: 0.8185065388679504
*Check whether the class and its superclass are in the same package: Not applicable (Main209 has no superclass).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is final: No.* 匹配到的元操作或API：
logic: Check whether the class is final: No.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9460525512695312
*Check whether the class has any constructors: Yes (Default constructor).* 匹配到的元操作或API：
query: Check whether the class has any constructors: Yes (Default constructor).
most similar API: Check whether the constructor is any annotation present
cosine Similarity: 0.8143998384475708
*Check whether all constructors of the class are private: No (Default constructor is not private).* 匹配到的元操作或API：
logic: Check whether all constructors of the class are private: No (Default constructor is not private).
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8851662874221802
*Check whether the class has any subclasses: No (Main209 has no subclasses stated in the test case).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclasses are declared within the same compilation unit as the class: Not applicable (Main209 has no subclasses).* 匹配到的元操作或API：
query: Check whether the subclasses are declared within the same compilation unit as the class: Not applicable (Main209 has no subclasses).
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8199977874755859
*Get the name of class: InputBits.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the superclass of class: Object (default superclass for all classes).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the superclass has private constructors: No (Object class does not have private constructors).* 匹配到的元操作或API：
query: Check whether the superclass has private constructors: No (Object class does not have private constructors).
most similar API: Check whether the constructor is private
cosine Similarity: 0.832919180393219
*Check whether the class is a top-level class: No.* 匹配到的元操作或API：
query: Check whether the class is a top-level class: No.
most similar API: Check whether the class or interface is top level
cosine Similarity: 0.8440269827842712
*Check whether the class is an inner class: Yes.* 匹配到的元操作或API：
logic: Check whether the class is an inner class: Yes.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9489811658859253
*Get the package name of the class: Same as Main209 (not specified).* 匹配到的元操作或API：
query: Get the package name of the class: Same as Main209 (not specified).
most similar API: get package name of class or interface: Returns the name of the package in which this class is declared.
cosine Similarity: 0.8615584373474121
*Get the package name of the superclass: java.lang (Object class).* 匹配到的元操作或API：
query: Get the package name of the superclass: java.lang (Object class).
most similar API: get package name of class or interface: Returns the name of the package in which this class is declared.
cosine Similarity: 0.8300786018371582
*Check whether the class and its superclass are in the same package: No.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is final: No.* 匹配到的元操作或API：
logic: Check whether the class is final: No.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9460525512695312
*Check whether the class has any constructors: Yes.* 匹配到的元操作或API：
query: Check whether the class has any constructors: Yes.
most similar API: Check whether the constructor is any annotation present
cosine Similarity: 0.8575382232666016
*Check whether all constructors of the class are private: Yes.* 匹配到的元操作或API：
logic: Check whether all constructors of the class are private: Yes.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8999346494674683
*Check whether the class has any subclasses: Yes (Sub is a subclass).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclasses are declared within the same compilation unit as the class: Yes (Sub is declared within the same file as InputBits).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: Sub.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the superclass of class: InputBits.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the superclass has private constructors: Yes.* 匹配到的元操作或API：
logic: Check whether the superclass has private constructors: Yes.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8597776293754578
*Check whether the class is a top-level class: No.* 匹配到的元操作或API：
query: Check whether the class is a top-level class: No.
most similar API: Check whether the class or interface is top level
cosine Similarity: 0.8440269827842712
*Check whether the class is an inner class: Yes.* 匹配到的元操作或API：
logic: Check whether the class is an inner class: Yes.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9489811658859253
*Get the package name of the class: Same as Main209 (not specified).* 匹配到的元操作或API：
query: Get the package name of the class: Same as Main209 (not specified).
most similar API: get package name of class or interface: Returns the name of the package in which this class is declared.
cosine Similarity: 0.8615584373474121
*Get the package name of the superclass: Same as Main209 (not specified).* 匹配到的元操作或API：
query: Get the package name of the superclass: Same as Main209 (not specified).
most similar API: get package name of class or interface: Returns the name of the package in which this class is declared.
cosine Similarity: 0.8436547517776489
*Check whether the class and its superclass are in the same package: Yes.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is final: Yes.* 匹配到的元操作或API：
logic: Check whether the class is final: Yes.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9417858719825745
*Check whether the class has any constructors: Yes.* 匹配到的元操作或API：
query: Check whether the class has any constructors: Yes.
most similar API: Check whether the constructor is any annotation present
cosine Similarity: 0.8575382232666016
*Check whether all constructors of the class are private: Yes.* 匹配到的元操作或API：
logic: Check whether all constructors of the class are private: Yes.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8999346494674683
*Check whether the class has any subclasses: No (Sub has no subclasses stated in the test case).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclasses are declared within the same compilation unit as the class: Not applicable (Sub has no subclasses).* 匹配到的元操作或API：
query: Check whether the subclasses are declared within the same compilation unit as the class: Not applicable (Sub has no subclasses).
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8040216565132141
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Inner class with only private constructor extended within compilation unit (#2536)
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
    public static final class Sub extends InputBits {
        private Sub() {
            super(1);
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
            ——ASTExplicitConstructorInvocation
              ——ASTArgumentList (size = 1)
                ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isTopLevel(), //Returns true if this type is declared at the top-level of a file.
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
8. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection), //Checks whether any annotation is present on this node. @param binaryNames            Collection that contains binary names of annotations.            Note: for now, canonical names are tolerated, this may be changed in PMD 7. @return <code>true</code> if any annotation is present on this node, else <code>false</code>
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName(), //Returns the name of the package in which this class is declared.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                ASTClassOrInterfaceType superClassType = node.getSuperClassTypeNode();
                if (superClassType == null || superClassType.isReferenceToClassSameCompilationUnit()) {
                    addViolation(data, node);
                }
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 9" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 9" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
To verify whether the provided test case adheres to the rule, we need to perform the following granular checks:

1. Get the name of class.
2. Check whether the class has declared annotations.
3. Get the super class of class.
4. Check whether the super class is declared within the same class.
5. Get all constructors of the super class.
6. Check whether each constructor is private.
7. Get all subclasses of the class.
8. Check whether each subclass is declared within the same class.
9. Get all constructors of the subclass.
10. Check whether each constructor calls a super constructor.
11. Check whether the super constructor is accessible (i.e., not private).

Let's perform these checks on the provided test case:

1. Get the name of class: `Main209`
2. Check whether the class has declared annotations: No annotations found.
3. Get the super class of class: `InputBits`
4. Check whether the super class is declared within the same class: Yes, `InputBits` is an inner class of `Main209`.
5. Get all constructors of the super class: One constructor found: `private InputBits(int number) { }`
6. Check whether each constructor is private: Yes, the constructor is private.
7. Get all subclasses of the class: One subclass found: `Sub`
8. Check whether each subclass is declared within the same class: Yes, `Sub` is an inner class of `Main209`.
9. Get all constructors of the subclass: One constructor found: `private Sub() { super(1); }`
10. Check whether each constructor calls a super constructor: Yes, the constructor calls `super(1);`.
11. Check whether the super constructor is accessible: No, the super constructor is private, which means it cannot be accessed outside its own class.

Based on these checks, the test case does not violate the rule because the subclass `Sub` is declared within the same class as `InputBits`, and the super constructor is private, making it impossible to extend `InputBits` from outside the compilation unit.

Thus, the number of classes violating the rule in this test case is indeed: 0.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get the super class of class.', 'Check whether the super class is declared within the same class.', 'Get all constructors of the super class.', 'Check whether each constructor is private.', 'Get all subclasses of the class.', 'Check whether each subclass is declared within the same class.', 'Get all constructors of the subclass.', 'Check whether each constructor calls a super constructor.', 'Check whether the super constructor is accessible (i.e., not private).', 'Get the name of class: `Main209`', 'Check whether the class has declared annotations: No annotations found.', 'Get the super class of class: `InputBits`', 'Check whether the super class is declared within the same class: Yes, `InputBits` is an inner class of `Main209`.', 'Get all constructors of the super class: One constructor found: `private InputBits(int number) { }`', 'Check whether each constructor is private: Yes, the constructor is private.', 'Get all subclasses of the class: One subclass found: `Sub`', 'Check whether each subclass is declared within the same class: Yes, `Sub` is an inner class of `Main209`.', 'Get all constructors of the subclass: One constructor found: `private Sub() { super(1); }`', 'Check whether each constructor calls a super constructor: Yes, the constructor calls `super(1);`.', 'Check whether the super constructor is accessible: No, the super constructor is private, which means it cannot be accessed outside its own class.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'ASTExplicitConstructorInvocation', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTExtendsList', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the super class is declared within the same class.* 匹配到的元操作或API：
query: Check whether the super class is declared within the same class.
most similar API: Check whether is declared in class
cosine Similarity: 0.8371114134788513
*Get all constructors of the super class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442476630210876
*Get all subclasses of the class.* 匹配到的元操作或API：
query: Get all subclasses of the class.
most similar API: get permitted subclasses of class or interface
cosine Similarity: 0.8104342222213745
*Check whether each subclass is declared within the same class.* 匹配到的元操作或API：
query: Check whether each subclass is declared within the same class.
most similar API: Check whether is declared in class
cosine Similarity: 0.8280214667320251
*Get all constructors of the subclass.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each constructor calls a super constructor.* 匹配到的元操作或API：
query: Check whether each constructor calls a super constructor.
most similar API: Check whether the explicit constructor invocation is super
cosine Similarity: 0.8814290761947632
*Check whether the super constructor is accessible (i.e., not private).* 匹配到的元操作或API：
logic: Check whether the super constructor is accessible (i.e., not private).
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8711243867874146
*Get the name of class: `Main209`* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has declared annotations: No annotations found.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations: No annotations found.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9445676803588867
*Get the super class of class: `InputBits`* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the super class is declared within the same class: Yes, `InputBits` is an inner class of `Main209`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors of the super class: One constructor found: `private InputBits(int number) { }`* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each constructor is private: Yes, the constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private: Yes, the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9432294368743896
*Get all subclasses of the class: One subclass found: `Sub`* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each subclass is declared within the same class: Yes, `Sub` is an inner class of `Main209`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors of the subclass: One constructor found: `private Sub() { super(1); }`* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each constructor calls a super constructor: Yes, the constructor calls `super(1);`.* 匹配到的元操作或API：
query: Check whether each constructor calls a super constructor: Yes, the constructor calls `super(1);`.
most similar API: Check whether the explicit constructor invocation is super
cosine Similarity: 0.8314722180366516
*Check whether the super constructor is accessible: No, the super constructor is private, which means it cannot be accessed outside its own class.* 匹配到的元操作或API：
query: Check whether the super constructor is accessible: No, the super constructor is private, which means it cannot be accessed outside its own class.
most similar API: Check whether the constructor is private
cosine Similarity: 0.8494288921356201
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Inner class with only private constructor extended within compilation unit (#2536)
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
    public static final class Sub extends InputBits {
        private Sub() {
            super(1);
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
            ——ASTExplicitConstructorInvocation
              ——ASTArgumentList (size = 1)
                ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
3. net.sourceforge.pmd.lang.java.types.TypeTestUtil: static public boolean isDeclaredInClass(java.lang.Class, net.sourceforge.pmd.lang.java.types.JMethodSig), //Returns true if the signature is that of a method declared in the given class. @param klass Class @param sig   Method signature to test @throws NullPointerException If any argument is null
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.util.List<ASTClassOrInterfaceType> getPermittedSubclasses()
6. net.sourceforge.pmd.lang.java.ast.ASTExplicitConstructorInvocation: public boolean isSuper(), //Returns true if this statement calls a constructor of the direct superclass. The JLS calls that a <i>superclass constructor invocation</i>.

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate) && !isExtendedWithinCompilationUnit(node)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate) && !isExtendedWithinCompilationUnit(node)) {
                addViolation(data, node);
            }
        }
        return data;
    }

    private boolean isExtendedWithinCompilationUnit(ASTClassOrInterfaceDeclaration node) {
        String simpleName = node.getSimpleName();
        return node.getRoot().descendants(ASTClassOrInterfaceDeclaration.class)
                .filter(subNode -> subNode != node)
                .anyMatch(subNode -> {
                    ASTClassOrInterfaceType superClassType = subNode.getSuperClassTypeNode();
                    return superClassType != null && simpleName.equals(superClassType.getSimpleName()) && subNode.descendants(ASTExplicitConstructorInvocation.class)
                            .anyMatch(ASTExplicitConstructorInvocation::isSuper);
                });
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Check whether the class has declared annotations.
        3. Get the javadoc comment of class.
        4. Check whether the class is abstract.
        5. Check whether the class is public.
        6. Check whether the class is private.
        7. Check whether the class is protected.
        8. Check whether the class is default package-private.
        9. Check whether the class is final.
        10. Check whether the class is static.
        11. Get the super class of class.
        12. Check whether the class has extended x class.
        13. Get a implemented interface of class.
        14. Check whether the class has implemented x interface.
        15. Get the name of the package where the class is located.
        16. Check whether the class is inner class.
        17. Check whether the class is anonymous class.
        18. Get the name of constructor.
        19. Get the signature of constructor.
        20. Get the javadoc comment of constructor.
        21. Check whether the constructor is private.
        22. Check whether the constructor is public.
        23. Check whether the constructor is default package-private.
        24. Check whether the constructor is protected.
        25. Get the number of formal parameters of constructor.
        26. Get a formal parameter of constructor.
        27. Get the type of formal parameter.
        28. Check whether the formal parameter is string type.
        29. Check whether the formal parameter is boolean type.
        30. Check whether the formal parameter is char type.
        31. Check whether the formal parameter is byte type.
        32. Check whether the formal parameter is short type.
        33. Check whether the formal parameter is int type.
        34. Check whether the formal parameter is long type.
        35. Check whether the formal parameter is float type.
        36. Check whether the formal parameter is double type.
        37. Check whether the formal parameter is boxed type.
        38. Check whether the formal parameter is a x class type.
        39. Check whether the formal parameter is array type.
        40. Check whether the formal parameter is enum type.
        41. Check whether the formal parameter is record type.
        42. Check whether the constructor has declared annotations.
        43. Get a declared annotation of constructor.
        44. Check whether the constructor has x annotation.
        45. Get a throw exception in constructor signature.
        46. Check whether the constructor signature throws x Exception.
        47. Get the class that constructor located in.

1. Get the name of class.
        The class name is Main209.
2. Check whether the class has declared annotations.
        The class does not have declared annotations.
3. Get the javadoc comment of class.
        The class does not have a javadoc comment.
4. Check whether the class is abstract.
        The class is not abstract.
5. Check whether the class is public.
        The class is public.
6. Check whether the class is private.
        The class is not private.
7. Check whether the class is protected.
        The class is not protected.
8. Check whether the class is default package-private.
        The class is not default package-private.
9. Check whether the class is final.
        The class is not final.
10. Check whether the class is static.
        The class is not static.
11. Get the super class of class.
        The super class of Main209 is Object.
12. Check whether the class has extended x class.
        The class has extended Object class.
13. Get a implemented interface of class.
        The class does not implement any interfaces.
14. Check whether the class has implemented x interface.
        The class has not implemented any interfaces.
15. Get the name of the package where the class is located.
        The package name is not provided, so it is in the default package.
16. Check whether the class is inner class.
        The class is not an inner class.
17. Check whether the class is anonymous class.
        The class is not an anonymous class.
18. Get the name of constructor.
        There is no constructor explicitly defined in Main209.
19. Get the signature of constructor.
        There is no constructor signature to get.
20. Get the javadoc comment of constructor.
        There is no constructor javadoc comment to get.
21. Check whether the constructor is private.
        There is no constructor, so this check does not apply.
22. Check whether the constructor is public.
        There is no constructor, so this check does not apply.
23. Check whether the constructor is default package-private.
        There is no constructor, so this check does not apply.
24. Check whether the constructor is protected.
        There is no constructor, so this check does not apply.
25. Get the number of formal parameters of constructor.
        There is no constructor, so this check does not apply.
26. Get a formal parameter of constructor.
        There is no constructor, so this check does not apply.
27. Get the type of formal parameter.
        There is no constructor, so this check does not apply.
28. Check whether the formal parameter is string type.
        There is no constructor, so this check does not apply.
29. Check whether the formal parameter is boolean type.
        There is no constructor, so this check does not apply.
30. Check whether the formal parameter is char type.
        There is no constructor, so this check does not apply.
31. Check whether the formal parameter is byte type.
        There is no constructor, so this check does not apply.
32. Check whether the formal parameter is short type.
        There is no constructor, so this check does not apply.
33. Check whether the formal parameter is int type.
        There is no constructor, so this check does not apply.
34. Check whether the formal parameter is long type.
        There is no constructor, so this check does not apply.
35. Check whether the formal parameter is float type.
        There is no constructor, so this check does not apply.
36. Check whether the formal parameter is double type.
        There is no constructor, so this check does not apply.
37. Check whether the formal parameter is boxed type.
        There is no constructor, so this check does not apply.
38. Check whether the formal parameter is a x class type.
        There is no constructor, so this check does not apply.
39. Check whether the formal parameter is array type.
        There is no constructor, so this check does not apply.
40. Check whether the formal parameter is enum type.
        There is no constructor, so this check does not apply.
41. Check whether the formal parameter is record type.
        There is no constructor, so this check does not apply.
42. Check whether the constructor has declared annotations.
        There is no constructor, so this check does not apply.
43. Get a declared annotation of constructor.
        There is no constructor, so this check does not apply.
44. Check whether the constructor has x annotation.
        There is no constructor, so this check does not apply.
45. Get a throw exception in constructor signature.
        There is no constructor, so this check does not apply.
46. Check whether the constructor signature throws x Exception.
        There is no constructor, so this check does not apply.
47. Get the class that constructor located in.
        There is no constructor, so this check does not apply.

Now, let's focus on the inner class InputBits and its subclass Sub.
1. Get the name of class.
        The class name is InputBits.
2. Check whether the class is an interface.
        The class is not an interface.
3. Check whether the class is abstract.
        The class is abstract.
4. Check whether the class is public.
        The class is not public.
5. Check whether the class is private.
        The class is private.
6. Check whether the class is protected.
        The class is not protected.
7. Check whether the class is default package-private.
        The class is not default package-private.
8. Check whether the class is final.
        The class is not final.
9. Check whether the class is static.
        The class is static.
10. Get the super class of class.
        The super class of InputBits is Object.
11. Check whether the class has extended x class.
        The class has extended Object class.
12. Get a implemented interface of class.
        The class does not implement any interfaces.
13. Check whether the class has implemented x interface.
        The class has not implemented any interfaces.
14. Get the name of the package where the class is located.
        The package name is not provided, so it is in the default package.
15. Check whether the class is inner class.
        The class is an inner class.
16. Check whether the class is anonymous class.
        The class is not an anonymous class.
17. Get the name of constructor.
        The constructor name is InputBits.
18. Get the signature of constructor.
        The constructor signature is InputBits(int number).
19. Get the javadoc comment of constructor.
        The constructor does not have a javadoc comment.
20. Check whether the constructor is private.
        The constructor is private.
21. Check whether the constructor is public.
        The constructor is not public.
22. Check whether the constructor is default package-private.
        The constructor is not default package-private.
23. Check whether the constructor is protected.
        The constructor is not protected.
24. Get the number of formal parameters of constructor.
        The number of formal parameters of the constructor is 1.
25. Get a formal parameter of constructor.
        The formal parameter of the constructor is number.
26. Get the type of formal parameter.
        The type of the formal parameter is int.
27. Check whether the formal parameter is string type.
        The formal parameter is not a string type.
28. Check whether the formal parameter is boolean type.
        The formal parameter is not a boolean type.
29. Check whether the formal parameter is char type.
        The formal parameter is not a char type.
30. Check whether the formal parameter is byte type.
        The formal parameter is not a byte type.
31. Check whether the formal parameter is short type.
        The formal parameter is not a short type.
32. Check whether the formal parameter is int type.
        The formal parameter is an int type.
33. Check whether the formal parameter is long type.
        The formal parameter is not a long type.
34. Check whether the formal parameter is float type.
        The formal parameter is not a float type.
35. Check whether the formal parameter is double type.
        The formal parameter is not a double type.
36. Check whether the formal parameter is boxed type.
        The formal parameter is not a boxed type.
37. Check whether the formal parameter is a x class type.
        The formal parameter is an int class type.
38. Check whether the formal parameter is array type.
        The formal parameter is not an array type.
39. Check whether the formal parameter is enum type.
        The formal parameter is not an enum type.
40. Check whether the formal parameter is record type.
        The formal parameter is not a record type.
41. Check whether the constructor has declared annotations.
        The constructor does not have declared annotations.
42. Get a declared annotation of constructor.
        The constructor does not have declared annotations.
43. Check whether the constructor has x annotation.
        The constructor does not have x annotation.
44. Get a throw exception in constructor signature.
        There is no throw exception in the constructor signature.
45. Check whether the constructor signature throws x Exception.
        The constructor signature does not throw x Exception.
46. Get the class that constructor located in.
        The constructor is located in the class Main209.

1. Get the name of class.
        The class name is Sub.
2. Check whether the class is an interface.
        The class is not an interface.
3. Check whether the class is abstract.
        The class is not abstract.
4. Check whether the class is public.
        The class is public.
5. Check whether the class is private.
        The class is not private.
6. Check whether the class is protected.
        The class is not protected.
7. Check whether the class is default package-private.
        The class is not default package-private.
8. Check whether the class is final.
        The class is final.
9. Check whether the class is static.
        The class is static.
10. Get the super class of class.
        The super class of Sub is InputBits.
11. Check whether the class has extended x class.
        The class has extended InputBits class.
12. Get a implemented interface of class.
        The class does not implement any interfaces.
13. Check whether the class has implemented x interface.
        The class has not implemented any interfaces.
14. Get the name of the package where the class is located.
        The package name is not provided, so it is in the default package.
15. Check whether the class is inner class.
        The class is an inner class.
16. Check whether the class is anonymous class.
        The class is not an anonymous class.
17. Get the name of constructor.
        The constructor name is Sub.
18. Get the signature of constructor.
        The constructor signature is Sub().
19. Get the javadoc comment of constructor.
        The constructor does not have a javadoc comment.
20. Check whether the constructor is private.
        The constructor is private.
21. Check whether the constructor is public.
        The constructor is not public.
22. Check whether the constructor is default package-private.
        The constructor is not default package-private.
23. Check whether the constructor is protected.
        The constructor is not protected.
24. Get the number of formal parameters of constructor.
        The number of formal parameters of the constructor is 0.
25. Check whether the constructor has declared annotations.
        The constructor does not have declared annotations.
26. Get a declared annotation of constructor.
        The constructor does not have declared annotations.
27. Check whether the constructor has x annotation.
        The constructor does not have x annotation.
28. Get a throw exception in constructor signature.
        There is no throw exception in the constructor signature.
29. Check whether the constructor signature throws x Exception.
        The constructor signature does not throw x Exception.
30. Get the class that constructor located in.
        The constructor is located in the class Main209.

Based on the checks above, the class InputBits is an abstract class with a private constructor, and its subclass Sub is final, which means Sub cannot be extended. Since the rule only applies to abstract classes without superclasses or implemented interfaces, and InputBits is abstract, this test case does not violate the rule because Sub can still extend InputBits within the same compilation unit. Therefore, the number of violating the rule in this test case is indeed 0.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get the javadoc comment of class.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get a implemented interface of class.', 'Check whether the class has implemented x interface.', 'Get the name of the package where the class is located.', 'Check whether the class is inner class.', 'Check whether the class is anonymous class.', 'Get the name of constructor.', 'Get the signature of constructor.', 'Get the javadoc comment of constructor.', 'Check whether the constructor is private.', 'Check whether the constructor is public.', 'Check whether the constructor is default package-private.', 'Check whether the constructor is protected.', 'Get the number of formal parameters of constructor.', 'Get a formal parameter of constructor.', 'Get the type of formal parameter.', 'Check whether the formal parameter is string type.', 'Check whether the formal parameter is boolean type.', 'Check whether the formal parameter is char type.', 'Check whether the formal parameter is byte type.', 'Check whether the formal parameter is short type.', 'Check whether the formal parameter is int type.', 'Check whether the formal parameter is long type.', 'Check whether the formal parameter is float type.', 'Check whether the formal parameter is double type.', 'Check whether the formal parameter is boxed type.', 'Check whether the formal parameter is a x class type.', 'Check whether the formal parameter is array type.', 'Check whether the formal parameter is enum type.', 'Check whether the formal parameter is record type.', 'Check whether the constructor has declared annotations.', 'Get a declared annotation of constructor.', 'Check whether the constructor has x annotation.', 'Get a throw exception in constructor signature.', 'Check whether the constructor signature throws x Exception.', 'Get the class that constructor located in.', 'Get the name of class.', 'Check whether the class has declared annotations.', 'Get the javadoc comment of class.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get a implemented interface of class.', 'Check whether the class has implemented x interface.', 'Get the name of the package where the class is located.', 'Check whether the class is inner class.', 'Check whether the class is anonymous class.', 'Get the name of constructor.', 'Get the signature of constructor.', 'Get the javadoc comment of constructor.', 'Check whether the constructor is private.', 'Check whether the constructor is public.', 'Check whether the constructor is default package-private.', 'Check whether the constructor is protected.', 'Get the number of formal parameters of constructor.', 'Get a formal parameter of constructor.', 'Get the type of formal parameter.', 'Check whether the formal parameter is string type.', 'Check whether the formal parameter is boolean type.', 'Check whether the formal parameter is char type.', 'Check whether the formal parameter is byte type.', 'Check whether the formal parameter is short type.', 'Check whether the formal parameter is int type.', 'Check whether the formal parameter is long type.', 'Check whether the formal parameter is float type.', 'Check whether the formal parameter is double type.', 'Check whether the formal parameter is boxed type.', 'Check whether the formal parameter is a x class type.', 'Check whether the formal parameter is array type.', 'Check whether the formal parameter is enum type.', 'Check whether the formal parameter is record type.', 'Check whether the constructor has declared annotations.', 'Get a declared annotation of constructor.', 'Check whether the constructor has x annotation.', 'Get a throw exception in constructor signature.', 'Check whether the constructor signature throws x Exception.', 'Get the class that constructor located in.', 'Get the name of class.', 'Check whether the class is an interface.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get a implemented interface of class.', 'Check whether the class has implemented x interface.', 'Get the name of the package where the class is located.', 'Check whether the class is inner class.', 'Check whether the class is anonymous class.', 'Get the name of constructor.', 'Get the signature of constructor.', 'Get the javadoc comment of constructor.', 'Check whether the constructor is private.', 'Check whether the constructor is public.', 'Check whether the constructor is default package-private.', 'Check whether the constructor is protected.', 'Get the number of formal parameters of constructor.', 'Get a formal parameter of constructor.', 'Get the type of formal parameter.', 'Check whether the formal parameter is string type.', 'Check whether the formal parameter is boolean type.', 'Check whether the formal parameter is char type.', 'Check whether the formal parameter is byte type.', 'Check whether the formal parameter is short type.', 'Check whether the formal parameter is int type.', 'Check whether the formal parameter is long type.', 'Check whether the formal parameter is float type.', 'Check whether the formal parameter is double type.', 'Check whether the formal parameter is boxed type.', 'Check whether the formal parameter is a x class type.', 'Check whether the formal parameter is array type.', 'Check whether the formal parameter is enum type.', 'Check whether the formal parameter is record type.', 'Check whether the constructor has declared annotations.', 'Get a declared annotation of constructor.', 'Check whether the constructor has x annotation.', 'Get a throw exception in constructor signature.', 'Check whether the constructor signature throws x Exception.', 'Get the class that constructor located in.', 'Get the name of class.', 'Check whether the class is an interface.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get a implemented interface of class.', 'Check whether the class has implemented x interface.', 'Get the name of the package where the class is located.', 'Check whether the class is inner class.', 'Check whether the class is anonymous class.', 'Get the name of constructor.', 'Get the signature of constructor.', 'Get the javadoc comment of constructor.', 'Check whether the constructor is private.', 'Check whether the constructor is public.', 'Check whether the constructor is default package-private.', 'Check whether the constructor is protected.', 'Get the number of formal parameters of constructor.', 'Check whether the constructor has declared annotations.', 'Get a declared annotation of constructor.', 'Check whether the constructor has x annotation.', 'Get a throw exception in constructor signature.', 'Check whether the constructor signature throws x Exception.', 'Get the class that constructor located in.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'ASTExplicitConstructorInvocation', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTExtendsList', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844120740890503
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a implemented interface of class.* 匹配到的元操作或API：
logic: Get a implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9851537942886353
*Check whether the class has implemented x interface.* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9905824661254883
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.987544596195221
*Check whether the class is anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9849605560302734
*Get the name of constructor.* 匹配到的元操作或API：
logic: Get the name of constructor.
most similar meta operation: Get the name of constructor
cosine Similarity: 0.9789292812347412
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828827381134033
*Get the javadoc comment of constructor.* 匹配到的元操作或API：
logic: Get the javadoc comment of constructor.
most similar meta operation: Get the javadoc comment of constructor
cosine Similarity: 0.9908277988433838
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Check whether the constructor is default package-private.* 匹配到的元操作或API：
logic: Check whether the constructor is default package-private.
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.9616611003875732
*Check whether the constructor is protected.* 匹配到的元操作或API：
logic: Check whether the constructor is protected.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9850410223007202
*Get the number of formal parameters of constructor.* 匹配到的元操作或API：
logic: Get the number of formal parameters of constructor.
most similar meta operation: Get the number of formal parameters of constructor
cosine Similarity: 0.9865633845329285
*Get a formal parameter of constructor.* 匹配到的元操作或API：
logic: Get a formal parameter of constructor.
most similar meta operation: Get a formal parameter of constructor
cosine Similarity: 0.98207688331604
*Get the type of formal parameter.* 匹配到的元操作或API：
logic: Get the type of formal parameter.
most similar meta operation: Get the type of formal parameter
cosine Similarity: 0.9854808449745178
*Check whether the formal parameter is string type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is string type.
most similar meta operation: Check whether the formal parameter is string type
cosine Similarity: 0.9882045984268188
*Check whether the formal parameter is boolean type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is boolean type.
most similar meta operation: Check whether the formal parameter is boolean type
cosine Similarity: 0.9861541986465454
*Check whether the formal parameter is char type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is char type.
most similar meta operation: Check whether the formal parameter is char type
cosine Similarity: 0.9883654713630676
*Check whether the formal parameter is byte type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is byte type.
most similar meta operation: Check whether the formal parameter is byte type
cosine Similarity: 0.989282488822937
*Check whether the formal parameter is short type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is short type.
most similar meta operation: Check whether the formal parameter is short type
cosine Similarity: 0.9876381158828735
*Check whether the formal parameter is int type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is int type.
most similar meta operation: Check whether the formal parameter is int type
cosine Similarity: 0.9879910945892334
*Check whether the formal parameter is long type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is long type.
most similar meta operation: Check whether the formal parameter is long type
cosine Similarity: 0.988408625125885
*Check whether the formal parameter is float type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is float type.
most similar meta operation: Check whether the formal parameter is float type
cosine Similarity: 0.9876444935798645
*Check whether the formal parameter is double type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is double type.
most similar meta operation: Check whether the formal parameter is double type
cosine Similarity: 0.9877136945724487
*Check whether the formal parameter is boxed type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is boxed type.
most similar meta operation: Check whether the formal parameter is boxed primitive type
cosine Similarity: 0.9612672328948975
*Check whether the formal parameter is a x class type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is a x class type.
most similar meta operation: Check whether the formal parameter is a x class type
cosine Similarity: 0.9905358552932739
*Check whether the formal parameter is array type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is array type.
most similar meta operation: Check whether the formal parameter is array type
cosine Similarity: 0.9873113036155701
*Check whether the formal parameter is enum type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is enum type.
most similar meta operation: Check whether the formal parameter is enum type
cosine Similarity: 0.9871471524238586
*Check whether the formal parameter is record type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is record type.
most similar meta operation: Check whether the formal parameter is record type
cosine Similarity: 0.9890471696853638
*Check whether the constructor has declared annotations.* 匹配到的元操作或API：
logic: Check whether the constructor has declared annotations.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.9810327291488647
*Get a declared annotation of constructor.* 匹配到的元操作或API：
logic: Get a declared annotation of constructor.
most similar meta operation: Get a declared annotation of constructor
cosine Similarity: 0.9872554540634155
*Check whether the constructor has x annotation.* 匹配到的元操作或API：
logic: Check whether the constructor has x annotation.
most similar meta operation: Check whether the constructor has x annotation
cosine Similarity: 0.9916678667068481
*Get a throw exception in constructor signature.* 匹配到的元操作或API：
logic: Get a throw exception in constructor signature.
most similar meta operation: Get a throw exception in constructor signature
cosine Similarity: 0.9784085154533386
*Check whether the constructor signature throws x Exception.* 匹配到的元操作或API：
logic: Check whether the constructor signature throws x Exception.
most similar meta operation: Check whether the constructor signature throws x Exception
cosine Similarity: 0.9923062324523926
*Get the class that constructor located in.* 匹配到的元操作或API：
logic: Get the class that constructor located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.8542751669883728
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844120740890503
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a implemented interface of class.* 匹配到的元操作或API：
logic: Get a implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9851537942886353
*Check whether the class has implemented x interface.* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9905824661254883
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.987544596195221
*Check whether the class is anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9849605560302734
*Get the name of constructor.* 匹配到的元操作或API：
logic: Get the name of constructor.
most similar meta operation: Get the name of constructor
cosine Similarity: 0.9789292812347412
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828827381134033
*Get the javadoc comment of constructor.* 匹配到的元操作或API：
logic: Get the javadoc comment of constructor.
most similar meta operation: Get the javadoc comment of constructor
cosine Similarity: 0.9908277988433838
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Check whether the constructor is default package-private.* 匹配到的元操作或API：
logic: Check whether the constructor is default package-private.
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.9616611003875732
*Check whether the constructor is protected.* 匹配到的元操作或API：
logic: Check whether the constructor is protected.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9850410223007202
*Get the number of formal parameters of constructor.* 匹配到的元操作或API：
logic: Get the number of formal parameters of constructor.
most similar meta operation: Get the number of formal parameters of constructor
cosine Similarity: 0.9865633845329285
*Get a formal parameter of constructor.* 匹配到的元操作或API：
logic: Get a formal parameter of constructor.
most similar meta operation: Get a formal parameter of constructor
cosine Similarity: 0.98207688331604
*Get the type of formal parameter.* 匹配到的元操作或API：
logic: Get the type of formal parameter.
most similar meta operation: Get the type of formal parameter
cosine Similarity: 0.9854808449745178
*Check whether the formal parameter is string type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is string type.
most similar meta operation: Check whether the formal parameter is string type
cosine Similarity: 0.9882045984268188
*Check whether the formal parameter is boolean type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is boolean type.
most similar meta operation: Check whether the formal parameter is boolean type
cosine Similarity: 0.9861541986465454
*Check whether the formal parameter is char type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is char type.
most similar meta operation: Check whether the formal parameter is char type
cosine Similarity: 0.9883654713630676
*Check whether the formal parameter is byte type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is byte type.
most similar meta operation: Check whether the formal parameter is byte type
cosine Similarity: 0.989282488822937
*Check whether the formal parameter is short type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is short type.
most similar meta operation: Check whether the formal parameter is short type
cosine Similarity: 0.9876381158828735
*Check whether the formal parameter is int type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is int type.
most similar meta operation: Check whether the formal parameter is int type
cosine Similarity: 0.9879910945892334
*Check whether the formal parameter is long type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is long type.
most similar meta operation: Check whether the formal parameter is long type
cosine Similarity: 0.988408625125885
*Check whether the formal parameter is float type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is float type.
most similar meta operation: Check whether the formal parameter is float type
cosine Similarity: 0.9876444935798645
*Check whether the formal parameter is double type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is double type.
most similar meta operation: Check whether the formal parameter is double type
cosine Similarity: 0.9877136945724487
*Check whether the formal parameter is boxed type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is boxed type.
most similar meta operation: Check whether the formal parameter is boxed primitive type
cosine Similarity: 0.9612672328948975
*Check whether the formal parameter is a x class type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is a x class type.
most similar meta operation: Check whether the formal parameter is a x class type
cosine Similarity: 0.9905358552932739
*Check whether the formal parameter is array type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is array type.
most similar meta operation: Check whether the formal parameter is array type
cosine Similarity: 0.9873113036155701
*Check whether the formal parameter is enum type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is enum type.
most similar meta operation: Check whether the formal parameter is enum type
cosine Similarity: 0.9871471524238586
*Check whether the formal parameter is record type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is record type.
most similar meta operation: Check whether the formal parameter is record type
cosine Similarity: 0.9890471696853638
*Check whether the constructor has declared annotations.* 匹配到的元操作或API：
logic: Check whether the constructor has declared annotations.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.9810327291488647
*Get a declared annotation of constructor.* 匹配到的元操作或API：
logic: Get a declared annotation of constructor.
most similar meta operation: Get a declared annotation of constructor
cosine Similarity: 0.9872554540634155
*Check whether the constructor has x annotation.* 匹配到的元操作或API：
logic: Check whether the constructor has x annotation.
most similar meta operation: Check whether the constructor has x annotation
cosine Similarity: 0.9916678667068481
*Get a throw exception in constructor signature.* 匹配到的元操作或API：
logic: Get a throw exception in constructor signature.
most similar meta operation: Get a throw exception in constructor signature
cosine Similarity: 0.9784085154533386
*Check whether the constructor signature throws x Exception.* 匹配到的元操作或API：
logic: Check whether the constructor signature throws x Exception.
most similar meta operation: Check whether the constructor signature throws x Exception
cosine Similarity: 0.9923062324523926
*Get the class that constructor located in.* 匹配到的元操作或API：
logic: Get the class that constructor located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.8542751669883728
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is an interface.* 匹配到的元操作或API：
logic: Check whether the class is an interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9778784513473511
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844120740890503
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a implemented interface of class.* 匹配到的元操作或API：
logic: Get a implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9851537942886353
*Check whether the class has implemented x interface.* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9905824661254883
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.987544596195221
*Check whether the class is anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9849605560302734
*Get the name of constructor.* 匹配到的元操作或API：
logic: Get the name of constructor.
most similar meta operation: Get the name of constructor
cosine Similarity: 0.9789292812347412
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828827381134033
*Get the javadoc comment of constructor.* 匹配到的元操作或API：
logic: Get the javadoc comment of constructor.
most similar meta operation: Get the javadoc comment of constructor
cosine Similarity: 0.9908277988433838
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Check whether the constructor is default package-private.* 匹配到的元操作或API：
logic: Check whether the constructor is default package-private.
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.9616611003875732
*Check whether the constructor is protected.* 匹配到的元操作或API：
logic: Check whether the constructor is protected.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9850410223007202
*Get the number of formal parameters of constructor.* 匹配到的元操作或API：
logic: Get the number of formal parameters of constructor.
most similar meta operation: Get the number of formal parameters of constructor
cosine Similarity: 0.9865633845329285
*Get a formal parameter of constructor.* 匹配到的元操作或API：
logic: Get a formal parameter of constructor.
most similar meta operation: Get a formal parameter of constructor
cosine Similarity: 0.98207688331604
*Get the type of formal parameter.* 匹配到的元操作或API：
logic: Get the type of formal parameter.
most similar meta operation: Get the type of formal parameter
cosine Similarity: 0.9854808449745178
*Check whether the formal parameter is string type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is string type.
most similar meta operation: Check whether the formal parameter is string type
cosine Similarity: 0.9882045984268188
*Check whether the formal parameter is boolean type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is boolean type.
most similar meta operation: Check whether the formal parameter is boolean type
cosine Similarity: 0.9861541986465454
*Check whether the formal parameter is char type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is char type.
most similar meta operation: Check whether the formal parameter is char type
cosine Similarity: 0.9883654713630676
*Check whether the formal parameter is byte type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is byte type.
most similar meta operation: Check whether the formal parameter is byte type
cosine Similarity: 0.989282488822937
*Check whether the formal parameter is short type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is short type.
most similar meta operation: Check whether the formal parameter is short type
cosine Similarity: 0.9876381158828735
*Check whether the formal parameter is int type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is int type.
most similar meta operation: Check whether the formal parameter is int type
cosine Similarity: 0.9879910945892334
*Check whether the formal parameter is long type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is long type.
most similar meta operation: Check whether the formal parameter is long type
cosine Similarity: 0.988408625125885
*Check whether the formal parameter is float type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is float type.
most similar meta operation: Check whether the formal parameter is float type
cosine Similarity: 0.9876444935798645
*Check whether the formal parameter is double type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is double type.
most similar meta operation: Check whether the formal parameter is double type
cosine Similarity: 0.9877136945724487
*Check whether the formal parameter is boxed type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is boxed type.
most similar meta operation: Check whether the formal parameter is boxed primitive type
cosine Similarity: 0.9612672328948975
*Check whether the formal parameter is a x class type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is a x class type.
most similar meta operation: Check whether the formal parameter is a x class type
cosine Similarity: 0.9905358552932739
*Check whether the formal parameter is array type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is array type.
most similar meta operation: Check whether the formal parameter is array type
cosine Similarity: 0.9873113036155701
*Check whether the formal parameter is enum type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is enum type.
most similar meta operation: Check whether the formal parameter is enum type
cosine Similarity: 0.9871471524238586
*Check whether the formal parameter is record type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is record type.
most similar meta operation: Check whether the formal parameter is record type
cosine Similarity: 0.9890471696853638
*Check whether the constructor has declared annotations.* 匹配到的元操作或API：
logic: Check whether the constructor has declared annotations.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.9810327291488647
*Get a declared annotation of constructor.* 匹配到的元操作或API：
logic: Get a declared annotation of constructor.
most similar meta operation: Get a declared annotation of constructor
cosine Similarity: 0.9872554540634155
*Check whether the constructor has x annotation.* 匹配到的元操作或API：
logic: Check whether the constructor has x annotation.
most similar meta operation: Check whether the constructor has x annotation
cosine Similarity: 0.9916678667068481
*Get a throw exception in constructor signature.* 匹配到的元操作或API：
logic: Get a throw exception in constructor signature.
most similar meta operation: Get a throw exception in constructor signature
cosine Similarity: 0.9784085154533386
*Check whether the constructor signature throws x Exception.* 匹配到的元操作或API：
logic: Check whether the constructor signature throws x Exception.
most similar meta operation: Check whether the constructor signature throws x Exception
cosine Similarity: 0.9923062324523926
*Get the class that constructor located in.* 匹配到的元操作或API：
logic: Get the class that constructor located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.8542751669883728
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is an interface.* 匹配到的元操作或API：
logic: Check whether the class is an interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9778784513473511
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844120740890503
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a implemented interface of class.* 匹配到的元操作或API：
logic: Get a implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9851537942886353
*Check whether the class has implemented x interface.* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9905824661254883
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.987544596195221
*Check whether the class is anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9849605560302734
*Get the name of constructor.* 匹配到的元操作或API：
logic: Get the name of constructor.
most similar meta operation: Get the name of constructor
cosine Similarity: 0.9789292812347412
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828827381134033
*Get the javadoc comment of constructor.* 匹配到的元操作或API：
logic: Get the javadoc comment of constructor.
most similar meta operation: Get the javadoc comment of constructor
cosine Similarity: 0.9908277988433838
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Check whether the constructor is default package-private.* 匹配到的元操作或API：
logic: Check whether the constructor is default package-private.
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.9616611003875732
*Check whether the constructor is protected.* 匹配到的元操作或API：
logic: Check whether the constructor is protected.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9850410223007202
*Get the number of formal parameters of constructor.* 匹配到的元操作或API：
logic: Get the number of formal parameters of constructor.
most similar meta operation: Get the number of formal parameters of constructor
cosine Similarity: 0.9865633845329285
*Check whether the constructor has declared annotations.* 匹配到的元操作或API：
logic: Check whether the constructor has declared annotations.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.9810327291488647
*Get a declared annotation of constructor.* 匹配到的元操作或API：
logic: Get a declared annotation of constructor.
most similar meta operation: Get a declared annotation of constructor
cosine Similarity: 0.9872554540634155
*Check whether the constructor has x annotation.* 匹配到的元操作或API：
logic: Check whether the constructor has x annotation.
most similar meta operation: Check whether the constructor has x annotation
cosine Similarity: 0.9916678667068481
*Get a throw exception in constructor signature.* 匹配到的元操作或API：
logic: Get a throw exception in constructor signature.
most similar meta operation: Get a throw exception in constructor signature
cosine Similarity: 0.9784085154533386
*Check whether the constructor signature throws x Exception.* 匹配到的元操作或API：
logic: Check whether the constructor signature throws x Exception.
most similar meta operation: Check whether the constructor signature throws x Exception
cosine Similarity: 0.9923062324523926
*Get the class that constructor located in.* 匹配到的元操作或API：
logic: Get the class that constructor located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.8542751669883728
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Inner class with only private constructor extended within compilation unit (#2536)
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
    public static final class Sub extends InputBits {
        private Sub() {
            super(1);
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
            ——ASTExplicitConstructorInvocation
              ——ASTArgumentList (size = 1)
                ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isProtected()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
11. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getSuperInterfaceTypeNodes()
12. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
13. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
14. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnonymous()
15. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.String getName()
16. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
17. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
18. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
19. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()
20. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPackagePrivate()
21. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isProtected()
22. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTFormalParameters getFormalParameters()
23. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
24. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
25. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
26. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTThrowsList getThrowsList()
27. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType()
28. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```
3.  //Check whether the class has implemented x interface
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node) {
    if (TypeTestUtil.isA(interfaceName.class, node)) {
        return true;
    }
    return false;
}
```
4.  //Get the number of formal parameters of constructor
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTConstructorDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```
5.  //Check whether the formal parameter is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFormalParameterStringType(ASTFormalParameter node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```
6.  //Check whether the formal parameter is boolean type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterBooleanType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN);
}
```
7.  //Check whether the formal parameter is char type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterCharType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.CHAR);
}
```
8.  //Check whether the formal parameter is byte type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterByteType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
}
```
9.  //Check whether the formal parameter is short type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterShortType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.SHORT);
}
```
10.  //Check whether the formal parameter is int type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterIntType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.INT);
}
```
11.  //Check whether the formal parameter is long type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterLongType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.LONG);
}
```
12.  //Check whether the formal parameter is float type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterFloatType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.FLOAT);
}
```
13.  //Check whether the formal parameter is double type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterDoubleType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.DOUBLE);
}
```
14.  //Check whether the formal parameter is boxed primitive type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public boolean isFormalParameterBoxedPrimitiveType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isBoxedPrimitive();
}
```
15.  //Check whether the formal parameter is a x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFormalParameterClassType(ASTFormalParameter node) {
    return TypeTestUtil.isA(x.class, node.getTypeNode());
}
```
16.  //Check whether the formal parameter is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isFormalParameterArrayType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```
17.  //Check whether the formal parameter is enum type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isFormalParameterEnumType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) type.getTypeMirror().getSymbol()).isEnum();
}
```
18.  //Check whether the formal parameter is record type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isFormalParameterRecordType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) type.getTypeMirror().getSymbol()).isRecord();
}
```
19.  //Check whether constructor has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTConstructorDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```
20.  //Check whether the constructor signature throws x Exception
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean throwsSpecificException(ASTConstructorDeclaration node){
    ASTThrowsList list = node.getThrowsList();
    if(list == null){
        return false;
    }else{
        for(ASTClassOrInterfaceType classOrInterfaceType : list){
            if(TypeTestUtil.isA(x.class, classOrInterfaceType)){
                return true;
            }
        }
    }
    return false;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                ASTCompilationUnit compilationUnit = node.getFirstParentOfType(ASTCompilationUnit.class);
                if (isClassExtendedWithinCompilationUnit(node, compilationUnit)) {
                    return data;
                }
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }

    private boolean isClassExtendedWithinCompilationUnit(ASTClassOrInterfaceDeclaration node, ASTCompilationUnit compilationUnit) {
        String className = node.getSimpleName();
        return compilationUnit.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class)
            .anyMatch(subclass -> subclass.getSuperClassTypeNode() != null && subclass.getSuperClassTypeNode().getSimpleName().equals(className));
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To ascertain whether the provided test case adheres to the rule, we need to carefully analyze the class and its constructors. Let's break down the operations step-by-step:

1. Get the name of class.
   - Main209

2. Get the declared inner class of class.
   - InputBits
   - Sub

3. Get the name of the inner class.
   - InputBits

4. Get all constructors declared in class.
   - InputBits(int number)

5. Get the signature of constructor.
   - private InputBits(int number)

6. Check whether the constructor is private.
   - Yes

7. Get the name of the inner class.
   - Sub

8. Get all constructors declared in class.
   - private Sub()

9. Get the signature of constructor.
   - private Sub()

10. Check whether the constructor is private.
    - Yes

11. Check whether the class has extended x class.
    - Sub extends InputBits

12. Check whether the super class of class is private.
    - No, the super class InputBits is not private, but it has a private constructor.

13. Check whether the class is public.
    - No, InputBits is private.

14. Check whether the class is final.
    - No, InputBits is not final.

15. Check whether the class is abstract.
    - No, InputBits is not abstract.

16. Check whether the class is an interface.
    - No, InputBits is a class.

17. Check whether the class has declared annotations.
    - No, InputBits does not have declared annotations.

18. Check whether the class is static.
    - Yes, InputBits is static.

19. Get the super class of class.
    - InputBits

20. Check whether the super class of class is private.
    - No, InputBits is not private, but it has a private constructor.

21. Get all methods declared in class.
    - No methods declared in InputBits.

22. Get all constructors declared in class.
    - InputBits(int number)

23. Check whether the constructor is private.
    - Yes

24. Check whether the class is final.
    - Yes, Sub is final.

25. Check whether the class is abstract.
    - No, Sub is not abstract.

26. Check whether the class is an interface.
    - No, Sub is a class.

27. Check whether the class has declared annotations.
    - No, Sub does not have declared annotations.

28. Check whether the class is static.
    - Yes, Sub is static.

29. Get the super class of class.
    - InputBits

30. Check whether the super class of class is private.
    - No, InputBits is not private, but it has a private constructor.

31. Check whether the class can be extended from outside their compilation unit.
    - No, because InputBits has a private constructor.

32. Check whether the class contains at least one abstract method.
    - No, InputBits does not contain any abstract methods.

33. Check whether the class can be made final.
    - Yes, InputBits can be made final because it cannot be extended from outside their compilation unit due to its private constructor.

34. Check whether the class is already final.
    - No, InputBits is not final.

Based on the analysis, the `InputBits` class can and should be made final because it cannot be extended from outside its compilation unit due to its private constructor. However, the `Sub` class is already final and does not violate the rule.

The number of violating the rule in this test case is: 1 (InputBits should be made final, but it is not).
['Get the name of class.', 'Get the declared inner class of class.', 'Get the name of the inner class.', 'Get all constructors declared in class.', 'Get the signature of constructor.', 'Check whether the constructor is private.', 'Get the name of the inner class.', 'Get all constructors declared in class.', 'Get the signature of constructor.', 'Check whether the constructor is private.', 'Check whether the class has extended x class.', 'Check whether the super class of class is private.', 'Check whether the class is public.', 'Check whether the class is final.', 'Check whether the class is abstract.', 'Check whether the class is an interface.', 'Check whether the class has declared annotations.', 'Check whether the class is static.', 'Get the super class of class.', 'Check whether the super class of class is private.', 'Get all methods declared in class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is final.', 'Check whether the class is abstract.', 'Check whether the class is an interface.', 'Check whether the class has declared annotations.', 'Check whether the class is static.', 'Get the super class of class.', 'Check whether the super class of class is private.', 'Check whether the class can be extended from outside their compilation unit.', 'Check whether the class contains at least one abstract method.', 'Check whether the class can be made final.', 'Check whether the class is already final.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTConstructorDeclaration', 'ASTExplicitConstructorInvocation', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTExtendsList', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the declared inner class of class.* 匹配到的元操作或API：
logic: Get the declared inner class of class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8535434603691101
*Get the name of the inner class.* 匹配到的元操作或API：
logic: Get the name of the inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.878083348274231
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828827381134033
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the name of the inner class.* 匹配到的元操作或API：
logic: Get the name of the inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.878083348274231
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828827381134033
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Check whether the super class of class is private.* 匹配到的元操作或API：
logic: Check whether the super class of class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.8993715643882751
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is an interface.* 匹配到的元操作或API：
logic: Check whether the class is an interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9778784513473511
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the super class of class is private.* 匹配到的元操作或API：
logic: Check whether the super class of class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.8993715643882751
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8142814636230469
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is an interface.* 匹配到的元操作或API：
logic: Check whether the class is an interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9778784513473511
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the super class of class is private.* 匹配到的元操作或API：
logic: Check whether the super class of class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.8993715643882751
*Check whether the class can be extended from outside their compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class contains at least one abstract method.* 匹配到的元操作或API：
logic: Check whether the class contains at least one abstract method.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.8919692635536194
*Check whether the class can be made final.* 匹配到的元操作或API：
logic: Check whether the class can be made final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9383472800254822
*Check whether the class is already final.* 匹配到的元操作或API：
logic: Check whether the class is already final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9633882641792297
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Inner class with only private constructor extended within compilation unit (#2536)
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
    public static final class Sub extends InputBits {
        private Sub() {
            super(1);
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
            ——ASTExplicitConstructorInvocation
              ——ASTArgumentList (size = 1)
                ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()
11. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
12. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
13. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
14. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()

1.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```
2.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                if (!isExtendedWithinCompilationUnit(node)) {
                    addViolation(data, node);
                }
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }

    private boolean isExtendedWithinCompilationUnit(ASTClassOrInterfaceDeclaration node) {
        String simpleName = node.getSimpleName();
        ASTCompilationUnit compilationUnit = node.getFirstParentOfType(ASTCompilationUnit.class);
        return compilationUnit.descendants(ASTClassOrInterfaceDeclaration.class)
                .filter(ASTClassOrInterfaceDeclaration::isNested)
                .anyMatch(subClass -> extendsSpecificClass(subClass, simpleName));
    }

    private boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node, String className) {
        ASTClassOrInterfaceType superClassTypeNode = node.getSuperClassTypeNode();
        return superClassTypeNode != null && className.equals(superClassTypeNode.getSimpleName());
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 9
[ERROR]   "ok 10" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
107
91
94
78
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is private.
3. Get the class that method located in.
4. Check whether the class has declared constructors.
5. If the class has declared constructors, get the declared constructor.
6. Check whether the declared constructor is private.
7. If the class does not have declared constructors, check whether the class is a static inner class.
8. Get all subclasses of the class.
9. Check whether each subclass is in the same compilation unit.
10. Check whether the class is final.

For the test case provided, the steps would be:

1. Get the name of class: Main209
2. Check whether the class is private: False
3. Get the class that method located in: Main209
4. Get all subclasses of the class: InputBits, Sub
5. Check whether each subclass is in the same compilation unit:
   - For Sub: True
   - For InputBits: False (it is the parent, not a subclass in the traditional sense)
6. Get the name of class: InputBits
7. Check whether the class is private: True
8. Check whether the class has declared constructors: False
9. Since the class is a private static inner class, it implicitly has a private constructor.
10. Check whether the class is final: False

Since InputBits has a private constructor and no explicit constructors, it cannot be extended from outside its compilation unit. However, it is not marked as final, which is the intended advice from the rule.

11. Get the name of class: Sub
12. Check whether the class is private: False
13. Get the class that method located in: Main209
14. Check whether the class is final: True (Sub is final, but it extends InputBits, which does not violate the rule as InputBits cannot be extended from outside its compilation unit)

The number of violating the rule in this test case is: 0

The rule is not violated because InputBits has a private constructor and cannot be extended from outside its compilation unit, and Sub is final but it is extending InputBits, which is within the same compilation unit.
['Get the name of class.', 'Check whether the class is private.', 'Get the class that method located in.', 'Check whether the class has declared constructors.', 'If the class has declared constructors, get the declared constructor.', 'Check whether the declared constructor is private.', 'If the class does not have declared constructors, check whether the class is a static inner class.', 'Get all subclasses of the class.', 'Check whether each subclass is in the same compilation unit.', 'Check whether the class is final.', 'Get the name of class: Main209', 'Check whether the class is private: False', 'Get the class that method located in: Main209', 'Get all subclasses of the class: InputBits, Sub', 'Check whether each subclass is in the same compilation unit:', 'Get the name of class: InputBits', 'Check whether the class is private: True', 'Check whether the class has declared constructors: False', 'Since the class is a private static inner class, it implicitly has a private constructor.', 'Check whether the class is final: False', 'Get the name of class: Sub', 'Check whether the class is private: False', 'Get the class that method located in: Main209', 'Check whether the class is final: True (Sub is final, but it extends InputBits, which does not violate the rule as InputBits cannot be extended from outside its compilation unit)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTExtendsList', 'TypesFromReflection', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Get the class that method located in.* 匹配到的元操作或API：
logic: Get the class that method located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9805244207382202
*Check whether the class has declared constructors.* 匹配到的元操作或API：
logic: Check whether the class has declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.8875755667686462
*If the class has declared constructors, get the declared constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the declared constructor is private.* 匹配到的元操作或API：
logic: Check whether the declared constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9762377738952637
*If the class does not have declared constructors, check whether the class is a static inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all subclasses of the class.* 匹配到的元操作或API：
query: Get all subclasses of the class.
most similar API: get permitted subclasses of class or interface
cosine Similarity: 0.8104342222213745
*Check whether each subclass is in the same compilation unit.* 匹配到的元操作或API：
query: Check whether each subclass is in the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8550677299499512
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get the name of class: Main209* 匹配到的元操作或API：
logic: Get the name of class: Main209
most similar meta operation: Get the name of class
cosine Similarity: 0.8585509061813354
*Check whether the class is private: False* 匹配到的元操作或API：
logic: Check whether the class is private: False
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9666430950164795
*Get the class that method located in: Main209* 匹配到的元操作或API：
logic: Get the class that method located in: Main209
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9098597168922424
*Get all subclasses of the class: InputBits, Sub* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each subclass is in the same compilation unit:* 匹配到的元操作或API：
query: Check whether each subclass is in the same compilation unit:
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8572415709495544
*Get the name of class: InputBits* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is private: True* 匹配到的元操作或API：
logic: Check whether the class is private: True
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9700987935066223
*Check whether the class has declared constructors: False* 匹配到的元操作或API：
logic: Check whether the class has declared constructors: False
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.8819501996040344
*Since the class is a private static inner class, it implicitly has a private constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is final: False* 匹配到的元操作或API：
logic: Check whether the class is final: False
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9627463817596436
*Get the name of class: Sub* 匹配到的元操作或API：
logic: Get the name of class: Sub
most similar meta operation: Get the name of class
cosine Similarity: 0.8676699995994568
*Check whether the class is private: False* 匹配到的元操作或API：
logic: Check whether the class is private: False
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9666430950164795
*Get the class that method located in: Main209* 匹配到的元操作或API：
logic: Get the class that method located in: Main209
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9098597168922424
*Check whether the class is final: True (Sub is final, but it extends InputBits, which does not violate the rule as InputBits cannot be extended from outside its compilation unit)* 匹配到的元操作或API：
query: Check whether the class is final: True (Sub is final, but it extends InputBits, which does not violate the rule as InputBits cannot be extended from outside its compilation unit)
most similar API: Check whether the class or interface is final: Returns true if this variable, method or class is final (even implicitly).
cosine Similarity: 0.8358994722366333
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Private inner class with no ctor and usage
public class Main209 {
    private static class InputBits {
        // default ctor is implicitly private
    }
    public static final class Sub extends InputBits {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.util.List<ASTClassOrInterfaceType> getPermittedSubclasses()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal(), //Returns true if this variable, method or class is final (even implicitly).

1.  //Check whether constructor has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTConstructorDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.isEmpty() && node.isPrivate() || constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                if (!isSubclassedInSameCompilationUnit(node)) {
                    addViolation(data, node);
                }
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }

    private boolean isSubclassedInSameCompilationUnit(ASTClassOrInterfaceDeclaration node) {
        String simpleName = node.getSimpleName();
        return node.getRoot().descendants(ASTClassOrInterfaceDeclaration.class)
                .filter(n -> n.getPermittedSubclasses().stream().anyMatch(c -> c.isReferenceToClassSameCompilationUnit() && c.getType() != null && c.getType().getSimpleName().equals(simpleName)))
                .findAny()
                .isPresent();
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is an inner class.
3. Get the name of the super class of class.
4. Get all constructors declared in super class.
5. Check whether the constructor is private.
6. Check whether the class has declared annotations.
7. Get all methods declared in class.
8. Check whether the method is abstract.
9. Get all fields declared in class.
10. Check whether the field is final.

Let's perform these checks on the `InputBits` class and the `Sub` class:

1. Get the name of class. // Class name is InputBits
2. Check whether the class is an inner class. // Yes, InputBits is an inner class
3. Get the name of the super class of class. // No super class explicitly mentioned; default super class is Object
4. Get all constructors declared in super class. // Not applicable here, as we're checking the constructors in InputBits
5. Get all constructors declared in class. // No constructors explicitly declared; default constructor is present
6. Check whether the default constructor is private. // No, the default constructor is package-private (default package-private)
7. Check whether the class has declared annotations. // No, no annotations are declared
8. Get all methods declared in class. // No methods are declared
9. Check whether the class has abstract methods. // No, no methods are declared, so no abstract methods
10. Get all fields declared in class. // No fields are declared
11. Check whether the class is final. // No, the class is not final

For the `Sub` class:

1. Get the name of class. // Class name is Sub
2. Check whether the class is an inner class. // No, Sub is not an inner class
3. Get the name of the super class of class. // Super class is InputBits
4. Get all constructors declared in super class. // No constructors explicitly declared; default constructor is present
5. Check whether the default constructor is private. // No, the default constructor is package-private (default package-private)
6. Check whether the class has declared annotations. // No, no annotations are declared
7. Get all methods declared in class. // No methods are declared
8. Check whether the class has abstract methods. // No, no methods are declared, so no abstract methods
9. Get all fields declared in class. // No fields are declared
10. Check whether the class is final. // No, the class is not final

Based on the checks performed, the `InputBits` class does not have any private constructors, so it can be extended from within the same package, not just the same compilation unit. Therefore, the `Sub` class can extend `InputBits` without any issues.

Thus, the number of classes violating the rule in this test case is indeed 0.
['Get the name of class.', 'Check whether the class is an inner class.', 'Get the name of the super class of class.', 'Get all constructors declared in super class.', 'Check whether the constructor is private.', 'Check whether the class has declared annotations.', 'Get all methods declared in class.', 'Check whether the method is abstract.', 'Get all fields declared in class.', 'Check whether the field is final.', 'Get the name of class. // Class name is InputBits', 'Check whether the class is an inner class. // Yes, InputBits is an inner class', 'Get the name of the super class of class. // No super class explicitly mentioned; default super class is Object', "Get all constructors declared in super class. // Not applicable here, as we're checking the constructors in InputBits", 'Get all constructors declared in class. // No constructors explicitly declared; default constructor is present', 'Check whether the default constructor is private. // No, the default constructor is package-private (default package-private)', 'Check whether the class has declared annotations. // No, no annotations are declared', 'Get all methods declared in class. // No methods are declared', 'Check whether the class has abstract methods. // No, no methods are declared, so no abstract methods', 'Get all fields declared in class. // No fields are declared', 'Check whether the class is final. // No, the class is not final', 'Get the name of class. // Class name is Sub', 'Check whether the class is an inner class. // No, Sub is not an inner class', 'Get the name of the super class of class. // Super class is InputBits', 'Get all constructors declared in super class. // No constructors explicitly declared; default constructor is present', 'Check whether the default constructor is private. // No, the default constructor is package-private (default package-private)', 'Check whether the class has declared annotations. // No, no annotations are declared', 'Get all methods declared in class. // No methods are declared', 'Check whether the class has abstract methods. // No, no methods are declared, so no abstract methods', 'Get all fields declared in class. // No fields are declared', 'Check whether the class is final. // No, the class is not final']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTExtendsList', 'TypesFromReflection', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Get the name of the super class of class.* 匹配到的元操作或API：
logic: Get the name of the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9248480796813965
*Get all constructors declared in super class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8142814636230469
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Get all fields declared in class.* 匹配到的元操作或API：
query: Get all fields declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8290456533432007
*Check whether the field is final.* 匹配到的元操作或API：
logic: Check whether the field is final.
most similar meta operation: Check whether the field is final
cosine Similarity: 0.9875956177711487
*Get the name of class. // Class name is InputBits* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is an inner class. // Yes, InputBits is an inner class* 匹配到的元操作或API：
logic: Check whether the class is an inner class. // Yes, InputBits is an inner class
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8907055854797363
*Get the name of the super class of class. // No super class explicitly mentioned; default super class is Object* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors declared in super class. // Not applicable here, as we're checking the constructors in InputBits* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors declared in class. // No constructors explicitly declared; default constructor is present* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the default constructor is private. // No, the default constructor is package-private (default package-private)* 匹配到的元操作或API：
logic: Check whether the default constructor is private. // No, the default constructor is package-private (default package-private)
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.9088448286056519
*Check whether the class has declared annotations. // No, no annotations are declared* 匹配到的元操作或API：
logic: Check whether the class has declared annotations. // No, no annotations are declared
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9519068002700806
*Get all methods declared in class. // No methods are declared* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has abstract methods. // No, no methods are declared, so no abstract methods* 匹配到的元操作或API：
logic: Check whether the class has abstract methods. // No, no methods are declared, so no abstract methods
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.8684167265892029
*Get all fields declared in class. // No fields are declared* 匹配到的元操作或API：
query: Get all fields declared in class. // No fields are declared
most similar API: get declarations of class or interface
cosine Similarity: 0.8042603135108948
*Check whether the class is final. // No, the class is not final* 匹配到的元操作或API：
logic: Check whether the class is final. // No, the class is not final
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9608432650566101
*Get the name of class. // Class name is Sub* 匹配到的元操作或API：
logic: Get the name of class. // Class name is Sub
most similar meta operation: Get the name of class
cosine Similarity: 0.8592577576637268
*Check whether the class is an inner class. // No, Sub is not an inner class* 匹配到的元操作或API：
logic: Check whether the class is an inner class. // No, Sub is not an inner class
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9091489315032959
*Get the name of the super class of class. // Super class is InputBits* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors declared in super class. // No constructors explicitly declared; default constructor is present* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the default constructor is private. // No, the default constructor is package-private (default package-private)* 匹配到的元操作或API：
logic: Check whether the default constructor is private. // No, the default constructor is package-private (default package-private)
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.9088448286056519
*Check whether the class has declared annotations. // No, no annotations are declared* 匹配到的元操作或API：
logic: Check whether the class has declared annotations. // No, no annotations are declared
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9519068002700806
*Get all methods declared in class. // No methods are declared* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has abstract methods. // No, no methods are declared, so no abstract methods* 匹配到的元操作或API：
logic: Check whether the class has abstract methods. // No, no methods are declared, so no abstract methods
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.8684167265892029
*Get all fields declared in class. // No fields are declared* 匹配到的元操作或API：
query: Get all fields declared in class. // No fields are declared
most similar API: get declarations of class or interface
cosine Similarity: 0.8042603135108948
*Check whether the class is final. // No, the class is not final* 匹配到的元操作或API：
logic: Check whether the class is final. // No, the class is not final
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9608432650566101
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Private inner class with no ctor and usage
public class Main209 {
    private static class InputBits {
        // default ctor is implicitly private
    }
    public static final class Sub extends InputBits {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
7. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isFinal()
8. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPackagePrivate()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.isEmpty() || constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                boolean hasSubclass = node.getCompilationUnit().getDeclarations(ASTClassOrInterfaceDeclaration.class)
                    .anyMatch(c -> c.getSuperClassTypeNode() != null && c.getSuperClassTypeNode().getImage().equals(node.getSimpleName()));
                if (!hasSubclass) {
                    addViolation(data, node);
                }
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get the name of the package where the class is located.
3. Get all declared constructors of class.
4. Check whether the constructor is private.
5. Check whether the class is an inner class.
6. Check whether the class has any annotations indicating it should be extended.
7. Get all subclasses of the class.
8. Check whether the subclass is declared inside the same compilation unit.
9. Check whether class is final.

For the `InputBits` class:
1. Get the name of class: InputBits
2. Get the name of the package where the class is located: (default package or Main209 package)
3. Get all declared constructors of class: No explicitly declared constructors, default constructor is used.
4. Check whether the constructor is private: Default constructor is implicitly private in a private inner class.
5. Check whether the class is an inner class: Yes, InputBits is an inner class of Main209.
6. Check whether the class has any annotations indicating it should be extended: No annotations are present.
7. Get all subclasses of the class: Sub is a subclass.
8. Check whether the subclass is declared inside the same compilation unit: Yes, Sub is declared inside Main209.
9. Check whether class is final: No, InputBits is not final.

Since the default constructor is implicitly private because `InputBits` is a private inner class, and the subclass `Sub` is declared within the same compilation unit, `InputBits` does not violate the rule.

For the `Sub` class:
1. Get the name of class: Sub
2. Check whether the class is an interface: No, Sub is a class.
3. Check whether the class has declared annotations: No annotations are present.
4. Check whether the class has extended x class: Yes, Sub extends InputBits.
5. Get the super class of class: InputBits
6. Check whether the super class has private constructors: Yes, InputBits has an implicitly private constructor.
7. Check whether the super class is an inner class: Yes, InputBits is an inner class of Main209.
8. Check whether the class is final: Yes, Sub is final.

Since `Sub` is final and extends a private inner class (`InputBits`), it does not violate the rule either.

The number of violations in this test case is: 0
['Get the name of class.', 'Get the name of the package where the class is located.', 'Get all declared constructors of class.', 'Check whether the constructor is private.', 'Check whether the class is an inner class.', 'Check whether the class has any annotations indicating it should be extended.', 'Get all subclasses of the class.', 'Check whether the subclass is declared inside the same compilation unit.', 'Check whether class is final.', 'Get the name of class: InputBits', 'Get the name of the package where the class is located: (default package or Main209 package)', 'Get all declared constructors of class: No explicitly declared constructors, default constructor is used.', 'Check whether the constructor is private: Default constructor is implicitly private in a private inner class.', 'Check whether the class is an inner class: Yes, InputBits is an inner class of Main209.', 'Check whether the class has any annotations indicating it should be extended: No annotations are present.', 'Get all subclasses of the class: Sub is a subclass.', 'Check whether the subclass is declared inside the same compilation unit: Yes, Sub is declared inside Main209.', 'Check whether class is final: No, InputBits is not final.', 'Get the name of class: Sub', 'Check whether the class is an interface: No, Sub is a class.', 'Check whether the class has declared annotations: No annotations are present.', 'Check whether the class has extended x class: Yes, Sub extends InputBits.', 'Get the super class of class: InputBits', 'Check whether the super class has private constructors: Yes, InputBits has an implicitly private constructor.', 'Check whether the super class is an inner class: Yes, InputBits is an inner class of Main209.', 'Check whether the class is final: Yes, Sub is final.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTExtendsList', 'TypesFromReflection', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Get all declared constructors of class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Check whether the class has any annotations indicating it should be extended.* 匹配到的元操作或API：
logic: Check whether the class has any annotations indicating it should be extended.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.8524868488311768
*Get all subclasses of the class.* 匹配到的元操作或API：
query: Get all subclasses of the class.
most similar API: get permitted subclasses of class or interface
cosine Similarity: 0.8104342222213745
*Check whether the subclass is declared inside the same compilation unit.* 匹配到的元操作或API：
query: Check whether the subclass is declared inside the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8592391014099121
*Check whether class is final.* 匹配到的元操作或API：
logic: Check whether class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.98996502161026
*Get the name of class: InputBits* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the package where the class is located: (default package or Main209 package)* 匹配到的元操作或API：
logic: Get the name of the package where the class is located: (default package or Main209 package)
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9107149243354797
*Get all declared constructors of class: No explicitly declared constructors, default constructor is used.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: Default constructor is implicitly private in a private inner class.* 匹配到的元操作或API：
logic: Check whether the constructor is private: Default constructor is implicitly private in a private inner class.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9212191700935364
*Check whether the class is an inner class: Yes, InputBits is an inner class of Main209.* 匹配到的元操作或API：
logic: Check whether the class is an inner class: Yes, InputBits is an inner class of Main209.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8720225691795349
*Check whether the class has any annotations indicating it should be extended: No annotations are present.* 匹配到的元操作或API：
query: Check whether the class has any annotations indicating it should be extended: No annotations are present.
most similar API: Check whether the class or interface is any annotation present
cosine Similarity: 0.806260347366333
*Get all subclasses of the class: Sub is a subclass.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass is declared inside the same compilation unit: Yes, Sub is declared inside Main209.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether class is final: No, InputBits is not final.* 匹配到的元操作或API：
logic: Check whether class is final: No, InputBits is not final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.8975862264633179
*Get the name of class: Sub* 匹配到的元操作或API：
logic: Get the name of class: Sub
most similar meta operation: Get the name of class
cosine Similarity: 0.8676699995994568
*Check whether the class is an interface: No, Sub is a class.* 匹配到的元操作或API：
logic: Check whether the class is an interface: No, Sub is a class.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.8919969797134399
*Check whether the class has declared annotations: No annotations are present.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations: No annotations are present.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9443188309669495
*Check whether the class has extended x class: Yes, Sub extends InputBits.* 匹配到的元操作或API：
logic: Check whether the class has extended x class: Yes, Sub extends InputBits.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.8974848985671997
*Get the super class of class: InputBits* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the super class has private constructors: Yes, InputBits has an implicitly private constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the super class is an inner class: Yes, InputBits is an inner class of Main209.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is final: Yes, Sub is final.* 匹配到的元操作或API：
logic: Check whether the class is final: Yes, Sub is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9107962250709534
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Private inner class with no ctor and usage
public class Main209 {
    private static class InputBits {
        // default ctor is implicitly private
    }
    public static final class Sub extends InputBits {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.util.List<ASTClassOrInterfaceType> getPermittedSubclasses()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection), //Checks whether any annotation is present on this node. @param binaryNames            Collection that contains binary names of annotations.            Note: for now, canonical names are tolerated, this may be changed in PMD 7. @return <code>true</code> if any annotation is present on this node, else <code>false</code>
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.isEmpty() || constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                if (!isExtendedOutsideCompilationUnit(node)) {
                    addViolation(data, node);
                }
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }

    private boolean isExtendedOutsideCompilationUnit(ASTClassOrInterfaceDeclaration node) {
        return node.getCompilationUnit().getDeclaredClasses().stream()
                .filter(ASTClassOrInterfaceDeclaration::isNested)
                .flatMap(ASTClassOrInterfaceDeclaration::getExtendsList)
                .map(ASTExtendsList::getFirstChildOfType, ASTClassOrInterfaceType.class)
                .anyMatch(type -> type.getType() == null && !type.isReferenceToClassSameCompilationUnit() && type.getSimpleName().equals(node.getSimpleName()));
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is an inner class.
3. Check whether the class is private.
4. Get all constructors declared in class.
5. Check whether the constructor is private.
6. Get the name of the super class of class.
7. Check whether the class is an inner class.
8. Check whether the class is private.
9. Get all constructors declared in the super class.
10. Check whether the constructor is private.
11. Get all subclasses of the class.
12. Check whether the class is an inner class.
13. Check whether the class is private.

In this case,
1. The class `Main209` is not an inner class and is not private.
2. The inner class `InputBits` is private and has an implicitly private default constructor.
3. The class `Sub` is a public final class and extends `InputBits`.

Since `InputBits` is a private inner class, it cannot be extended from outside its compilation unit, and `Sub` is correctly marked as final. Therefore, there are no violations of the rule in this test case.
['Get the name of class.', 'Check whether the class is an inner class.', 'Check whether the class is private.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get the name of the super class of class.', 'Check whether the class is an inner class.', 'Check whether the class is private.', 'Get all constructors declared in the super class.', 'Check whether the constructor is private.', 'Get all subclasses of the class.', 'Check whether the class is an inner class.', 'Check whether the class is private.', 'The class `Main209` is not an inner class and is not private.', 'The inner class `InputBits` is private and has an implicitly private default constructor.', 'The class `Sub` is a public final class and extends `InputBits`.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTExtendsList', 'TypesFromReflection', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the name of the super class of class.* 匹配到的元操作或API：
logic: Get the name of the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9248480796813965
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Get all constructors declared in the super class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get all subclasses of the class.* 匹配到的元操作或API：
query: Get all subclasses of the class.
most similar API: get permitted subclasses of class or interface
cosine Similarity: 0.8104342222213745
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*The class `Main209` is not an inner class and is not private.* 匹配到的元操作或API：
未匹配成功元操作或API
*The inner class `InputBits` is private and has an implicitly private default constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*The class `Sub` is a public final class and extends `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Private inner class with no ctor and usage
public class Main209 {
    private static class InputBits {
        // default ctor is implicitly private
    }
    public static final class Sub extends InputBits {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.util.List<ASTClassOrInterfaceType> getPermittedSubclasses()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate) && !hasSubclass(node)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate) && !hasSubclass(node)) {
                addViolation(data, node);
            }
        }
        return data;
    }

    private boolean hasSubclass(ASTClassOrInterfaceDeclaration node) {
        String simpleName = node.getSimpleName();
        return node.getRoot().descendants(ASTClassOrInterfaceDeclaration.class)
                   .map(ASTClassOrInterfaceDeclaration::getSuperClassTypeNode)
                   .filter(supertype -> supertype != null)
                   .map(ASTClassOrInterfaceType::getName)
                   .anyMatch(simpleName::equals);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Check whether the class is an inner class.
        3. Check whether the inner class is static.
        4. Get the name of super class of class.
        5. Check whether the super class is declared in the same compilation unit.
        6. Get all constructors declared in class.
        7. Check whether the constructor is private.
        8. Get all subclasses of class.
        9. Check whether each subclass is declared in the same compilation unit.

For the test case provided:

1. Get the name of class: Main209
2. Check whether the class is an inner class: False
3. Get the name of class: InputBits
4. Check whether the class is an inner class: True
5. Check whether the inner class is static: True
6. Get the name of super class of class: Object (for InputBits)
7. Check whether the super class is declared in the same compilation unit: False (Object is not in the same compilation unit as InputBits)
8. Get all constructors declared in class: InputBits has an implicit default constructor
9. Check whether the constructor is private: False (the implicit default constructor is package-private)
10. Get all subclasses of class: InputBits has a subclass Sub
11. Check whether each subclass is declared in the same compilation unit: True (Sub is declared in the same compilation unit as InputBits)

Since InputBits does not have a private constructor and its subclass Sub is declared in the same compilation unit, InputBits does not violate the rule.

The number of violations in this test case is indeed 0.
['Get the name of class.', 'Check whether the class is an inner class.', 'Check whether the inner class is static.', 'Get the name of super class of class.', 'Check whether the super class is declared in the same compilation unit.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get all subclasses of class.', 'Check whether each subclass is declared in the same compilation unit.', 'Get the name of class: Main209', 'Check whether the class is an inner class: False', 'Get the name of class: InputBits', 'Check whether the class is an inner class: True', 'Check whether the inner class is static: True', 'Get the name of super class of class: Object (for InputBits)', 'Check whether the super class is declared in the same compilation unit: False (Object is not in the same compilation unit as InputBits)', 'Get all constructors declared in class: InputBits has an implicit default constructor', 'Check whether the constructor is private: False (the implicit default constructor is package-private)', 'Get all subclasses of class: InputBits has a subclass Sub', 'Check whether each subclass is declared in the same compilation unit: True (Sub is declared in the same compilation unit as InputBits)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTExtendsList', 'TypesFromReflection', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Check whether the inner class is static.* 匹配到的元操作或API：
logic: Check whether the inner class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9092438220977783
*Get the name of super class of class.* 匹配到的元操作或API：
logic: Get the name of super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9218384623527527
*Check whether the super class is declared in the same compilation unit.* 匹配到的元操作或API：
query: Check whether the super class is declared in the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.847521960735321
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get all subclasses of class.* 匹配到的元操作或API：
query: Get all subclasses of class.
most similar API: get permitted subclasses of class or interface
cosine Similarity: 0.8182532787322998
*Check whether each subclass is declared in the same compilation unit.* 匹配到的元操作或API：
query: Check whether each subclass is declared in the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8518114686012268
*Get the name of class: Main209* 匹配到的元操作或API：
logic: Get the name of class: Main209
most similar meta operation: Get the name of class
cosine Similarity: 0.8585509061813354
*Check whether the class is an inner class: False* 匹配到的元操作或API：
logic: Check whether the class is an inner class: False
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9639589190483093
*Get the name of class: InputBits* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is an inner class: True* 匹配到的元操作或API：
logic: Check whether the class is an inner class: True
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9726787209510803
*Check whether the inner class is static: True* 匹配到的元操作或API：
logic: Check whether the inner class is static: True
most similar meta operation: Check whether the class is static
cosine Similarity: 0.900020956993103
*Get the name of super class of class: Object (for InputBits)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the super class is declared in the same compilation unit: False (Object is not in the same compilation unit as InputBits)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors declared in class: InputBits has an implicit default constructor* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: False (the implicit default constructor is package-private)* 匹配到的元操作或API：
logic: Check whether the constructor is private: False (the implicit default constructor is package-private)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9103065729141235
*Get all subclasses of class: InputBits has a subclass Sub* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each subclass is declared in the same compilation unit: True (Sub is declared in the same compilation unit as InputBits)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Private inner class with no ctor and usage
public class Main209 {
    private static class InputBits {
        // default ctor is implicitly private
    }
    public static final class Sub extends InputBits {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.util.List<ASTClassOrInterfaceType> getPermittedSubclasses()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.isEmpty() || constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                NodeStream<ASTClassOrInterfaceDeclaration> subclasses = node.getCompilationUnit().descendants(ASTClassOrInterfaceDeclaration.class)
                        .filter(sub -> sub.getSuperClassTypeNode() != null && sub.getSuperClassTypeNode().isReferenceToClassSameCompilationUnit() && sub.getSuperClassTypeNode().getType().getQualifiedName().equals(node.getQualifiedName()));
                if (!subclasses.anyMatch(sub -> !sub.isFinal())) {
                    addViolation(data, node);
                }
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 10
[ERROR]   "ok 11" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
107
91
97
81
83
69
94
78
96
81
93
78
144
127
77
63
156
136
106
91
116
101
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Get the declared constructors of class.
        3. Check whether each constructor is private.
        4. Check whether the class is abstract.
        5. Get all methods declared in class.
        6. Check whether each method is abstract.
        7. Check whether the class is an inner class.
        8. Check whether the class has declared annotations.
        9. Get the name of the package where the class is located.

For the given test case, perform these checks:

1. Get the name of class.
        - Outer
2. Get the declared constructors of class.
        - Constructors of Outer are not relevant as the rule focuses on inner classes.
3. For the inner class `Base`:
        1. Get the declared constructors of class.
        2. Check whether each constructor is private.
        3. Check whether the class is abstract.
        4. Get all methods declared in class.
        5. Check whether each method is abstract.
        6. Check whether the class is an inner class.
        7. Check whether the class has declared annotations.
        8. Get the name of the package where the class is located.

Let's perform the checks for the inner class `Base`:

1. Get the name of class.
        - Base
2. Get the declared constructors of class.
        - There are no explicitly declared constructors, so the default constructor is used.
3. Check whether each constructor is private.
        - The default constructor is not private, but there are no explicitly declared constructors.
4. Check whether the class is abstract.
        - Yes, Base is an abstract class.
5. Get all methods declared in class.
        - `run()`
6. Check whether each method is abstract.
        - Yes, `run()` is an abstract method.
7. Check whether the class is an inner class.
        - Yes, Base is an inner class of Outer.
8. Check whether the class has declared annotations.
        - No, Base does not have any declared annotations.
9. Get the name of the package where the class is located.
        - This is not relevant for the rule as it focuses on the visibility of constructors.

Given that `Base` is an abstract class with at least one abstract method and none of the constructors are explicitly declared as private, it does not violate the rule. Therefore, the number of violating the rule in this test case is indeed 0.
['Get the name of class.', 'Get the declared constructors of class.', 'Check whether each constructor is private.', 'Check whether the class is abstract.', 'Get all methods declared in class.', 'Check whether each method is abstract.', 'Check whether the class is an inner class.', 'Check whether the class has declared annotations.', 'Get the name of the package where the class is located.', 'Get the name of class.', 'Get the declared constructors of class.', 'For the inner class `Base`:', 'Get the declared constructors of class.', 'Check whether each constructor is private.', 'Check whether the class is abstract.', 'Get all methods declared in class.', 'Check whether each method is abstract.', 'Check whether the class is an inner class.', 'Check whether the class has declared annotations.', 'Get the name of the package where the class is located.', 'Get the name of class.', 'Get the declared constructors of class.', 'Check whether each constructor is private.', 'Check whether the class is abstract.', 'Get all methods declared in class.', 'Check whether each method is abstract.', 'Check whether the class is an inner class.', 'Check whether the class has declared annotations.', 'Get the name of the package where the class is located.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTExpressionStatement', 'TokenUtils', 'ASTAnonymousClassDeclaration', 'ASTClassOrInterfaceDeclaration', 'ASTConstructorCall', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the declared constructors of class.* 匹配到的元操作或API：
query: Get the declared constructors of class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8173896074295044
*Check whether each constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442476630210876
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether each method is abstract.* 匹配到的元操作或API：
logic: Check whether each method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9491450190544128
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the declared constructors of class.* 匹配到的元操作或API：
query: Get the declared constructors of class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8173896074295044
*For the inner class `Base`:* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the declared constructors of class.* 匹配到的元操作或API：
query: Get the declared constructors of class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8173896074295044
*Check whether each constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442476630210876
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether each method is abstract.* 匹配到的元操作或API：
logic: Check whether each method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9491450190544128
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the declared constructors of class.* 匹配到的元操作或API：
query: Get the declared constructors of class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8173896074295044
*Check whether each constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442476630210876
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether each method is abstract.* 匹配到的元操作或API：
logic: Check whether each method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9491450190544128
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract classes with abstract methods should be ignored #3668
public class Outer {
    private abstract class Base {
        abstract void run();
    }
    public void someMethod() {
        Base b = new Base() {
            void run() {}
        };
        b.run();
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
    ——ASTMethodDeclaration (method name = 'someMethod')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'b')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 0)
              ——ASTAnonymousClassDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceBody
                  ——ASTMethodDeclaration (method name = 'run')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 0)
                    ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'run')
            ——ASTVariableAccess (referenced variable name = 'b')
            ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                if (!isExtendedByInnerClass(node)) {
                    addViolation(data, node);
                }
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }

    private boolean isExtendedByInnerClass(ASTClassOrInterfaceDeclaration node) {
        ASTClassOrInterfaceBody body = node.getFirstChildOfType(ASTClassOrInterfaceBody.class);
        if (body != null) {
            return body.descendants(ASTAnonymousClassDeclaration.class).anyMatch(anonymous -> isSubclassOf(anonymous, node.getSimpleName()));
        }
        return false;
    }

    private boolean isSubclassOf(ASTAnonymousClassDeclaration anonymous, String className) {
        NodeStream<ASTClassOrInterfaceDeclaration> declarations = anonymous.getDeclarations(ASTClassOrInterfaceDeclaration.class);
        return declarations.anyMatch(declaration -> declaration.getSuperClassType() != null && declaration.getSuperClassType().getSimpleName().equals(className));
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To analyze whether the test case adheres to the rule, we need to perform the following granular checks:

1. Get the name of class (Outer).
2. Check whether class has declared annotations.
3. Get a declared annotation of class.
4. Check whether the class has x annotation.
5. Get the javadoc comment of class.
6. Check whether the class is abstract.
7. Check whether the class is public.
8. Check whether the class is private.
9. Check whether the class is protected.
10. Check whether the class is default package-private.
11. Check whether the class is final.
12. Check whether the class is static.
13. Get the super class of class.
14. Check whether the class has extended x class.
15. Get a implemented interface of class.
16. Check whether the class has implemented x interface.
17. Get the name of the package where the class is located.
18. Check whether the class is interface.
19. Check whether the class is inner class.
20. Check whether the class is anonymous class.
21. Check whether the class is default package-private.
22. Get the constructor list of class.
23. Check whether constructor is private.
24. Check whether constructor is public.
25. Check whether constructor is default package-private.
26. Check whether constructor is protected.
27. Get the name of class (Base).
28. Check whether class has declared annotations.
29. Get a declared annotation of class.
30. Check whether the class has x annotation.
31. Get the javadoc comment of class.
32. Check whether the class is abstract.
33. Check whether the class is public.
34. Check whether the class is private.
35. Check whether the class is protected.
36. Check whether the class is default package-private.
37. Check whether the class is final.
38. Check whether the class is static.
39. Get the super class of class.
40. Check whether the class has extended x class.
41. Get a implemented interface of class.
42. Check whether the class has implemented x interface.
43. Get the name of the package where the class is located.
44. Check whether the class is interface.
45. Check whether the class is inner class.
46. Check whether the class is anonymous class.
47. Check whether the class is default package-private.
48. Get the constructor list of class.
49. Check whether constructor is private.
50. Check whether constructor is public.
51. Check whether constructor is default package-private.
52. Check whether constructor is protected.
53. Get the method list of class.
54. Check whether the method is abstract.
55. Check whether the method is private.
56. Check whether the method is public.
57. Check whether the method is default package-private.
58. Check whether the method is protected.
59. Check whether the method is main method.
60. Get the return type of method.
61. Check whether the method signature throws x Exception.
62. Check whether method has declared annotations.
63. Get a declared annotation of method.
64. Check whether the method has x annotation.
65. Check whether the method is synchronized.
66. Check whether the method is static.
67. Check whether the method is final.
68. Check whether the method is native.
69. Check whether the method is overridable.
70. Check whether the method is overridden.
71. Get the original method of this overridden method.
72. Get the class that method located in.
73. Check whether the method is a junit method.
74. Get the return expression in return statement.

Now, let's apply these checks to the test case:

1. Get the name of class (Outer).
2. Check whether class has declared annotations. (False)
3. Get a declared annotation of class. (Not applicable)
4. Check whether the class has x annotation. (Not applicable)
5. Get the javadoc comment of class. (Not applicable)
6. Check whether the class is abstract. (False)
7. Check whether the class is public. (True)
8. Check whether the class is private. (False)
9. Check whether the class is protected. (False)
10. Check whether the class is default package-private. (False)
11. Check whether the class is final. (False)
12. Check whether the class is static. (False)
13. Get the super class of class. (Object)
14. Check whether the class has extended x class. (False)
15. Get a implemented interface of class. (Not applicable)
16. Check whether the class has implemented x interface. (Not applicable)
17. Get the name of the package where the class is located. (Not applicable)
18. Check whether the class is interface. (False)
19. Check whether the class is inner class. (False)
20. Check whether the class is anonymous class. (False)
21. Check whether the class is default package-private. (False)
22. Get the constructor list of class.
23. Check whether constructor is private. (False)
24. Check whether constructor is public. (True)
25. Check whether constructor is default package-private. (False)
26. Check whether constructor is protected. (False)
27. Get the name of class (Base).
28. Check whether class has declared annotations. (False)
29. Get a declared annotation of class. (Not applicable)
30. Check whether the class has x annotation. (Not applicable)
31. Get the javadoc comment of class. (Not applicable)
32. Check whether the class is abstract. (True)
33. Check whether the class is public. (False)
34. Check whether the class is private. (True)
35. Check whether the class is protected. (False)
36. Check whether the class is default package-private. (False)
37. Check whether the class is final. (False)
38. Check whether the class is static. (False)
39. Get the super class of class. (Outer)
40. Check whether the class has extended x class. (True, extended from Outer)
41. Get a implemented interface of class. (Not applicable)
42. Check whether the class has implemented x interface. (Not applicable)
43. Get the name of the package where the class is located. (Not applicable)
44. Check whether the class is interface. (False)
45. Check whether the class is inner class. (True, inner class of Outer)
46. Check whether the class is anonymous class. (False)
47. Check whether the class is default package-private. (False)
48. Get the constructor list of class.
49. Check whether constructor is private. (Not applicable, no constructor explicitly defined)
50. Check whether constructor is public. (Not applicable, no constructor explicitly defined)
51. Check whether constructor is default package-private. (Not applicable, no constructor explicitly defined)
52. Check whether constructor is protected. (Not applicable, no constructor explicitly defined)
53. Get the method list of class.
54. Check whether the method is abstract. (True, run method is abstract)
55. Check whether the method is private. (False)
56. Check whether the method is public. (False)
57. Check whether the method is default package-private. (False)
58. Check whether the method is protected. (False)
59. Check whether the method is main method. (False)
60. Get the return type of method. (void)
61. Check whether the method signature throws x Exception. (Not applicable)
62. Check whether method has declared annotations. (False)
63. Get a declared annotation of method. (Not applicable)
64. Check whether the method has x annotation. (Not applicable)
65. Check whether the method is synchronized. (False)
66. Check whether the method is static. (False)
67. Check whether the method is final. (False)
68. Check whether the method is native. (False)
69. Check whether the method is overridable. (True, run method is abstract)
70. Check whether the method is overridden. (False, run method is not overridden in Base)
71. Get the original method of this overridden method. (Not applicable)
72. Get the class that method located in. (Base)
73. Check whether the method is a junit method. (False)
74. Get the return expression in return statement. (Not applicable)

Based on the checks performed, the test case does not violate the rule because:
- The class `Base` is private and cannot be extended from outside its compilation unit.
- It contains an abstract method `run`, which is required for the rule to be applicable only if the class were not abstract.
- There are no constructors declared in `Base`, but the absence of constructors does not apply as the rule specifies the constructors being private, which is not the case here.
- The class `Base` is explicitly declared as abstract, thus it is ignored by the rule as per the description.

Therefore, the number of violations in this test case is indeed: 0.
['Get the name of class (Outer).', 'Check whether class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the class has x annotation.', 'Get the javadoc comment of class.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get a implemented interface of class.', 'Check whether the class has implemented x interface.', 'Get the name of the package where the class is located.', 'Check whether the class is interface.', 'Check whether the class is inner class.', 'Check whether the class is anonymous class.', 'Check whether the class is default package-private.', 'Get the constructor list of class.', 'Check whether constructor is private.', 'Check whether constructor is public.', 'Check whether constructor is default package-private.', 'Check whether constructor is protected.', 'Get the name of class (Base).', 'Check whether class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the class has x annotation.', 'Get the javadoc comment of class.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get a implemented interface of class.', 'Check whether the class has implemented x interface.', 'Get the name of the package where the class is located.', 'Check whether the class is interface.', 'Check whether the class is inner class.', 'Check whether the class is anonymous class.', 'Check whether the class is default package-private.', 'Get the constructor list of class.', 'Check whether constructor is private.', 'Check whether constructor is public.', 'Check whether constructor is default package-private.', 'Check whether constructor is protected.', 'Get the method list of class.', 'Check whether the method is abstract.', 'Check whether the method is private.', 'Check whether the method is public.', 'Check whether the method is default package-private.', 'Check whether the method is protected.', 'Check whether the method is main method.', 'Get the return type of method.', 'Check whether the method signature throws x Exception.', 'Check whether method has declared annotations.', 'Get a declared annotation of method.', 'Check whether the method has x annotation.', 'Check whether the method is synchronized.', 'Check whether the method is static.', 'Check whether the method is final.', 'Check whether the method is native.', 'Check whether the method is overridable.', 'Check whether the method is overridden.', 'Get the original method of this overridden method.', 'Get the class that method located in.', 'Check whether the method is a junit method.', 'Get the return expression in return statement.', 'Get the name of class (Outer).', 'Check whether class has declared annotations. (False)', 'Get a declared annotation of class. (Not applicable)', 'Check whether the class has x annotation. (Not applicable)', 'Get the javadoc comment of class. (Not applicable)', 'Check whether the class is abstract. (False)', 'Check whether the class is public. (True)', 'Check whether the class is private. (False)', 'Check whether the class is protected. (False)', 'Check whether the class is default package-private. (False)', 'Check whether the class is final. (False)', 'Check whether the class is static. (False)', 'Get the super class of class. (Object)', 'Check whether the class has extended x class. (False)', 'Get a implemented interface of class. (Not applicable)', 'Check whether the class has implemented x interface. (Not applicable)', 'Get the name of the package where the class is located. (Not applicable)', 'Check whether the class is interface. (False)', 'Check whether the class is inner class. (False)', 'Check whether the class is anonymous class. (False)', 'Check whether the class is default package-private. (False)', 'Get the constructor list of class.', 'Check whether constructor is private. (False)', 'Check whether constructor is public. (True)', 'Check whether constructor is default package-private. (False)', 'Check whether constructor is protected. (False)', 'Get the name of class (Base).', 'Check whether class has declared annotations. (False)', 'Get a declared annotation of class. (Not applicable)', 'Check whether the class has x annotation. (Not applicable)', 'Get the javadoc comment of class. (Not applicable)', 'Check whether the class is abstract. (True)', 'Check whether the class is public. (False)', 'Check whether the class is private. (True)', 'Check whether the class is protected. (False)', 'Check whether the class is default package-private. (False)', 'Check whether the class is final. (False)', 'Check whether the class is static. (False)', 'Get the super class of class. (Outer)', 'Check whether the class has extended x class. (True, extended from Outer)', 'Get a implemented interface of class. (Not applicable)', 'Check whether the class has implemented x interface. (Not applicable)', 'Get the name of the package where the class is located. (Not applicable)', 'Check whether the class is interface. (False)', 'Check whether the class is inner class. (True, inner class of Outer)', 'Check whether the class is anonymous class. (False)', 'Check whether the class is default package-private. (False)', 'Get the constructor list of class.', 'Check whether constructor is private. (Not applicable, no constructor explicitly defined)', 'Check whether constructor is public. (Not applicable, no constructor explicitly defined)', 'Check whether constructor is default package-private. (Not applicable, no constructor explicitly defined)', 'Check whether constructor is protected. (Not applicable, no constructor explicitly defined)', 'Get the method list of class.', 'Check whether the method is abstract. (True, run method is abstract)', 'Check whether the method is private. (False)', 'Check whether the method is public. (False)', 'Check whether the method is default package-private. (False)', 'Check whether the method is protected. (False)', 'Check whether the method is main method. (False)', 'Get the return type of method. (void)', 'Check whether the method signature throws x Exception. (Not applicable)', 'Check whether method has declared annotations. (False)', 'Get a declared annotation of method. (Not applicable)', 'Check whether the method has x annotation. (Not applicable)', 'Check whether the method is synchronized. (False)', 'Check whether the method is static. (False)', 'Check whether the method is final. (False)', 'Check whether the method is native. (False)', 'Check whether the method is overridable. (True, run method is abstract)', 'Check whether the method is overridden. (False, run method is not overridden in Base)', 'Get the original method of this overridden method. (Not applicable)', 'Get the class that method located in. (Base)', 'Check whether the method is a junit method. (False)', 'Get the return expression in return statement. (Not applicable)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTExpressionStatement', 'TokenUtils', 'ASTAnonymousClassDeclaration', 'ASTClassOrInterfaceDeclaration', 'ASTConstructorCall', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class (Outer).* 匹配到的元操作或API：
logic: Get the name of class (Outer).
most similar meta operation: Get the name of class
cosine Similarity: 0.8748226761817932
*Check whether class has declared annotations.* 匹配到的元操作或API：
logic: Check whether class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9901518821716309
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.987838864326477
*Check whether the class has x annotation.* 匹配到的元操作或API：
logic: Check whether the class has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9908236265182495
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844120740890503
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a implemented interface of class.* 匹配到的元操作或API：
logic: Get a implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9851537942886353
*Check whether the class has implemented x interface.* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9905824661254883
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is interface.* 匹配到的元操作或API：
logic: Check whether the class is interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9844173789024353
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.987544596195221
*Check whether the class is anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9849605560302734
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Get the constructor list of class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether constructor is private.* 匹配到的元操作或API：
logic: Check whether constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9868366718292236
*Check whether constructor is public.* 匹配到的元操作或API：
logic: Check whether constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.9838052988052368
*Check whether constructor is default package-private.* 匹配到的元操作或API：
logic: Check whether constructor is default package-private.
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.9625356793403625
*Check whether constructor is protected.* 匹配到的元操作或API：
logic: Check whether constructor is protected.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9870729446411133
*Get the name of class (Base).* 匹配到的元操作或API：
logic: Get the name of class (Base).
most similar meta operation: Get the name of class
cosine Similarity: 0.8888643980026245
*Check whether class has declared annotations.* 匹配到的元操作或API：
logic: Check whether class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9901518821716309
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.987838864326477
*Check whether the class has x annotation.* 匹配到的元操作或API：
logic: Check whether the class has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9908236265182495
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844120740890503
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a implemented interface of class.* 匹配到的元操作或API：
logic: Get a implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9851537942886353
*Check whether the class has implemented x interface.* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9905824661254883
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is interface.* 匹配到的元操作或API：
logic: Check whether the class is interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9844173789024353
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.987544596195221
*Check whether the class is anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9849605560302734
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Get the constructor list of class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether constructor is private.* 匹配到的元操作或API：
logic: Check whether constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9868366718292236
*Check whether constructor is public.* 匹配到的元操作或API：
logic: Check whether constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.9838052988052368
*Check whether constructor is default package-private.* 匹配到的元操作或API：
logic: Check whether constructor is default package-private.
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.9625356793403625
*Check whether constructor is protected.* 匹配到的元操作或API：
logic: Check whether constructor is protected.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9870729446411133
*Get the method list of class.* 匹配到的元操作或API：
query: Get the method list of class.
most similar API: get class of method
cosine Similarity: 0.8167366981506348
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Check whether the method is private.* 匹配到的元操作或API：
logic: Check whether the method is private.
most similar meta operation: Check whether the method is private
cosine Similarity: 0.9821236729621887
*Check whether the method is public.* 匹配到的元操作或API：
logic: Check whether the method is public.
most similar meta operation: Check whether the method is public
cosine Similarity: 0.982057511806488
*Check whether the method is default package-private.* 匹配到的元操作或API：
logic: Check whether the method is default package-private.
most similar meta operation: Check whether the method is default package-private
cosine Similarity: 0.972201406955719
*Check whether the method is protected.* 匹配到的元操作或API：
logic: Check whether the method is protected.
most similar meta operation: Check whether the method is protected
cosine Similarity: 0.9815421104431152
*Check whether the method is main method.* 匹配到的元操作或API：
logic: Check whether the method is main method.
most similar meta operation: Check whether the method is main method
cosine Similarity: 0.9875174760818481
*Get the return type of method.* 匹配到的元操作或API：
logic: Get the return type of method.
most similar meta operation: Get the return type of method
cosine Similarity: 0.983596682548523
*Check whether the method signature throws x Exception.* 匹配到的元操作或API：
logic: Check whether the method signature throws x Exception.
most similar meta operation: Check whether the method signature throws x Exception
cosine Similarity: 0.9918776750564575
*Check whether method has declared annotations.* 匹配到的元操作或API：
logic: Check whether method has declared annotations.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9891549348831177
*Get a declared annotation of method.* 匹配到的元操作或API：
logic: Get a declared annotation of method.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9867770671844482
*Check whether the method has x annotation.* 匹配到的元操作或API：
logic: Check whether the method has x annotation.
most similar meta operation: Check whether the method has x annotation
cosine Similarity: 0.9902997016906738
*Check whether the method is synchronized.* 匹配到的元操作或API：
logic: Check whether the method is synchronized.
most similar meta operation: Check whether the method is synchronized
cosine Similarity: 0.9820958375930786
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is final.* 匹配到的元操作或API：
logic: Check whether the method is final.
most similar meta operation: Check whether the method is final
cosine Similarity: 0.985183835029602
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is overridable.* 匹配到的元操作或API：
logic: Check whether the method is overridable.
most similar meta operation: Check whether the method is overridable
cosine Similarity: 0.9839692115783691
*Check whether the method is overridden.* 匹配到的元操作或API：
logic: Check whether the method is overridden.
most similar meta operation: Check whether the method is overridden
cosine Similarity: 0.9829655885696411
*Get the original method of this overridden method.* 匹配到的元操作或API：
logic: Get the original method of this overridden method.
most similar meta operation: Get the original method of this overridden method
cosine Similarity: 0.9831136465072632
*Get the class that method located in.* 匹配到的元操作或API：
logic: Get the class that method located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9805244207382202
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Get the return expression in return statement.* 匹配到的元操作或API：
logic: Get the return expression in return statement.
most similar meta operation: Get the return expression in return statement
cosine Similarity: 0.9881546497344971
*Get the name of class (Outer).* 匹配到的元操作或API：
logic: Get the name of class (Outer).
most similar meta operation: Get the name of class
cosine Similarity: 0.8748226761817932
*Check whether class has declared annotations. (False)* 匹配到的元操作或API：
logic: Check whether class has declared annotations. (False)
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9754647612571716
*Get a declared annotation of class. (Not applicable)* 匹配到的元操作或API：
logic: Get a declared annotation of class. (Not applicable)
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9583664536476135
*Check whether the class has x annotation. (Not applicable)* 匹配到的元操作或API：
logic: Check whether the class has x annotation. (Not applicable)
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9748991131782532
*Get the javadoc comment of class. (Not applicable)* 匹配到的元操作或API：
logic: Get the javadoc comment of class. (Not applicable)
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9703301787376404
*Check whether the class is abstract. (False)* 匹配到的元操作或API：
logic: Check whether the class is abstract. (False)
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9625082015991211
*Check whether the class is public. (True)* 匹配到的元操作或API：
logic: Check whether the class is public. (True)
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9759844541549683
*Check whether the class is private. (False)* 匹配到的元操作或API：
logic: Check whether the class is private. (False)
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9672161936759949
*Check whether the class is protected. (False)* 匹配到的元操作或API：
logic: Check whether the class is protected. (False)
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9651520848274231
*Check whether the class is default package-private. (False)* 匹配到的元操作或API：
logic: Check whether the class is default package-private. (False)
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9806113243103027
*Check whether the class is final. (False)* 匹配到的元操作或API：
logic: Check whether the class is final. (False)
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9751865863800049
*Check whether the class is static. (False)* 匹配到的元操作或API：
logic: Check whether the class is static. (False)
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9639024138450623
*Get the super class of class. (Object)* 匹配到的元操作或API：
logic: Get the super class of class. (Object)
most similar meta operation: Get the super class of class
cosine Similarity: 0.9456300735473633
*Check whether the class has extended x class. (False)* 匹配到的元操作或API：
logic: Check whether the class has extended x class. (False)
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9709400534629822
*Get a implemented interface of class. (Not applicable)* 匹配到的元操作或API：
logic: Get a implemented interface of class. (Not applicable)
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.955134928226471
*Check whether the class has implemented x interface. (Not applicable)* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface. (Not applicable)
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9737664461135864
*Get the name of the package where the class is located. (Not applicable)* 匹配到的元操作或API：
logic: Get the name of the package where the class is located. (Not applicable)
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9588011503219604
*Check whether the class is interface. (False)* 匹配到的元操作或API：
logic: Check whether the class is interface. (False)
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9615940451622009
*Check whether the class is inner class. (False)* 匹配到的元操作或API：
logic: Check whether the class is inner class. (False)
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9710730910301208
*Check whether the class is anonymous class. (False)* 匹配到的元操作或API：
logic: Check whether the class is anonymous class. (False)
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.969922661781311
*Check whether the class is default package-private. (False)* 匹配到的元操作或API：
logic: Check whether the class is default package-private. (False)
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9806113243103027
*Get the constructor list of class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether constructor is private. (False)* 匹配到的元操作或API：
logic: Check whether constructor is private. (False)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9748086929321289
*Check whether constructor is public. (True)* 匹配到的元操作或API：
logic: Check whether constructor is public. (True)
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.9776686429977417
*Check whether constructor is default package-private. (False)* 匹配到的元操作或API：
logic: Check whether constructor is default package-private. (False)
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.9747249484062195
*Check whether constructor is protected. (False)* 匹配到的元操作或API：
logic: Check whether constructor is protected. (False)
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9771617650985718
*Get the name of class (Base).* 匹配到的元操作或API：
logic: Get the name of class (Base).
most similar meta operation: Get the name of class
cosine Similarity: 0.8888643980026245
*Check whether class has declared annotations. (False)* 匹配到的元操作或API：
logic: Check whether class has declared annotations. (False)
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9754647612571716
*Get a declared annotation of class. (Not applicable)* 匹配到的元操作或API：
logic: Get a declared annotation of class. (Not applicable)
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9583664536476135
*Check whether the class has x annotation. (Not applicable)* 匹配到的元操作或API：
logic: Check whether the class has x annotation. (Not applicable)
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9748991131782532
*Get the javadoc comment of class. (Not applicable)* 匹配到的元操作或API：
logic: Get the javadoc comment of class. (Not applicable)
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9703301787376404
*Check whether the class is abstract. (True)* 匹配到的元操作或API：
logic: Check whether the class is abstract. (True)
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9733724594116211
*Check whether the class is public. (False)* 匹配到的元操作或API：
logic: Check whether the class is public. (False)
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9632431268692017
*Check whether the class is private. (True)* 匹配到的元操作或API：
logic: Check whether the class is private. (True)
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9749976396560669
*Check whether the class is protected. (False)* 匹配到的元操作或API：
logic: Check whether the class is protected. (False)
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9651520848274231
*Check whether the class is default package-private. (False)* 匹配到的元操作或API：
logic: Check whether the class is default package-private. (False)
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9806113243103027
*Check whether the class is final. (False)* 匹配到的元操作或API：
logic: Check whether the class is final. (False)
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9751865863800049
*Check whether the class is static. (False)* 匹配到的元操作或API：
logic: Check whether the class is static. (False)
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9639024138450623
*Get the super class of class. (Outer)* 匹配到的元操作或API：
logic: Get the super class of class. (Outer)
most similar meta operation: Get the super class of class
cosine Similarity: 0.9273505806922913
*Check whether the class has extended x class. (True, extended from Outer)* 匹配到的元操作或API：
logic: Check whether the class has extended x class. (True, extended from Outer)
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9540606737136841
*Get a implemented interface of class. (Not applicable)* 匹配到的元操作或API：
logic: Get a implemented interface of class. (Not applicable)
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.955134928226471
*Check whether the class has implemented x interface. (Not applicable)* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface. (Not applicable)
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9737664461135864
*Get the name of the package where the class is located. (Not applicable)* 匹配到的元操作或API：
logic: Get the name of the package where the class is located. (Not applicable)
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9588011503219604
*Check whether the class is interface. (False)* 匹配到的元操作或API：
logic: Check whether the class is interface. (False)
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9615940451622009
*Check whether the class is inner class. (True, inner class of Outer)* 匹配到的元操作或API：
logic: Check whether the class is inner class. (True, inner class of Outer)
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9538792371749878
*Check whether the class is anonymous class. (False)* 匹配到的元操作或API：
logic: Check whether the class is anonymous class. (False)
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.969922661781311
*Check whether the class is default package-private. (False)* 匹配到的元操作或API：
logic: Check whether the class is default package-private. (False)
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9806113243103027
*Get the constructor list of class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether constructor is private. (Not applicable, no constructor explicitly defined)* 匹配到的元操作或API：
logic: Check whether constructor is private. (Not applicable, no constructor explicitly defined)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9415706992149353
*Check whether constructor is public. (Not applicable, no constructor explicitly defined)* 匹配到的元操作或API：
logic: Check whether constructor is public. (Not applicable, no constructor explicitly defined)
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.9366418123245239
*Check whether constructor is default package-private. (Not applicable, no constructor explicitly defined)* 匹配到的元操作或API：
logic: Check whether constructor is default package-private. (Not applicable, no constructor explicitly defined)
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.9577924609184265
*Check whether constructor is protected. (Not applicable, no constructor explicitly defined)* 匹配到的元操作或API：
logic: Check whether constructor is protected. (Not applicable, no constructor explicitly defined)
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9378445148468018
*Get the method list of class.* 匹配到的元操作或API：
query: Get the method list of class.
most similar API: get class of method
cosine Similarity: 0.8167366981506348
*Check whether the method is abstract. (True, run method is abstract)* 匹配到的元操作或API：
logic: Check whether the method is abstract. (True, run method is abstract)
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9383814334869385
*Check whether the method is private. (False)* 匹配到的元操作或API：
logic: Check whether the method is private. (False)
most similar meta operation: Check whether the method is private
cosine Similarity: 0.9704478979110718
*Check whether the method is public. (False)* 匹配到的元操作或API：
logic: Check whether the method is public. (False)
most similar meta operation: Check whether the method is public
cosine Similarity: 0.9660108685493469
*Check whether the method is default package-private. (False)* 匹配到的元操作或API：
logic: Check whether the method is default package-private. (False)
most similar meta operation: Check whether the method is default package-private
cosine Similarity: 0.9806065559387207
*Check whether the method is protected. (False)* 匹配到的元操作或API：
logic: Check whether the method is protected. (False)
most similar meta operation: Check whether the method is protected
cosine Similarity: 0.9715660810470581
*Check whether the method is main method. (False)* 匹配到的元操作或API：
logic: Check whether the method is main method. (False)
most similar meta operation: Check whether the method is main method
cosine Similarity: 0.9738593101501465
*Get the return type of method. (void)* 匹配到的元操作或API：
logic: Get the return type of method. (void)
most similar meta operation: Get the return type of method
cosine Similarity: 0.9459793567657471
*Check whether the method signature throws x Exception. (Not applicable)* 匹配到的元操作或API：
logic: Check whether the method signature throws x Exception. (Not applicable)
most similar meta operation: Check whether the method signature throws x Exception
cosine Similarity: 0.9815589189529419
*Check whether method has declared annotations. (False)* 匹配到的元操作或API：
logic: Check whether method has declared annotations. (False)
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.976698100566864
*Get a declared annotation of method. (Not applicable)* 匹配到的元操作或API：
logic: Get a declared annotation of method. (Not applicable)
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9599894285202026
*Check whether the method has x annotation. (Not applicable)* 匹配到的元操作或API：
logic: Check whether the method has x annotation. (Not applicable)
most similar meta operation: Check whether the method has x annotation
cosine Similarity: 0.9749922156333923
*Check whether the method is synchronized. (False)* 匹配到的元操作或API：
logic: Check whether the method is synchronized. (False)
most similar meta operation: Check whether the method is synchronized
cosine Similarity: 0.960806131362915
*Check whether the method is static. (False)* 匹配到的元操作或API：
logic: Check whether the method is static. (False)
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9680750370025635
*Check whether the method is final. (False)* 匹配到的元操作或API：
logic: Check whether the method is final. (False)
most similar meta operation: Check whether the method is final
cosine Similarity: 0.9729667901992798
*Check whether the method is native. (False)* 匹配到的元操作或API：
logic: Check whether the method is native. (False)
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9748203158378601
*Check whether the method is overridable. (True, run method is abstract)* 匹配到的元操作或API：
logic: Check whether the method is overridable. (True, run method is abstract)
most similar meta operation: Check whether the method is overridable
cosine Similarity: 0.9249852895736694
*Check whether the method is overridden. (False, run method is not overridden in Base)* 匹配到的元操作或API：
logic: Check whether the method is overridden. (False, run method is not overridden in Base)
most similar meta operation: Check whether the method is overridden
cosine Similarity: 0.9129576683044434
*Get the original method of this overridden method. (Not applicable)* 匹配到的元操作或API：
logic: Get the original method of this overridden method. (Not applicable)
most similar meta operation: Get the original method of this overridden method
cosine Similarity: 0.9631508588790894
*Get the class that method located in. (Base)* 匹配到的元操作或API：
logic: Get the class that method located in. (Base)
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9330137968063354
*Check whether the method is a junit method. (False)* 匹配到的元操作或API：
logic: Check whether the method is a junit method. (False)
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9680162668228149
*Get the return expression in return statement. (Not applicable)* 匹配到的元操作或API：
logic: Get the return expression in return statement. (Not applicable)
most similar meta operation: Get the return expression in return statement
cosine Similarity: 0.956623375415802
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract classes with abstract methods should be ignored #3668
public class Outer {
    private abstract class Base {
        abstract void run();
    }
    public void someMethod() {
        Base b = new Base() {
            void run() {}
        };
        b.run();
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
    ——ASTMethodDeclaration (method name = 'someMethod')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'b')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 0)
              ——ASTAnonymousClassDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceBody
                  ——ASTMethodDeclaration (method name = 'run')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 0)
                    ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'run')
            ——ASTVariableAccess (referenced variable name = 'b')
            ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isProtected()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
11. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
12. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
13. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getSuperInterfaceTypeNodes()
14. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
15. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()
16. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
17. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnonymous()
18. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
19. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()
20. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPackagePrivate()
21. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isProtected()
22. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.Class<Class<?> getClass()
23. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
24. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPrivate()
25. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPublic()
26. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPackagePrivate()
27. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isProtected()
28. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isMainMethod()
29. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getResultTypeNode()
30. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
31. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
32. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isSynchronized()
33. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
34. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isFinal()
35. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
36. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isOverridden()
37. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getOverriddenMethod()
38. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType()
39. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
40. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getExpr()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```
3.  //Check whether the class has implemented x interface
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node) {
    if (TypeTestUtil.isA(interfaceName.class, node)) {
        return true;
    }
    return false;
}
```
4.  //Check whether the method signature throws x Exception
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean throwsSpecificException(ASTMethodDeclaration node){
    ASTThrowsList list = node.getThrowsList();
    if(list == null){
        return false;
    }else{
        for(ASTClassOrInterfaceType classOrInterfaceType : list){
            if(TypeTestUtil.isA(x.class, classOrInterfaceType)){
                return true;
            }
        }
    }
    return false;
}
```
5.  //Check whether method has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTMethodDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```
6.  //Check whether the method is overridable
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.ast.JModifier;
public boolean isOverridable(ASTMethodDeclaration method){
    return method.hasModifiers(JModifier.STATIC, JModifier.PRIVATE, JModifier.FINAL);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate) && !hasAbstractMethods(node)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }

    private boolean hasAbstractMethods(ASTClassOrInterfaceDeclaration node) {
        return node.descendants(ASTMethodDeclaration.class)
                   .anyMatch(ASTMethodDeclaration::isAbstract);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To ascertain whether the test case adheres to the rule, let's perform granular checks:

1. Get the name of class.
        2. Check whether the class is public.
        3. Get all constructors declared in class.
        4. Check whether the constructor is private.
        5. Get the name of the inner class.
        6. Check whether the inner class is abstract.
        7. Get all methods declared in the inner class.
        8. Check whether the method is abstract.
        9. Get the number of violating the rule in this test case.
        10. Check whether the number of violating the rule is 0.

Let's break it down for the given test case:

1. Get the name of class.
        - The class name is `Outer`.

2. Check whether the class is public.
        - The class is public.

3. Get all constructors declared in class.
        - The class `Outer` does not have any explicitly declared constructors, so it has the default public constructor.

4. Check whether the constructor is private.
        - The default constructor is not private.

5. Get the name of the inner class.
        - The inner class name is `Base`.

6. Check whether the inner class is abstract.
        - The inner class `Base` is abstract.

7. Get all methods declared in the inner class.
        - The inner class `Base` has one method `run()`.

8. Check whether the method is abstract.
        - The method `run()` is abstract.

9. Get all constructors declared in inner class.
        - The inner class `Base` has one constructor, which is private.

10. Check whether the constructor is private.
        - The constructor of the inner class `Base` is private.

11. Get the number of violating the rule in this test case.
        - The test case does not have any classes that violate the rule because `Base` is an abstract class with a private constructor, but it is intended to be extended within the same compilation unit (anonymous inner class).

12. Check whether the number of violating the rule is 0.
        - The number of violations is 0, which matches the expected result.

Since all checks align with the given test case and the expected result, the test case adheres to the rule. The abstract class `Base` with private constructors and abstract methods should indeed be ignored.
['Get the name of class.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get the name of the inner class.', 'Check whether the inner class is abstract.', 'Get all methods declared in the inner class.', 'Check whether the method is abstract.', 'Get the number of violating the rule in this test case.', 'Check whether the number of violating the rule is 0.', 'Get the name of class.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get the name of the inner class.', 'Check whether the inner class is abstract.', 'Get all methods declared in the inner class.', 'Check whether the method is abstract.', 'Get all constructors declared in inner class.', 'Check whether the constructor is private.', 'Get the number of violating the rule in this test case.', 'Check whether the number of violating the rule is 0.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTExpressionStatement', 'TokenUtils', 'ASTAnonymousClassDeclaration', 'ASTClassOrInterfaceDeclaration', 'ASTConstructorCall', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the name of the inner class.* 匹配到的元操作或API：
logic: Get the name of the inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.878083348274231
*Check whether the inner class is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9326449036598206
*Get all methods declared in the inner class.* 匹配到的元操作或API：
query: Get all methods declared in the inner class.
most similar API: get declared annotations of method
cosine Similarity: 0.8091904520988464
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Get the number of violating the rule in this test case.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the number of violating the rule is 0.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the name of the inner class.* 匹配到的元操作或API：
logic: Get the name of the inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.878083348274231
*Check whether the inner class is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9326449036598206
*Get all methods declared in the inner class.* 匹配到的元操作或API：
query: Get all methods declared in the inner class.
most similar API: get declared annotations of method
cosine Similarity: 0.8091904520988464
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Get all constructors declared in inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the number of violating the rule in this test case.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the number of violating the rule is 0.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract classes with abstract methods should be ignored #3668
public class Outer {
    private abstract class Base {
        abstract void run();
    }
    public void someMethod() {
        Base b = new Base() {
            void run() {}
        };
        b.run();
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
    ——ASTMethodDeclaration (method name = 'someMethod')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'b')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 0)
              ——ASTAnonymousClassDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceBody
                  ——ASTMethodDeclaration (method name = 'run')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 0)
                    ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'run')
            ——ASTVariableAccess (referenced variable name = 'b')
            ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate) && !hasAbstractMethods(node) && !isInstantiatedAnonymous(node)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }

    private boolean hasAbstractMethods(ASTClassOrInterfaceDeclaration node) {
        return node.descendants(ASTMethodDeclaration.class).anyMatch(ASTMethodDeclaration::isAbstract);
    }

    private boolean isInstantiatedAnonymous(ASTClassOrInterfaceDeclaration node) {
        String simpleName = node.getSimpleName();
        return node.getRoot().descendants(ASTAnonymousClassDeclaration.class)
                   .anyMatch(acd -> acd.getParent() instanceof ASTLocalVariableDeclaration &&
                                      ((ASTLocalVariableDeclaration) acd.getParent()).getTypeNode().getImage().equals(simpleName));
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To ascertain whether the provided test case adheres to the rule, let's perform the necessary granular checks:

1. Get the name of class.
2. Get the name of the inner class.
3. Check whether the inner class is private.
4. Get the constructors of the inner class.
5. Check whether the constructor is private.
6. Check whether the inner class is abstract.
7. Get all methods declared in the inner class.
8. Check whether the method is abstract.
9. Get the usage of the inner class.
10. Check whether the inner class is instantiated outside its compilation unit.
11. Check whether the inner class is instantiated within its compilation unit.

Let's apply these checks to the given test case:

1. Get the name of class: The class name is `Outer`.
2. Get the name of the inner class: The inner class name is `Base`.
3. Check whether the inner class is private: Yes, the inner class `Base` is private.
4. Get the constructors of the inner class: There are no constructors explicitly defined in the inner class `Base`.
5. Check whether the constructor is private: Since there are no constructors, this check does not apply.
6. Check whether the inner class is abstract: Yes, the inner class `Base` is abstract.
7. Get all methods declared in the inner class: The inner class `Base` has one method declared, `run()`.
8. Check whether the method is abstract: Yes, the method `run()` is abstract.
9. Get the usage of the inner class: The inner class `Base` is instantiated within the `someMethod` of the `Outer` class.
10. Check whether the inner class is instantiated outside its compilation unit: No, the inner class `Base` is instantiated within the same compilation unit (inside the `someMethod` of `Outer` class).
11. Check whether the inner class is instantiated within its compilation unit: Yes, the inner class `Base` is instantiated within the same compilation unit (inside the `someMethod` of `Outer` class).

Since the inner class `Base` is private, abstract, and instantiated within its compilation unit, it does not violate the rule. The number of violating the rule in this test case is indeed 0.
['Get the name of class.', 'Get the name of the inner class.', 'Check whether the inner class is private.', 'Get the constructors of the inner class.', 'Check whether the constructor is private.', 'Check whether the inner class is abstract.', 'Get all methods declared in the inner class.', 'Check whether the method is abstract.', 'Get the usage of the inner class.', 'Check whether the inner class is instantiated outside its compilation unit.', 'Check whether the inner class is instantiated within its compilation unit.', 'Get the name of class: The class name is `Outer`.', 'Get the name of the inner class: The inner class name is `Base`.', 'Check whether the inner class is private: Yes, the inner class `Base` is private.', 'Get the constructors of the inner class: There are no constructors explicitly defined in the inner class `Base`.', 'Check whether the constructor is private: Since there are no constructors, this check does not apply.', 'Check whether the inner class is abstract: Yes, the inner class `Base` is abstract.', 'Get all methods declared in the inner class: The inner class `Base` has one method declared, `run()`.', 'Check whether the method is abstract: Yes, the method `run()` is abstract.', 'Get the usage of the inner class: The inner class `Base` is instantiated within the `someMethod` of the `Outer` class.', 'Check whether the inner class is instantiated outside its compilation unit: No, the inner class `Base` is instantiated within the same compilation unit (inside the `someMethod` of `Outer` class).', 'Check whether the inner class is instantiated within its compilation unit: Yes, the inner class `Base` is instantiated within the same compilation unit (inside the `someMethod` of `Outer` class).']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTExpressionStatement', 'TokenUtils', 'ASTAnonymousClassDeclaration', 'ASTClassOrInterfaceDeclaration', 'ASTConstructorCall', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of the inner class.* 匹配到的元操作或API：
logic: Get the name of the inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.878083348274231
*Check whether the inner class is private.* 匹配到的元操作或API：
logic: Check whether the inner class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9290029406547546
*Get the constructors of the inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the inner class is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9326449036598206
*Get all methods declared in the inner class.* 匹配到的元操作或API：
query: Get all methods declared in the inner class.
most similar API: get declared annotations of method
cosine Similarity: 0.8091904520988464
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Get the usage of the inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is instantiated outside its compilation unit.* 匹配到的元操作或API：
query: Check whether the inner class is instantiated outside its compilation unit.
most similar API: Check whether the compilation unit is unnamed class
cosine Similarity: 0.8263728022575378
*Check whether the inner class is instantiated within its compilation unit.* 匹配到的元操作或API：
query: Check whether the inner class is instantiated within its compilation unit.
most similar API: Check whether the compilation unit is unnamed class
cosine Similarity: 0.8541575074195862
*Get the name of class: The class name is `Outer`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the inner class: The inner class name is `Base`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is private: Yes, the inner class `Base` is private.* 匹配到的元操作或API：
query: Check whether the inner class is private: Yes, the inner class `Base` is private.
most similar API: Check whether the class or interface is private
cosine Similarity: 0.81907057762146
*Get the constructors of the inner class: There are no constructors explicitly defined in the inner class `Base`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: Since there are no constructors, this check does not apply.* 匹配到的元操作或API：
logic: Check whether the constructor is private: Since there are no constructors, this check does not apply.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9214857220649719
*Check whether the inner class is abstract: Yes, the inner class `Base` is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract: Yes, the inner class `Base` is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.8661724328994751
*Get all methods declared in the inner class: The inner class `Base` has one method declared, `run()`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is abstract: Yes, the method `run()` is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract: Yes, the method `run()` is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9078574180603027
*Get the usage of the inner class: The inner class `Base` is instantiated within the `someMethod` of the `Outer` class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is instantiated outside its compilation unit: No, the inner class `Base` is instantiated within the same compilation unit (inside the `someMethod` of `Outer` class).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is instantiated within its compilation unit: Yes, the inner class `Base` is instantiated within the same compilation unit (inside the `someMethod` of `Outer` class).* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract classes with abstract methods should be ignored #3668
public class Outer {
    private abstract class Base {
        abstract void run();
    }
    public void someMethod() {
        Base b = new Base() {
            void run() {}
        };
        b.run();
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
    ——ASTMethodDeclaration (method name = 'someMethod')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'b')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 0)
              ——ASTAnonymousClassDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceBody
                  ——ASTMethodDeclaration (method name = 'run')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 0)
                    ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'run')
            ——ASTVariableAccess (referenced variable name = 'b')
            ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
7. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean isUnnamedClass()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                ASTClassOrInterfaceBody body = node.getFirstChildOfType(ASTClassOrInterfaceBody.class);
                if (body != null) {
                    List<ASTMethodDeclaration> methods = body.descendants(ASTMethodDeclaration.class).collect(Collectors.toList());
                    if (methods.stream().noneMatch(ASTMethodDeclaration::isAbstract)) {
                        addViolation(data, node);
                    }
                }
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "ok 13" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
107
91
97
81
144
127
94
78
=========================error_testcase_logics=========================
To analyze the provided test case, we need to perform the following granular checks:

1. Get the name of class.
        2. Get the name of the package where the class is located.
        3. Check whether the class is public.
        4. Check whether the class is abstract.
        5. Check whether the class has declared annotations.
        6. Get all constructors declared in class.
        7. Check whether the constructor is private.
        8. Get all methods declared in class.
        9. Check whether the method is abstract.
        10. Get all inner classes declared in class.
        11. Check whether the inner class is private.
        12. Check whether the inner class is abstract.
        13. Check whether the inner class has declared annotations.
        14. Get all constructors declared in inner class.
        15. Check whether the constructor is private.
        16. Get all methods declared in inner class.
        17. Check whether the method is abstract.
        18. Get all subclasses of inner class.
        19. Check whether the subclass is declared within the same compilation unit.

Starting with the `Outer` class:

1. Get the name of class. // Outer
2. Get the name of the package where the class is located. // Assuming no package, so default package.
3. Check whether the class is public. // True
4. Check whether the class is abstract. // False
5. Check whether the class has declared annotations. // False
6. Get all constructors declared in class. // No constructors explicitly declared
7. Check whether the constructor is private. // Not applicable, no constructors declared
8. Get all methods declared in class. // No methods declared
9. Check whether the method is abstract. // Not applicable, no methods declared

Next, we check the `Base` inner class:

10. Get all inner classes declared in class. // Base, Sub
11. Get the name of class. // Base
12. Check whether the class is private. // True
13. Check whether the class is abstract. // True
14. Check whether the class has declared annotations. // False
15. Get all constructors declared in class. // No constructors explicitly declared
16. Check whether the constructor is private. // Not applicable, no constructors declared
17. Get all methods declared in class. // run
18. Check whether the method is abstract. // False
19. Get the name of method. // run
20. Check whether the method is private. // True

Finally, we check the `Sub` inner class:

21. Get the name of class. // Sub
22. Check whether the class is private. // True
23. Check whether the class is abstract. // False
24. Check whether the class has declared annotations. // False
25. Get all constructors declared in class. // No constructors explicitly declared
26. Check whether the constructor is private. // Not applicable, no constructors declared
27. Get all methods declared in class. // No methods declared
28. Get the super class of class. // Base
29. Check whether the super class is declared within the same compilation unit. // True

From the above checks, we can see that the `Base` class is private and abstract, but it does not have any abstract methods. The `Sub` class is a private subclass of `Base` and is also declared within the same compilation unit. Therefore, the `Base` class cannot be extended from outside its compilation unit, and the `Sub` class does not violate the rule by reassigning a final field since there are no final fields being reassigned.

Thus, the number of violations of the rule in this test case is indeed 0.
['Get the name of class.', 'Get the name of the package where the class is located.', 'Check whether the class is public.', 'Check whether the class is abstract.', 'Check whether the class has declared annotations.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get all methods declared in class.', 'Check whether the method is abstract.', 'Get all inner classes declared in class.', 'Check whether the inner class is private.', 'Check whether the inner class is abstract.', 'Check whether the inner class has declared annotations.', 'Get all constructors declared in inner class.', 'Check whether the constructor is private.', 'Get all methods declared in inner class.', 'Check whether the method is abstract.', 'Get all subclasses of inner class.', 'Check whether the subclass is declared within the same compilation unit.', 'Get the name of class. // Outer', 'Get the name of the package where the class is located. // Assuming no package, so default package.', 'Check whether the class is public. // True', 'Check whether the class is abstract. // False', 'Check whether the class has declared annotations. // False', 'Get all constructors declared in class. // No constructors explicitly declared', 'Check whether the constructor is private. // Not applicable, no constructors declared', 'Get all methods declared in class. // No methods declared', 'Check whether the method is abstract. // Not applicable, no methods declared', 'Get all inner classes declared in class. // Base, Sub', 'Get the name of class. // Base', 'Check whether the class is private. // True', 'Check whether the class is abstract. // True', 'Check whether the class has declared annotations. // False', 'Get all constructors declared in class. // No constructors explicitly declared', 'Check whether the constructor is private. // Not applicable, no constructors declared', 'Get all methods declared in class. // run', 'Check whether the method is abstract. // False', 'Get the name of method. // run', 'Check whether the method is private. // True', 'Get the name of class. // Sub', 'Check whether the class is private. // True', 'Check whether the class is abstract. // False', 'Check whether the class has declared annotations. // False', 'Get all constructors declared in class. // No constructors explicitly declared', 'Check whether the constructor is private. // Not applicable, no constructors declared', 'Get all methods declared in class. // No methods declared', 'Get the super class of class. // Base', 'Check whether the super class is declared within the same compilation unit. // True']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'ASTExtendsList', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Get all inner classes declared in class.* 匹配到的元操作或API：
query: Get all inner classes declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8037846684455872
*Check whether the inner class is private.* 匹配到的元操作或API：
logic: Check whether the inner class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9290029406547546
*Check whether the inner class is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9326449036598206
*Check whether the inner class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the inner class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9374713897705078
*Get all constructors declared in inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get all methods declared in inner class.* 匹配到的元操作或API：
query: Get all methods declared in inner class.
most similar API: get declared annotations of method
cosine Similarity: 0.8129565119743347
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Get all subclasses of inner class.* 匹配到的元操作或API：
query: Get all subclasses of inner class.
most similar API: get permitted subclasses of class or interface
cosine Similarity: 0.8041579127311707
*Check whether the subclass is declared within the same compilation unit.* 匹配到的元操作或API：
query: Check whether the subclass is declared within the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8590628504753113
*Get the name of class. // Outer* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the package where the class is located. // Assuming no package, so default package.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located. // Assuming no package, so default package.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9160338640213013
*Check whether the class is public. // True* 匹配到的元操作或API：
logic: Check whether the class is public. // True
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9579840302467346
*Check whether the class is abstract. // False* 匹配到的元操作或API：
logic: Check whether the class is abstract. // False
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.948445737361908
*Check whether the class has declared annotations. // False* 匹配到的元操作或API：
logic: Check whether the class has declared annotations. // False
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9573260545730591
*Get all constructors declared in class. // No constructors explicitly declared* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private. // Not applicable, no constructors declared* 匹配到的元操作或API：
logic: Check whether the constructor is private. // Not applicable, no constructors declared
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9467725157737732
*Get all methods declared in class. // No methods declared* 匹配到的元操作或API：
query: Get all methods declared in class. // No methods declared
most similar API: get declared annotations of method
cosine Similarity: 0.8183726668357849
*Check whether the method is abstract. // Not applicable, no methods declared* 匹配到的元操作或API：
logic: Check whether the method is abstract. // Not applicable, no methods declared
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9295436143875122
*Get all inner classes declared in class. // Base, Sub* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class. // Base* 匹配到的元操作或API：
logic: Get the name of class. // Base
most similar meta operation: Get the name of class
cosine Similarity: 0.8772722482681274
*Check whether the class is private. // True* 匹配到的元操作或API：
logic: Check whether the class is private. // True
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9566875696182251
*Check whether the class is abstract. // True* 匹配到的元操作或API：
logic: Check whether the class is abstract. // True
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.956919252872467
*Check whether the class has declared annotations. // False* 匹配到的元操作或API：
logic: Check whether the class has declared annotations. // False
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9573260545730591
*Get all constructors declared in class. // No constructors explicitly declared* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private. // Not applicable, no constructors declared* 匹配到的元操作或API：
logic: Check whether the constructor is private. // Not applicable, no constructors declared
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9467725157737732
*Get all methods declared in class. // run* 匹配到的元操作或API：
query: Get all methods declared in class. // run
most similar API: get declared annotations of method
cosine Similarity: 0.8052103519439697
*Check whether the method is abstract. // False* 匹配到的元操作或API：
logic: Check whether the method is abstract. // False
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9525656700134277
*Get the name of method. // run* 匹配到的元操作或API：
logic: Get the name of method. // run
most similar meta operation: Get the name of method
cosine Similarity: 0.8681309819221497
*Check whether the method is private. // True* 匹配到的元操作或API：
logic: Check whether the method is private. // True
most similar meta operation: Check whether the method is private
cosine Similarity: 0.9590681791305542
*Get the name of class. // Sub* 匹配到的元操作或API：
logic: Get the name of class. // Sub
most similar meta operation: Get the name of class
cosine Similarity: 0.8704888224601746
*Check whether the class is private. // True* 匹配到的元操作或API：
logic: Check whether the class is private. // True
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9566875696182251
*Check whether the class is abstract. // False* 匹配到的元操作或API：
logic: Check whether the class is abstract. // False
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.948445737361908
*Check whether the class has declared annotations. // False* 匹配到的元操作或API：
logic: Check whether the class has declared annotations. // False
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9573260545730591
*Get all constructors declared in class. // No constructors explicitly declared* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private. // Not applicable, no constructors declared* 匹配到的元操作或API：
logic: Check whether the constructor is private. // Not applicable, no constructors declared
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9467725157737732
*Get all methods declared in class. // No methods declared* 匹配到的元操作或API：
query: Get all methods declared in class. // No methods declared
most similar API: get declared annotations of method
cosine Similarity: 0.8183726668357849
*Get the super class of class. // Base* 匹配到的元操作或API：
logic: Get the super class of class. // Base
most similar meta operation: Get the super class of class
cosine Similarity: 0.9240906834602356
*Check whether the super class is declared within the same compilation unit. // True* 匹配到的元操作或API：
query: Check whether the super class is declared within the same compilation unit. // True
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8303824663162231
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                ASTClassOrInterfaceBody body = node.getFirstChildOfType(ASTClassOrInterfaceBody.class);
                if (body != null) {
                    List<ASTMethodDeclaration> methods = body.descendants(ASTMethodDeclaration.class).collect(Collectors.toList());
                    if (methods.stream().noneMatch(ASTMethodDeclaration::isAbstract)) {
                        addViolation(data, node);
                    }
                }
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this positive testcase:
public class Outer {
    private abstract class Base {
        abstract void run();
    }
    public void someMethod() {
        Base b = new Base() {
            void run() {}
        };
        b.run();
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract classes without abstract methods but with subclasses should be ignored #3668
public class Outer {
    private abstract class Base {
        private void run() {}
    }
    private final class Sub extends Base {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.util.List<ASTClassOrInterfaceType> getPermittedSubclasses()
11. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot
12. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
13. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPrivate()
14. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                ASTClassOrInterfaceBody body = node.getFirstChildOfType(ASTClassOrInterfaceBody.class);
                if (body != null) {
                    List<ASTMethodDeclaration> methods = body.descendants(ASTMethodDeclaration.class).collect(Collectors.toList());
                    if (methods.stream().noneMatch(ASTMethodDeclaration::isAbstract)) {
                        if (!hasSubclassesInSameCompilationUnit(node)) {
                            addViolation(data, node);
                        }
                    }
                }
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }

    private boolean hasSubclassesInSameCompilationUnit(ASTClassOrInterfaceDeclaration node) {
        return node.getRoot().getDescendantsOfType(ASTClassOrInterfaceDeclaration.class)
                .stream()
                .anyMatch(sub -> sub.getSuperClassTypeNode() != null && sub.getSuperClassTypeNode().isReferenceToClassSameCompilationUnit() && sub.getSuperClassTypeNode().getType() != null && node.getSimpleName().equals(sub.getSuperClassTypeNode().getType().getSimpleName()));
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class has declared annotations.
3. Check whether the class is abstract.
4. Check whether the class is public.
5. Check whether the class is private.
6. Check whether the class is protected.
7. Check whether the class is default package-private.
8. Check whether the class is final.
9. Get the number of constructors of the class.
10. Get the signature of constructor.
11. Check whether the constructor is private.
12. Get the super class of class.
13. Check whether the class has extended x class.
14. Get all methods declared in class.
15. Check whether method is abstract.
16. Get the name of class.
17. Check whether the class has declared annotations.
18. Check whether the class is abstract.
19. Check whether the class is public.
20. Check whether the class is private.
21. Check whether the class is protected.
22. Check whether the class is default package-private.
23. Check whether the class is final.
24. Get the super class of class.
25. Check whether the class has extended x class.

Perform the checks on `Outer`:
1. Get the name of class: Outer
2. Check whether the class has declared annotations: No
3. Check whether the class is abstract: No
4. Check whether the class is public: Yes
5. Check whether the class is private: No
6. Check whether the class is protected: No
7. Check whether the class is default package-private: No
8. Check whether the class is final: No

Perform the checks on `Base`:
9. Get the name of class: Base
10. Check whether the class has declared annotations: No
11. Check whether the class is abstract: Yes
12. Check whether the class is public: No
13. Check whether the class is private: Yes
14. Check whether the class is protected: No
15. Check whether the class is default package-private: No
16. Check whether the class is final: No
17. Get the super class of class: Object
18. Check whether the class has extended x class: No
19. Get all methods declared in class: private void run()
20. Check whether method is abstract: No

Perform the checks on `Sub`:
21. Get the name of class: Sub
22. Check whether the class has declared annotations: No
23. Check whether the class is abstract: No
24. Check whether the class is public: No
25. Check whether the class is private: Yes
26. Check whether the class is protected: No
27. Check whether the class is default package-private: No
28. Check whether the class is final: Yes
29. Get the super class of class: Base
30. Check whether the class has extended x class: Yes (Base)

In this test case, the class `Sub` is final and has an abstract superclass `Base` with a private constructor. However, the rule specifies that abstract classes (even if they have private constructors) should be ignored. Therefore, `Sub` does not violate the rule because `Base` is abstract. The number of classes violating the rule in this test case is 0.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Get the number of constructors of the class.', 'Get the signature of constructor.', 'Check whether the constructor is private.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get all methods declared in class.', 'Check whether method is abstract.', 'Get the name of class.', 'Check whether the class has declared annotations.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get the name of class: Outer', 'Check whether the class has declared annotations: No', 'Check whether the class is abstract: No', 'Check whether the class is public: Yes', 'Check whether the class is private: No', 'Check whether the class is protected: No', 'Check whether the class is default package-private: No', 'Check whether the class is final: No', 'Get the name of class: Base', 'Check whether the class has declared annotations: No', 'Check whether the class is abstract: Yes', 'Check whether the class is public: No', 'Check whether the class is private: Yes', 'Check whether the class is protected: No', 'Check whether the class is default package-private: No', 'Check whether the class is final: No', 'Get the super class of class: Object', 'Check whether the class has extended x class: No', 'Get all methods declared in class: private void run()', 'Check whether method is abstract: No', 'Get the name of class: Sub', 'Check whether the class has declared annotations: No', 'Check whether the class is abstract: No', 'Check whether the class is public: No', 'Check whether the class is private: Yes', 'Check whether the class is protected: No', 'Check whether the class is default package-private: No', 'Check whether the class is final: Yes', 'Get the super class of class: Base', 'Check whether the class has extended x class: Yes (Base)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'ASTExtendsList', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844120740890503
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get the number of constructors of the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828827381134033
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether method is abstract.* 匹配到的元操作或API：
logic: Check whether method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.98253333568573
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844120740890503
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get the name of class: Outer* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has declared annotations: No* 匹配到的元操作或API：
logic: Check whether the class has declared annotations: No
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9471337795257568
*Check whether the class is abstract: No* 匹配到的元操作或API：
logic: Check whether the class is abstract: No
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9449758529663086
*Check whether the class is public: Yes* 匹配到的元操作或API：
logic: Check whether the class is public: Yes
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9447720050811768
*Check whether the class is private: No* 匹配到的元操作或API：
logic: Check whether the class is private: No
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9601792693138123
*Check whether the class is protected: No* 匹配到的元操作或API：
logic: Check whether the class is protected: No
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9315000772476196
*Check whether the class is default package-private: No* 匹配到的元操作或API：
logic: Check whether the class is default package-private: No
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9762306213378906
*Check whether the class is final: No* 匹配到的元操作或API：
logic: Check whether the class is final: No
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9627070426940918
*Get the name of class: Base* 匹配到的元操作或API：
logic: Get the name of class: Base
most similar meta operation: Get the name of class
cosine Similarity: 0.8843188285827637
*Check whether the class has declared annotations: No* 匹配到的元操作或API：
logic: Check whether the class has declared annotations: No
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9471337795257568
*Check whether the class is abstract: Yes* 匹配到的元操作或API：
logic: Check whether the class is abstract: Yes
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.949992299079895
*Check whether the class is public: No* 匹配到的元操作或API：
logic: Check whether the class is public: No
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9522130489349365
*Check whether the class is private: Yes* 匹配到的元操作或API：
logic: Check whether the class is private: Yes
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9429656267166138
*Check whether the class is protected: No* 匹配到的元操作或API：
logic: Check whether the class is protected: No
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9315000772476196
*Check whether the class is default package-private: No* 匹配到的元操作或API：
logic: Check whether the class is default package-private: No
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9762306213378906
*Check whether the class is final: No* 匹配到的元操作或API：
logic: Check whether the class is final: No
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9627070426940918
*Get the super class of class: Object* 匹配到的元操作或API：
logic: Get the super class of class: Object
most similar meta operation: Get the super class of class
cosine Similarity: 0.9086419939994812
*Check whether the class has extended x class: No* 匹配到的元操作或API：
logic: Check whether the class has extended x class: No
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9652364253997803
*Get all methods declared in class: private void run()* 匹配到的元操作或API：
query: Get all methods declared in class: private void run()
most similar API: get declared annotations of method
cosine Similarity: 0.8060813546180725
*Check whether method is abstract: No* 匹配到的元操作或API：
logic: Check whether method is abstract: No
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9394564032554626
*Get the name of class: Sub* 匹配到的元操作或API：
logic: Get the name of class: Sub
most similar meta operation: Get the name of class
cosine Similarity: 0.8676699995994568
*Check whether the class has declared annotations: No* 匹配到的元操作或API：
logic: Check whether the class has declared annotations: No
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9471337795257568
*Check whether the class is abstract: No* 匹配到的元操作或API：
logic: Check whether the class is abstract: No
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9449758529663086
*Check whether the class is public: No* 匹配到的元操作或API：
logic: Check whether the class is public: No
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9522130489349365
*Check whether the class is private: Yes* 匹配到的元操作或API：
logic: Check whether the class is private: Yes
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9429656267166138
*Check whether the class is protected: No* 匹配到的元操作或API：
logic: Check whether the class is protected: No
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9315000772476196
*Check whether the class is default package-private: No* 匹配到的元操作或API：
logic: Check whether the class is default package-private: No
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9762306213378906
*Check whether the class is final: Yes* 匹配到的元操作或API：
logic: Check whether the class is final: Yes
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9564178586006165
*Get the super class of class: Base* 匹配到的元操作或API：
logic: Get the super class of class: Base
most similar meta operation: Get the super class of class
cosine Similarity: 0.9260243773460388
*Check whether the class has extended x class: Yes (Base)* 匹配到的元操作或API：
logic: Check whether the class has extended x class: Yes (Base)
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9298582077026367
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                ASTClassOrInterfaceBody body = node.getFirstChildOfType(ASTClassOrInterfaceBody.class);
                if (body != null) {
                    List<ASTMethodDeclaration> methods = body.descendants(ASTMethodDeclaration.class).collect(Collectors.toList());
                    if (methods.stream().noneMatch(ASTMethodDeclaration::isAbstract)) {
                        addViolation(data, node);
                    }
                }
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this positive testcase:
public class Outer {
    private abstract class Base {
        abstract void run();
    }
    public void someMethod() {
        Base b = new Base() {
            void run() {}
        };
        b.run();
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract classes without abstract methods but with subclasses should be ignored #3668
public class Outer {
    private abstract class Base {
        private void run() {}
    }
    private final class Sub extends Base {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isProtected()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
8. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
9. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
11. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
12. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                ASTClassOrInterfaceBody body = node.getFirstChildOfType(ASTClassOrInterfaceBody.class);
                if (body != null) {
                    List<ASTMethodDeclaration> methods = body.descendants(ASTMethodDeclaration.class).collect(Collectors.toList());
                    if (methods.stream().noneMatch(ASTMethodDeclaration::isAbstract)) {
                        if (!hasSubclasses(node)) {
                            addViolation(data, node);
                        }
                    }
                }
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }

    private boolean hasSubclasses(ASTClassOrInterfaceDeclaration node) {
        String simpleName = node.getSimpleName();
        return node.getRoot().findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).stream()
                .anyMatch(subclass -> {
                    ASTClassOrInterfaceType superClassTypeNode = subclass.getSuperClassTypeNode();
                    return superClassTypeNode != null && superClassTypeNode.getName().equals(simpleName);
                });
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Check whether the class is final.
        3. Get the class that method located in.
        4. Check whether the class has declared annotations.
        5. Get a declared annotation of class.
        6. Check whether the class is abstract.
        7. Get the super class of class.
        8. Get all constructors declared in class.
        9. Check whether the constructor is private.
        10. Check whether the class has extended x class.
        11. Get all methods declared in class.
        12. Check whether the method is abstract.

For the `Base` class:
1. Get the name of class (Base).
2. Check whether the class is final (false).
3. Get the class that method located in (Base).
4. Check whether the class has declared annotations (false).
5. Check whether the class is abstract (true).
6. Get the super class of class (Object).
7. Get all constructors declared in class (none).
8. Check whether the class has extended x class (false).
9. Get all methods declared in class (run method).
10. Check whether the method is abstract (false).

For the `Sub` class:
1. Get the name of class (Sub).
2. Check whether the class is final (true).
3. Get the class that method located in (Sub).
4. Check whether the class has declared annotations (false).
5. Check whether the class is abstract (false).
6. Get the super class of class (Base).
7. Get all constructors declared in class (default constructor).
8. Check whether the constructor is private (false).
9. Check whether the class has extended x class (true, extended Base).
10. Get all methods declared in class (none).

Since `Base` is an abstract class and does not have any constructors (default or defined), it cannot be instantiated or extended outside its compilation unit. However, it has a subclass `Sub` within the same compilation unit, which makes `Base` not final. `Sub` is final, but it does not have any private constructors, and it is extended from within the same compilation unit.

Thus, there are no classes in this test case that violate the rule.

If you meant to check for the `Base` class to see if it should be final:
1. Check whether the class is an interface (false for Base).
2. Check whether the class has declared annotations (false for Base).
3. Check whether the class is abstract (true for Base).
4. Get all constructors declared in class (none for Base).
5. Check whether the class has extended x class (false for Base).
6. Get all methods declared in class (run method for Base).
7. Check whether the method is abstract (false for run method).

Since `Base` has no constructors (which implies they are implicitly private and thus cannot be extended from outside the compilation unit) and it is abstract, it should be made final according to the rule. However, the test case explicitly states that abstract classes with subclasses should be ignored, so `Base` is not flagged.

If you meant to check for the `Sub` class:
1. Check whether the class is an interface (false for Sub).
2. Check whether the class has declared annotations (false for Sub).
3. Check whether the class is abstract (false for Sub).
4. Get all constructors declared in class (default constructor for Sub).
5. Check whether the constructor is private (false for the default constructor).
6. Check whether the class has extended x class (true, extended Base for Sub).
7. Get all methods declared in class (none for Sub).

`Sub` is final but it does not have any private constructors and it is extended from within the same compilation unit, so it does not violate the rule.

In summary, the test case does not violate the rule as per the provided description and conditions.
['Get the name of class.', 'Check whether the class is final.', 'Get the class that method located in.', 'Check whether the class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the class is abstract.', 'Get the super class of class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has extended x class.', 'Get all methods declared in class.', 'Check whether the method is abstract.', 'Get the name of class (Base).', 'Check whether the class is final (false).', 'Get the class that method located in (Base).', 'Check whether the class has declared annotations (false).', 'Check whether the class is abstract (true).', 'Get the super class of class (Object).', 'Get all constructors declared in class (none).', 'Check whether the class has extended x class (false).', 'Get all methods declared in class (run method).', 'Check whether the method is abstract (false).', 'Get the name of class (Sub).', 'Check whether the class is final (true).', 'Get the class that method located in (Sub).', 'Check whether the class has declared annotations (false).', 'Check whether the class is abstract (false).', 'Get the super class of class (Base).', 'Get all constructors declared in class (default constructor).', 'Check whether the constructor is private (false).', 'Check whether the class has extended x class (true, extended Base).', 'Get all methods declared in class (none).', 'Check whether the class is an interface (false for Base).', 'Check whether the class has declared annotations (false for Base).', 'Check whether the class is abstract (true for Base).', 'Get all constructors declared in class (none for Base).', 'Check whether the class has extended x class (false for Base).', 'Get all methods declared in class (run method for Base).', 'Check whether the method is abstract (false for run method).', 'Check whether the class is an interface (false for Sub).', 'Check whether the class has declared annotations (false for Sub).', 'Check whether the class is abstract (false for Sub).', 'Get all constructors declared in class (default constructor for Sub).', 'Check whether the constructor is private (false for the default constructor).', 'Check whether the class has extended x class (true, extended Base for Sub).', 'Get all methods declared in class (none for Sub).']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'ASTExtendsList', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get the class that method located in.* 匹配到的元操作或API：
logic: Get the class that method located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9805244207382202
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.987838864326477
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Get the name of class (Base).* 匹配到的元操作或API：
logic: Get the name of class (Base).
most similar meta operation: Get the name of class
cosine Similarity: 0.8888643980026245
*Check whether the class is final (false).* 匹配到的元操作或API：
logic: Check whether the class is final (false).
most similar meta operation: Check whether the class is final
cosine Similarity: 0.961378276348114
*Get the class that method located in (Base).* 匹配到的元操作或API：
logic: Get the class that method located in (Base).
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9087925553321838
*Check whether the class has declared annotations (false).* 匹配到的元操作或API：
logic: Check whether the class has declared annotations (false).
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9468936920166016
*Check whether the class is abstract (true).* 匹配到的元操作或API：
logic: Check whether the class is abstract (true).
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.955297589302063
*Get the super class of class (Object).* 匹配到的元操作或API：
logic: Get the super class of class (Object).
most similar meta operation: Get the super class of class
cosine Similarity: 0.9455075263977051
*Get all constructors declared in class (none).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has extended x class (false).* 匹配到的元操作或API：
logic: Check whether the class has extended x class (false).
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9601330161094666
*Get all methods declared in class (run method).* 匹配到的元操作或API：
query: Get all methods declared in class (run method).
most similar API: get declared annotations of method
cosine Similarity: 0.8182715177536011
*Check whether the method is abstract (false).* 匹配到的元操作或API：
logic: Check whether the method is abstract (false).
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9484283924102783
*Get the name of class (Sub).* 匹配到的元操作或API：
logic: Get the name of class (Sub).
most similar meta operation: Get the name of class
cosine Similarity: 0.881794810295105
*Check whether the class is final (true).* 匹配到的元操作或API：
logic: Check whether the class is final (true).
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9706144332885742
*Get the class that method located in (Sub).* 匹配到的元操作或API：
logic: Get the class that method located in (Sub).
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9022948741912842
*Check whether the class has declared annotations (false).* 匹配到的元操作或API：
logic: Check whether the class has declared annotations (false).
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9468936920166016
*Check whether the class is abstract (false).* 匹配到的元操作或API：
logic: Check whether the class is abstract (false).
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9445146322250366
*Get the super class of class (Base).* 匹配到的元操作或API：
logic: Get the super class of class (Base).
most similar meta operation: Get the super class of class
cosine Similarity: 0.9442464113235474
*Get all constructors declared in class (default constructor).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private (false).* 匹配到的元操作或API：
logic: Check whether the constructor is private (false).
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9621583223342896
*Check whether the class has extended x class (true, extended Base).* 匹配到的元操作或API：
logic: Check whether the class has extended x class (true, extended Base).
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9463228583335876
*Get all methods declared in class (none).* 匹配到的元操作或API：
query: Get all methods declared in class (none).
most similar API: get declared annotations of method
cosine Similarity: 0.8048223853111267
*Check whether the class is an interface (false for Base).* 匹配到的元操作或API：
logic: Check whether the class is an interface (false for Base).
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9238117933273315
*Check whether the class has declared annotations (false for Base).* 匹配到的元操作或API：
logic: Check whether the class has declared annotations (false for Base).
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9406558275222778
*Check whether the class is abstract (true for Base).* 匹配到的元操作或API：
logic: Check whether the class is abstract (true for Base).
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9357800483703613
*Get all constructors declared in class (none for Base).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has extended x class (false for Base).* 匹配到的元操作或API：
logic: Check whether the class has extended x class (false for Base).
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9503598213195801
*Get all methods declared in class (run method for Base).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is abstract (false for run method).* 匹配到的元操作或API：
logic: Check whether the method is abstract (false for run method).
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9322475790977478
*Check whether the class is an interface (false for Sub).* 匹配到的元操作或API：
logic: Check whether the class is an interface (false for Sub).
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9090306758880615
*Check whether the class has declared annotations (false for Sub).* 匹配到的元操作或API：
logic: Check whether the class has declared annotations (false for Sub).
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9329879283905029
*Check whether the class is abstract (false for Sub).* 匹配到的元操作或API：
logic: Check whether the class is abstract (false for Sub).
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9252703785896301
*Get all constructors declared in class (default constructor for Sub).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private (false for the default constructor).* 匹配到的元操作或API：
logic: Check whether the constructor is private (false for the default constructor).
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9556863307952881
*Check whether the class has extended x class (true, extended Base for Sub).* 匹配到的元操作或API：
logic: Check whether the class has extended x class (true, extended Base for Sub).
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9325131773948669
*Get all methods declared in class (none for Sub).* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                ASTClassOrInterfaceBody body = node.getFirstChildOfType(ASTClassOrInterfaceBody.class);
                if (body != null) {
                    List<ASTMethodDeclaration> methods = body.descendants(ASTMethodDeclaration.class).collect(Collectors.toList());
                    if (methods.stream().noneMatch(ASTMethodDeclaration::isAbstract)) {
                        addViolation(data, node);
                    }
                }
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this positive testcase:
public class Outer {
    private abstract class Base {
        abstract void run();
    }
    public void someMethod() {
        Base b = new Base() {
            void run() {}
        };
        b.run();
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract classes without abstract methods but with subclasses should be ignored #3668
public class Outer {
    private abstract class Base {
        private void run() {}
    }
    private final class Sub extends Base {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
8. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
9. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                ASTClassOrInterfaceBody body = node.getFirstChildOfType(ASTClassOrInterfaceBody.class);
                if (body != null) {
                    List<ASTMethodDeclaration> methods = body.descendants(ASTMethodDeclaration.class).collect(Collectors.toList());
                    if (methods.stream().noneMatch(ASTMethodDeclaration::isAbstract)) {
                        if (!hasSubclasses(node)) {
                            addViolation(data, node);
                        }
                    }
                }
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }

    private boolean hasSubclasses(ASTClassOrInterfaceDeclaration node) {
        String simpleName = node.getSimpleName();
        ASTClassOrInterfaceBody body = node.getFirstChildOfType(ASTClassOrInterfaceBody.class);
        if (body != null) {
            return body.descendants(ASTExtendsList.class)
                        .anyMatch(e -> e.getFirstChildOfType(ASTClassOrInterfaceType.class).getImage().equals(simpleName));
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is private.
3. Check whether the class is abstract.
4. Get all constructors declared in class.
5. Check whether the constructor is private.
6. Get all subclasses of class.
7. Check whether any subclass is outside the compilation unit.
8. If the class is private and has subclasses, check whether the subclasses are within the same compilation unit.
9. If the class is abstract, check whether it has any abstract methods.
10. Get the name of the super class of class.
11. Check whether the super class is private.

For `Outer` class:
- 1. Get the name of class: Outer
- 2. Check whether the class is private: False
- 3. Check whether the class is abstract: False

For `Base` class:
- 1. Get the name of class: Base
- 2. Check whether the class is private: True
- 3. Check whether the class is abstract: True
- 4. Get all constructors declared in class: Assuming default constructor
- 5. Check whether the constructor is private: False (default constructor is package-private)
- 6. Get all subclasses of class: Sub
- 7. Check whether any subclass is outside the compilation unit: False (Sub is in the same compilation unit)
- 8. If the class is private and has subclasses, check whether the subclasses are within the same compilation unit: Not applicable (previous check returned false)
- 9. If the class is abstract, check whether it has any abstract methods: False (no abstract methods declared)
- 10. Get the name of the super class of class: Object (default super class)
- 11. Check whether the super class is private: False (Object is not a private class)

For `Sub` class:
- 1. Get the name of class: Sub
- 2. Check whether the class is private: True
- 3. Check whether the class is abstract: False

Final Check: Since `Base` is private and does not have any abstract methods, and its subclass `Sub` is within the same compilation unit, it does not violate the rule. The number of violating the rule in this test case is: 0.
['Get the name of class.', 'Check whether the class is private.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get all subclasses of class.', 'Check whether any subclass is outside the compilation unit.', 'If the class is private and has subclasses, check whether the subclasses are within the same compilation unit.', 'If the class is abstract, check whether it has any abstract methods.', 'Get the name of the super class of class.', 'Check whether the super class is private.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'ASTExtendsList', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get all subclasses of class.* 匹配到的元操作或API：
query: Get all subclasses of class.
most similar API: get permitted subclasses of class or interface
cosine Similarity: 0.8182532787322998
*Check whether any subclass is outside the compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the class is private and has subclasses, check whether the subclasses are within the same compilation unit.* 匹配到的元操作或API：
query: If the class is private and has subclasses, check whether the subclasses are within the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8270125389099121
*If the class is abstract, check whether it has any abstract methods.* 匹配到的元操作或API：
logic: If the class is abstract, check whether it has any abstract methods.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9112098813056946
*Get the name of the super class of class.* 匹配到的元操作或API：
logic: Get the name of the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9248480796813965
*Check whether the super class is private.* 匹配到的元操作或API：
logic: Check whether the super class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.8868167996406555
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                ASTClassOrInterfaceBody body = node.getFirstChildOfType(ASTClassOrInterfaceBody.class);
                if (body != null) {
                    List<ASTMethodDeclaration> methods = body.descendants(ASTMethodDeclaration.class).collect(Collectors.toList());
                    if (methods.stream().noneMatch(ASTMethodDeclaration::isAbstract)) {
                        addViolation(data, node);
                    }
                }
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this positive testcase:
public class Outer {
    private abstract class Base {
        abstract void run();
    }
    public void someMethod() {
        Base b = new Base() {
            void run() {}
        };
        b.run();
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract classes without abstract methods but with subclasses should be ignored #3668
public class Outer {
    private abstract class Base {
        private void run() {}
    }
    private final class Sub extends Base {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.util.List<ASTClassOrInterfaceType> getPermittedSubclasses()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                ASTClassOrInterfaceBody body = node.getFirstChildOfType(ASTClassOrInterfaceBody.class);
                if (body != null) {
                    List<ASTMethodDeclaration> methods = body.descendants(ASTMethodDeclaration.class).collect(Collectors.toList());
                    if (methods.stream().noneMatch(ASTMethodDeclaration::isAbstract)) {
                        if (!hasSubclassesInSameCompilationUnit(node)) {
                            addViolation(data, node);
                        }
                    }
                }
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                if (!hasSubclassesInSameCompilationUnit(node)) {
                    addViolation(data, node);
                }
            }
        }
        return data;
    }

    private boolean hasSubclassesInSameCompilationUnit(ASTClassOrInterfaceDeclaration node) {
        String simpleName = node.getSimpleName();
        return node.getCompilationUnit().getDeclarations().stream()
                .filter(ASTClassOrInterfaceDeclaration.class::isInstance)
                .map(ASTClassOrInterfaceDeclaration.class::cast)
                .anyMatch(sub -> {
                    ASTClassOrInterfaceType superClassTypeNode = sub.getSuperClassTypeNode();
                    return superClassTypeNode != null && superClassTypeNode.getSimpleName().equals(simpleName) && superClassTypeNode.isReferenceToClassSameCompilationUnit();
                });
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To perform granular checks on the provided test case to verify adherence to the rule, we need to inspect the `Base` and `Sub` classes within the `Outer` class.

1. Get the name of class.
2. Check whether the class is public.
3. Get the name of class.
4. Check whether the class is private.
5. Check whether the class is abstract.
6. Get all methods declared in class.
7. Check whether the method is abstract.
8. Get all constructors declared in class.
9. Check whether the constructor is private.
10. Get the name of class.
11. Check whether the class is public.
12. Get the name of class.
13. Check whether the class is private.
14. Get the super class of class.
15. Check whether the super class is final.
16. Check whether the class extends the super class.
17. Get all constructors declared in class.
18. Check whether the constructor is private.

Let's break it down:

1. Get the name of class (Outer).
2. Check whether the class is public (True, as declared public).
3. Get the name of class (Base).
4. Check whether the class is private (True, as declared private).
5. Check whether the class is abstract (True, as declared abstract).
6. Get all methods declared in class (Base).
7. Check whether the method is abstract (False, as method `run()` is not abstract).
8. Get all constructors declared in class (Base).
9. Check whether the constructor is private (True, as all constructors are implicitly private since the class is private).
10. Get the name of class (Sub).
11. Check whether the class is public (False, as declared private).
12. Get the name of class (Sub).
13. Check whether the class is private (True, as declared private).
14. Get the super class of class (Sub).
15. Check whether the super class is final (False, as super class `Base` is not final).
16. Check whether the class extends the super class (True, as `Sub` extends `Base`).
17. Get all constructors declared in class (Sub).
18. Check whether the constructor is private (True, as all constructors are implicitly private since the class is private).

Given these checks, the `Base` class is abstract and private, meaning it cannot be extended outside the `Outer` class. The `Sub` class is also private, extending `Base`. Since all constructors of both `Base` and `Sub` are implicitly private, they cannot be instantiated or extended from outside their compilation unit. Therefore, the `Base` class does not violate the rule even though it is abstract without abstract methods because it cannot be extended outside its compilation unit.

The number of violations in this test case is 0, as per the description and checks performed.
['Get the name of class.', 'Check whether the class is public.', 'Get the name of class.', 'Check whether the class is private.', 'Check whether the class is abstract.', 'Get all methods declared in class.', 'Check whether the method is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get the name of class.', 'Check whether the class is public.', 'Get the name of class.', 'Check whether the class is private.', 'Get the super class of class.', 'Check whether the super class is final.', 'Check whether the class extends the super class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get the name of class (Outer).', 'Check whether the class is public (True, as declared public).', 'Get the name of class (Base).', 'Check whether the class is private (True, as declared private).', 'Check whether the class is abstract (True, as declared abstract).', 'Get all methods declared in class (Base).', 'Check whether the method is abstract (False, as method `run()` is not abstract).', 'Get all constructors declared in class (Base).', 'Check whether the constructor is private (True, as all constructors are implicitly private since the class is private).', 'Get the name of class (Sub).', 'Check whether the class is public (False, as declared private).', 'Get the name of class (Sub).', 'Check whether the class is private (True, as declared private).', 'Get the super class of class (Sub).', 'Check whether the super class is final (False, as super class `Base` is not final).', 'Check whether the class extends the super class (True, as `Sub` extends `Base`).', 'Get all constructors declared in class (Sub).', 'Check whether the constructor is private (True, as all constructors are implicitly private since the class is private).']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'ASTExtendsList', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the super class is final.* 匹配到的元操作或API：
logic: Check whether the super class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.8660691976547241
*Check whether the class extends the super class.* 匹配到的元操作或API：
logic: Check whether the class extends the super class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.8541654348373413
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the name of class (Outer).* 匹配到的元操作或API：
logic: Get the name of class (Outer).
most similar meta operation: Get the name of class
cosine Similarity: 0.8748226761817932
*Check whether the class is public (True, as declared public).* 匹配到的元操作或API：
logic: Check whether the class is public (True, as declared public).
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9350396394729614
*Get the name of class (Base).* 匹配到的元操作或API：
logic: Get the name of class (Base).
most similar meta operation: Get the name of class
cosine Similarity: 0.8888643980026245
*Check whether the class is private (True, as declared private).* 匹配到的元操作或API：
logic: Check whether the class is private (True, as declared private).
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9359906911849976
*Check whether the class is abstract (True, as declared abstract).* 匹配到的元操作或API：
logic: Check whether the class is abstract (True, as declared abstract).
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9388939142227173
*Get all methods declared in class (Base).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is abstract (False, as method `run()` is not abstract).* 匹配到的元操作或API：
logic: Check whether the method is abstract (False, as method `run()` is not abstract).
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9213118553161621
*Get all constructors declared in class (Base).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private (True, as all constructors are implicitly private since the class is private).* 匹配到的元操作或API：
logic: Check whether the constructor is private (True, as all constructors are implicitly private since the class is private).
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.937626838684082
*Get the name of class (Sub).* 匹配到的元操作或API：
logic: Get the name of class (Sub).
most similar meta operation: Get the name of class
cosine Similarity: 0.881794810295105
*Check whether the class is public (False, as declared private).* 匹配到的元操作或API：
logic: Check whether the class is public (False, as declared private).
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9243053793907166
*Get the name of class (Sub).* 匹配到的元操作或API：
logic: Get the name of class (Sub).
most similar meta operation: Get the name of class
cosine Similarity: 0.881794810295105
*Check whether the class is private (True, as declared private).* 匹配到的元操作或API：
logic: Check whether the class is private (True, as declared private).
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9359906911849976
*Get the super class of class (Sub).* 匹配到的元操作或API：
logic: Get the super class of class (Sub).
most similar meta operation: Get the super class of class
cosine Similarity: 0.9463566541671753
*Check whether the super class is final (False, as super class `Base` is not final).* 匹配到的元操作或API：
logic: Check whether the super class is final (False, as super class `Base` is not final).
most similar meta operation: Check whether the class is final
cosine Similarity: 0.8629709482192993
*Check whether the class extends the super class (True, as `Sub` extends `Base`).* 匹配到的元操作或API：
query: Check whether the class extends the super class (True, as `Sub` extends `Base`).
most similar API: Check whether the extends list equals
cosine Similarity: 0.8031558394432068
*Get all constructors declared in class (Sub).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private (True, as all constructors are implicitly private since the class is private).* 匹配到的元操作或API：
logic: Check whether the constructor is private (True, as all constructors are implicitly private since the class is private).
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.937626838684082
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                ASTClassOrInterfaceBody body = node.getFirstChildOfType(ASTClassOrInterfaceBody.class);
                if (body != null) {
                    List<ASTMethodDeclaration> methods = body.descendants(ASTMethodDeclaration.class).collect(Collectors.toList());
                    if (methods.stream().noneMatch(ASTMethodDeclaration::isAbstract)) {
                        addViolation(data, node);
                    }
                }
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
This checker has passed this positive testcase:
public class Outer {
    private abstract class Base {
        abstract void run();
    }
    public void someMethod() {
        Base b = new Base() {
            void run() {}
        };
        b.run();
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract classes without abstract methods but with subclasses should be ignored #3668
public class Outer {
    private abstract class Base {
        private void run() {}
    }
    private final class Sub extends Base {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
10. net.sourceforge.pmd.lang.java.ast.ASTExtendsList: public boolean equals(java.lang.Object)

1.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.stream.Collectors;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                ASTClassOrInterfaceBody body = node.getFirstChildOfType(ASTClassOrInterfaceBody.class);
                if (body != null) {
                    List<ASTMethodDeclaration> methods = body.descendants(ASTMethodDeclaration.class).collect(Collectors.toList());
                    if (methods.stream().noneMatch(ASTMethodDeclaration::isAbstract)) {
                        if (!hasSubclassesOutsideCompilationUnit(node)) {
                            addViolation(data, node);
                        }
                    }
                }
            }
        } else if (!node.isNested() && node.isAbstract() && !node.isFinal()) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).collect(Collectors.toList());
            if (constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return data;
    }

    private boolean hasSubclassesOutsideCompilationUnit(ASTClassOrInterfaceDeclaration node) {
        String simpleName = node.getSimpleName();
        return node.getRoot().findDescendantsOfType(ASTClassOrInterfaceDeclaration.class)
                .stream()
                .anyMatch(sub -> sub.isNested() && extendsSpecificClass(sub, simpleName) && !sub.isInSameCompilationUnit(node));
    }

    private boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration sub, String simpleName) {
        ASTClassOrInterfaceType superClassTypeNode = sub.getSuperClassTypeNode();
        return superClassTypeNode != null && superClassTypeNode.getSimpleName().equals(simpleName);
    }

    private boolean isInSameCompilationUnit(ASTClassOrInterfaceDeclaration node, ASTClassOrInterfaceDeclaration other) {
        return node.getRoot().equals(other.getRoot());
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 13
测试用例全部通过
最终通过 15 个测试用例
正例 11 个
反例 4 个
输入token：1164238
输出token：807386
结束

规则执行完毕，时间总花销： 5702.980924129486 秒
