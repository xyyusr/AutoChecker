开始

========================================== Rule AvoidInstantiatingObjectsInLoopsRule ===========================================
一共 23 个测试用例
正例 14 个
反例 9 个
1970
1570
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Get the method located in class.
3. Get the name of method.
4. Get the body of method.
5. Get the loop statement in method body.
6. Get the body of loop statement.
7. Get the object creation within loop statement body.
8. Check whether the object creation within loop statement body is of type String.

In this test case:
6. The body of the method `test1` contains a `for(;;)` loop.
7. The body of the loop contains `String a = new String();`.
8. The object creation within the loop body is of type `String`.

Since the object creation within the loop body is of type `String`, this test case violates the rule once. The description "bad 1" and the number of violations "1" are correct.
['Get the name of class.', 'Get the method located in class.', 'Get the name of method.', 'Get the body of method.', 'Get the loop statement in method body.', 'Get the body of loop statement.', 'Get the object creation within loop statement body.', 'Check whether the object creation within loop statement body is of type String.', 'The body of the method `test1` contains a `for(;;)` loop.', 'The body of the loop contains `String a = new String();`.', 'The object creation within the loop body is of type `String`.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTForStatement']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the method located in class.* 匹配到的元操作或API：
logic: Get the method located in class.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.8985239267349243
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752806425094604
*Get the loop statement in method body.* 匹配到的元操作或API：
query: Get the loop statement in method body.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8579763770103455
*Get the body of loop statement.* 匹配到的元操作或API：
query: Get the body of loop statement.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.9263396263122559
*Get the object creation within loop statement body.* 匹配到的元操作或API：
query: Get the object creation within loop statement body.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.815815269947052
*Check whether the object creation within loop statement body is of type String.* 匹配到的元操作或API：
未匹配成功元操作或API
*The body of the method `test1` contains a `for(;;)` loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*The body of the loop contains `String a = new String();`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The object creation within the loop body is of type `String`.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: New objects can not be created within loops;
The test case corresponding to the rule:
```
// TEST1
public class Foo {
    public void test1() {
        for(;;) {
            String a = new String();
        }
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test1')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'a')
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
5. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTForStatement.class, ASTLocalVariableDeclaration.class);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            for (ASTLocalVariableDeclaration declaration : body.children(ASTLocalVariableDeclaration.class)) {
                if (declaration.getFirstChildOfType(ASTConstructorCall.class) != null) {
                    addViolation(data, declaration);
                }
            }
        } else if (body instanceof ASTLocalVariableDeclaration) {
            // Handle the case where the body of the for loop is a single local variable declaration
            ASTLocalVariableDeclaration declaration = (ASTLocalVariableDeclaration) body;
            if (declaration.getFirstChildOfType(ASTConstructorCall.class) != null) {
                addViolation(data, declaration);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTLocalVariableDeclaration node, Object data) {
        if (node.getFirstChildOfType(ASTConstructorCall.class) != null) {
            ASTStatement parent = node.getParent();
            while (parent != null) {
                if (parent instanceof ASTForStatement) {
                    addViolation(data, node);
                    break;
                }
                parent = parent.getParent();
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the loop variable of for loop.
        2. Get the body of for loop.
        3. Check whether the body of for loop contains a constructor call.
        4. Get the type of object created by constructor call.
        5. Check whether the type of object is String class type.
        If the body of the for loop contains a constructor call to create a new object of type String, then this test case violates the rule.
['Get the loop variable of for loop.', 'Get the body of for loop.', 'Check whether the body of for loop contains a constructor call.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTForStatement']
*Get the loop variable of for loop.* 匹配到的元操作或API：
logic: Get the loop variable of for loop.
most similar meta operation: Get a loop variable of for loop
cosine Similarity: 0.975679874420166
*Get the body of for loop.* 匹配到的元操作或API：
query: Get the body of for loop.
most similar API: get body of for statement
cosine Similarity: 0.9184505939483643
*Check whether the body of for loop contains a constructor call.* 匹配到的元操作或API：
query: Check whether the body of for loop contains a constructor call.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8580939173698425
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: New objects can not be created within loops;
The test case corresponding to the rule:
```
// TEST1
public class Foo {
    public void test1() {
        for(;;) {
            String a = new String();
        }
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test1')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'a')
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public net.sourceforge.pmd.lang.ast.NodeStream<ASTVariableDeclaratorId> getLoopVariables(net.sourceforge.pmd.lang.java.ast.ASTForStatement)
2. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTForStatement.class, ASTLocalVariableDeclaration.class);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        node.getBody().descendants(ASTConstructorCall.class).forEach(constructorCall -> {
            if (isVariableAccessStringType(constructorCall)) {
                addViolation(data, constructorCall);
            }
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTLocalVariableDeclaration node, Object data) {
        if (node.getParent() instanceof ASTForStatement) {
            node.children(ASTConstructorCall.class).forEach(constructorCall -> {
                if (isVariableAccessStringType(constructorCall)) {
                    addViolation(data, constructorCall);
                }
            });
        }
        return super.visit(node, data);
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        JType type = node.getTypeNode().getType();
        return TypeTestUtil.isA(String.class, type);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
        2. Get the name of method.
        3. Get the loop statement.
        4. Get the body of the loop statement.
        5. Get the object creation within the loop body.
        6. Check whether an object is created within the loop.
        If an object is created within the loop, then this test case violates the rule.

Based on the test case provided:

1. Get the name of class.
   - The name of the class is `Foo`.

2. Get the name of method.
   - The name of the method is `test1`.

3. Get the loop statement.
   - The loop statement is `for(;;)`.

4. Get the body of the loop statement.
   - The body of the loop statement is `{ String a = new String(); }`.

5. Get the object creation within the loop body.
   - The object creation within the loop body is `new String()`.

6. Check whether an object is created within the loop.
   - An object is created within the loop (specifically, a `String` object).

Since the object creation (`new String()`) is within the loop, this test case violates the rule. The description "bad 1" and the number of violations as "1" are correct based on this granular check.
['Get the name of class.', 'Get the name of method.', 'Get the loop statement.', 'Get the body of the loop statement.', 'Get the object creation within the loop body.', 'Check whether an object is created within the loop.', 'Get the name of class.', 'Get the name of method.', 'Get the loop statement.', 'Get the body of the loop statement.', 'Get the object creation within the loop body.', 'Check whether an object is created within the loop.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTForStatement']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the loop statement.* 匹配到的元操作或API：
query: Get the loop statement.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8175114989280701
*Get the body of the loop statement.* 匹配到的元操作或API：
query: Get the body of the loop statement.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.9237593412399292
*Get the object creation within the loop body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether an object is created within the loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the loop statement.* 匹配到的元操作或API：
query: Get the loop statement.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8175114989280701
*Get the body of the loop statement.* 匹配到的元操作或API：
query: Get the body of the loop statement.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.9237593412399292
*Get the object creation within the loop body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether an object is created within the loop.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: New objects can not be created within loops;
The test case corresponding to the rule:
```
// TEST1
public class Foo {
    public void test1() {
        for(;;) {
            String a = new String();
        }
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test1')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'a')
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
3. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {

    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTForStatement.class, ASTLocalVariableDeclaration.class);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<? extends JavaNode> children = node.children(ASTLocalVariableDeclaration.class);
        children.forEach(localVar -> {
            if (localVar.hasDescendant(ASTConstructorCall.class)) {
                addViolation(data, localVar);
            }
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTLocalVariableDeclaration node, Object data) {
        if (node.getNthParent(1) instanceof ASTForStatement && node.hasDescendant(ASTConstructorCall.class)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the loop variable of for loop.
        2. Get the body of the for loop.
        3. Get all method calls within the for loop body.
        4. Get the constructor call within the for loop body.
        5. Check whether the constructor call is new String().
        If there is a constructor call within the for loop body, then this test case violates the rule.
        
In this specific test case:
1. Get the body of the for loop.
        2. Get all constructor calls within the for loop body.
        3. Check whether there is a constructor call for new String().
        4. Check whether the constructor call is new String().
        
This test case contains one constructor call within the for loop body, which violates the rule.
['Get the loop variable of for loop.', 'Get the body of the for loop.', 'Get all method calls within the for loop body.', 'Get the constructor call within the for loop body.', 'Check whether the constructor call is new String().', 'Get the body of the for loop.', 'Get all constructor calls within the for loop body.', 'Check whether there is a constructor call for new String().', 'Check whether the constructor call is new String().']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTForStatement']
*Get the loop variable of for loop.* 匹配到的元操作或API：
logic: Get the loop variable of for loop.
most similar meta operation: Get a loop variable of for loop
cosine Similarity: 0.975679874420166
*Get the body of the for loop.* 匹配到的元操作或API：
query: Get the body of the for loop.
most similar API: get body of for statement
cosine Similarity: 0.9058630466461182
*Get all method calls within the for loop body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the constructor call within the for loop body.* 匹配到的元操作或API：
query: Get the constructor call within the for loop body.
most similar API: get text of constructor call
cosine Similarity: 0.8321789503097534
*Check whether the constructor call is new String().* 匹配到的元操作或API：
query: Check whether the constructor call is new String().
most similar API: Check whether the constructor call equals
cosine Similarity: 0.829264223575592
*Get the body of the for loop.* 匹配到的元操作或API：
query: Get the body of the for loop.
most similar API: get body of for statement
cosine Similarity: 0.9058630466461182
*Get all constructor calls within the for loop body.* 匹配到的元操作或API：
query: Get all constructor calls within the for loop body.
most similar API: get arguments of constructor call
cosine Similarity: 0.8052245378494263
*Check whether there is a constructor call for new String().* 匹配到的元操作或API：
query: Check whether there is a constructor call for new String().
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8274120688438416
*Check whether the constructor call is new String().* 匹配到的元操作或API：
query: Check whether the constructor call is new String().
most similar API: Check whether the constructor call equals
cosine Similarity: 0.829264223575592
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: New objects can not be created within loops;
The test case corresponding to the rule:
```
// TEST1
public class Foo {
    public void test1() {
        for(;;) {
            String a = new String();
        }
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test1')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'a')
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public net.sourceforge.pmd.lang.ast.NodeStream<ASTVariableDeclaratorId> getLoopVariables(net.sourceforge.pmd.lang.java.ast.ASTForStatement)
2. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.document.Chars getText()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean equals(java.lang.Object)
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTForStatement.class, ASTLocalVariableDeclaration.class);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            for (ASTLocalVariableDeclaration decl : ((ASTBlock) body).children(ASTLocalVariableDeclaration.class)) {
                for (ASTConstructorCall call : decl.children(ASTConstructorCall.class)) {
                    if (call != null) {
                        addViolation(data, call);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTLocalVariableDeclaration node, Object data) {
        if (node.getParent() instanceof ASTForStatement) {
            for (ASTConstructorCall call : node.children(ASTConstructorCall.class)) {
                if (call != null) {
                    addViolation(data, call);
                }
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the type of object created by constructor call.
2. Get the type of the loop statement.
3. Check whether the loop statement is a for loop.
4. Check whether the constructor call is within the for loop.
5. Check whether the type of object created by constructor call is a string type.
6. Get the type of object created by constructor call.
7. Check whether the constructor call is within the for loop.

For this specific test case:
1. Get the type of object created by constructor call. // String
2. Get the type of the loop statement. // for loop
3. Check whether the loop statement is a for loop. // true
4. Check whether the constructor call is within the for loop. // true
5. Check whether the type of object created by constructor call is a string type. // true
6. Get the type of object created by constructor call. // String
7. Check whether the constructor call is within the for loop. // true

The description of this test case is: bad 1
The number of violating the rule in this test case is: 1
['Get the type of object created by constructor call.', 'Get the type of the loop statement.', 'Check whether the loop statement is a for loop.', 'Check whether the constructor call is within the for loop.', 'Check whether the type of object created by constructor call is a string type.', 'Get the type of object created by constructor call.', 'Check whether the constructor call is within the for loop.', 'Get the type of object created by constructor call. // String', 'Get the type of the loop statement. // for loop', 'Check whether the loop statement is a for loop. // true', 'Check whether the constructor call is within the for loop. // true', 'Check whether the type of object created by constructor call is a string type. // true', 'Get the type of object created by constructor call. // String', 'Check whether the constructor call is within the for loop. // true']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTForStatement']
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Get the type of the loop statement.* 匹配到的元操作或API：
query: Get the type of the loop statement.
most similar API: get enclosing type of for statement
cosine Similarity: 0.8178216814994812
*Check whether the loop statement is a for loop.* 匹配到的元操作或API：
query: Check whether the loop statement is a for loop.
most similar API: Check whether the for statement equals
cosine Similarity: 0.8447393178939819
*Check whether the constructor call is within the for loop.* 匹配到的元操作或API：
query: Check whether the constructor call is within the for loop.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8738609552383423
*Check whether the type of object created by constructor call is a string type.* 匹配到的元操作或API：
logic: Check whether the type of object created by constructor call is a string type.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.883967936038971
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the constructor call is within the for loop.* 匹配到的元操作或API：
query: Check whether the constructor call is within the for loop.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8738609552383423
*Get the type of object created by constructor call. // String* 匹配到的元操作或API：
logic: Get the type of object created by constructor call. // String
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9657415151596069
*Get the type of the loop statement. // for loop* 匹配到的元操作或API：
query: Get the type of the loop statement. // for loop
most similar API: get type system of for statement
cosine Similarity: 0.8618820309638977
*Check whether the loop statement is a for loop. // true* 匹配到的元操作或API：
query: Check whether the loop statement is a for loop. // true
most similar API: Check whether the for statement equals
cosine Similarity: 0.8205075263977051
*Check whether the constructor call is within the for loop. // true* 匹配到的元操作或API：
query: Check whether the constructor call is within the for loop. // true
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8631014823913574
*Check whether the type of object created by constructor call is a string type. // true* 匹配到的元操作或API：
logic: Check whether the type of object created by constructor call is a string type. // true
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.8629873394966125
*Get the type of object created by constructor call. // String* 匹配到的元操作或API：
logic: Get the type of object created by constructor call. // String
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9657415151596069
*Check whether the constructor call is within the for loop. // true* 匹配到的元操作或API：
query: Check whether the constructor call is within the for loop. // true
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8631014823913574
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: New objects can not be created within loops;
The test case corresponding to the rule:
```
// TEST1
public class Foo {
    public void test1() {
        for(;;) {
            String a = new String();
        }
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test1')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'a')
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType(), //Returns the node representing the type declaration this node is found in. The type of that node is the type of the {@code this} expression. <p>This returns null for nodes that aren't enclosed in a type declaration. This includes {@linkplain ASTPackageDeclaration PackageDeclaration}, This includes {@linkplain ASTImportDeclaration ImportDeclaration}, {@linkplain ASTModuleDeclaration ModuleDeclaration}, {@linkplain ASTCompilationUnit CompilationUnit}, and top-level {@linkplain ASTAnyTypeDeclaration AnyTypeDeclaration}s.
3. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean equals(java.lang.Object)
5. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.types.TypeSystem getTypeSystem()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTForStatement.class, ASTLocalVariableDeclaration.class);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        node.descendants(ASTLocalVariableDeclaration.class).forEach(ld -> {
            if (ld.getFirstChildOfType(ASTConstructorCall.class) != null) {
                addViolation(data, ld);
            }
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTLocalVariableDeclaration node, Object data) {
        if (node.getNthParent(1, ASTForStatement.class) != null && node.getFirstChildOfType(ASTConstructorCall.class) != null) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 1
2074
1658
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the type of the loop statement.
        2. Check whether the loop statement is a while statement.
        3. Get the body of the while statement.
        4. Identify all object creation expressions within the body of the while statement.
        5. Check whether any object creation expressions are present within the loop body.
        If there is an object creation expression within the body of the while loop, then this test case violates the rule.

In this specific test case:
1. The type of the loop statement is a while statement.
2. The condition of the while statement is `true`, making it an infinite loop.
3. The body of the while statement contains `String a = new String();`.
4. There is an object creation expression `new String()` within the loop body.
5. Since an object creation expression is present, the test case violates the rule.
['Get the type of the loop statement.', 'Check whether the loop statement is a while statement.', 'Get the body of the while statement.', 'Identify all object creation expressions within the body of the while statement.', 'Check whether any object creation expressions are present within the loop body.', 'The type of the loop statement is a while statement.', 'The condition of the while statement is `true`, making it an infinite loop.', 'The body of the while statement contains `String a = new String();`.', 'There is an object creation expression `new String()` within the loop body.', 'Since an object creation expression is present, the test case violates the rule.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ASTWhileStatement', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTBooleanLiteral', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the type of the loop statement.* 匹配到的元操作或API：
query: Get the type of the loop statement.
most similar API: get type system of while statement
cosine Similarity: 0.8199769258499146
*Check whether the loop statement is a while statement.* 匹配到的元操作或API：
query: Check whether the loop statement is a while statement.
most similar API: Check whether the while statement equals
cosine Similarity: 0.8921941518783569
*Get the body of the while statement.* 匹配到的元操作或API：
query: Get the body of the while statement.
most similar API: get body of while statement
cosine Similarity: 0.9759774804115295
*Identify all object creation expressions within the body of the while statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any object creation expressions are present within the loop body.* 匹配到的元操作或API：
query: Check whether any object creation expressions are present within the loop body.
most similar API: Check whether the constructor call is expression
cosine Similarity: 0.8009081482887268
*The type of the loop statement is a while statement.* 匹配到的元操作或API：
query: The type of the loop statement is a while statement.
most similar API: descendants of while statement
cosine Similarity: 0.8074723482131958
*The condition of the while statement is `true`, making it an infinite loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*The body of the while statement contains `String a = new String();`.* 匹配到的元操作或API：
未匹配成功元操作或API
*There is an object creation expression `new String()` within the loop body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Since an object creation expression is present, the test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: New objects can not be created within loops;
The test case corresponding to the rule:
```
// TEST2
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test1')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTWhileStatement
          ——ASTBooleanLiteral
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'a')
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.types.TypeSystem getTypeSystem()
2. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
5. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.ast.NodeStream$DescendantNodeStream<NodeStream$DescendantNodeStream<N> descendants()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoWhileStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        checkForConstructorCallInLoopBody(node.getBody(), node);
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        checkForConstructorCallInLoopBody(node.getBody(), node);
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        checkForConstructorCallInLoopBody(node.getBody(), node);
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoWhileStatement node, Object data) {
        checkForConstructorCallInLoopBody(node.getBody(), node);
        return super.visit(node, data);
    }

    private void checkForConstructorCallInLoopBody(JavaNode body, JavaNode loopNode) {
        body.descendants(ASTConstructorCall.class).forEach(constructorCall -> addViolation(data, loopNode));
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the condition of while statement.
        2. Get the body of while statement.
        3. Perform an operation on the body of the while statement to identify object creation.
        4. Check whether the body contains a constructor call.
        5. Get the type of object created by constructor call.
        6. Check whether the constructor call is within a loop statement.
        If the body of the while statement contains a constructor call, then this test case violates the rule.
        
Let's apply these granular checks to the provided test case:

1. Get the condition of while statement.
        - The condition is `true`.

2. Get the body of while statement.
        - The body is `{ String a = new String(); }`.

3. Perform an operation on the body of the while statement to identify object creation.
        - Identify any object creation within the body.

4. Check whether the body contains a constructor call.
        - The body contains `new String()`.

5. Get the type of object created by constructor call.
        - The type created is `String`.

6. Check whether the constructor call is within a loop statement.
        - The constructor call is within the `while(true)` loop.

Given these checks, the test case does indeed violate the rule as it creates a new `String` object within the `while` loop.
['Get the condition of while statement.', 'Get the body of while statement.', 'Perform an operation on the body of the while statement to identify object creation.', 'Check whether the body contains a constructor call.', 'Get the type of object created by constructor call.', 'Check whether the constructor call is within a loop statement.', 'Get the condition of while statement.', 'Get the body of while statement.', 'Perform an operation on the body of the while statement to identify object creation.', 'Check whether the body contains a constructor call.', 'Get the type of object created by constructor call.', 'Check whether the constructor call is within a loop statement.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ASTWhileStatement', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTBooleanLiteral', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of while statement.* 匹配到的元操作或API：
logic: Get the condition of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.9850377440452576
*Get the body of while statement.* 匹配到的元操作或API：
logic: Get the body of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.8570233583450317
*Perform an operation on the body of the while statement to identify object creation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body contains a constructor call.* 匹配到的元操作或API：
query: Check whether the body contains a constructor call.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8527532815933228
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the constructor call is within a loop statement.* 匹配到的元操作或API：
query: Check whether the constructor call is within a loop statement.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8523243069648743
*Get the condition of while statement.* 匹配到的元操作或API：
logic: Get the condition of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.9850377440452576
*Get the body of while statement.* 匹配到的元操作或API：
logic: Get the body of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.8570233583450317
*Perform an operation on the body of the while statement to identify object creation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body contains a constructor call.* 匹配到的元操作或API：
query: Check whether the body contains a constructor call.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8527532815933228
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the constructor call is within a loop statement.* 匹配到的元操作或API：
query: Check whether the constructor call is within a loop statement.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8523243069648743
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: New objects can not be created within loops;
The test case corresponding to the rule:
```
// TEST2
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test1')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTWhileStatement
          ——ASTBooleanLiteral
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'a')
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTBlock.class);
    }

    @Override
    public Object visit(ASTBlock node, RuleContext data) {
        JavaNode parent = node.getParent();
        if (parent instanceof ASTWhileStatement || parent instanceof ASTForStatement || parent instanceof ASTForeachStatement) {
            node.descendants(ASTConstructorCall.class).forEach(constructorCall -> addViolation(data, constructorCall));
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the type of loop statement.
        2. Get the loop variable of for loop (if applicable).
        3. Get the condition of while statement.
        4. Get the condition of do-while statement.
        5. Get statements within the loop body.
        6. Check whether the statement is an object creation statement (new keyword).
        7. Get the type of object created by constructor call.
        
For the given test case:

1. Get the type of loop statement. (It is a while loop)
2. Get the condition of while statement. (It is true)
3. Get statements within the loop body. (It contains "String a = new String();")
4. Check whether the statement is an object creation statement (new keyword). (Yes, it is)
5. Get the type of object created by constructor call. (It is String)

Since the test case creates a new object `String a = new String();` within the while loop, it violates the rule.
['Get the type of loop statement.', 'Get the loop variable of for loop (if applicable).', 'Get the condition of while statement.', 'Get the condition of do-while statement.', 'Get statements within the loop body.', 'Check whether the statement is an object creation statement (new keyword).', 'Get the type of object created by constructor call.', 'Get the type of loop statement. (It is a while loop)', 'Get the condition of while statement. (It is true)', 'Get statements within the loop body. (It contains "String a = new String();")', 'Check whether the statement is an object creation statement (new keyword). (Yes, it is)', 'Get the type of object created by constructor call. (It is String)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ASTWhileStatement', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTBooleanLiteral', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the type of loop statement.* 匹配到的元操作或API：
query: Get the type of loop statement.
most similar API: get enclosing type of while statement
cosine Similarity: 0.8150316476821899
*Get the loop variable of for loop (if applicable).* 匹配到的元操作或API：
logic: Get the loop variable of for loop (if applicable).
most similar meta operation: Get a loop variable of for loop
cosine Similarity: 0.9619483351707458
*Get the condition of while statement.* 匹配到的元操作或API：
logic: Get the condition of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.9850377440452576
*Get the condition of do-while statement.* 匹配到的元操作或API：
logic: Get the condition of do-while statement.
most similar meta operation: Get the condition of do-while statement
cosine Similarity: 0.9866269826889038
*Get statements within the loop body.* 匹配到的元操作或API：
query: Get statements within the loop body.
most similar API: get body of while statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8211447596549988
*Check whether the statement is an object creation statement (new keyword).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Get the type of loop statement. (It is a while loop)* 匹配到的元操作或API：
query: Get the type of loop statement. (It is a while loop)
most similar API: get type system of while statement
cosine Similarity: 0.8755667209625244
*Get the condition of while statement. (It is true)* 匹配到的元操作或API：
logic: Get the condition of while statement. (It is true)
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.960480809211731
*Get statements within the loop body. (It contains "String a = new String();")* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the statement is an object creation statement (new keyword). (Yes, it is)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of object created by constructor call. (It is String)* 匹配到的元操作或API：
logic: Get the type of object created by constructor call. (It is String)
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9735678434371948
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: New objects can not be created within loops;
The test case corresponding to the rule:
```
// TEST2
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test1')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTWhileStatement
          ——ASTBooleanLiteral
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'a')
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType(), //Returns the node representing the type declaration this node is found in. The type of that node is the type of the {@code this} expression. <p>This returns null for nodes that aren't enclosed in a type declaration. This includes {@linkplain ASTPackageDeclaration PackageDeclaration}, This includes {@linkplain ASTImportDeclaration ImportDeclaration}, {@linkplain ASTModuleDeclaration ModuleDeclaration}, {@linkplain ASTCompilationUnit CompilationUnit}, and top-level {@linkplain ASTAnyTypeDeclaration AnyTypeDeclaration}s.
2. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public net.sourceforge.pmd.lang.ast.NodeStream<ASTVariableDeclaratorId> getLoopVariables(net.sourceforge.pmd.lang.java.ast.ASTForStatement)
3. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
4. net.sourceforge.pmd.lang.java.ast.ASTDoStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody()
5. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
7. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.types.TypeSystem getTypeSystem()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
True
此测试用例生成了first checker: bad 2


======================接下来开始迭代=====================
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
80
65
=========================error_testcase_logics=========================
1. Get the body of the do-while statement.
2. Get all statements within the do-while body.
3. Check whether any statement is an object creation statement.
4. If an object creation statement is found, get the type of object created by the constructor call.
5. Check whether the object creation statement is within a loop.

In this test case:

1. Get the body of the do-while statement.
   - The body contains the statement `String a = new String();`.
2. Get all statements within the do-while body.
   - The statement is `String a = new String();`.
3. Check whether any statement is an object creation statement.
   - The statement `String a = new String();` is an object creation statement.
4. If an object creation statement is found, get the type of object created by the constructor call.
   - The type of object created is `String`.
5. Check whether the object creation statement is within a loop.
   - The statement `String a = new String();` is within the `do-while` loop.

Since there is an object creation statement within the loop, this test case violates the rule.
['Get the body of the do-while statement.', 'Get all statements within the do-while body.', 'Check whether any statement is an object creation statement.', 'If an object creation statement is found, get the type of object created by the constructor call.', 'Check whether the object creation statement is within a loop.', 'Get the body of the do-while statement.', 'Get all statements within the do-while body.', 'Check whether any statement is an object creation statement.', 'If an object creation statement is found, get the type of object created by the constructor call.', 'Check whether the object creation statement is within a loop.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'ASTDoStatement', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTBooleanLiteral', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the body of the do-while statement.* 匹配到的元操作或API：
query: Get the body of the do-while statement.
most similar API: get body of do statement
cosine Similarity: 0.9093490839004517
*Get all statements within the do-while body.* 匹配到的元操作或API：
query: Get all statements within the do-while body.
most similar API: get body of do statement
cosine Similarity: 0.8269577026367188
*Check whether any statement is an object creation statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*If an object creation statement is found, get the type of object created by the constructor call.* 匹配到的元操作或API：
logic: If an object creation statement is found, get the type of object created by the constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9367185831069946
*Check whether the object creation statement is within a loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the do-while statement.* 匹配到的元操作或API：
query: Get the body of the do-while statement.
most similar API: get body of do statement
cosine Similarity: 0.9093490839004517
*Get all statements within the do-while body.* 匹配到的元操作或API：
query: Get all statements within the do-while body.
most similar API: get body of do statement
cosine Similarity: 0.8269577026367188
*Check whether any statement is an object creation statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*If an object creation statement is found, get the type of object created by the constructor call.* 匹配到的元操作或API：
logic: If an object creation statement is found, get the type of object created by the constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9367185831069946
*Check whether the object creation statement is within a loop.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}


This checker is failed(false negative) on this negative test case:
```
// TEST3
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test1')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTDoStatement
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'a')
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 0)
          ——ASTBooleanLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTDoStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that will be run while the guard evaluates to true.
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
100
82
111
94
96
81
=========================error_testcase_logics=========================
1. Get the condition of while statement.
2. Check whether the condition of while statement contains an object creation.
If the condition of the while statement contains a new object creation (e.g., `new String()`), then this test case violates the rule.

In this specific test case, step 2 would identify that `new String().length() > 0` contains an object creation, thus indicating a violation of the rule.
['Get the condition of while statement.', 'Check whether the condition of while statement contains an object creation.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTInfixExpression', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ASTWhileStatement', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of while statement.* 匹配到的元操作或API：
logic: Get the condition of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.9850377440452576
*Check whether the condition of while statement contains an object creation.* 匹配到的元操作或API：
query: Check whether the condition of while statement contains an object creation.
most similar API: Check whether the while statement equals
cosine Similarity: 0.8226257562637329
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}


This checker is failed(false negative) on this negative test case:
```
// Instantiation in loop condition
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test1')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTWhileStatement
          ——ASTInfixExpression
            ——ASTMethodCall (called method name = 'length')
              ——ASTConstructorCall
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 0)
              ——ASTArgumentList (size = 0)
            ——ASTNumericLiteral
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "ok 1" failed不通过
77
63
=========================error_testcase_logics=========================
1. Get the loop statement in the method.
2. Get the body of the loop statement.
3. Check whether the body of the loop contains a constructor call.
4. If the body contains a constructor call, check whether the constructor call is within a throw statement.
5. If the body contains a constructor call that is not within a throw statement, then it's a violation of the rule.
6. If the body contains a constructor call within a throw statement, then it's not a violation of the rule.

In this test case:
- The loop statement is identified.
- The body of the loop contains a constructor call (`new Exception()`).
- The constructor call is within a throw statement (`throw new Exception();`).

Therefore, the number of violations of the rule in this test case is: 0
['Get the loop statement in the method.', 'Get the body of the loop statement.', 'Check whether the body of the loop contains a constructor call.', 'If the body contains a constructor call, check whether the constructor call is within a throw statement.', "If the body contains a constructor call that is not within a throw statement, then it's a violation of the rule.", "If the body contains a constructor call within a throw statement, then it's not a violation of the rule."]
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTThrowStatement', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTForStatement']
*Get the loop statement in the method.* 匹配到的元操作或API：
query: Get the loop statement in the method.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8049269914627075
*Get the body of the loop statement.* 匹配到的元操作或API：
query: Get the body of the loop statement.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.9237593412399292
*Check whether the body of the loop contains a constructor call.* 匹配到的元操作或API：
query: Check whether the body of the loop contains a constructor call.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8666519522666931
*If the body contains a constructor call, check whether the constructor call is within a throw statement.* 匹配到的元操作或API：
query: If the body contains a constructor call, check whether the constructor call is within a throw statement.
most similar API: Check whether the throw statement equals
cosine Similarity: 0.8316130638122559
*If the body contains a constructor call that is not within a throw statement, then it's a violation of the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the body contains a constructor call within a throw statement, then it's not a violation of the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}


This checker is failed(false positive) on this positive test case:
```
// throw new is OK
public class Foo {
    public void test1() {
        for(;;) {
            throw new Exception();
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test1')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTBlock
            ——ASTThrowStatement
              ——ASTConstructorCall
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTThrowStatement: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.filter(call -> !isInsideThrowStatement(call)).forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.filter(call -> !isInsideThrowStatement(call)).forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.filter(call -> !isInsideThrowStatement(call)).forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.filter(call -> !isInsideThrowStatement(call)).forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.filter(call -> !isInsideThrowStatement(call)).forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    private boolean isInsideThrowStatement(ASTConstructorCall call) {
        return call.getFirstParentOfType(ASTThrowStatement.class) != null;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 1" failed'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 1" failed不通过
=========================error_testcase_logics=========================
1. Get the body of the for loop.
2. Perform a check on all statements within the for loop's body to identify object creation.
3. Get the type of object created by constructor call.
4. Check whether the statement is a throw statement.
5. Get the expression in throw statement.
6. Get the type of exception thrown in throw statement.
7. Check whether the expression in throw statement is an object creation (i.e., a constructor call).

If the statement within the for loop's body is a throw statement and the expression in the throw statement is not an object creation (i.e., not a constructor call), then it does not violate the rule. In this test case, the throw statement is throwing an exception, which is an object creation, but since the rule explicitly states that `throw new` is OK, this test case does not violate the rule.
        
Since the throw statement in the loop is creating an exception object but is explicitly allowed by the rule, the number of violations is 0.
['Get the body of the for loop.', "Perform a check on all statements within the for loop's body to identify object creation.", 'Get the type of object created by constructor call.', 'Check whether the statement is a throw statement.', 'Get the expression in throw statement.', 'Get the type of exception thrown in throw statement.', 'Check whether the expression in throw statement is an object creation (i.e., a constructor call).']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTThrowStatement', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTForStatement']
*Get the body of the for loop.* 匹配到的元操作或API：
query: Get the body of the for loop.
most similar API: get body of for statement
cosine Similarity: 0.9058630466461182
*Perform a check on all statements within the for loop's body to identify object creation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the statement is a throw statement.* 匹配到的元操作或API：
query: Check whether the statement is a throw statement.
most similar API: Check whether the throw statement equals
cosine Similarity: 0.9275836944580078
*Get the expression in throw statement.* 匹配到的元操作或API：
logic: Get the expression in throw statement.
most similar meta operation: Get the expression in throw statement
cosine Similarity: 0.9904441833496094
*Get the type of exception thrown in throw statement.* 匹配到的元操作或API：
logic: Get the type of exception thrown in throw statement.
most similar meta operation: Get the type of exception thrown in throw statement
cosine Similarity: 0.9913609623908997
*Check whether the expression in throw statement is an object creation (i.e., a constructor call).* 匹配到的元操作或API：
query: Check whether the expression in throw statement is an object creation (i.e., a constructor call).
most similar API: Check whether the constructor call is expression
cosine Similarity: 0.8630031943321228
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}


This checker is failed(false positive) on this positive test case:
```
// throw new is OK
public class Foo {
    public void test1() {
        for(;;) {
            throw new Exception();
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test1')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTBlock
            ——ASTThrowStatement
              ——ASTConstructorCall
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
3. net.sourceforge.pmd.lang.java.ast.ASTThrowStatement: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTThrowStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getExpr()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.

1.  //Get the type of exception thrown in throw statement
```java
import net.sourceforge.pmd.lang.java.ast.ASTThrowStatement;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getThrownExceptionType(ASTThrowStatement node) {
    JTypeMirror thrownType = node.getExpr().getTypeMirror();
    return thrownType;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    private void checkConstructorCalls(ASTBlock block, Object data) {
        block.descendants(ASTLocalVariableDeclaration.class).forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls
                .filter(call -> !(call.getParent() instanceof ASTThrowStatement))
                .forEach(call -> addViolation(data, call));
        });
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.getParent() instanceof ASTForStatement) {
            checkConstructorCalls(node, data);
        } else if (node.getParent() instanceof ASTDoStatement) {
            checkConstructorCalls(node, data);
        } else if (node.getParent() instanceof ASTForeachStatement) {
            checkConstructorCalls(node, data);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 1" failed'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 1" failed不通过
=========================error_testcase_logics=========================
1. Check whether the method contains a loop statement.
2. If the method contains a loop statement, get the body of the loop statement.
3. Check whether the loop body contains a constructor call.
4. If the loop body contains a constructor call, get the type of object created by the constructor call.
5. Check whether the constructor call is within a throw statement.

Let's perform these checks step-by-step on the provided test case:

1. Check whether the method contains a loop statement.
   - The method `test1` contains a `for` loop.

2. If the method contains a loop statement, get the body of the loop statement.
   - The body of the `for` loop is `throw new Exception();`.

3. Check whether the loop body contains a constructor call.
   - The loop body contains a constructor call `new Exception()`.

4. If the loop body contains a constructor call, get the type of object created by the constructor call.
   - The type of object created by the constructor call is `Exception`.

5. Check whether the constructor call is within a throw statement.
   - The constructor call `new Exception()` is within a throw statement `throw new Exception();`.

Since the new object creation is within a throw statement, it does not violate the rule. Therefore, the number of violations is 0 as expected.
['Check whether the method contains a loop statement.', 'If the method contains a loop statement, get the body of the loop statement.', 'Check whether the loop body contains a constructor call.', 'If the loop body contains a constructor call, get the type of object created by the constructor call.', 'Check whether the constructor call is within a throw statement.', 'Check whether the method contains a loop statement.', 'If the method contains a loop statement, get the body of the loop statement.', 'Check whether the loop body contains a constructor call.', 'If the loop body contains a constructor call, get the type of object created by the constructor call.', 'Check whether the constructor call is within a throw statement.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTThrowStatement', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTForStatement']
*Check whether the method contains a loop statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the method contains a loop statement, get the body of the loop statement.* 匹配到的元操作或API：
query: If the method contains a loop statement, get the body of the loop statement.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8723873496055603
*Check whether the loop body contains a constructor call.* 匹配到的元操作或API：
query: Check whether the loop body contains a constructor call.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8537522554397583
*If the loop body contains a constructor call, get the type of object created by the constructor call.* 匹配到的元操作或API：
logic: If the loop body contains a constructor call, get the type of object created by the constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9072109460830688
*Check whether the constructor call is within a throw statement.* 匹配到的元操作或API：
query: Check whether the constructor call is within a throw statement.
most similar API: Check whether the throw statement equals
cosine Similarity: 0.8713610172271729
*Check whether the method contains a loop statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the method contains a loop statement, get the body of the loop statement.* 匹配到的元操作或API：
query: If the method contains a loop statement, get the body of the loop statement.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8723873496055603
*Check whether the loop body contains a constructor call.* 匹配到的元操作或API：
query: Check whether the loop body contains a constructor call.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8537522554397583
*If the loop body contains a constructor call, get the type of object created by the constructor call.* 匹配到的元操作或API：
logic: If the loop body contains a constructor call, get the type of object created by the constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9072109460830688
*Check whether the constructor call is within a throw statement.* 匹配到的元操作或API：
query: Check whether the constructor call is within a throw statement.
most similar API: Check whether the throw statement equals
cosine Similarity: 0.8713610172271729
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}


This checker is failed(false positive) on this positive test case:
```
// throw new is OK
public class Foo {
    public void test1() {
        for(;;) {
            throw new Exception();
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test1')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTBlock
            ——ASTThrowStatement
              ——ASTConstructorCall
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
4. net.sourceforge.pmd.lang.java.ast.ASTThrowStatement: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.filter(call -> !(call.getParent() instanceof ASTThrowStatement)).forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.filter(call -> !(call.getParent() instanceof ASTThrowStatement)).forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.filter(call -> !(call.getParent() instanceof ASTThrowStatement)).forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.filter(call -> !(call.getParent() instanceof ASTThrowStatement)).forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.filter(call -> !(call.getParent() instanceof ASTThrowStatement)).forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 1" failed'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 1" failed不通过
=========================error_testcase_logics=========================
1. Get the loop variable of for loop.
2. Get the body of for loop.
3. Check whether the body of for loop contains a constructor call.
4. Check the type of object created by constructor call.
5. Check whether the body of for loop contains a throw statement.
6. Get the expression in throw statement.
7. Check whether the expression in throw statement is a constructor call.

In this specific test case:
- Step 2 retrieves the body of the for loop, which contains a `throw new Exception();` statement.
- Step 5 confirms that there is indeed a throw statement in the body.
- Step 6 retrieves the expression in the throw statement, which is `new Exception()`.
- Step 7 confirms that the expression in the throw statement is a constructor call, which is allowed by the rule.

Therefore, the number of violations of the rule in this test case is: 0.
['Get the loop variable of for loop.', 'Get the body of for loop.', 'Check whether the body of for loop contains a constructor call.', 'Check the type of object created by constructor call.', 'Check whether the body of for loop contains a throw statement.', 'Get the expression in throw statement.', 'Check whether the expression in throw statement is a constructor call.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTThrowStatement', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTForStatement']
*Get the loop variable of for loop.* 匹配到的元操作或API：
logic: Get the loop variable of for loop.
most similar meta operation: Get a loop variable of for loop
cosine Similarity: 0.975679874420166
*Get the body of for loop.* 匹配到的元操作或API：
query: Get the body of for loop.
most similar API: get body of for statement
cosine Similarity: 0.9184505939483643
*Check whether the body of for loop contains a constructor call.* 匹配到的元操作或API：
query: Check whether the body of for loop contains a constructor call.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8580939173698425
*Check the type of object created by constructor call.* 匹配到的元操作或API：
logic: Check the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9449140429496765
*Check whether the body of for loop contains a throw statement.* 匹配到的元操作或API：
query: Check whether the body of for loop contains a throw statement.
most similar API: Check whether the throw statement equals
cosine Similarity: 0.8651082515716553
*Get the expression in throw statement.* 匹配到的元操作或API：
logic: Get the expression in throw statement.
most similar meta operation: Get the expression in throw statement
cosine Similarity: 0.9904441833496094
*Check whether the expression in throw statement is a constructor call.* 匹配到的元操作或API：
query: Check whether the expression in throw statement is a constructor call.
most similar API: Check whether the constructor call is expression
cosine Similarity: 0.9059643149375916
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}


This checker is failed(false positive) on this positive test case:
```
// throw new is OK
public class Foo {
    public void test1() {
        for(;;) {
            throw new Exception();
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test1')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTBlock
            ——ASTThrowStatement
              ——ASTConstructorCall
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public net.sourceforge.pmd.lang.ast.NodeStream<ASTVariableDeclaratorId> getLoopVariables(net.sourceforge.pmd.lang.java.ast.ASTForStatement)
2. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
5. net.sourceforge.pmd.lang.java.ast.ASTThrowStatement: public boolean equals(java.lang.Object)
6. net.sourceforge.pmd.lang.java.ast.ASTThrowStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getExpr()
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> {
                if (!isThrowExpression(call)) {
                    addViolation(data, call);
                }
            });
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> {
                    if (!isThrowExpression(call)) {
                        addViolation(data, call);
                    }
                });
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> {
                if (!isThrowExpression(call)) {
                    addViolation(data, call);
                }
            });
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> {
                if (!isThrowExpression(call)) {
                    addViolation(data, call);
                }
            });
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> {
                if (!isThrowExpression(call)) {
                    addViolation(data, call);
                }
            });
        });
        return super.visit(node, data);
    }

    private boolean isThrowExpression(ASTConstructorCall call) {
        ASTNode parent = call.getParent();
        return parent instanceof ASTThrowStatement;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the loop statement in the method.
2. Get the body of the loop statement.
3. Check whether the body of the loop contains a constructor call.
4. Get the type of object created by constructor call.
5. Check whether the called method is throw.
6. Get the return type of called method.
7. Check whether the return type of called method is Exception.

To ascertain whether the test case adheres to the rule, we'll perform the following checks:

1. Get the loop statement in the method `test1`.
2. Get the body of the loop statement.
3. Check whether the body of the loop contains a constructor call.
4. Get the type of object created by the constructor call.
5. Check whether the called method is `throw`.
6. Get the return type of the called method.
7. Check whether the return type of the called method is `Exception`.

In this test case, the loop body contains a method call (`throw new Exception()`), which does not create a new object in the traditional sense, so it does not violate the rule. Therefore, the number of violations in this test case is indeed 0.
['Get the loop statement in the method.', 'Get the body of the loop statement.', 'Check whether the body of the loop contains a constructor call.', 'Get the type of object created by constructor call.', 'Check whether the called method is throw.', 'Get the return type of called method.', 'Check whether the return type of called method is Exception.', 'Get the loop statement in the method `test1`.', 'Get the body of the loop statement.', 'Check whether the body of the loop contains a constructor call.', 'Get the type of object created by the constructor call.', 'Check whether the called method is `throw`.', 'Get the return type of the called method.', 'Check whether the return type of the called method is `Exception`.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTThrowStatement', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTForStatement']
*Get the loop statement in the method.* 匹配到的元操作或API：
query: Get the loop statement in the method.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8049269914627075
*Get the body of the loop statement.* 匹配到的元操作或API：
query: Get the body of the loop statement.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.9237593412399292
*Check whether the body of the loop contains a constructor call.* 匹配到的元操作或API：
query: Check whether the body of the loop contains a constructor call.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8666519522666931
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the called method is throw.* 匹配到的元操作或API：
query: Check whether the called method is throw.
most similar API: Check whether the throw statement equals
cosine Similarity: 0.8289461135864258
*Get the return type of called method.* 匹配到的元操作或API：
logic: Get the return type of called method.
most similar meta operation: Get the return type of called method
cosine Similarity: 0.983582615852356
*Check whether the return type of called method is Exception.* 匹配到的元操作或API：
logic: Check whether the return type of called method is Exception.
most similar meta operation: Check whether the return type of called method is string
cosine Similarity: 0.885635256767273
*Get the loop statement in the method `test1`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the loop statement.* 匹配到的元操作或API：
query: Get the body of the loop statement.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.9237593412399292
*Check whether the body of the loop contains a constructor call.* 匹配到的元操作或API：
query: Check whether the body of the loop contains a constructor call.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8666519522666931
*Get the type of object created by the constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by the constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.983032763004303
*Check whether the called method is `throw`.* 匹配到的元操作或API：
query: Check whether the called method is `throw`.
most similar API: Check whether the throw statement equals
cosine Similarity: 0.8555271625518799
*Get the return type of the called method.* 匹配到的元操作或API：
logic: Get the return type of the called method.
most similar meta operation: Get the return type of called method
cosine Similarity: 0.9767904877662659
*Check whether the return type of the called method is `Exception`.* 匹配到的元操作或API：
logic: Check whether the return type of the called method is `Exception`.
most similar meta operation: Check whether the return type of called method is string
cosine Similarity: 0.8729771375656128
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}


This checker is failed(false positive) on this positive test case:
```
// throw new is OK
public class Foo {
    public void test1() {
        for(;;) {
            throw new Exception();
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test1')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTBlock
            ——ASTThrowStatement
              ——ASTConstructorCall
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
4. net.sourceforge.pmd.lang.java.ast.ASTThrowStatement: public boolean equals(java.lang.Object)

1.  //Get the return type of called method
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.JMethodSig;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getReturnType(ASTMethodCall call) {
    JMethodSig m = call.getMethodType();
    return m.getReturnType();
}
```
2.  //Check whether the return type of called method is string
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.JMethodSig;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnStringType(ASTMethodCall call) {
    JMethodSig m = call.getMethodType();
    return TypeTestUtil.isA(String.class, m.getReturnType());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.filter(call -> !isThrowConstructorCall(call)).forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.filter(call -> !isThrowConstructorCall(call)).forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.filter(call -> !isThrowConstructorCall(call)).forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.filter(call -> !isThrowConstructorCall(call)).forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.filter(call -> !isThrowConstructorCall(call)).forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.filter(call -> !isThrowConstructorCall(call)).forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.filter(call -> !isThrowConstructorCall(call)).forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.filter(call -> !isThrowConstructorCall(call)).forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    private boolean isThrowConstructorCall(ASTConstructorCall call) {
        return call.getParent() instanceof ASTThrowStatement;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 1" failed'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 1" failed不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 1
[ERROR]   "ok 2" failed不通过
77
63
=========================error_testcase_logics=========================
1. Get the name of method.
2. Get the signature of method.
3. Get the body of method.
4. Identify all loop statements within the method body.
5. For each loop statement, identify all object creations (new keyword) within the loop body.
6. Check whether the object creation is a return statement.

In this specific test case:

1. Get the name of method -> Method name is `test1`.
2. Get the signature of method -> Method signature is `public String test1()`.
3. Get the body of method -> Method body contains a for loop with a return statement.
4. Identify all loop statements within the method body -> There is one for loop.
5. For each loop statement, identify all object creations (new keyword) within the loop body -> There is one object creation `new String()` within the for loop.
6. Check whether the object creation is a return statement -> The object creation `new String()` is part of a return statement.

Since the object creation within the loop is used in a return statement, it does not violate the rule as the new object is not being used or referenced further in the loop body. Therefore, the number of violations in this test case is indeed 0.
['Get the name of method.', 'Get the signature of method.', 'Get the body of method.', 'Identify all loop statements within the method body.', 'For each loop statement, identify all object creations (new keyword) within the loop body.', 'Check whether the object creation is a return statement.', 'Get the name of method -> Method name is `test1`.', 'Get the signature of method -> Method signature is `public String test1()`.', 'Get the body of method -> Method body contains a for loop with a return statement.', 'Identify all loop statements within the method body -> There is one for loop.', 'For each loop statement, identify all object creations (new keyword) within the loop body -> There is one object creation `new String()` within the for loop.', 'Check whether the object creation is a return statement -> The object creation `new String()` is part of a return statement.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTConstructorCall', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'ASTForStatement']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752806425094604
*Identify all loop statements within the method body.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each loop statement, identify all object creations (new keyword) within the loop body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the object creation is a return statement.* 匹配到的元操作或API：
query: Check whether the object creation is a return statement.
most similar API: Check whether the return statement equals
cosine Similarity: 0.8329678773880005
*Get the name of method -> Method name is `test1`.* 匹配到的元操作或API：
logic: Get the name of method -> Method name is `test1`.
most similar meta operation: Get the name of method
cosine Similarity: 0.8808637261390686
*Get the signature of method -> Method signature is `public String test1()`.* 匹配到的元操作或API：
logic: Get the signature of method -> Method signature is `public String test1()`.
most similar meta operation: Get the signature of method
cosine Similarity: 0.8925122618675232
*Get the body of method -> Method body contains a for loop with a return statement.* 匹配到的元操作或API：
query: Get the body of method -> Method body contains a for loop with a return statement.
most similar API: get body of method
cosine Similarity: 0.8737258315086365
*Identify all loop statements within the method body -> There is one for loop.* 匹配到的元操作或API：
query: Identify all loop statements within the method body -> There is one for loop.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8190109133720398
*For each loop statement, identify all object creations (new keyword) within the loop body -> There is one object creation `new String()` within the for loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the object creation is a return statement -> The object creation `new String()` is part of a return statement.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}


This checker is failed(false positive) on this positive test case:
```
// return new in loop is OK
public class Foo {
    public String test1() {
        for(;;) {
            return new String();
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test1')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTConstructorCall
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
4. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public boolean equals(java.lang.Object)
5. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    private boolean containsReturnWithNew(ASTStatement statement) {
        if (statement instanceof ASTBlock) {
            return ((ASTBlock) statement).descendants(ASTReturnStatement.class).anyMatch(this::returnStatementContainsNew);
        } else if (statement instanceof ASTReturnStatement) {
            return returnStatementContainsNew((ASTReturnStatement) statement);
        }
        return false;
    }

    private boolean returnStatementContainsNew(ASTReturnStatement returnStatement) {
        return returnStatement.jjtGetChild(0) instanceof ASTConstructorCall;
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        ASTStatement body = node.getBody();
        if (!containsReturnWithNew(body)) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = body.descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (!containsReturnWithNew(body)) {
            if (body instanceof ASTBlock) {
                NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
                localVariableDeclarations.forEach(declaration -> {
                    NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                    constructorCalls.forEach(call -> addViolation(data, call));
                });
            } else if (body instanceof ASTLocalVariableDeclaration) {
                NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            }
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        ASTStatement body = node.getBody();
        if (!containsReturnWithNew(body)) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = body.descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (!containsReturnWithNew(body)) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = body.descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the loop variable of for loop.
        2. Check whether the loop has a body.
        3. Get the body of the loop.
        4. Check whether the body contains an object creation within the loop.
        5. Get the type of object created by constructor call.
        6. Check whether the object creation is inside a return statement.

Given the test case:

1. Get the loop variable of for loop.
        - The loop variable is not explicitly declared (infinite loop `for(;;)`).

2. Check whether the loop has a body.
        - The loop has a body containing a `return` statement.

3. Get the body of the loop.
        - The body of the loop is the `return new String();` statement.

4. Check whether the body contains an object creation within the loop.
        - The body does contain an object creation (`new String()`).

5. Get the type of object created by constructor call.
        - The type of object created is `String`.

6. Check whether the object creation is inside a return statement.
        - The object creation is inside a `return` statement.

Since the object creation is inside a `return` statement, it does not violate the rule as per the provided description. Therefore, the number of violations in this test case is indeed 0.
['Get the loop variable of for loop.', 'Check whether the loop has a body.', 'Get the body of the loop.', 'Check whether the body contains an object creation within the loop.', 'Get the type of object created by constructor call.', 'Check whether the object creation is inside a return statement.', 'Get the loop variable of for loop.', 'Check whether the loop has a body.', 'Get the body of the loop.', 'Check whether the body contains an object creation within the loop.', 'Get the type of object created by constructor call.', 'Check whether the object creation is inside a return statement.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTConstructorCall', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'ASTForStatement']
*Get the loop variable of for loop.* 匹配到的元操作或API：
logic: Get the loop variable of for loop.
most similar meta operation: Get a loop variable of for loop
cosine Similarity: 0.975679874420166
*Check whether the loop has a body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the loop.* 匹配到的元操作或API：
query: Get the body of the loop.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8687449097633362
*Check whether the body contains an object creation within the loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the object creation is inside a return statement.* 匹配到的元操作或API：
query: Check whether the object creation is inside a return statement.
most similar API: Check whether the return statement equals
cosine Similarity: 0.8462252616882324
*Get the loop variable of for loop.* 匹配到的元操作或API：
logic: Get the loop variable of for loop.
most similar meta operation: Get a loop variable of for loop
cosine Similarity: 0.975679874420166
*Check whether the loop has a body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the loop.* 匹配到的元操作或API：
query: Get the body of the loop.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8687449097633362
*Check whether the body contains an object creation within the loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the object creation is inside a return statement.* 匹配到的元操作或API：
query: Check whether the object creation is inside a return statement.
most similar API: Check whether the return statement equals
cosine Similarity: 0.8462252616882324
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}


This checker is failed(false positive) on this positive test case:
```
// return new in loop is OK
public class Foo {
    public String test1() {
        for(;;) {
            return new String();
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test1')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTConstructorCall
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public net.sourceforge.pmd.lang.ast.NodeStream<ASTVariableDeclaratorId> getLoopVariables(net.sourceforge.pmd.lang.java.ast.ASTForStatement)
2. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
4. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> {
                if (!isInReturnStatement(call)) {
                    addViolation(data, call);
                }
            });
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> {
                if (!isInReturnStatement(call)) {
                    addViolation(data, call);
                }
            });
        });
        return super.visit(node, data);
    }

    private boolean isInReturnStatement(ASTConstructorCall call) {
        return call.getFirstParentOfType(ASTReturnStatement.class) != null;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 2" failed'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 2" failed不通过
=========================error_testcase_logics=========================
1. Get the name of the method.
2. Get the signature of the method.
3. Get the body of the method.
4. Check whether the method contains a for loop.
5. Get the statements inside the for loop.
6. Check whether any statement inside the for loop is an object creation (new keyword).
7. If a statement inside the for loop is an object creation, check whether it is a return statement.

Given the test case:
1. The name of the method is `test1`.
2. The signature of the method is `public String test1()`.
3. The body of the method includes a for loop and a return statement inside the for loop.
4. The method does contain a for loop.
5. The statements inside the for loop include `return new String()`.
6. The statement inside the for loop is an object creation (`new String()`).
7. The object creation is part of a return statement.

Since the object creation is within the loop but is part of a return statement, this does not violate the rule as per the provided description. Therefore, the number of violations in this test case is indeed 0.
['Get the name of the method.', 'Get the signature of the method.', 'Get the body of the method.', 'Check whether the method contains a for loop.', 'Get the statements inside the for loop.', 'Check whether any statement inside the for loop is an object creation (new keyword).', 'If a statement inside the for loop is an object creation, check whether it is a return statement.', 'The name of the method is `test1`.', 'The signature of the method is `public String test1()`.', 'The body of the method includes a for loop and a return statement inside the for loop.', 'The method does contain a for loop.', 'The statements inside the for loop include `return new String()`.', 'The statement inside the for loop is an object creation (`new String()`).', 'The object creation is part of a return statement.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTConstructorCall', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'ASTForStatement']
*Get the name of the method.* 匹配到的元操作或API：
logic: Get the name of the method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9713990092277527
*Get the signature of the method.* 匹配到的元操作或API：
logic: Get the signature of the method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9734326601028442
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Check whether the method contains a for loop.* 匹配到的元操作或API：
query: Check whether the method contains a for loop.
most similar API: Check whether the method equals
cosine Similarity: 0.8113793134689331
*Get the statements inside the for loop.* 匹配到的元操作或API：
query: Get the statements inside the for loop.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8594882488250732
*Check whether any statement inside the for loop is an object creation (new keyword).* 匹配到的元操作或API：
未匹配成功元操作或API
*If a statement inside the for loop is an object creation, check whether it is a return statement.* 匹配到的元操作或API：
query: If a statement inside the for loop is an object creation, check whether it is a return statement.
most similar API: Check whether the return statement equals
cosine Similarity: 0.8169234395027161
*The name of the method is `test1`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The signature of the method is `public String test1()`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The body of the method includes a for loop and a return statement inside the for loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method does contain a for loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*The statements inside the for loop include `return new String()`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The statement inside the for loop is an object creation (`new String()`).* 匹配到的元操作或API：
未匹配成功元操作或API
*The object creation is part of a return statement.* 匹配到的元操作或API：
query: The object creation is part of a return statement.
most similar API: children of return statement
cosine Similarity: 0.8003795146942139
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}


This checker is failed(false positive) on this positive test case:
```
// return new in loop is OK
public class Foo {
    public String test1() {
        for(;;) {
            return new String();
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test1')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTConstructorCall
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean equals(java.lang.Object)
5. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
6. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public boolean equals(java.lang.Object)
7. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<N> children()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTStatement statement = node.getFirstParentOfType(ASTStatement.class);
        if (statement instanceof ASTLocalVariableDeclaration || !(statement.getFirstParentOfType(ASTReturnStatement.class) != null)) {
            ASTStatement loopBody = statement.getFirstParentOfType(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class).getBody();
            if (!(loopBody instanceof ASTBlock && loopBody.getFirstDescendantOfType(ASTReturnStatement.class) != null)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Check whether the class has extended any class.
2. Check whether the class has implemented any interfaces.
3. Get all methods declared in the class.
4. Get the method name of the declared method.
5. Get the method body of the declared method.
6. Check whether the method body contains any loop statements.
7. Get the loop statement from the method body.
8. Check whether the loop statement contains any object creation (new keyword).
9. If the object creation is within the loop, check whether it is a return statement.
10. If the object creation is within the loop and is not a return statement, then it violates the rule.

For the given test case:
1. Check whether the class has extended any class.
        - Foo does not extend any class other than Object, which is default and not explicitly declared, so this check passes.
2. Check whether the class has implemented any interfaces.
        - Foo does not implement any interfaces, so this check passes.
3. Get all methods declared in the class.
        - The method `test1()` is declared in the class.
4. Get the method name of the declared method.
        - The method name is `test1`.
5. Get the method body of the declared method.
        - The method body contains a for loop and a return statement.
6. Check whether the method body contains any loop statements.
        - The method body contains a for loop, so this check passes.
7. Get the loop statement from the method body.
        - The loop statement is `for(;;)`.
8. Check whether the loop statement contains any object creation (new keyword).
        - The loop statement contains `new String()`, so this check passes.
9. If the object creation is within the loop, check whether it is a return statement.
        - `new String()` is within the loop and is part of a return statement, so this check passes.
10. If the object creation is within the loop and is not a return statement, then it violates the rule.
        - Since `new String()` is part of a return statement and not assigned to any variable, it does not violate the rule.

The number of violating the rule in this test case is: 0
['Check whether the class has extended any class.', 'Check whether the class has implemented any interfaces.', 'Get all methods declared in the class.', 'Get the method name of the declared method.', 'Get the method body of the declared method.', 'Check whether the method body contains any loop statements.', 'Get the loop statement from the method body.', 'Check whether the loop statement contains any object creation (new keyword).', 'If the object creation is within the loop, check whether it is a return statement.', 'If the object creation is within the loop and is not a return statement, then it violates the rule.', 'Check whether the class has extended any class.', 'Check whether the class has implemented any interfaces.', 'Get all methods declared in the class.', 'Get the method name of the declared method.', 'Get the method body of the declared method.', 'Check whether the method body contains any loop statements.', 'Get the loop statement from the method body.', 'Check whether the loop statement contains any object creation (new keyword).', 'If the object creation is within the loop, check whether it is a return statement.', 'If the object creation is within the loop and is not a return statement, then it violates the rule.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTConstructorCall', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'ASTForStatement']
*Check whether the class has extended any class.* 匹配到的元操作或API：
logic: Check whether the class has extended any class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.899549126625061
*Check whether the class has implemented any interfaces.* 匹配到的元操作或API：
logic: Check whether the class has implemented any interfaces.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.8998100161552429
*Get all methods declared in the class.* 匹配到的元操作或API：
query: Get all methods declared in the class.
most similar API: get declared annotations of method
cosine Similarity: 0.837310254573822
*Get the method name of the declared method.* 匹配到的元操作或API：
logic: Get the method name of the declared method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9164146184921265
*Get the method body of the declared method.* 匹配到的元操作或API：
logic: Get the method body of the declared method.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.854401707649231
*Check whether the method body contains any loop statements.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop statement from the method body.* 匹配到的元操作或API：
query: Get the loop statement from the method body.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.858727216720581
*Check whether the loop statement contains any object creation (new keyword).* 匹配到的元操作或API：
未匹配成功元操作或API
*If the object creation is within the loop, check whether it is a return statement.* 匹配到的元操作或API：
query: If the object creation is within the loop, check whether it is a return statement.
most similar API: Check whether the return statement equals
cosine Similarity: 0.8317408561706543
*If the object creation is within the loop and is not a return statement, then it violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has extended any class.* 匹配到的元操作或API：
logic: Check whether the class has extended any class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.899549126625061
*Check whether the class has implemented any interfaces.* 匹配到的元操作或API：
logic: Check whether the class has implemented any interfaces.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.8998100161552429
*Get all methods declared in the class.* 匹配到的元操作或API：
query: Get all methods declared in the class.
most similar API: get declared annotations of method
cosine Similarity: 0.837310254573822
*Get the method name of the declared method.* 匹配到的元操作或API：
logic: Get the method name of the declared method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9164146184921265
*Get the method body of the declared method.* 匹配到的元操作或API：
logic: Get the method body of the declared method.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.854401707649231
*Check whether the method body contains any loop statements.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop statement from the method body.* 匹配到的元操作或API：
query: Get the loop statement from the method body.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.858727216720581
*Check whether the loop statement contains any object creation (new keyword).* 匹配到的元操作或API：
未匹配成功元操作或API
*If the object creation is within the loop, check whether it is a return statement.* 匹配到的元操作或API：
query: If the object creation is within the loop, check whether it is a return statement.
most similar API: Check whether the return statement equals
cosine Similarity: 0.8317408561706543
*If the object creation is within the loop and is not a return statement, then it violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}


This checker is failed(false positive) on this positive test case:
```
// return new in loop is OK
public class Foo {
    public String test1() {
        for(;;) {
            return new String();
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test1')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTConstructorCall
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
3. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
4. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public boolean equals(java.lang.Object)

1.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```
2.  //Check whether the class has implemented x interface
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node) {
    if (TypeTestUtil.isA(interfaceName.class, node)) {
        return true;
    }
    return false;
}
```
3.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        NodeStream<ASTStatement> statements = node.children(ASTStatement.class);
        statements.forEach(statement -> {
            if (statement instanceof ASTReturnStatement) {
                ASTReturnStatement returnStatement = (ASTReturnStatement) statement;
                if (returnStatement.getExpression() != null) {
                    NodeStream<ASTConstructorCall> constructorCalls = returnStatement.getExpression().descendants(ASTConstructorCall.class);
                    constructorCalls.forEach(call -> addViolation(data, call));
                }
            }
        });
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all loop statements within the class.
3. Check whether the loop statement is a for loop.
4. Get the body of the for loop.
5. Check whether the body of the for loop contains a constructor call.
6. Get the name of called method.
7. Check whether the name is a constructor (i.e., matches the class name or is a new instance creation).
8. Get the number of constructor calls within the loop body.
9. Check whether the loop statement is a while statement.
10. Get the body of the while loop.
11. Check whether the body of the while loop contains a constructor call.
12. Get the name of called method.
13. Check whether the name is a constructor (i.e., matches the class name or is a new instance creation).
14. Get the number of constructor calls within the while loop body.
15. Check whether the loop statement is a do-while statement.
16. Get the body of the do-while loop.
17. Check whether the body of the do-while loop contains a constructor call.
18. Get the name of called method.
19. Check whether the name is a constructor (i.e., matches the class name or is a new instance creation).
20. Get the number of constructor calls within the do-while loop body.

For the given test case:

1. Get the name of class. (Class name is Foo)
2. Get all loop statements within the class. (There is one for loop)
3. Check whether the loop statement is a for loop. (Yes)
4. Get the body of the for loop. (Body contains a return statement)
5. Check whether the body of the for loop contains a constructor call. (Yes, return new String() is a constructor call)
6. Get the name of called method. (Constructor name is String)
7. Check whether the name is a constructor (i.e., matches the class name or is a new instance creation). (Yes)
8. Get the number of constructor calls within the loop body. (1)

However, the rule specifically states that creating new objects within loops is avoided, but returning a new object from a loop (specifically a return statement) is not counted as creating a new object within the loop body. Therefore, the test case does not violate the rule.

1. Get the number of violating the rule in this test case. (0)
['Get the name of class.', 'Get all loop statements within the class.', 'Check whether the loop statement is a for loop.', 'Get the body of the for loop.', 'Check whether the body of the for loop contains a constructor call.', 'Get the name of called method.', 'Check whether the name is a constructor (i.e., matches the class name or is a new instance creation).', 'Get the number of constructor calls within the loop body.', 'Check whether the loop statement is a while statement.', 'Get the body of the while loop.', 'Check whether the body of the while loop contains a constructor call.', 'Get the name of called method.', 'Check whether the name is a constructor (i.e., matches the class name or is a new instance creation).', 'Get the number of constructor calls within the while loop body.', 'Check whether the loop statement is a do-while statement.', 'Get the body of the do-while loop.', 'Check whether the body of the do-while loop contains a constructor call.', 'Get the name of called method.', 'Check whether the name is a constructor (i.e., matches the class name or is a new instance creation).', 'Get the number of constructor calls within the do-while loop body.', 'Get the name of class. (Class name is Foo)', 'Get all loop statements within the class. (There is one for loop)', 'Check whether the loop statement is a for loop. (Yes)', 'Get the body of the for loop. (Body contains a return statement)', 'Check whether the body of the for loop contains a constructor call. (Yes, return new String() is a constructor call)', 'Get the name of called method. (Constructor name is String)', 'Check whether the name is a constructor (i.e., matches the class name or is a new instance creation). (Yes)', 'Get the number of constructor calls within the loop body. (1)', 'Get the number of violating the rule in this test case. (0)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTConstructorCall', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'ASTForStatement']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all loop statements within the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the loop statement is a for loop.* 匹配到的元操作或API：
query: Check whether the loop statement is a for loop.
most similar API: Check whether the for statement equals
cosine Similarity: 0.8447393178939819
*Get the body of the for loop.* 匹配到的元操作或API：
query: Get the body of the for loop.
most similar API: get body of for statement
cosine Similarity: 0.9058630466461182
*Check whether the body of the for loop contains a constructor call.* 匹配到的元操作或API：
query: Check whether the body of the for loop contains a constructor call.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8616231679916382
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the name is a constructor (i.e., matches the class name or is a new instance creation).* 匹配到的元操作或API：
query: Check whether the name is a constructor (i.e., matches the class name or is a new instance creation).
most similar API: Check whether the constructor call is qualified instance creation
cosine Similarity: 0.8267571926116943
*Get the number of constructor calls within the loop body.* 匹配到的元操作或API：
query: Get the number of constructor calls within the loop body.
most similar API: get num children of constructor call
cosine Similarity: 0.8328583836555481
*Check whether the loop statement is a while statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the while loop.* 匹配到的元操作或API：
query: Get the body of the while loop.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.817240297794342
*Check whether the body of the while loop contains a constructor call.* 匹配到的元操作或API：
query: Check whether the body of the while loop contains a constructor call.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8647770881652832
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the name is a constructor (i.e., matches the class name or is a new instance creation).* 匹配到的元操作或API：
query: Check whether the name is a constructor (i.e., matches the class name or is a new instance creation).
most similar API: Check whether the constructor call is qualified instance creation
cosine Similarity: 0.8267571926116943
*Get the number of constructor calls within the while loop body.* 匹配到的元操作或API：
query: Get the number of constructor calls within the while loop body.
most similar API: get num children of constructor call
cosine Similarity: 0.8368421792984009
*Check whether the loop statement is a do-while statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the do-while loop.* 匹配到的元操作或API：
query: Get the body of the do-while loop.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8215391039848328
*Check whether the body of the do-while loop contains a constructor call.* 匹配到的元操作或API：
query: Check whether the body of the do-while loop contains a constructor call.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.860209584236145
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the name is a constructor (i.e., matches the class name or is a new instance creation).* 匹配到的元操作或API：
query: Check whether the name is a constructor (i.e., matches the class name or is a new instance creation).
most similar API: Check whether the constructor call is qualified instance creation
cosine Similarity: 0.8267571926116943
*Get the number of constructor calls within the do-while loop body.* 匹配到的元操作或API：
query: Get the number of constructor calls within the do-while loop body.
most similar API: get num children of constructor call
cosine Similarity: 0.8342083096504211
*Get the name of class. (Class name is Foo)* 匹配到的元操作或API：
logic: Get the name of class. (Class name is Foo)
most similar meta operation: Get the name of class
cosine Similarity: 0.9266812205314636
*Get all loop statements within the class. (There is one for loop)* 匹配到的元操作或API：
query: Get all loop statements within the class. (There is one for loop)
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8012701272964478
*Check whether the loop statement is a for loop. (Yes)* 匹配到的元操作或API：
query: Check whether the loop statement is a for loop. (Yes)
most similar API: Check whether the for statement equals
cosine Similarity: 0.8469074964523315
*Get the body of the for loop. (Body contains a return statement)* 匹配到的元操作或API：
query: Get the body of the for loop. (Body contains a return statement)
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.9012265801429749
*Check whether the body of the for loop contains a constructor call. (Yes, return new String() is a constructor call)* 匹配到的元操作或API：
query: Check whether the body of the for loop contains a constructor call. (Yes, return new String() is a constructor call)
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8215075731277466
*Get the name of called method. (Constructor name is String)* 匹配到的元操作或API：
logic: Get the name of called method. (Constructor name is String)
most similar meta operation: Get the name of called method
cosine Similarity: 0.9052836894989014
*Check whether the name is a constructor (i.e., matches the class name or is a new instance creation). (Yes)* 匹配到的元操作或API：
query: Check whether the name is a constructor (i.e., matches the class name or is a new instance creation). (Yes)
most similar API: Check whether the constructor call is qualified instance creation
cosine Similarity: 0.8203124403953552
*Get the number of constructor calls within the loop body. (1)* 匹配到的元操作或API：
query: Get the number of constructor calls within the loop body. (1)
most similar API: get num children of constructor call
cosine Similarity: 0.844455897808075
*Get the number of violating the rule in this test case. (0)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}


This checker is failed(false positive) on this positive test case:
```
// return new in loop is OK
public class Foo {
    public String test1() {
        for(;;) {
            return new String();
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test1')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTConstructorCall
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean equals(java.lang.Object)
5. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isQualifiedInstanceCreation(), //Returns true if this expression begins with a primary expression. Such an expression creates an instance of inner member classes and their anonymous subclasses. For example, {@code new Outer().new Inner()} evaluates to an instance of the Inner class, which is nested inside the new instance of Outer.
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public int getNumChildren()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> {
                if (!isInReturnStatement(call)) {
                    addViolation(data, call);
                }
            });
        });
        return super.visit(node, data);
    }

    private boolean isInReturnStatement(ASTConstructorCall call) {
        return call.getFirstParentOfType(ASTReturnStatement.class) != null;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 2" failed'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 2" failed不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 2
[ERROR]   "bad 7" failed不通过
156
136
=========================error_testcase_logics=========================
1. Get the method declaration from method call.
        2. Get the body of the method.
        3. Locate all for loops within the method body.
        4. Get the loop body of each for loop.
        5. Locate all object creation within the loop body.
        6. Check whether the object creation is within an anonymous class declaration.
        7. Get the methods within the anonymous class.
        8. Locate all for loops within the methods of the anonymous class.
        9. Get the loop body of each for loop in the anonymous class.
        10. Locate all object creation within the loop body of the anonymous class.
        11. Check whether the object creation is within a loop.

Based on the test case provided, the steps would be:

1. Get the method declaration from method call `baz`.
        2. Get the body of the method `baz`.
        3. Locate all for loops within the method body of `baz`.
        4. Get the loop body of each for loop in the method body of `baz`.
        5. Locate all object creation within the loop body of the method `baz`.
        6. Check whether the object creation `String a = new String();` is within an anonymous class declaration. (False, it's in a named inner class)
        7. Get the methods within the inner class `Inner`.
        8. Locate all for loops within the methods of the inner class `Inner`.
        9. Get the loop body of each for loop in the inner class `Inner`.
        10. Locate all object creation within the loop body of the inner class `Inner`.
        11. Check whether the object creation `String a = new String();` is within a loop. (True, it's in a loop in `baz`)

1. Get the method declaration from method call `foo`.
        2. Get the body of the method `foo`.
        3. Locate all for loops within the method body of `foo`.
        4. Get the loop body of each for loop in the method body of `foo`.
        5. Locate all object creation within the loop body of the method `foo`.
        6. Check whether the object creation `String a = new String();` is within an anonymous class declaration. (False, it's in an anonymous class)
        7. Get the methods within the anonymous class.
        8. Locate all for loops within the methods of the anonymous class.
        9. Get the loop body of each for loop in the anonymous class.
        10. Locate all object creation within the loop body of the anonymous class.
        11. Check whether the object creation `String a = new String();` is within a loop. (True, it's in a loop in `bar`)

The number of violations is 2 as there are two object creations within loops in the provided test case.
['Get the method declaration from method call.', 'Get the body of the method.', 'Locate all for loops within the method body.', 'Get the loop body of each for loop.', 'Locate all object creation within the loop body.', 'Check whether the object creation is within an anonymous class declaration.', 'Get the methods within the anonymous class.', 'Locate all for loops within the methods of the anonymous class.', 'Get the loop body of each for loop in the anonymous class.', 'Locate all object creation within the loop body of the anonymous class.', 'Check whether the object creation is within a loop.', 'Get the method declaration from method call `baz`.', 'Get the body of the method `baz`.', 'Locate all for loops within the method body of `baz`.', 'Get the loop body of each for loop in the method body of `baz`.', 'Locate all object creation within the loop body of the method `baz`.', "Check whether the object creation `String a = new String();` is within an anonymous class declaration. (False, it's in a named inner class)", 'Get the methods within the inner class `Inner`.', 'Locate all for loops within the methods of the inner class `Inner`.', 'Get the loop body of each for loop in the inner class `Inner`.', 'Locate all object creation within the loop body of the inner class `Inner`.', "Check whether the object creation `String a = new String();` is within a loop. (True, it's in a loop in `baz`)", 'Get the method declaration from method call `foo`.', 'Get the body of the method `foo`.', 'Locate all for loops within the method body of `foo`.', 'Get the loop body of each for loop in the method body of `foo`.', 'Locate all object creation within the loop body of the method `foo`.', "Check whether the object creation `String a = new String();` is within an anonymous class declaration. (False, it's in an anonymous class)", 'Get the methods within the anonymous class.', 'Locate all for loops within the methods of the anonymous class.', 'Get the loop body of each for loop in the anonymous class.', 'Locate all object creation within the loop body of the anonymous class.', "Check whether the object creation `String a = new String();` is within a loop. (True, it's in a loop in `bar`)"]
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTVariableDeclarator', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTAnonymousClassDeclaration', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTForStatement']
*Get the method declaration from method call.* 匹配到的元操作或API：
logic: Get the method declaration from method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9787436127662659
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Locate all for loops within the method body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop body of each for loop.* 匹配到的元操作或API：
query: Get the loop body of each for loop.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8853704929351807
*Locate all object creation within the loop body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the object creation is within an anonymous class declaration.* 匹配到的元操作或API：
logic: Check whether the object creation is within an anonymous class declaration.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.8696296215057373
*Get the methods within the anonymous class.* 匹配到的元操作或API：
query: Get the methods within the anonymous class.
most similar API: get operations of anonymous class
cosine Similarity: 0.8641552925109863
*Locate all for loops within the methods of the anonymous class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop body of each for loop in the anonymous class.* 匹配到的元操作或API：
query: Get the loop body of each for loop in the anonymous class.
most similar API: get body of anonymous class
cosine Similarity: 0.8609646558761597
*Locate all object creation within the loop body of the anonymous class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the object creation is within a loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the method declaration from method call `baz`.* 匹配到的元操作或API：
logic: Get the method declaration from method call `baz`.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.8856160640716553
*Get the body of the method `baz`.* 匹配到的元操作或API：
query: Get the body of the method `baz`.
most similar API: get body of method
cosine Similarity: 0.8301869034767151
*Locate all for loops within the method body of `baz`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop body of each for loop in the method body of `baz`.* 匹配到的元操作或API：
query: Get the loop body of each for loop in the method body of `baz`.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8543773293495178
*Locate all object creation within the loop body of the method `baz`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the object creation `String a = new String();` is within an anonymous class declaration. (False, it's in a named inner class)* 匹配到的元操作或API：
query: Check whether the object creation `String a = new String();` is within an anonymous class declaration. (False, it's in a named inner class)
most similar API: Check whether is anonymous class creation
cosine Similarity: 0.8377068042755127
*Get the methods within the inner class `Inner`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Locate all for loops within the methods of the inner class `Inner`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop body of each for loop in the inner class `Inner`.* 匹配到的元操作或API：
query: Get the loop body of each for loop in the inner class `Inner`.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8309459090232849
*Locate all object creation within the loop body of the inner class `Inner`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the object creation `String a = new String();` is within a loop. (True, it's in a loop in `baz`)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the method declaration from method call `foo`.* 匹配到的元操作或API：
logic: Get the method declaration from method call `foo`.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9304693341255188
*Get the body of the method `foo`.* 匹配到的元操作或API：
query: Get the body of the method `foo`.
most similar API: get body of method
cosine Similarity: 0.9110667705535889
*Locate all for loops within the method body of `foo`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop body of each for loop in the method body of `foo`.* 匹配到的元操作或API：
query: Get the loop body of each for loop in the method body of `foo`.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8722696304321289
*Locate all object creation within the loop body of the method `foo`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the object creation `String a = new String();` is within an anonymous class declaration. (False, it's in an anonymous class)* 匹配到的元操作或API：
query: Check whether the object creation `String a = new String();` is within an anonymous class declaration. (False, it's in an anonymous class)
most similar API: Check whether is anonymous class creation
cosine Similarity: 0.8480482697486877
*Get the methods within the anonymous class.* 匹配到的元操作或API：
query: Get the methods within the anonymous class.
most similar API: get operations of anonymous class
cosine Similarity: 0.8641552925109863
*Locate all for loops within the methods of the anonymous class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop body of each for loop in the anonymous class.* 匹配到的元操作或API：
query: Get the loop body of each for loop in the anonymous class.
most similar API: get body of anonymous class
cosine Similarity: 0.8609646558761597
*Locate all object creation within the loop body of the anonymous class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the object creation `String a = new String();` is within a loop. (True, it's in a loop in `bar`)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}


This checker is failed(false negative) on this negative test case:
```
// false negative in anonymous classes
public class Sample {
    private static class Inner {
        private void baz() {
            for(;;) {
                String a = new String();
            }
        }
    }

    public void foo() {
        Sample anonymousClass = new Sample() {
            void bar() {
                for(;;) {
                    String a = new String();
                }
            }
        };
    }
}
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Sample')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Inner')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'baz')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
            ——ASTForStatement
              ——ASTBlock
                ——ASTLocalVariableDeclaration
                  ——ASTModifierList
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTVariableDeclarator
                    ——ASTVariableDeclaratorId (declared variable name = 'a')
                    ——ASTConstructorCall
                      ——ASTClassOrInterfaceType (this is a class type)
                      ——ASTArgumentList (size = 0)
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'anonymousClass')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 0)
              ——ASTAnonymousClassDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceBody
                  ——ASTMethodDeclaration (method name = 'bar')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 0)
                    ——ASTBlock
                      ——ASTForStatement
                        ——ASTBlock
                          ——ASTLocalVariableDeclaration
                            ——ASTModifierList
                            ——ASTClassOrInterfaceType (this is a class type)
                            ——ASTVariableDeclarator
                              ——ASTVariableDeclaratorId (declared variable name = 'a')
                              ——ASTConstructorCall
                                ——ASTClassOrInterfaceType (this is a class type)
                                ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
2. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnonymous()
4. net.sourceforge.pmd.lang.java.ast.ASTAnonymousClassDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTMethodOrConstructorDeclaration> getOperations(), //Returns the operations declared in this class (methods and constructors).
5. net.sourceforge.pmd.lang.java.ast.ASTAnonymousClassDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTTypeBody getBody(), //Returns the body of this type declaration.
6. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isAnonymousClassCreation(net.sourceforge.pmd.lang.java.ast.ASTExpression)

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class, ASTAnonymousClassDeclaration.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTAnonymousClassDeclaration node, Object data) {
        if (node.isAnonymous()) {
            node.getBody().descendants(ASTForStatement.class).forEach(this::checkForLoop);
            node.getBody().descendants(ASTWhileStatement.class).forEach(this::checkWhileLoop);
            node.getBody().descendants(ASTDoStatement.class).forEach(this::checkDoLoop);
            node.getBody().descendants(ASTForeachStatement.class).forEach(this::checkForEachLoop);
        }
        return super.visit(node, data);
    }

    private void checkForLoop(ASTForStatement node) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(call));
        });
    }

    private void checkWhileLoop(ASTWhileStatement node) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(call));
        });
    }

    private void checkDoLoop(ASTDoStatement node) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(call));
        }
    }

    private void checkForEachLoop(ASTForeachStatement node) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(call));
        });
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To granularly check the adherence of the given test case to the rule "New objects can not be created within loops," we will perform the following checks:

1. Get the class declaration of Sample.
2. Check whether the class has inner classes.
3. Get the inner class declaration named Inner.
4. Get all methods declared in the Inner class.
5. Get the method declaration named baz.
6. Get all statements in the baz method.
7. Check whether a statement is a loop statement.
8. Get all statements within the loop statement in baz.
9. Check whether a statement within the loop is an object creation (constructor call).
10. Get the type of object created by the constructor call within the loop in baz.
11. Get the class declaration of Sample.
12. Get all methods declared in the Sample class.
13. Get the method declaration named foo.
14. Get all statements in the foo method.
15. Check whether a statement is an object creation (constructor call).
16. Check whether the created object is an anonymous class.
17. Get the method declarations within the anonymous class.
18. Get the method declaration named bar.
19. Get all statements in the bar method.
20. Check whether a statement is a loop statement.
21. Get all statements within the loop statement in bar.
22. Check whether a statement within the loop is an object creation (constructor call).
23. Get the type of object created by the constructor call within the loop in bar.

By performing these granular checks, we can identify whether new objects are being created within loops in both the `baz` method of the `Inner` class and the `bar` method of the anonymous class.

Let's perform these checks for the given test case:

1. Get the class declaration of Sample.
2. Check whether the class has inner classes. -> True (Inner class is present)
3. Get the inner class declaration named Inner.
4. Get all methods declared in the Inner class. -> baz method is present
5. Get the method declaration named baz.
6. Get all statements in the baz method. -> for loop and String creation is present
7. Check whether a statement is a loop statement. -> True (for(;;) is a loop)
8. Get all statements within the loop statement in baz. -> String creation is present
9. Check whether a statement within the loop is an object creation (constructor call). -> True (String a = new String();)
10. Get the type of object created by the constructor call within the loop in baz. -> String
11. Get the class declaration of Sample.
12. Get all methods declared in the Sample class. -> foo method is present
13. Get the method declaration named foo.
14. Get all statements in the foo method. -> Object creation of anonymous class and method bar is present
15. Check whether a statement is an object creation (constructor call). -> True (Sample anonymousClass = new Sample() {...})
16. Check whether the created object is an anonymous class. -> True (new Sample() {...} is an anonymous class)
17. Get the method declarations within the anonymous class. -> bar method is present
18. Get the method declaration named bar.
19. Get all statements in the bar method. -> for loop and String creation is present
20. Check whether a statement is a loop statement. -> True (for(;;) is a loop)
21. Get all statements within the loop statement in bar. -> String creation is present
22. Check whether a statement within the loop is an object creation (constructor call). -> True (String a = new String();)
23. Get the type of object created by the constructor call within the loop in bar. -> String

Based on these checks, we can confirm that there are indeed two violations of the rule: one within the `baz` method of the `Inner` class and another within the `bar` method of the anonymous class.
['Get the class declaration of Sample.', 'Check whether the class has inner classes.', 'Get the inner class declaration named Inner.', 'Get all methods declared in the Inner class.', 'Get the method declaration named baz.', 'Get all statements in the baz method.', 'Check whether a statement is a loop statement.', 'Get all statements within the loop statement in baz.', 'Check whether a statement within the loop is an object creation (constructor call).', 'Get the type of object created by the constructor call within the loop in baz.', 'Get the class declaration of Sample.', 'Get all methods declared in the Sample class.', 'Get the method declaration named foo.', 'Get all statements in the foo method.', 'Check whether a statement is an object creation (constructor call).', 'Check whether the created object is an anonymous class.', 'Get the method declarations within the anonymous class.', 'Get the method declaration named bar.', 'Get all statements in the bar method.', 'Check whether a statement is a loop statement.', 'Get all statements within the loop statement in bar.', 'Check whether a statement within the loop is an object creation (constructor call).', 'Get the type of object created by the constructor call within the loop in bar.', 'Get the class declaration of Sample.', 'Check whether the class has inner classes. -> True (Inner class is present)', 'Get the inner class declaration named Inner.', 'Get all methods declared in the Inner class. -> baz method is present', 'Get the method declaration named baz.', 'Get all statements in the baz method. -> for loop and String creation is present', 'Check whether a statement is a loop statement. -> True (for(;;) is a loop)', 'Get all statements within the loop statement in baz. -> String creation is present', 'Check whether a statement within the loop is an object creation (constructor call). -> True (String a = new String();)', 'Get the type of object created by the constructor call within the loop in baz. -> String', 'Get the class declaration of Sample.', 'Get all methods declared in the Sample class. -> foo method is present', 'Get the method declaration named foo.', 'Get all statements in the foo method. -> Object creation of anonymous class and method bar is present', 'Check whether a statement is an object creation (constructor call). -> True (Sample anonymousClass = new Sample() {...})', 'Check whether the created object is an anonymous class. -> True (new Sample() {...} is an anonymous class)', 'Get the method declarations within the anonymous class. -> bar method is present', 'Get the method declaration named bar.', 'Get all statements in the bar method. -> for loop and String creation is present', 'Check whether a statement is a loop statement. -> True (for(;;) is a loop)', 'Get all statements within the loop statement in bar. -> String creation is present', 'Check whether a statement within the loop is an object creation (constructor call). -> True (String a = new String();)', 'Get the type of object created by the constructor call within the loop in bar. -> String']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTVariableDeclarator', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTAnonymousClassDeclaration', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTForStatement']
*Get the class declaration of Sample.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has inner classes.* 匹配到的元操作或API：
logic: Check whether the class has inner classes.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9536193609237671
*Get the inner class declaration named Inner.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all methods declared in the Inner class.* 匹配到的元操作或API：
query: Get all methods declared in the Inner class.
most similar API: get declared annotations of method
cosine Similarity: 0.8091904520988464
*Get the method declaration named baz.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all statements in the baz method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether a statement is a loop statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all statements within the loop statement in baz.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether a statement within the loop is an object creation (constructor call).* 匹配到的元操作或API：
query: Check whether a statement within the loop is an object creation (constructor call).
most similar API: Check whether the constructor call is qualified instance creation
cosine Similarity: 0.8348720669746399
*Get the type of object created by the constructor call within the loop in baz.* 匹配到的元操作或API：
logic: Get the type of object created by the constructor call within the loop in baz.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9057597517967224
*Get the class declaration of Sample.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all methods declared in the Sample class.* 匹配到的元操作或API：
query: Get all methods declared in the Sample class.
most similar API: get declared annotations of method
cosine Similarity: 0.8130830526351929
*Get the method declaration named foo.* 匹配到的元操作或API：
logic: Get the method declaration named foo.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.8857018351554871
*Get all statements in the foo method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether a statement is an object creation (constructor call).* 匹配到的元操作或API：
query: Check whether a statement is an object creation (constructor call).
most similar API: Check whether the constructor call is qualified instance creation
cosine Similarity: 0.8514916896820068
*Check whether the created object is an anonymous class.* 匹配到的元操作或API：
logic: Check whether the created object is an anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9379844665527344
*Get the method declarations within the anonymous class.* 匹配到的元操作或API：
logic: Get the method declarations within the anonymous class.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.8530774712562561
*Get the method declaration named bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all statements in the bar method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether a statement is a loop statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all statements within the loop statement in bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether a statement within the loop is an object creation (constructor call).* 匹配到的元操作或API：
query: Check whether a statement within the loop is an object creation (constructor call).
most similar API: Check whether the constructor call is qualified instance creation
cosine Similarity: 0.8348720669746399
*Get the type of object created by the constructor call within the loop in bar.* 匹配到的元操作或API：
logic: Get the type of object created by the constructor call within the loop in bar.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9122259616851807
*Get the class declaration of Sample.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has inner classes. -> True (Inner class is present)* 匹配到的元操作或API：
logic: Check whether the class has inner classes. -> True (Inner class is present)
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9296166896820068
*Get the inner class declaration named Inner.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all methods declared in the Inner class. -> baz method is present* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the method declaration named baz.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all statements in the baz method. -> for loop and String creation is present* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether a statement is a loop statement. -> True (for(;;) is a loop)* 匹配到的元操作或API：
query: Check whether a statement is a loop statement. -> True (for(;;) is a loop)
most similar API: Check whether the for statement equals
cosine Similarity: 0.8007388114929199
*Get all statements within the loop statement in baz. -> String creation is present* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether a statement within the loop is an object creation (constructor call). -> True (String a = new String();)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of object created by the constructor call within the loop in baz. -> String* 匹配到的元操作或API：
logic: Get the type of object created by the constructor call within the loop in baz. -> String
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.8928247094154358
*Get the class declaration of Sample.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all methods declared in the Sample class. -> foo method is present* 匹配到的元操作或API：
query: Get all methods declared in the Sample class. -> foo method is present
most similar API: get declared annotations of method
cosine Similarity: 0.8055821061134338
*Get the method declaration named foo.* 匹配到的元操作或API：
logic: Get the method declaration named foo.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.8857018351554871
*Get all statements in the foo method. -> Object creation of anonymous class and method bar is present* 匹配到的元操作或API：
query: Get all statements in the foo method. -> Object creation of anonymous class and method bar is present
most similar API: get declarations of anonymous class
cosine Similarity: 0.8004545569419861
*Check whether a statement is an object creation (constructor call). -> True (Sample anonymousClass = new Sample() {...})* 匹配到的元操作或API：
query: Check whether a statement is an object creation (constructor call). -> True (Sample anonymousClass = new Sample() {...})
most similar API: Check whether is anonymous class creation
cosine Similarity: 0.8346787095069885
*Check whether the created object is an anonymous class. -> True (new Sample() {...} is an anonymous class)* 匹配到的元操作或API：
query: Check whether the created object is an anonymous class. -> True (new Sample() {...} is an anonymous class)
most similar API: Check whether is anonymous class creation
cosine Similarity: 0.8394004106521606
*Get the method declarations within the anonymous class. -> bar method is present* 匹配到的元操作或API：
query: Get the method declarations within the anonymous class. -> bar method is present
most similar API: get declarations of anonymous class
cosine Similarity: 0.8701998591423035
*Get the method declaration named bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all statements in the bar method. -> for loop and String creation is present* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether a statement is a loop statement. -> True (for(;;) is a loop)* 匹配到的元操作或API：
query: Check whether a statement is a loop statement. -> True (for(;;) is a loop)
most similar API: Check whether the for statement equals
cosine Similarity: 0.8007388114929199
*Get all statements within the loop statement in bar. -> String creation is present* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether a statement within the loop is an object creation (constructor call). -> True (String a = new String();)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of object created by the constructor call within the loop in bar. -> String* 匹配到的元操作或API：
logic: Get the type of object created by the constructor call within the loop in bar. -> String
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9057136178016663
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}


This checker is failed(false negative) on this negative test case:
```
// false negative in anonymous classes
public class Sample {
    private static class Inner {
        private void baz() {
            for(;;) {
                String a = new String();
            }
        }
    }

    public void foo() {
        Sample anonymousClass = new Sample() {
            void bar() {
                for(;;) {
                    String a = new String();
                }
            }
        };
    }
}
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Sample')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Inner')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'baz')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
            ——ASTForStatement
              ——ASTBlock
                ——ASTLocalVariableDeclaration
                  ——ASTModifierList
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTVariableDeclarator
                    ——ASTVariableDeclaratorId (declared variable name = 'a')
                    ——ASTConstructorCall
                      ——ASTClassOrInterfaceType (this is a class type)
                      ——ASTArgumentList (size = 0)
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'anonymousClass')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 0)
              ——ASTAnonymousClassDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceBody
                  ——ASTMethodDeclaration (method name = 'bar')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 0)
                    ——ASTBlock
                      ——ASTForStatement
                        ——ASTBlock
                          ——ASTLocalVariableDeclaration
                            ——ASTModifierList
                            ——ASTClassOrInterfaceType (this is a class type)
                            ——ASTVariableDeclarator
                              ——ASTVariableDeclaratorId (declared variable name = 'a')
                              ——ASTConstructorCall
                                ——ASTClassOrInterfaceType (this is a class type)
                                ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isQualifiedInstanceCreation(), //Returns true if this expression begins with a primary expression. Such an expression creates an instance of inner member classes and their anonymous subclasses. For example, {@code new Outer().new Inner()} evaluates to an instance of the Inner class, which is nested inside the new instance of Outer.
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnonymous()
6. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public boolean equals(java.lang.Object)
7. net.sourceforge.pmd.lang.java.ast.ASTAnonymousClassDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
8. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isAnonymousClassCreation(net.sourceforge.pmd.lang.java.ast.ASTExpression)

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isAnonymous()) {
            NodeStream<ASTForStatement> forStatements = node.getDeclarations(ASTForStatement.class).flatMap(NodeStream::stream);
            forStatements.forEach(statement -> {
                NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = statement.getBody().descendants(ASTLocalVariableDeclaration.class);
                localVariableDeclarations.forEach(declaration -> {
                    NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                    constructorCalls.forEach(call -> addViolation(data, call));
                });
            });

            NodeStream<ASTWhileStatement> whileStatements = node.getDeclarations(ASTWhileStatement.class).flatMap(NodeStream::stream);
            whileStatements.forEach(statement -> {
                NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = statement.getBody().descendants(ASTLocalVariableDeclaration.class);
                localVariableDeclarations.forEach(declaration -> {
                    NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                    constructorCalls.forEach(call -> addViolation(data, call));
                });
            });

            NodeStream<ASTDoStatement> doStatements = node.getDeclarations(ASTDoStatement.class).flatMap(NodeStream::stream);
            doStatements.forEach(statement -> {
                ASTStatement body = statement.getBody();
                if (body instanceof ASTBlock) {
                    NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
                    localVariableDeclarations.forEach(declaration -> {
                        NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                        constructorCalls.forEach(call -> addViolation(data, call));
                    });
                } else if (body instanceof ASTLocalVariableDeclaration) {
                    NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
                    constructorCalls.forEach(call -> addViolation(data, call));
                }
            });

            NodeStream<ASTForeachStatement> foreachStatements = node.getDeclarations(ASTForeachStatement.class).flatMap(NodeStream::stream);
            foreachStatements.forEach(statement -> {
                NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = statement.getBody().descendants(ASTLocalVariableDeclaration.class);
                localVariableDeclarations.forEach(declaration -> {
                    NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                    constructorCalls.forEach(call -> addViolation(data, call));
                });
            });
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of the method.
2. Check whether the method has a loop statement.
3. Get the loop statement inside the method.
4. Check whether there is an object creation within the loop statement.
5. Get the type of object created by constructor call.
6. Check whether the class is an anonymous class.
7. Repeat steps 2 to 6 for all methods in the class, including methods in inner and anonymous classes.

Applying these steps to the provided test case:

1. Get the name of the method. (Method name is baz)
2. Check whether the method has a loop statement. (Yes, it has an infinite for loop)
3. Get the loop statement inside the method. (Infinite for loop)
4. Check whether there is an object creation within the loop statement. (Yes, String a = new String())
5. Get the type of object created by constructor call. (String)
6. Check whether the class is an anonymous class. (No, it is an inner class)

This identifies one violation in the `baz` method of the `Inner` class.

Now, repeat the steps for the `foo` method:

1. Get the name of the method. (Method name is foo)
2. Check whether the method has a loop statement. (No, it does not have a loop directly)
3. Get the loop statement inside the method. (There is no loop statement)
4. Check whether there is an object creation within the loop statement. (This step is not applicable as there is no loop)
5. However, we need to check inside the anonymous class.
6. Get the anonymous class inside the method. (Sample anonymousClass = new Sample() {...})
7. Get the methods declared in the anonymous class. (Method name is bar)
8. Check whether the method has a loop statement. (Yes, it has an infinite for loop)
9. Get the loop statement inside the method. (Infinite for loop)
10. Check whether there is an object creation within the loop statement. (Yes, String a = new String())
11. Get the type of object created by constructor call. (String)
12. Check whether the class is an anonymous class. (Yes, it is an anonymous class)

This identifies a second violation in the `bar` method of the anonymous class.

Thus, the number of violations in the test case is 2.
['Get the name of the method.', 'Check whether the method has a loop statement.', 'Get the loop statement inside the method.', 'Check whether there is an object creation within the loop statement.', 'Get the type of object created by constructor call.', 'Check whether the class is an anonymous class.', 'Repeat steps 2 to 6 for all methods in the class, including methods in inner and anonymous classes.', 'Get the name of the method. (Method name is baz)', 'Check whether the method has a loop statement. (Yes, it has an infinite for loop)', 'Get the loop statement inside the method. (Infinite for loop)', 'Check whether there is an object creation within the loop statement. (Yes, String a = new String())', 'Get the type of object created by constructor call. (String)', 'Check whether the class is an anonymous class. (No, it is an inner class)', 'Get the name of the method. (Method name is foo)', 'Check whether the method has a loop statement. (No, it does not have a loop directly)', 'Get the loop statement inside the method. (There is no loop statement)', 'Check whether there is an object creation within the loop statement. (This step is not applicable as there is no loop)', 'However, we need to check inside the anonymous class.', 'Get the anonymous class inside the method. (Sample anonymousClass = new Sample() {...})', 'Get the methods declared in the anonymous class. (Method name is bar)', 'Check whether the method has a loop statement. (Yes, it has an infinite for loop)', 'Get the loop statement inside the method. (Infinite for loop)', 'Check whether there is an object creation within the loop statement. (Yes, String a = new String())', 'Get the type of object created by constructor call. (String)', 'Check whether the class is an anonymous class. (Yes, it is an anonymous class)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTVariableDeclarator', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTAnonymousClassDeclaration', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTForStatement']
*Get the name of the method.* 匹配到的元操作或API：
logic: Get the name of the method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9713990092277527
*Check whether the method has a loop statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop statement inside the method.* 匹配到的元操作或API：
query: Get the loop statement inside the method.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8081913590431213
*Check whether there is an object creation within the loop statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the class is an anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is an anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9796479344367981
*Repeat steps 2 to 6 for all methods in the class, including methods in inner and anonymous classes.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the method. (Method name is baz)* 匹配到的元操作或API：
logic: Get the name of the method. (Method name is baz)
most similar meta operation: Get the name of method
cosine Similarity: 0.8989502191543579
*Check whether the method has a loop statement. (Yes, it has an infinite for loop)* 匹配到的元操作或API：
query: Check whether the method has a loop statement. (Yes, it has an infinite for loop)
most similar API: Check whether the for statement equals
cosine Similarity: 0.8023701310157776
*Get the loop statement inside the method. (Infinite for loop)* 匹配到的元操作或API：
query: Get the loop statement inside the method. (Infinite for loop)
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.820917010307312
*Check whether there is an object creation within the loop statement. (Yes, String a = new String())* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of object created by constructor call. (String)* 匹配到的元操作或API：
logic: Get the type of object created by constructor call. (String)
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9796581864356995
*Check whether the class is an anonymous class. (No, it is an inner class)* 匹配到的元操作或API：
logic: Check whether the class is an anonymous class. (No, it is an inner class)
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9525277614593506
*Get the name of the method. (Method name is foo)* 匹配到的元操作或API：
logic: Get the name of the method. (Method name is foo)
most similar meta operation: Get the name of method
cosine Similarity: 0.9393507242202759
*Check whether the method has a loop statement. (No, it does not have a loop directly)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop statement inside the method. (There is no loop statement)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether there is an object creation within the loop statement. (This step is not applicable as there is no loop)* 匹配到的元操作或API：
未匹配成功元操作或API
*However, we need to check inside the anonymous class.* 匹配到的元操作或API：
query: However, we need to check inside the anonymous class.
most similar API: Check whether the anonymous class is anonymous
cosine Similarity: 0.8257437944412231
*Get the anonymous class inside the method. (Sample anonymousClass = new Sample() {...})* 匹配到的元操作或API：
query: Get the anonymous class inside the method. (Sample anonymousClass = new Sample() {...})
most similar API: get class of anonymous class
cosine Similarity: 0.8422433137893677
*Get the methods declared in the anonymous class. (Method name is bar)* 匹配到的元操作或API：
query: Get the methods declared in the anonymous class. (Method name is bar)
most similar API: get declarations of anonymous class
cosine Similarity: 0.8652836084365845
*Check whether the method has a loop statement. (Yes, it has an infinite for loop)* 匹配到的元操作或API：
query: Check whether the method has a loop statement. (Yes, it has an infinite for loop)
most similar API: Check whether the for statement equals
cosine Similarity: 0.8023701310157776
*Get the loop statement inside the method. (Infinite for loop)* 匹配到的元操作或API：
query: Get the loop statement inside the method. (Infinite for loop)
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.820917010307312
*Check whether there is an object creation within the loop statement. (Yes, String a = new String())* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of object created by constructor call. (String)* 匹配到的元操作或API：
logic: Get the type of object created by constructor call. (String)
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9796581864356995
*Check whether the class is an anonymous class. (Yes, it is an anonymous class)* 匹配到的元操作或API：
logic: Check whether the class is an anonymous class. (Yes, it is an anonymous class)
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9652551412582397
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}


This checker is failed(false negative) on this negative test case:
```
// false negative in anonymous classes
public class Sample {
    private static class Inner {
        private void baz() {
            for(;;) {
                String a = new String();
            }
        }
    }

    public void foo() {
        Sample anonymousClass = new Sample() {
            void bar() {
                for(;;) {
                    String a = new String();
                }
            }
        };
    }
}
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Sample')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Inner')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'baz')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
            ——ASTForStatement
              ——ASTBlock
                ——ASTLocalVariableDeclaration
                  ——ASTModifierList
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTVariableDeclarator
                    ——ASTVariableDeclaratorId (declared variable name = 'a')
                    ——ASTConstructorCall
                      ——ASTClassOrInterfaceType (this is a class type)
                      ——ASTArgumentList (size = 0)
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'anonymousClass')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 0)
              ——ASTAnonymousClassDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceBody
                  ——ASTMethodDeclaration (method name = 'bar')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 0)
                    ——ASTBlock
                      ——ASTForStatement
                        ——ASTBlock
                          ——ASTLocalVariableDeclaration
                            ——ASTModifierList
                            ——ASTClassOrInterfaceType (this is a class type)
                            ——ASTVariableDeclarator
                              ——ASTVariableDeclaratorId (declared variable name = 'a')
                              ——ASTConstructorCall
                                ——ASTClassOrInterfaceType (this is a class type)
                                ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnonymous()
5. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public boolean equals(java.lang.Object)
6. net.sourceforge.pmd.lang.java.ast.ASTAnonymousClassDeclaration: public boolean isAnonymous(), //Returns true if this is an {@linkplain ASTAnonymousClassDeclaration anonymous class declaration}.
7. net.sourceforge.pmd.lang.java.ast.ASTAnonymousClassDeclaration: public java.lang.Class<Class<?> getClass()
8. net.sourceforge.pmd.lang.java.ast.ASTAnonymousClassDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });

        node.getBody().descendants(ASTAnonymousClassDeclaration.class).forEach(this::checkAnonymousClassForInstantiations);
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        node.getBody().descendants(ASTAnonymousClassDeclaration.class).forEach(this::checkAnonymousClassForInstantiations);
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });

        node.getBody().descendants(ASTAnonymousClassDeclaration.class).forEach(this::checkAnonymousClassForInstantiations);
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });

        node.getBody().descendants(ASTAnonymousClassDeclaration.class).forEach(this::checkAnonymousClassForInstantiations);
        return super.visit(node, data);
    }

    private void checkAnonymousClassForInstantiations(ASTAnonymousClassDeclaration anonymousClass) {
        anonymousClass.getDeclarations(ASTMethodDeclaration.class).forEach(method -> {
            method.getDeclarations(ASTForStatement.class).forEach(forStatement -> {
                forStatement.getBody().descendants(ASTLocalVariableDeclaration.class).forEach(declaration -> {
                    declaration.descendants(ASTConstructorCall.class).forEach(call -> addViolation(call));
                });
            });

            method.getDeclarations(ASTDoStatement.class).forEach(doStatement -> {
                doStatement.getBody().descendants(ASTLocalVariableDeclaration.class).forEach(declaration -> {
                    declaration.descendants(ASTConstructorCall.class).forEach(call -> addViolation(call));
                });
            });

            method.getDeclarations(ASTWhileStatement.class).forEach(whileStatement -> {
                whileStatement.getBody().descendants(ASTLocalVariableDeclaration.class).forEach(declaration -> {
                    declaration.descendants(ASTConstructorCall.class).forEach(call -> addViolation(call));
                });
            });

            method.getDeclarations(ASTForeachStatement.class).forEach(foreachStatement -> {
                foreachStatement.getBody().descendants(ASTLocalVariableDeclaration.class).forEach(declaration -> {
                    declaration.descendants(ASTConstructorCall.class).forEach(call -> addViolation(call));
                });
            });
        });
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To verify the adherence to the rule, we need to inspect each loop in the test case for object creation within them. Here are the granular checks:

1. Get the class that method `baz` is located in.
2. Get the name of the class.
3. Check whether the class is an inner class.
4. Get the loop statement in method `baz`.
5. Check whether there is an object creation within the loop statement.
6. Get the type of object created by the constructor call.
7. Check whether the type of object is `String` class type.

For the anonymous class:

8. Get the constructor call for the anonymous class.
9. Get the method `bar` from the anonymous class.
10. Get the loop statement in method `bar`.
11. Check whether there is an object creation within the loop statement.
12. Get the type of object created by the constructor call.
13. Check whether the type of object is `String` class type.

These checks will help us determine whether the rule is being violated in the provided test case. Specifically, we are looking for object creation within loop statements, and the checks should confirm that there are indeed two violations (one in `baz` and one in `bar` within the anonymous class).
            
['Get the class that method `baz` is located in.', 'Get the name of the class.', 'Check whether the class is an inner class.', 'Get the loop statement in method `baz`.', 'Check whether there is an object creation within the loop statement.', 'Get the type of object created by the constructor call.', 'Check whether the type of object is `String` class type.', 'Get the constructor call for the anonymous class.', 'Get the method `bar` from the anonymous class.', 'Get the loop statement in method `bar`.', 'Check whether there is an object creation within the loop statement.', 'Get the type of object created by the constructor call.', 'Check whether the type of object is `String` class type.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTVariableDeclarator', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTAnonymousClassDeclaration', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTForStatement']
*Get the class that method `baz` is located in.* 匹配到的元操作或API：
logic: Get the class that method `baz` is located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.8616764545440674
*Get the name of the class.* 匹配到的元操作或API：
logic: Get the name of the class.
most similar meta operation: Get the name of class
cosine Similarity: 0.968898594379425
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Get the loop statement in method `baz`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether there is an object creation within the loop statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of object created by the constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by the constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.983032763004303
*Check whether the type of object is `String` class type.* 匹配到的元操作或API：
logic: Check whether the type of object is `String` class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8684031367301941
*Get the constructor call for the anonymous class.* 匹配到的元操作或API：
query: Get the constructor call for the anonymous class.
most similar API: get anonymous class declaration of constructor call
cosine Similarity: 0.9105991125106812
*Get the method `bar` from the anonymous class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop statement in method `bar`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether there is an object creation within the loop statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of object created by the constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by the constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.983032763004303
*Check whether the type of object is `String` class type.* 匹配到的元操作或API：
logic: Check whether the type of object is `String` class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8684031367301941
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}


This checker is failed(false negative) on this negative test case:
```
// false negative in anonymous classes
public class Sample {
    private static class Inner {
        private void baz() {
            for(;;) {
                String a = new String();
            }
        }
    }

    public void foo() {
        Sample anonymousClass = new Sample() {
            void bar() {
                for(;;) {
                    String a = new String();
                }
            }
        };
    }
}
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Sample')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Inner')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'baz')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
            ——ASTForStatement
              ——ASTBlock
                ——ASTLocalVariableDeclaration
                  ——ASTModifierList
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTVariableDeclarator
                    ——ASTVariableDeclaratorId (declared variable name = 'a')
                    ——ASTConstructorCall
                      ——ASTClassOrInterfaceType (this is a class type)
                      ——ASTArgumentList (size = 0)
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'anonymousClass')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 0)
              ——ASTAnonymousClassDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceBody
                  ——ASTMethodDeclaration (method name = 'bar')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 0)
                    ——ASTBlock
                      ——ASTForStatement
                        ——ASTBlock
                          ——ASTLocalVariableDeclaration
                            ——ASTModifierList
                            ——ASTClassOrInterfaceType (this is a class type)
                            ——ASTVariableDeclarator
                              ——ASTVariableDeclaratorId (declared variable name = 'a')
                              ——ASTConstructorCall
                                ——ASTClassOrInterfaceType (this is a class type)
                                ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTAnonymousClassDeclaration getAnonymousClassDeclaration()

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTMethodDeclaration enclosingMethod = node.getFirstParentOfType(ASTMethodDeclaration.class);
        if (enclosingMethod != null) {
            ASTClassOrInterfaceDeclaration enclosingType = enclosingMethod.getEnclosingType();
            if (enclosingType instanceof ASTAnonymousClassDeclaration) {
                ASTBlock body = node.getFirstParentOfType(ASTBlock.class);
                if (body != null) {
                    ASTStatement parentStatement = body.getFirstParentOfType(ASTStatement.class);
                    if (parentStatement instanceof ASTWhileStatement || parentStatement instanceof ASTForStatement || parentStatement instanceof ASTForeachStatement || parentStatement instanceof ASTDoStatement) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of the class.
        2. Check whether the class is an inner class.
        3. Get all methods declared in class.
        4. Check whether the method is baz.
        5. Get all statements inside the method baz.
        6. Check whether the statement is a loop statement.
        7. Get all statements inside the loop statement.
        8. Check whether the statement is an object creation (new).
        9. Get the type of object created in the object creation statement.
        10. Check whether the type of object created is String.
        11. Get the name of the class.
        12. Check whether the class has an anonymous class.
        13. Get all methods declared in the anonymous class.
        14. Check whether the method is bar.
        15. Get all statements inside the method bar.
        16. Check whether the statement is a loop statement.
        17. Get all statements inside the loop statement.
        18. Check whether the statement is an object creation (new).
        19. Get the type of object created in the object creation statement.
        20. Check whether the type of object created is String.
        If the method baz contains an object creation inside a loop and the object creation creates a new String, then this is a violation.
        If the anonymous class method bar contains an object creation inside a loop and the object creation creates a new String, then this is another violation.
            
['Get the name of the class.', 'Check whether the class is an inner class.', 'Get all methods declared in class.', 'Check whether the method is baz.', 'Get all statements inside the method baz.', 'Check whether the statement is a loop statement.', 'Get all statements inside the loop statement.', 'Check whether the statement is an object creation (new).', 'Get the type of object created in the object creation statement.', 'Check whether the type of object created is String.', 'Get the name of the class.', 'Check whether the class has an anonymous class.', 'Get all methods declared in the anonymous class.', 'Check whether the method is bar.', 'Get all statements inside the method bar.', 'Check whether the statement is a loop statement.', 'Get all statements inside the loop statement.', 'Check whether the statement is an object creation (new).', 'Get the type of object created in the object creation statement.', 'Check whether the type of object created is String.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTVariableDeclarator', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTAnonymousClassDeclaration', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTForStatement']
*Get the name of the class.* 匹配到的元操作或API：
logic: Get the name of the class.
most similar meta operation: Get the name of class
cosine Similarity: 0.968898594379425
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether the method is baz.* 匹配到的元操作或API：
query: Check whether the method is baz.
most similar API: Check whether is test method
cosine Similarity: 0.826753556728363
*Get all statements inside the method baz.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the statement is a loop statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all statements inside the loop statement.* 匹配到的元操作或API：
query: Get all statements inside the loop statement.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8103177547454834
*Check whether the statement is an object creation (new).* 匹配到的元操作或API：
query: Check whether the statement is an object creation (new).
most similar API: Check whether the constructor call is qualified instance creation
cosine Similarity: 0.8086106777191162
*Get the type of object created in the object creation statement.* 匹配到的元操作或API：
logic: Get the type of object created in the object creation statement.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9113978147506714
*Check whether the type of object created is String.* 匹配到的元操作或API：
logic: Check whether the type of object created is String.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.8635118007659912
*Get the name of the class.* 匹配到的元操作或API：
logic: Get the name of the class.
most similar meta operation: Get the name of class
cosine Similarity: 0.968898594379425
*Check whether the class has an anonymous class.* 匹配到的元操作或API：
logic: Check whether the class has an anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9539774656295776
*Get all methods declared in the anonymous class.* 匹配到的元操作或API：
query: Get all methods declared in the anonymous class.
most similar API: get declarations of anonymous class
cosine Similarity: 0.8749818801879883
*Check whether the method is bar.* 匹配到的元操作或API：
query: Check whether the method is bar.
most similar API: Check whether is test method
cosine Similarity: 0.832916259765625
*Get all statements inside the method bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the statement is a loop statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all statements inside the loop statement.* 匹配到的元操作或API：
query: Get all statements inside the loop statement.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8103177547454834
*Check whether the statement is an object creation (new).* 匹配到的元操作或API：
query: Check whether the statement is an object creation (new).
most similar API: Check whether the constructor call is qualified instance creation
cosine Similarity: 0.8086106777191162
*Get the type of object created in the object creation statement.* 匹配到的元操作或API：
logic: Get the type of object created in the object creation statement.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9113978147506714
*Check whether the type of object created is String.* 匹配到的元操作或API：
logic: Check whether the type of object created is String.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.8635118007659912
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}


This checker is failed(false negative) on this negative test case:
```
// false negative in anonymous classes
public class Sample {
    private static class Inner {
        private void baz() {
            for(;;) {
                String a = new String();
            }
        }
    }

    public void foo() {
        Sample anonymousClass = new Sample() {
            void bar() {
                for(;;) {
                    String a = new String();
                }
            }
        };
    }
}
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Sample')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Inner')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'baz')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
            ——ASTForStatement
              ——ASTBlock
                ——ASTLocalVariableDeclaration
                  ——ASTModifierList
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTVariableDeclarator
                    ——ASTVariableDeclaratorId (declared variable name = 'a')
                    ——ASTConstructorCall
                      ——ASTClassOrInterfaceType (this is a class type)
                      ——ASTArgumentList (size = 0)
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'anonymousClass')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 0)
              ——ASTAnonymousClassDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceBody
                  ——ASTMethodDeclaration (method name = 'bar')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 0)
                    ——ASTBlock
                      ——ASTForStatement
                        ——ASTBlock
                          ——ASTLocalVariableDeclaration
                            ——ASTModifierList
                            ——ASTClassOrInterfaceType (this is a class type)
                            ——ASTVariableDeclarator
                              ——ASTVariableDeclaratorId (declared variable name = 'a')
                              ——ASTConstructorCall
                                ——ASTClassOrInterfaceType (this is a class type)
                                ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
5. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isQualifiedInstanceCreation(), //Returns true if this expression begins with a primary expression. Such an expression creates an instance of inner member classes and their anonymous subclasses. For example, {@code new Outer().new Inner()} evaluates to an instance of the Inner class, which is nested inside the new instance of Outer.
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnonymous()
9. net.sourceforge.pmd.lang.java.ast.ASTAnonymousClassDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)

1.  //Check whether the field is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFieldStringType(ASTFieldDeclaration node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });

        visitAnonymousClasses(node.getBody(), data);
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        visitAnonymousClasses(body, data);
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });

        visitAnonymousClasses(node.getBody(), data);
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });

        visitAnonymousClasses(node.getBody(), data);
        return super.visit(node, data);
    }

    private void visitAnonymousClasses(ASTNode node, Object data) {
        NodeStream<ASTAnonymousClassDeclaration> anonymousClasses = node.descendants(ASTAnonymousClassDeclaration.class);
        anonymousClasses.forEach(anonymousClass -> {
            NodeStream<ASTMethodDeclaration> methods = anonymousClass.descendants(ASTMethodDeclaration.class);
            methods.forEach(method -> {
                NodeStream<ASTForStatement> forStatements = method.descendants(ASTForStatement.class);
                forStatements.forEach(forStatement -> {
                    NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = forStatement.getBody().descendants(ASTLocalVariableDeclaration.class);
                    localVariableDeclarations.forEach(declaration -> {
                        NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                        constructorCalls.forEach(call -> addViolation(data, call));
                    });
                });

                NodeStream<ASTWhileStatement> whileStatements = method.descendants(ASTWhileStatement.class);
                whileStatements.forEach(whileStatement -> {
                    NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = whileStatement.getBody().descendants(ASTLocalVariableDeclaration.class);
                    localVariableDeclarations.forEach(declaration -> {
                        NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                        constructorCalls.forEach(call -> addViolation(data, call));
                    });
                });

                NodeStream<ASTDoStatement> doStatements = method.descendants(ASTDoStatement.class);
                doStatements.forEach(doStatement -> {
                    NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = doStatement.getBody().descendants(ASTLocalVariableDeclaration.class);
                    localVariableDeclarations.forEach(declaration -> {
                        NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                        constructorCalls.forEach(call -> addViolation(data, call));
                    });
                });
            });
        });
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 7
[ERROR]   "bad 8" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
100
82
94
78
111
94
96
81
77
63
93
78
94
79
77
63
96
80
99
82
77
63
77
63
=========================error_testcase_logics=========================
1. Get the body of the method.
2. Get all statements within the method body.
3. Identify all loop statements within the method body.
4. Get the body of the for loop statement.
5. Identify all method calls within the loop body.
6. Check whether the method call is a constructor call.
7. If the method call is a constructor call, check whether it is within a loop.

In this test case:

1. The body of the method `checkCollection` is retrieved.
2. All statements within the method body are identified, including the for loop.
3. The for loop statement is identified.
4. The body of the for loop statement is retrieved.
5. All method calls within the loop body are identified, including `thisIsACar.add(new Car());`.
6. The constructor call `new Car()` is identified.
7. The constructor call is within a loop, which violates the rule.

Therefore, the number of violations in this test case is: 1.
['Get the body of the method.', 'Get all statements within the method body.', 'Identify all loop statements within the method body.', 'Get the body of the for loop statement.', 'Identify all method calls within the loop body.', 'Check whether the method call is a constructor call.', 'If the method call is a constructor call, check whether it is within a loop.', 'The body of the method `checkCollection` is retrieved.', 'All statements within the method body are identified, including the for loop.', 'The for loop statement is identified.', 'The body of the for loop statement is retrieved.', 'All method calls within the loop body are identified, including `thisIsACar.add(new Car());`.', 'The constructor call `new Car()` is identified.', 'The constructor call is within a loop, which violates the rule.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTStatementExpressionList', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'ASTForUpdate', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTForInit', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTTypeArguments', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTExpressionStatement', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'ASTForStatement']
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Get all statements within the method body.* 匹配到的元操作或API：
query: Get all statements within the method body.
most similar API: get of statement expression list
cosine Similarity: 0.8091014623641968
*Identify all loop statements within the method body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the for loop statement.* 匹配到的元操作或API：
query: Get the body of the for loop statement.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.9543164968490601
*Identify all method calls within the loop body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method call is a constructor call.* 匹配到的元操作或API：
query: Check whether the method call is a constructor call.
most similar API: Check whether the constructor call is qualified instance creation
cosine Similarity: 0.8884625434875488
*If the method call is a constructor call, check whether it is within a loop.* 匹配到的元操作或API：
query: If the method call is a constructor call, check whether it is within a loop.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8634268045425415
*The body of the method `checkCollection` is retrieved.* 匹配到的元操作或API：
未匹配成功元操作或API
*All statements within the method body are identified, including the for loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*The for loop statement is identified.* 匹配到的元操作或API：
未匹配成功元操作或API
*The body of the for loop statement is retrieved.* 匹配到的元操作或API：
query: The body of the for loop statement is retrieved.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.9004502892494202
*All method calls within the loop body are identified, including `thisIsACar.add(new Car());`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The constructor call `new Car()` is identified.* 匹配到的元操作或API：
未匹配成功元操作或API
*The constructor call is within a loop, which violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}


This checker is failed(false negative) on this negative test case:
```
// Collections with unresolved type
// Types are unresolved
//import java.util.Collection;
//import java.util.ArrayList;

public class Sample {
    public Collection<Car> checkCollection() {
        Collection<Car> thisIsACar = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
            thisIsACar.add(new Car());
        }
        return thisIsACar;
    }

    private static class Car {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Sample')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'checkCollection')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'Collection<Car>')
        ——ASTTypeArguments
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
            ——ASTTypeArguments
              ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'thisIsACar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
                ——ASTTypeArguments
              ——ASTArgumentList (size = 0)
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'add')
                ——ASTVariableAccess (referenced variable name = 'thisIsACar')
                ——ASTArgumentList (size = 1)
                  ——ASTConstructorCall
                    ——ASTClassOrInterfaceType (this is a class type)
                    ——ASTArgumentList (size = 0)
        ——ASTReturnStatement
          ——ASTVariableAccess (referenced variable name = 'thisIsACar')
    ——ASTClassOrInterfaceDeclaration (class name = 'Car')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
2. net.sourceforge.pmd.lang.java.ast.ASTStatementExpressionList: public N get(int), //@throws IndexOutOfBoundsException if not in range
3. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isQualifiedInstanceCreation(), //Returns true if this expression begins with a primary expression. Such an expression creates an instance of inner member classes and their anonymous subclasses. For example, {@code new Outer().new Inner()} evaluates to an instance of the Inner class, which is nested inside the new instance of Outer.
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        NodeStream<ASTConstructorCall> constructorCalls = node.descendants(ASTConstructorCall.class);
        constructorCalls.forEach(call -> addViolation(data, call));
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTStatementExpressionList node, Object data) {
        NodeStream<ASTConstructorCall> constructorCalls = node.descendants(ASTConstructorCall.class);
        constructorCalls.forEach(call -> addViolation(data, call));
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 8" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 8" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the name of the method.
2. Get the body of the method.
3. Get all statements in the method body.
4. Get the loop statements in the method body.
5. Get the body of the for loop.
6. Get all statements in the for loop body.
7. Get the method calls in the for loop body.
8. Get the constructor calls in the for loop body.
9. Get the type of object created by constructor call.
10. Check whether the type of object is Car class type.

In this test case, the method `checkCollection` contains a for loop in its body. Inside the for loop, a new `Car` object is created using a constructor call. This violates the rule that new objects should not be created within loops. Therefore, the number of violations in this test case is 1.
['Get the name of the method.', 'Get the body of the method.', 'Get all statements in the method body.', 'Get the loop statements in the method body.', 'Get the body of the for loop.', 'Get all statements in the for loop body.', 'Get the method calls in the for loop body.', 'Get the constructor calls in the for loop body.', 'Get the type of object created by constructor call.', 'Check whether the type of object is Car class type.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTStatementExpressionList', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'ASTForUpdate', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTForInit', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTTypeArguments', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTExpressionStatement', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'ASTForStatement']
*Get the name of the method.* 匹配到的元操作或API：
logic: Get the name of the method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9713990092277527
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Get all statements in the method body.* 匹配到的元操作或API：
query: Get all statements in the method body.
most similar API: get of statement expression list
cosine Similarity: 0.8075003027915955
*Get the loop statements in the method body.* 匹配到的元操作或API：
query: Get the loop statements in the method body.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8382323980331421
*Get the body of the for loop.* 匹配到的元操作或API：
query: Get the body of the for loop.
most similar API: get body of for statement
cosine Similarity: 0.9058630466461182
*Get all statements in the for loop body.* 匹配到的元操作或API：
query: Get all statements in the for loop body.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.889079749584198
*Get the method calls in the for loop body.* 匹配到的元操作或API：
query: Get the method calls in the for loop body.
most similar API: get method name of method call
cosine Similarity: 0.8141843676567078
*Get the constructor calls in the for loop body.* 匹配到的元操作或API：
query: Get the constructor calls in the for loop body.
most similar API: get arguments of constructor call
cosine Similarity: 0.815955638885498
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is Car class type.* 匹配到的元操作或API：
logic: Check whether the type of object is Car class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8622030019760132
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}


This checker is failed(false negative) on this negative test case:
```
// Collections with unresolved type
// Types are unresolved
//import java.util.Collection;
//import java.util.ArrayList;

public class Sample {
    public Collection<Car> checkCollection() {
        Collection<Car> thisIsACar = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
            thisIsACar.add(new Car());
        }
        return thisIsACar;
    }

    private static class Car {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Sample')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'checkCollection')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'Collection<Car>')
        ——ASTTypeArguments
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
            ——ASTTypeArguments
              ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'thisIsACar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
                ——ASTTypeArguments
              ——ASTArgumentList (size = 0)
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'add')
                ——ASTVariableAccess (referenced variable name = 'thisIsACar')
                ——ASTArgumentList (size = 1)
                  ——ASTConstructorCall
                    ——ASTClassOrInterfaceType (this is a class type)
                    ——ASTArgumentList (size = 0)
        ——ASTReturnStatement
          ——ASTVariableAccess (referenced variable name = 'thisIsACar')
    ——ASTClassOrInterfaceDeclaration (class name = 'Car')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
3. net.sourceforge.pmd.lang.java.ast.ASTStatementExpressionList: public N get(int), //@throws IndexOutOfBoundsException if not in range
4. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
5. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {

    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        node.descendants(ASTLocalVariableDeclaration.class).forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });

        node.descendants(ASTExpressionStatement.class).forEach(statement -> {
            NodeStream<ASTConstructorCall> constructorCalls = statement.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 8" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 8" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the loop variable of for loop.
        2. Get the condition of for loop.
        3. Get the initialization of for loop.
        4. Get the update of for loop.
        5. Get the statements in the for loop body.
        6. Check whether the statement is a constructor call.
        7. Get the type of object created by constructor call.
        8. Check whether the constructor call is within the loop body.

In this test case:
1. The loop variable is `i`.
2. The condition of the for loop is `i < 3`.
3. The initialization of the for loop is `int i = 0`.
4. The update of the for loop is `++i`.
5. The statements in the for loop body are `thisIsACar.add(new Car());`.
6. The statement `thisIsACar.add(new Car());` is a method call, but it contains a constructor call.
7. The type of object created by the constructor call is `Car`.
8. The constructor call `new Car()` is within the loop body, which violates the rule.

Given the provided test case, the number of violating the rule is indeed 1.
['Get the loop variable of for loop.', 'Get the condition of for loop.', 'Get the initialization of for loop.', 'Get the update of for loop.', 'Get the statements in the for loop body.', 'Check whether the statement is a constructor call.', 'Get the type of object created by constructor call.', 'Check whether the constructor call is within the loop body.', 'The loop variable is `i`.', 'The condition of the for loop is `i < 3`.', 'The initialization of the for loop is `int i = 0`.', 'The update of the for loop is `++i`.', 'The statements in the for loop body are `thisIsACar.add(new Car());`.', 'The statement `thisIsACar.add(new Car());` is a method call, but it contains a constructor call.', 'The type of object created by the constructor call is `Car`.', 'The constructor call `new Car()` is within the loop body, which violates the rule.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTStatementExpressionList', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'ASTForUpdate', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTForInit', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTTypeArguments', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTExpressionStatement', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'ASTForStatement']
*Get the loop variable of for loop.* 匹配到的元操作或API：
logic: Get the loop variable of for loop.
most similar meta operation: Get a loop variable of for loop
cosine Similarity: 0.975679874420166
*Get the condition of for loop.* 匹配到的元操作或API：
logic: Get the condition of for loop.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.8640909790992737
*Get the initialization of for loop.* 匹配到的元操作或API：
query: Get the initialization of for loop.
most similar API: get init of for statement
cosine Similarity: 0.9044363498687744
*Get the update of for loop.* 匹配到的元操作或API：
query: Get the update of for loop.
most similar API: get update of for statement
cosine Similarity: 0.9226908683776855
*Get the statements in the for loop body.* 匹配到的元操作或API：
query: Get the statements in the for loop body.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.9116761684417725
*Check whether the statement is a constructor call.* 匹配到的元操作或API：
query: Check whether the statement is a constructor call.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8765487670898438
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the constructor call is within the loop body.* 匹配到的元操作或API：
query: Check whether the constructor call is within the loop body.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8520429134368896
*The loop variable is `i`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The condition of the for loop is `i < 3`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The initialization of the for loop is `int i = 0`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The update of the for loop is `++i`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The statements in the for loop body are `thisIsACar.add(new Car());`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The statement `thisIsACar.add(new Car());` is a method call, but it contains a constructor call.* 匹配到的元操作或API：
未匹配成功元操作或API
*The type of object created by the constructor call is `Car`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The constructor call `new Car()` is within the loop body, which violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}


This checker is failed(false negative) on this negative test case:
```
// Collections with unresolved type
// Types are unresolved
//import java.util.Collection;
//import java.util.ArrayList;

public class Sample {
    public Collection<Car> checkCollection() {
        Collection<Car> thisIsACar = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
            thisIsACar.add(new Car());
        }
        return thisIsACar;
    }

    private static class Car {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Sample')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'checkCollection')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'Collection<Car>')
        ——ASTTypeArguments
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
            ——ASTTypeArguments
              ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'thisIsACar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
                ——ASTTypeArguments
              ——ASTArgumentList (size = 0)
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'add')
                ——ASTVariableAccess (referenced variable name = 'thisIsACar')
                ——ASTArgumentList (size = 1)
                  ——ASTConstructorCall
                    ——ASTClassOrInterfaceType (this is a class type)
                    ——ASTArgumentList (size = 0)
        ——ASTReturnStatement
          ——ASTVariableAccess (referenced variable name = 'thisIsACar')
    ——ASTClassOrInterfaceDeclaration (class name = 'Car')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public net.sourceforge.pmd.lang.ast.NodeStream<ASTVariableDeclaratorId> getLoopVariables(net.sourceforge.pmd.lang.java.ast.ASTForStatement)
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
3. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getInit(), //Returns the statement nested within the {@linkplain ASTForInit init clause}, if it exists. This is either a {@linkplain ASTLocalVariableDeclaration local variable declaration} or a {@linkplain ASTStatementExpressionList statement expression list}.
4. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatementExpressionList getUpdate(), //Returns the statement nested within the update clause, if it exists.
5. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean equals(java.lang.Object)
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTConstructorCall> constructorCallsInInit = node.getInit().descendants(ASTConstructorCall.class);
        constructorCallsInInit.forEach(call -> addViolation(data, call));

        NodeStream<ASTConstructorCall> constructorCallsInUpdate = node.getUpdate().descendants(ASTConstructorCall.class);
        constructorCallsInUpdate.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 8" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 8" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the body of the method.
2. Identify all loop statements within the method body.
3. For each loop statement, get the loop body.
4. Identify all object creation expressions within the loop body.
5. Count the number of object creation expressions.

In this specific test case:
1. Get the body of the method `checkCollection`.
2. Identify the `for` loop statement within the method body.
3. Get the loop body of the `for` loop.
4. Identify the object creation expression `new Car()` within the loop body.
5. Count the number of object creation expressions, which is 1.

Since there is one object creation expression within the loop body, the test case violates the rule once.
['Get the body of the method.', 'Identify all loop statements within the method body.', 'For each loop statement, get the loop body.', 'Identify all object creation expressions within the loop body.', 'Count the number of object creation expressions.', 'Get the body of the method `checkCollection`.', 'Identify the `for` loop statement within the method body.', 'Get the loop body of the `for` loop.', 'Identify the object creation expression `new Car()` within the loop body.', 'Count the number of object creation expressions, which is 1.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTStatementExpressionList', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'ASTForUpdate', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTForInit', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTTypeArguments', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTExpressionStatement', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'ASTForStatement']
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Identify all loop statements within the method body.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each loop statement, get the loop body.* 匹配到的元操作或API：
query: For each loop statement, get the loop body.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8959190249443054
*Identify all object creation expressions within the loop body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Count the number of object creation expressions.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the method `checkCollection`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Identify the `for` loop statement within the method body.* 匹配到的元操作或API：
query: Identify the `for` loop statement within the method body.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8313420414924622
*Get the loop body of the `for` loop.* 匹配到的元操作或API：
logic: Get the loop body of the `for` loop.
most similar meta operation: Get a loop variable of for loop
cosine Similarity: 0.8537600636482239
*Identify the object creation expression `new Car()` within the loop body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Count the number of object creation expressions, which is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}


This checker is failed(false negative) on this negative test case:
```
// Collections with unresolved type
// Types are unresolved
//import java.util.Collection;
//import java.util.ArrayList;

public class Sample {
    public Collection<Car> checkCollection() {
        Collection<Car> thisIsACar = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
            thisIsACar.add(new Car());
        }
        return thisIsACar;
    }

    private static class Car {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Sample')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'checkCollection')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'Collection<Car>')
        ——ASTTypeArguments
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
            ——ASTTypeArguments
              ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'thisIsACar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
                ——ASTTypeArguments
              ——ASTArgumentList (size = 0)
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'add')
                ——ASTVariableAccess (referenced variable name = 'thisIsACar')
                ——ASTArgumentList (size = 1)
                  ——ASTConstructorCall
                    ——ASTClassOrInterfaceType (this is a class type)
                    ——ASTArgumentList (size = 0)
        ——ASTReturnStatement
          ——ASTVariableAccess (referenced variable name = 'thisIsACar')
    ——ASTClassOrInterfaceDeclaration (class name = 'Car')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
2. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
3. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public net.sourceforge.pmd.lang.ast.NodeStream<ASTVariableDeclaratorId> getLoopVariables(net.sourceforge.pmd.lang.java.ast.ASTForStatement)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });

        node.getInit().descendants(ASTConstructorCall.class).forEach(call -> addViolation(data, call));
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 8" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 8" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the loop variable of for loop.
2. Get the condition of for loop.
3. Get the body of for loop.
4. Get all object creation expressions within the for loop body.
5. Check whether the number of object creation expressions is greater than 0.
6. Get the type of object created by constructor call.
7. Check whether the type is Car class type.

In this test case:
- The for loop is identified.
- The body of the for loop is identified.
- The object creation expression `new Car()` within the for loop body is identified.
- Since there is an object creation expression within the for loop, the rule is violated.

The number of violating the rule in this test case is: 1
['Get the loop variable of for loop.', 'Get the condition of for loop.', 'Get the body of for loop.', 'Get all object creation expressions within the for loop body.', 'Check whether the number of object creation expressions is greater than 0.', 'Get the type of object created by constructor call.', 'Check whether the type is Car class type.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTStatementExpressionList', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'ASTForUpdate', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTForInit', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTTypeArguments', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTExpressionStatement', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'ASTForStatement']
*Get the loop variable of for loop.* 匹配到的元操作或API：
logic: Get the loop variable of for loop.
most similar meta operation: Get a loop variable of for loop
cosine Similarity: 0.975679874420166
*Get the condition of for loop.* 匹配到的元操作或API：
logic: Get the condition of for loop.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.8640909790992737
*Get the body of for loop.* 匹配到的元操作或API：
query: Get the body of for loop.
most similar API: get body of for statement
cosine Similarity: 0.9184505939483643
*Get all object creation expressions within the for loop body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the number of object creation expressions is greater than 0.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type is Car class type.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}


This checker is failed(false negative) on this negative test case:
```
// Collections with unresolved type
// Types are unresolved
//import java.util.Collection;
//import java.util.ArrayList;

public class Sample {
    public Collection<Car> checkCollection() {
        Collection<Car> thisIsACar = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
            thisIsACar.add(new Car());
        }
        return thisIsACar;
    }

    private static class Car {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Sample')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'checkCollection')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'Collection<Car>')
        ——ASTTypeArguments
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
            ——ASTTypeArguments
              ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'thisIsACar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
                ——ASTTypeArguments
              ——ASTArgumentList (size = 0)
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'add')
                ——ASTVariableAccess (referenced variable name = 'thisIsACar')
                ——ASTArgumentList (size = 1)
                  ——ASTConstructorCall
                    ——ASTClassOrInterfaceType (this is a class type)
                    ——ASTArgumentList (size = 0)
        ——ASTReturnStatement
          ——ASTVariableAccess (referenced variable name = 'thisIsACar')
    ——ASTClassOrInterfaceDeclaration (class name = 'Car')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public net.sourceforge.pmd.lang.ast.NodeStream<ASTVariableDeclaratorId> getLoopVariables(net.sourceforge.pmd.lang.java.ast.ASTForStatement)
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
3. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });

        NodeStream<ASTConstructorCall> constructorCallsInInit = node.getForInit().descendants(ASTConstructorCall.class);
        constructorCallsInInit.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 8
[ERROR]   "bad 9" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
94
79
94
78
87
72
82
68
97
81
93
78
119
103
93
78
=========================error_testcase_logics=========================
1. Get the body of the for-each loop.
        2. Get all object creation expressions within the body of the for-each loop.
        3. Check whether the type of object created by constructor call is an array type.
        If the body of the for-each loop contains an object creation expression where the type of object created is an array type, then this test case violates the rule.
['Get the body of the for-each loop.', 'Get all object creation expressions within the body of the for-each loop.', 'Check whether the type of object created by constructor call is an array type.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'ASTArrayAllocation', 'TypeConversion', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTForeachStatement', 'ASTArrayType', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTArrayInitializer', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the body of the for-each loop.* 匹配到的元操作或API：
query: Get the body of the for-each loop.
most similar API: get body of foreach statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8478140830993652
*Get all object creation expressions within the body of the for-each loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the type of object created by constructor call is an array type.* 匹配到的元操作或API：
logic: Check whether the type of object created by constructor call is an array type.
most similar meta operation: Check whether the return type of called method is array type
cosine Similarity: 0.8771704435348511
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));
        });
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}


This checker is failed(false negative) on this negative test case:
```
// False negative with array allocations within loops
public class AvoidInstantiatingArraysInLoops {
    public static void main(String[] args) {
        for (String arg : args) {
            String[] copy = new String[] { arg };
        }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'AvoidInstantiatingArraysInLoops')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'main')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTClassOrInterfaceType (this is a class type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclaratorId (declared variable name = 'args')
      ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTClassOrInterfaceType (this is a class type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'arg')
          ——ASTVariableAccess (referenced variable name = 'args')
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTArrayType (this is a primitive type)
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArrayDimensions
                  ——ASTArrayTypeDim
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'copy')
                ——ASTArrayAllocation
                  ——ASTArrayType (this is a primitive type)
                    ——ASTClassOrInterfaceType (this is a class type)
                    ——ASTArrayDimensions
                      ——ASTArrayTypeDim
                  ——ASTArrayInitializer
                    ——ASTVariableAccess (referenced variable name = 'arg')


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForeachStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.

1.  //Check whether the return type of called method is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.JMethodSig;
public boolean isReturnArrayType(ASTMethodCall call) {
    JMethodSig m = call.getMethodType();
    return m.getReturnType().isArray();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));

                NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
                arrayAllocations.forEach(allocation -> addViolation(data, allocation));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = body.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "ok 13" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
100
82
94
78
111
94
94
79
94
78
87
72
79
65
77
63
97
81
93
78
94
79
77
63
99
82
93
78
77
63
=========================error_testcase_logics=========================
1. Get the loop variable of for loop.
2. Get the condition of for loop.
3. Get the body of for loop.
4. Check whether the body of for loop contains a constructor call.
5. Get the type of object created by constructor call.
6. Check whether the constructor call is to create a new array.
7. Get the loop variable of for loop.
8. Get the condition of for loop.
9. Get the body of for loop.
10. Check whether the body of for loop contains a constructor call.
11. Get the type of object created by constructor call.
12. Check whether the constructor call is to create a new array.

In this test case:
- For the first for loop, the body contains a return statement that creates a new array. However, this does not violate the rule because the loop is exited immediately after the first iteration with the return statement.
- For the second for loop, the body contains a statement that creates a new array and assigns it to a local variable `a`. Although this array creation occurs within the loop, the loop is exited immediately after the first iteration with the `break` statement.

Since the loops are exited immediately after the first iteration, no new objects (arrays) are created multiple times within the loops, so the number of violations is 0.
['Get the loop variable of for loop.', 'Get the condition of for loop.', 'Get the body of for loop.', 'Check whether the body of for loop contains a constructor call.', 'Get the type of object created by constructor call.', 'Check whether the constructor call is to create a new array.', 'Get the loop variable of for loop.', 'Get the condition of for loop.', 'Get the body of for loop.', 'Check whether the body of for loop contains a constructor call.', 'Get the type of object created by constructor call.', 'Check whether the constructor call is to create a new array.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'JavaSemanticErrors', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTStatementExpressionList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTArrayAllocation', 'TypeConversion', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ASTBreakStatement', 'TestFrameworksUtil', 'ASTForUpdate', 'ClassNamesUtil', 'JavaAstUtils', 'ASTArrayType', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTForInit', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'ASTArrayInitializer', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'ASTForStatement']
*Get the loop variable of for loop.* 匹配到的元操作或API：
logic: Get the loop variable of for loop.
most similar meta operation: Get a loop variable of for loop
cosine Similarity: 0.975679874420166
*Get the condition of for loop.* 匹配到的元操作或API：
logic: Get the condition of for loop.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.8640909790992737
*Get the body of for loop.* 匹配到的元操作或API：
query: Get the body of for loop.
most similar API: get body of for statement
cosine Similarity: 0.9184505939483643
*Check whether the body of for loop contains a constructor call.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the constructor call is to create a new array.* 匹配到的元操作或API：
query: Check whether the constructor call is to create a new array.
most similar API: Check whether is array initializer
cosine Similarity: 0.8042190074920654
*Get the loop variable of for loop.* 匹配到的元操作或API：
logic: Get the loop variable of for loop.
most similar meta operation: Get a loop variable of for loop
cosine Similarity: 0.975679874420166
*Get the condition of for loop.* 匹配到的元操作或API：
logic: Get the condition of for loop.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.8640909790992737
*Get the body of for loop.* 匹配到的元操作或API：
query: Get the body of for loop.
most similar API: get body of for statement
cosine Similarity: 0.9184505939483643
*Check whether the body of for loop contains a constructor call.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the constructor call is to create a new array.* 匹配到的元操作或API：
query: Check whether the constructor call is to create a new array.
most similar API: Check whether is array initializer
cosine Similarity: 0.8042190074920654
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));

                NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
                arrayAllocations.forEach(allocation -> addViolation(data, allocation));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = body.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}
This checker has passed this negative testcase:
public class AvoidInstantiatingArraysInLoops {
    public static void main(String[] args) {
        for (String arg : args) {
            String[] copy = new String[] { arg };
        }
    }
}


This checker is failed(false positive) on this positive test case:
```
// False positive when array is returned
public class AvoidInstantiatingArraysInLoops {
    public int[] test() {
        for (int i = 0; i < 10; i++) {
            return new int[] { i };
        }

        for (int i = 0; i < 10; i++) {
            int[] a = new int[] { i };
            break;
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'AvoidInstantiatingArraysInLoops')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test')
      ——ASTModifierList
      ——ASTArrayType (method return type = 'int[]')
        ——ASTPrimitiveType (this is a primitive type)
        ——ASTArrayDimensions
          ——ASTArrayTypeDim
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTArrayAllocation
                ——ASTArrayType (this is a primitive type)
                  ——ASTPrimitiveType (this is a primitive type)
                  ——ASTArrayDimensions
                    ——ASTArrayTypeDim
                ——ASTArrayInitializer
                  ——ASTVariableAccess (referenced variable name = 'i')
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayTypeDim
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'a')
                ——ASTArrayAllocation
                  ——ASTArrayType (this is a primitive type)
                    ——ASTPrimitiveType (this is a primitive type)
                    ——ASTArrayDimensions
                      ——ASTArrayTypeDim
                  ——ASTArrayInitializer
                    ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTBreakStatement


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public net.sourceforge.pmd.lang.ast.NodeStream<ASTVariableDeclaratorId> getLoopVariables(net.sourceforge.pmd.lang.java.ast.ASTForStatement)
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
3. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
5. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isArrayInitializer(net.sourceforge.pmd.lang.java.ast.ASTExpression)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> {
                if (!JavaAstUtils.isArrayInitializer(allocation)) {
                    addViolation(data, allocation);
                }
            });
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));

                NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
                arrayAllocations.forEach(allocation -> {
                    if (!JavaAstUtils.isArrayInitializer(allocation)) {
                        addViolation(data, allocation);
                    }
                });
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = body.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> {
                if (!JavaAstUtils.isArrayInitializer(allocation)) {
                    addViolation(data, allocation);
                }
            });
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> {
                if (!JavaAstUtils.isArrayInitializer(allocation)) {
                    addViolation(data, allocation);
                }
            });
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> {
                if (!JavaAstUtils.isArrayInitializer(allocation)) {
                    addViolation(data, allocation);
                }
            });
        });
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 9" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 9" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the number of loop statements in the class.
2. Get the loop variable of the first for loop.
3. Get the body of the first for loop.
4. Check whether the body of the first for loop contains a new object creation.
5. Get the number of loop statements in the body of the first for loop.
6. Check whether the body of the first for loop contains a return statement with new object creation.
7. Get the loop variable of the second for loop.
8. Get the body of the second for loop.
9. Check whether the body of the second for loop contains a new object creation.
10. Check whether the body of the second for loop contains a break statement.
11. Check whether the new object creation in the second for loop is followed by a break statement.
12. Check whether the body of the second for loop contains a new object creation outside of the break statement.
13. Check whether the body of the second for loop contains a new object creation inside the break statement.

For the provided test case:
- The first loop contains a return statement with a new object creation. Since the return statement exits the loop immediately, this does not violate the rule.
- The second loop contains a new object creation followed by a break statement. The break statement ensures that the new object creation does not occur in subsequent iterations of the loop, so this also does not violate the rule.

Therefore, the number of violations in this test case is 0, as no new objects are created within the loop in a way that would occur multiple times.
['Get the number of loop statements in the class.', 'Get the loop variable of the first for loop.', 'Get the body of the first for loop.', 'Check whether the body of the first for loop contains a new object creation.', 'Get the number of loop statements in the body of the first for loop.', 'Check whether the body of the first for loop contains a return statement with new object creation.', 'Get the loop variable of the second for loop.', 'Get the body of the second for loop.', 'Check whether the body of the second for loop contains a new object creation.', 'Check whether the body of the second for loop contains a break statement.', 'Check whether the new object creation in the second for loop is followed by a break statement.', 'Check whether the body of the second for loop contains a new object creation outside of the break statement.', 'Check whether the body of the second for loop contains a new object creation inside the break statement.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'JavaSemanticErrors', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTStatementExpressionList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTArrayAllocation', 'TypeConversion', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ASTBreakStatement', 'TestFrameworksUtil', 'ASTForUpdate', 'ClassNamesUtil', 'JavaAstUtils', 'ASTArrayType', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTForInit', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'ASTArrayInitializer', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'ASTForStatement']
*Get the number of loop statements in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop variable of the first for loop.* 匹配到的元操作或API：
logic: Get the loop variable of the first for loop.
most similar meta operation: Get a loop variable of for loop
cosine Similarity: 0.9334625005722046
*Get the body of the first for loop.* 匹配到的元操作或API：
query: Get the body of the first for loop.
most similar API: get body of for statement
cosine Similarity: 0.872355043888092
*Check whether the body of the first for loop contains a new object creation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of loop statements in the body of the first for loop.* 匹配到的元操作或API：
query: Get the number of loop statements in the body of the first for loop.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.836471438407898
*Check whether the body of the first for loop contains a return statement with new object creation.* 匹配到的元操作或API：
query: Check whether the body of the first for loop contains a return statement with new object creation.
most similar API: Check whether the return statement equals
cosine Similarity: 0.8126545548439026
*Get the loop variable of the second for loop.* 匹配到的元操作或API：
logic: Get the loop variable of the second for loop.
most similar meta operation: Get a loop variable of for loop
cosine Similarity: 0.925615668296814
*Get the body of the second for loop.* 匹配到的元操作或API：
query: Get the body of the second for loop.
most similar API: get body of for statement
cosine Similarity: 0.8675823211669922
*Check whether the body of the second for loop contains a new object creation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the second for loop contains a break statement.* 匹配到的元操作或API：
query: Check whether the body of the second for loop contains a break statement.
most similar API: Check whether the break statement equals
cosine Similarity: 0.8501760363578796
*Check whether the new object creation in the second for loop is followed by a break statement.* 匹配到的元操作或API：
query: Check whether the new object creation in the second for loop is followed by a break statement.
most similar API: Check whether the break statement equals
cosine Similarity: 0.8028421401977539
*Check whether the body of the second for loop contains a new object creation outside of the break statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the second for loop contains a new object creation inside the break statement.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));

                NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
                arrayAllocations.forEach(allocation -> addViolation(data, allocation));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = body.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}
This checker has passed this negative testcase:
public class AvoidInstantiatingArraysInLoops {
    public static void main(String[] args) {
        for (String arg : args) {
            String[] copy = new String[] { arg };
        }
    }
}


This checker is failed(false positive) on this positive test case:
```
// False positive when array is returned
public class AvoidInstantiatingArraysInLoops {
    public int[] test() {
        for (int i = 0; i < 10; i++) {
            return new int[] { i };
        }

        for (int i = 0; i < 10; i++) {
            int[] a = new int[] { i };
            break;
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'AvoidInstantiatingArraysInLoops')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test')
      ——ASTModifierList
      ——ASTArrayType (method return type = 'int[]')
        ——ASTPrimitiveType (this is a primitive type)
        ——ASTArrayDimensions
          ——ASTArrayTypeDim
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTArrayAllocation
                ——ASTArrayType (this is a primitive type)
                  ——ASTPrimitiveType (this is a primitive type)
                  ——ASTArrayDimensions
                    ——ASTArrayTypeDim
                ——ASTArrayInitializer
                  ——ASTVariableAccess (referenced variable name = 'i')
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayTypeDim
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'a')
                ——ASTArrayAllocation
                  ——ASTArrayType (this is a primitive type)
                    ——ASTPrimitiveType (this is a primitive type)
                    ——ASTArrayDimensions
                      ——ASTArrayTypeDim
                  ——ASTArrayInitializer
                    ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTBreakStatement


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public net.sourceforge.pmd.lang.ast.NodeStream<ASTVariableDeclaratorId> getLoopVariables(net.sourceforge.pmd.lang.java.ast.ASTForStatement)
2. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
3. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTBreakStatement: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));

                NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
                arrayAllocations.forEach(allocation -> addViolation(data, allocation));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = body.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });

        if (!hasReturnOrBreak(node.getBody())) {
            JavaAstUtils.getLoopVariables(node).forEach(variable -> {
                NodeStream<ASTConstructorCall> constructorCalls = node.getBody().descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));

                NodeStream<ASTArrayAllocation> arrayAllocations = node.getBody().descendants(ASTArrayAllocation.class);
                arrayAllocations.forEach(allocation -> addViolation(data, allocation));
            });
        }

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });

        if (!hasReturnOrBreak(node.getBody())) {
            NodeStream<ASTConstructorCall> constructorCalls = node.getBody().descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = node.getBody().descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        }

        return super.visit(node, data);
    }

    private boolean hasReturnOrBreak(ASTStatement body) {
        return body.descendants(ASTReturnStatement.class).anyMatch(rs -> true) ||
               body.descendants(ASTBreakStatement.class).anyMatch(bs -> true);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To perform granular checks on the provided test case to ensure it does not violate the rule "New objects can not be created within loops," we will examine each loop and the object creation within it:

1. Get the first for loop in the class.
2. Get the body of the first for loop.
3. Check whether the body of the first for loop contains an object creation expression.
4. If an object creation expression is found, check whether it is inside a loop.
5. Get the return expression inside the body of the first for loop.
6. Check whether the return expression is an object creation expression.
7. Check whether the object creation expression in the return statement is inside a loop.
8. Get the second for loop in the class.
9. Get the body of the second for loop.
10. Check whether the body of the second for loop contains an object creation expression.
11. If an object creation expression is found, check whether it is inside a loop.
12. Get the local variable declaration inside the body of the second for loop.
13. Check whether the local variable declaration is an array.
14. Get the initializer of the local variable declaration.
15. Check whether the initializer is an object creation expression.
16. Check whether the object creation expression in the initializer is inside a loop.

By performing these granular checks, we can determine whether the test case violates the rule. In this specific test case:

- The first for loop contains a return statement that creates a new array object. However, since the return statement exits the loop, the object creation is not within the loop body in the iterative sense.
- The second for loop contains an object creation expression within its body, but it is immediately followed by a break statement, which exits the loop after the first iteration. Therefore, the object creation is not within the loop body in the iterative sense.

Since neither loop contains an object creation that iteratively violates the rule, the number of violations is 0.
['Get the first for loop in the class.', 'Get the body of the first for loop.', 'Check whether the body of the first for loop contains an object creation expression.', 'If an object creation expression is found, check whether it is inside a loop.', 'Get the return expression inside the body of the first for loop.', 'Check whether the return expression is an object creation expression.', 'Check whether the object creation expression in the return statement is inside a loop.', 'Get the second for loop in the class.', 'Get the body of the second for loop.', 'Check whether the body of the second for loop contains an object creation expression.', 'If an object creation expression is found, check whether it is inside a loop.', 'Get the local variable declaration inside the body of the second for loop.', 'Check whether the local variable declaration is an array.', 'Get the initializer of the local variable declaration.', 'Check whether the initializer is an object creation expression.', 'Check whether the object creation expression in the initializer is inside a loop.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'JavaSemanticErrors', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTStatementExpressionList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTArrayAllocation', 'TypeConversion', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ASTBreakStatement', 'TestFrameworksUtil', 'ASTForUpdate', 'ClassNamesUtil', 'JavaAstUtils', 'ASTArrayType', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTForInit', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'ASTArrayInitializer', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'ASTForStatement']
*Get the first for loop in the class.* 匹配到的元操作或API：
query: Get the first for loop in the class.
most similar API: get first child of for statement
cosine Similarity: 0.8234211206436157
*Get the body of the first for loop.* 匹配到的元操作或API：
query: Get the body of the first for loop.
most similar API: get body of for statement
cosine Similarity: 0.872355043888092
*Check whether the body of the first for loop contains an object creation expression.* 匹配到的元操作或API：
未匹配成功元操作或API
*If an object creation expression is found, check whether it is inside a loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the return expression inside the body of the first for loop.* 匹配到的元操作或API：
logic: Get the return expression inside the body of the first for loop.
most similar meta operation: Get the return expression in return statement
cosine Similarity: 0.8821003437042236
*Check whether the return expression is an object creation expression.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the object creation expression in the return statement is inside a loop.* 匹配到的元操作或API：
query: Check whether the object creation expression in the return statement is inside a loop.
most similar API: Check whether the return statement equals
cosine Similarity: 0.8158668279647827
*Get the second for loop in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the second for loop.* 匹配到的元操作或API：
query: Get the body of the second for loop.
most similar API: get body of for statement
cosine Similarity: 0.8675823211669922
*Check whether the body of the second for loop contains an object creation expression.* 匹配到的元操作或API：
未匹配成功元操作或API
*If an object creation expression is found, check whether it is inside a loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the local variable declaration inside the body of the second for loop.* 匹配到的元操作或API：
query: Get the local variable declaration inside the body of the second for loop.
most similar API: get body of for statement
cosine Similarity: 0.8079923987388611
*Check whether the local variable declaration is an array.* 匹配到的元操作或API：
logic: Check whether the local variable declaration is an array.
most similar meta operation: Check whether the local variable is array type
cosine Similarity: 0.9371558427810669
*Get the initializer of the local variable declaration.* 匹配到的元操作或API：
logic: Get the initializer of the local variable declaration.
most similar meta operation: Get the literal value that the local variable is initialized to
cosine Similarity: 0.8566635251045227
*Check whether the initializer is an object creation expression.* 匹配到的元操作或API：
query: Check whether the initializer is an object creation expression.
most similar API: Check whether the array initializer is expression
cosine Similarity: 0.8724830746650696
*Check whether the object creation expression in the initializer is inside a loop.* 匹配到的元操作或API：
query: Check whether the object creation expression in the initializer is inside a loop.
most similar API: Check whether the array initializer is expression
cosine Similarity: 0.856814980506897
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));

                NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
                arrayAllocations.forEach(allocation -> addViolation(data, allocation));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = body.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}
This checker has passed this negative testcase:
public class AvoidInstantiatingArraysInLoops {
    public static void main(String[] args) {
        for (String arg : args) {
            String[] copy = new String[] { arg };
        }
    }
}


This checker is failed(false positive) on this positive test case:
```
// False positive when array is returned
public class AvoidInstantiatingArraysInLoops {
    public int[] test() {
        for (int i = 0; i < 10; i++) {
            return new int[] { i };
        }

        for (int i = 0; i < 10; i++) {
            int[] a = new int[] { i };
            break;
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'AvoidInstantiatingArraysInLoops')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test')
      ——ASTModifierList
      ——ASTArrayType (method return type = 'int[]')
        ——ASTPrimitiveType (this is a primitive type)
        ——ASTArrayDimensions
          ——ASTArrayTypeDim
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTArrayAllocation
                ——ASTArrayType (this is a primitive type)
                  ——ASTPrimitiveType (this is a primitive type)
                  ——ASTArrayDimensions
                    ——ASTArrayTypeDim
                ——ASTArrayInitializer
                  ——ASTVariableAccess (referenced variable name = 'i')
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayTypeDim
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'a')
                ——ASTArrayAllocation
                  ——ASTArrayType (this is a primitive type)
                    ——ASTPrimitiveType (this is a primitive type)
                    ——ASTArrayDimensions
                      ——ASTArrayTypeDim
                  ——ASTArrayInitializer
                    ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTBreakStatement


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.ast.Node getFirstChild()
2. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
3. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getExpr()
4. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public boolean equals(java.lang.Object)
5. net.sourceforge.pmd.lang.java.ast.ASTArrayInitializer: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.

1.  //Check whether the local variable is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isLocalVariableArrayType(ASTLocalVariableDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```
2.  //Get the literal value that the local variable is initialized to
```java
import net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTLiteral;
import net.sourceforge.pmd.lang.ast.NodeStream;
public ASTLiteral getInitializedValue(ASTLocalVariableDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a local declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTLiteral) {
                    return (ASTLiteral)init;
                }
            }
        }
    }
    return null;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));

                NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
                arrayAllocations.forEach(allocation -> addViolation(data, allocation));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = body.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });

        NodeStream<ASTArrayAllocation> arrayAllocationsInBody = node.getBody().descendants(ASTArrayAllocation.class);
        arrayAllocationsInBody.forEach(allocation -> {
            if (!isPartOfReturnStatement(allocation, node.getBody())) {
                addViolation(data, allocation);
            }
        });

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> {
                if (!isPartOfReturnStatement(allocation, node.getBody())) {
                    addViolation(data, allocation);
                }
            });
        });

        return super.visit(node, data);
    }

    private boolean isPartOfReturnStatement(ASTArrayAllocation allocation, ASTStatement body) {
        NodeStream<ASTReturnStatement> returnStatements = body.descendants(ASTReturnStatement.class);
        for (ASTReturnStatement returnStatement : returnStatements) {
            ASTExpression expr = returnStatement.getExpr();
            if (expr != null && expr.equals(allocation)) {
                return true;
            }
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 13" resulted in wrong number of failures, ==> expected: <0> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 13" resulted in wrong number of failures, ==> expected: <0> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all methods declared in class.
3. Get the name of method.
4. Get the body of method.
5. Get all statements in method body.
6. Check whether the statement is a loop statement.
7. Get the type of loop statement.
8. Get all statements in the loop body.
9. Check whether the statement is a constructor call.
10. Get the type of object created by constructor call.
11. Check whether the object created is an array type.
12. Check whether the statement is a return statement.
13. Get the return expression in return statement.
14. Check whether the return expression is a constructor call.
15. Get the type of object created by constructor call.
16. Check whether the object created is an array type.

Let's apply these granular checks to your test case:

1. Get the name of class.
    - Class name is `AvoidInstantiatingArraysInLoops`.
2. Get all methods declared in class.
    - Methods declared are `test()`.
3. Get the name of method.
    - Method name is `test`.
4. Get the body of method.
    - Method body contains two for loops and a return statement.
5. Get all statements in method body.
6. Check whether the statement is a loop statement.
    - The first loop is a for loop.
    - The second loop is a for loop.
7. Get the type of loop statement.
    - Both are for loops.
8. Get all statements in the loop body.
    - In the first loop, the statement is a return statement.
    - In the second loop, the statement is an assignment statement.
9. Check whether the statement is a constructor call.
    - The return statement in the first loop contains a constructor call.
    - The assignment statement in the second loop does not contain a constructor call.
10. Get the type of object created by constructor call.
    - In the first loop, the type of object is `int[]`.
    - In the second loop, there is no constructor call.
11. Check whether the object created is an array type.
    - In the first loop, the object created is an array type.
    - In the second loop, there is no constructor call.
12. Check whether the statement is a return statement.
    - The statement in the first loop body is a return statement.
    - The statement in the second loop body is not a return statement.
13. Get the return expression in return statement.
    - The return expression in the first loop is `new int[] { i }`.
14. Check whether the return expression is a constructor call.
    - The return expression is a constructor call.
15. Get the type of object created by constructor call.
    - The type of object created by the constructor call is `int[]`.
16. Check whether the object created is an array type.
    - The object created is an array type.

From the above checks, the first loop violates the rule because a new array object is created within the loop body. The second loop does not create a new object within the loop body, so it does not violate the rule.

Therefore, the number of violations in this test case is: 1 (only the first loop).
['Get the name of class.', 'Get all methods declared in class.', 'Get the name of method.', 'Get the body of method.', 'Get all statements in method body.', 'Check whether the statement is a loop statement.', 'Get the type of loop statement.', 'Get all statements in the loop body.', 'Check whether the statement is a constructor call.', 'Get the type of object created by constructor call.', 'Check whether the object created is an array type.', 'Check whether the statement is a return statement.', 'Get the return expression in return statement.', 'Check whether the return expression is a constructor call.', 'Get the type of object created by constructor call.', 'Check whether the object created is an array type.', 'Get the name of class.', 'Get all methods declared in class.', 'Get the name of method.', 'Get the body of method.', 'Get all statements in method body.', 'Check whether the statement is a loop statement.', 'Get the type of loop statement.', 'Get all statements in the loop body.', 'Check whether the statement is a constructor call.', 'Get the type of object created by constructor call.', 'Check whether the object created is an array type.', 'Check whether the statement is a return statement.', 'Get the return expression in return statement.', 'Check whether the return expression is a constructor call.', 'Get the type of object created by constructor call.', 'Check whether the object created is an array type.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'JavaSemanticErrors', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTStatementExpressionList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTArrayAllocation', 'TypeConversion', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ASTBreakStatement', 'TestFrameworksUtil', 'ASTForUpdate', 'ClassNamesUtil', 'JavaAstUtils', 'ASTArrayType', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTForInit', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'ASTArrayInitializer', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'ASTForStatement']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752806425094604
*Get all statements in method body.* 匹配到的元操作或API：
query: Get all statements in method body.
most similar API: get of statement expression list
cosine Similarity: 0.8097154498100281
*Check whether the statement is a loop statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of loop statement.* 匹配到的元操作或API：
query: Get the type of loop statement.
most similar API: get enclosing type of for statement
cosine Similarity: 0.8097243905067444
*Get all statements in the loop body.* 匹配到的元操作或API：
query: Get all statements in the loop body.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8535429239273071
*Check whether the statement is a constructor call.* 匹配到的元操作或API：
query: Check whether the statement is a constructor call.
most similar API: Check whether is call on this instance
cosine Similarity: 0.8083162307739258
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the object created is an array type.* 匹配到的元操作或API：
logic: Check whether the object created is an array type.
most similar meta operation: Check whether the field is array type
cosine Similarity: 0.8790366649627686
*Check whether the statement is a return statement.* 匹配到的元操作或API：
query: Check whether the statement is a return statement.
most similar API: Check whether the return statement equals
cosine Similarity: 0.9054477214813232
*Get the return expression in return statement.* 匹配到的元操作或API：
logic: Get the return expression in return statement.
most similar meta operation: Get the return expression in return statement
cosine Similarity: 0.9881546497344971
*Check whether the return expression is a constructor call.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the object created is an array type.* 匹配到的元操作或API：
logic: Check whether the object created is an array type.
most similar meta operation: Check whether the field is array type
cosine Similarity: 0.8790366649627686
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752806425094604
*Get all statements in method body.* 匹配到的元操作或API：
query: Get all statements in method body.
most similar API: get of statement expression list
cosine Similarity: 0.8097154498100281
*Check whether the statement is a loop statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of loop statement.* 匹配到的元操作或API：
query: Get the type of loop statement.
most similar API: get enclosing type of for statement
cosine Similarity: 0.8097243905067444
*Get all statements in the loop body.* 匹配到的元操作或API：
query: Get all statements in the loop body.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8535429239273071
*Check whether the statement is a constructor call.* 匹配到的元操作或API：
query: Check whether the statement is a constructor call.
most similar API: Check whether is call on this instance
cosine Similarity: 0.8083162307739258
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the object created is an array type.* 匹配到的元操作或API：
logic: Check whether the object created is an array type.
most similar meta operation: Check whether the field is array type
cosine Similarity: 0.8790366649627686
*Check whether the statement is a return statement.* 匹配到的元操作或API：
query: Check whether the statement is a return statement.
most similar API: Check whether the return statement equals
cosine Similarity: 0.9054477214813232
*Get the return expression in return statement.* 匹配到的元操作或API：
logic: Get the return expression in return statement.
most similar meta operation: Get the return expression in return statement
cosine Similarity: 0.9881546497344971
*Check whether the return expression is a constructor call.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the object created is an array type.* 匹配到的元操作或API：
logic: Check whether the object created is an array type.
most similar meta operation: Check whether the field is array type
cosine Similarity: 0.8790366649627686
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));

                NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
                arrayAllocations.forEach(allocation -> addViolation(data, allocation));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = body.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}
This checker has passed this negative testcase:
public class AvoidInstantiatingArraysInLoops {
    public static void main(String[] args) {
        for (String arg : args) {
            String[] copy = new String[] { arg };
        }
    }
}


This checker is failed(false positive) on this positive test case:
```
// False positive when array is returned
public class AvoidInstantiatingArraysInLoops {
    public int[] test() {
        for (int i = 0; i < 10; i++) {
            return new int[] { i };
        }

        for (int i = 0; i < 10; i++) {
            int[] a = new int[] { i };
            break;
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'AvoidInstantiatingArraysInLoops')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test')
      ——ASTModifierList
      ——ASTArrayType (method return type = 'int[]')
        ——ASTPrimitiveType (this is a primitive type)
        ——ASTArrayDimensions
          ——ASTArrayTypeDim
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTArrayAllocation
                ——ASTArrayType (this is a primitive type)
                  ——ASTPrimitiveType (this is a primitive type)
                  ——ASTArrayDimensions
                    ——ASTArrayTypeDim
                ——ASTArrayInitializer
                  ——ASTVariableAccess (referenced variable name = 'i')
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayTypeDim
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'a')
                ——ASTArrayAllocation
                  ——ASTArrayType (this is a primitive type)
                    ——ASTPrimitiveType (this is a primitive type)
                    ——ASTArrayDimensions
                      ——ASTArrayTypeDim
                  ——ASTArrayInitializer
                    ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTBreakStatement


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
5. net.sourceforge.pmd.lang.java.ast.ASTStatementExpressionList: public N get(int), //@throws IndexOutOfBoundsException if not in range
6. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType(), //Returns the node representing the type declaration this node is found in. The type of that node is the type of the {@code this} expression. <p>This returns null for nodes that aren't enclosed in a type declaration. This includes {@linkplain ASTPackageDeclaration PackageDeclaration}, This includes {@linkplain ASTImportDeclaration ImportDeclaration}, {@linkplain ASTModuleDeclaration ModuleDeclaration}, {@linkplain ASTCompilationUnit CompilationUnit}, and top-level {@linkplain ASTAnyTypeDeclaration AnyTypeDeclaration}s.
7. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
8. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isCallOnThisInstance(net.sourceforge.pmd.lang.java.ast.ASTMethodCall)
9. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
10. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public boolean equals(java.lang.Object)
11. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getExpr()

1.  //Check whether the field is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isFieldArrayType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));

                NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
                arrayAllocations.forEach(allocation -> addViolation(data, allocation));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = body.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTArrayAllocation node, Object data) {
        if (node.getFirstParentOfType(ASTForStatement.class) != null ||
            node.getFirstParentOfType(ASTWhileStatement.class) != null ||
            node.getFirstParentOfType(ASTDoStatement.class) != null ||
            node.getFirstParentOfType(ASTForeachStatement.class) != null) {
            ASTStatement parentStatement = node.getFirstParentOfType(ASTStatement.class);
            if (!(parentStatement instanceof ASTReturnStatement)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        if (node.getFirstParentOfType(ASTForStatement.class) != null ||
            node.getFirstParentOfType(ASTWhileStatement.class) != null ||
            node.getFirstParentOfType(ASTDoStatement.class) != null ||
            node.getFirstParentOfType(ASTForeachStatement.class) != null) {
            ASTStatement parentStatement = node.getFirstParentOfType(ASTStatement.class);
            if (!(parentStatement instanceof ASTReturnStatement)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 13" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 13" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
To ascertain whether the test case adheres to the rule "New objects can not be created within loops," we will perform the following granular checks:

1. Get the name of method.
2. Get the body of method.
3. Get all loop statements in the method body.
4. For each loop statement, get the loop body.
5. Check whether there is a constructor call in the loop body.
6. If there is a constructor call, get the type of object created by constructor call.
7. Get all return statements in the loop body.
8. Check whether there is an array creation expression in the return statement.
9. If there is an array creation expression, check whether it is directly returned.
10. Get all local variable declarations in the loop body.
11. Check whether there is an array creation expression in the local variable declaration.
12. If there is an array creation expression in the local variable declaration, check whether it is followed by a break statement.

Let's apply these checks to the provided test case:

1. Get the name of method.
        - The method name is `test`.

2. Get the body of method.
        - The body contains two `for` loops.

3. Get all loop statements in the method body.
        - The loop statements are:
          ```java
          for (int i = 0; i < 10; i++) {
              return new int[] { i };
          }
          ```
          and
          ```java
          for (int i = 0; i < 10; i++) {
              int[] a = new int[] { i };
              break;
          }
          ```

4. For each loop statement, get the loop body.
        - Loop body of the first loop:
          ```java
          return new int[] { i };
          ```
        - Loop body of the second loop:
          ```java
          int[] a = new int[] { i };
          break;
          ```

5. Check whether there is a constructor call in the loop body.
        - There are no constructor calls in the loop bodies.

6. If there is a constructor call, get the type of object created by constructor call.
        - Not applicable as there are no constructor calls.

7. Get all return statements in the loop body.
        - The first loop has a return statement:
          ```java
          return new int[] { i };
          ```
        - The second loop does not have a return statement.

8. Check whether there is an array creation expression in the return statement.
        - The return statement in the first loop contains an array creation expression:
          ```java
          new int[] { i };
          ```

9. If there is an array creation expression, check whether it is directly returned.
        - In the first loop, the array creation expression is directly returned.

10. Get all local variable declarations in the loop body.
        - The second loop has a local variable declaration:
          ```java
          int[] a = new int[] { i };
          ```

11. Check whether there is an array creation expression in the local variable declaration.
        - The local variable declaration in the second loop contains an array creation expression:
          ```java
          new int[] { i };
          ```

12. If there is an array creation expression in the local variable declaration, check whether it is followed by a break statement.
        - In the second loop, the array creation expression is followed by a `break` statement.

Based on the above checks, the test case does not violate the rule because:

- In the first loop, the array creation expression is directly returned, which is not considered a new object being created within the loop for the purpose of this rule.
- In the second loop, the array creation expression is followed by a `break` statement, which exits the loop after the first iteration, effectively not creating a new object in subsequent iterations.

Therefore, the number of violations of the rule in this test case is 0.
['Get the name of method.', 'Get the body of method.', 'Get all loop statements in the method body.', 'For each loop statement, get the loop body.', 'Check whether there is a constructor call in the loop body.', 'If there is a constructor call, get the type of object created by constructor call.', 'Get all return statements in the loop body.', 'Check whether there is an array creation expression in the return statement.', 'If there is an array creation expression, check whether it is directly returned.', 'Get all local variable declarations in the loop body.', 'Check whether there is an array creation expression in the local variable declaration.', 'If there is an array creation expression in the local variable declaration, check whether it is followed by a break statement.', 'Get the name of method.', 'Get the body of method.', 'Get all loop statements in the method body.', 'For each loop statement, get the loop body.', 'Check whether there is a constructor call in the loop body.', 'If there is a constructor call, get the type of object created by constructor call.', 'Get all return statements in the loop body.', 'Check whether there is an array creation expression in the return statement.', 'If there is an array creation expression, check whether it is directly returned.', 'Get all local variable declarations in the loop body.', 'Check whether there is an array creation expression in the local variable declaration.', 'If there is an array creation expression in the local variable declaration, check whether it is followed by a break statement.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'JavaSemanticErrors', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTStatementExpressionList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTArrayAllocation', 'TypeConversion', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ASTBreakStatement', 'TestFrameworksUtil', 'ASTForUpdate', 'ClassNamesUtil', 'JavaAstUtils', 'ASTArrayType', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTForInit', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'ASTArrayInitializer', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'ASTForStatement']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752806425094604
*Get all loop statements in the method body.* 匹配到的元操作或API：
query: Get all loop statements in the method body.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8223956823348999
*For each loop statement, get the loop body.* 匹配到的元操作或API：
query: For each loop statement, get the loop body.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8959190249443054
*Check whether there is a constructor call in the loop body.* 匹配到的元操作或API：
未匹配成功元操作或API
*If there is a constructor call, get the type of object created by constructor call.* 匹配到的元操作或API：
logic: If there is a constructor call, get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9758976697921753
*Get all return statements in the loop body.* 匹配到的元操作或API：
query: Get all return statements in the loop body.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8168071508407593
*Check whether there is an array creation expression in the return statement.* 匹配到的元操作或API：
query: Check whether there is an array creation expression in the return statement.
most similar API: Check whether the array allocation is expression
cosine Similarity: 0.8267906308174133
*If there is an array creation expression, check whether it is directly returned.* 匹配到的元操作或API：
query: If there is an array creation expression, check whether it is directly returned.
most similar API: Check whether the array allocation is expression
cosine Similarity: 0.8436121940612793
*Get all local variable declarations in the loop body.* 匹配到的元操作或API：
query: Get all local variable declarations in the loop body.
most similar API: get declared annotations of local variable
cosine Similarity: 0.8413324356079102
*Check whether there is an array creation expression in the local variable declaration.* 匹配到的元操作或API：
logic: Check whether there is an array creation expression in the local variable declaration.
most similar meta operation: Check whether the local variable is array type
cosine Similarity: 0.8711307048797607
*If there is an array creation expression in the local variable declaration, check whether it is followed by a break statement.* 匹配到的元操作或API：
query: If there is an array creation expression in the local variable declaration, check whether it is followed by a break statement.
most similar API: Check whether the array allocation is expression
cosine Similarity: 0.8021177053451538
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752806425094604
*Get all loop statements in the method body.* 匹配到的元操作或API：
query: Get all loop statements in the method body.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8223956823348999
*For each loop statement, get the loop body.* 匹配到的元操作或API：
query: For each loop statement, get the loop body.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8959190249443054
*Check whether there is a constructor call in the loop body.* 匹配到的元操作或API：
未匹配成功元操作或API
*If there is a constructor call, get the type of object created by constructor call.* 匹配到的元操作或API：
logic: If there is a constructor call, get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9758976697921753
*Get all return statements in the loop body.* 匹配到的元操作或API：
query: Get all return statements in the loop body.
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8168071508407593
*Check whether there is an array creation expression in the return statement.* 匹配到的元操作或API：
query: Check whether there is an array creation expression in the return statement.
most similar API: Check whether the array allocation is expression
cosine Similarity: 0.8267906308174133
*If there is an array creation expression, check whether it is directly returned.* 匹配到的元操作或API：
query: If there is an array creation expression, check whether it is directly returned.
most similar API: Check whether the array allocation is expression
cosine Similarity: 0.8436121940612793
*Get all local variable declarations in the loop body.* 匹配到的元操作或API：
query: Get all local variable declarations in the loop body.
most similar API: get declared annotations of local variable
cosine Similarity: 0.8413324356079102
*Check whether there is an array creation expression in the local variable declaration.* 匹配到的元操作或API：
logic: Check whether there is an array creation expression in the local variable declaration.
most similar meta operation: Check whether the local variable is array type
cosine Similarity: 0.8711307048797607
*If there is an array creation expression in the local variable declaration, check whether it is followed by a break statement.* 匹配到的元操作或API：
query: If there is an array creation expression in the local variable declaration, check whether it is followed by a break statement.
most similar API: Check whether the array allocation is expression
cosine Similarity: 0.8021177053451538
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: New objects can not be created within loops;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));

                NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
                arrayAllocations.forEach(allocation -> addViolation(data, allocation));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = body.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}
This checker has passed this negative testcase:
public class AvoidInstantiatingArraysInLoops {
    public static void main(String[] args) {
        for (String arg : args) {
            String[] copy = new String[] { arg };
        }
    }
}


This checker is failed(false positive) on this positive test case:
```
// False positive when array is returned
public class AvoidInstantiatingArraysInLoops {
    public int[] test() {
        for (int i = 0; i < 10; i++) {
            return new int[] { i };
        }

        for (int i = 0; i < 10; i++) {
            int[] a = new int[] { i };
            break;
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'AvoidInstantiatingArraysInLoops')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'test')
      ——ASTModifierList
      ——ASTArrayType (method return type = 'int[]')
        ——ASTPrimitiveType (this is a primitive type)
        ——ASTArrayDimensions
          ——ASTArrayTypeDim
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTArrayAllocation
                ——ASTArrayType (this is a primitive type)
                  ——ASTPrimitiveType (this is a primitive type)
                  ——ASTArrayDimensions
                    ——ASTArrayTypeDim
                ——ASTArrayInitializer
                  ——ASTVariableAccess (referenced variable name = 'i')
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayTypeDim
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'a')
                ——ASTArrayAllocation
                  ——ASTArrayType (this is a primitive type)
                    ——ASTPrimitiveType (this is a primitive type)
                    ——ASTArrayDimensions
                      ——ASTArrayTypeDim
                  ——ASTArrayInitializer
                    ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTBreakStatement


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
3. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
5. net.sourceforge.pmd.lang.java.ast.ASTArrayAllocation: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
6. net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()

1.  //Check whether the local variable is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isLocalVariableArrayType(ASTLocalVariableDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ASTWhileStatement.class, ASTForStatement.class, ASTForeachStatement.class, ASTDoStatement.class);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock) {
            NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = ((ASTBlock) body).descendants(ASTLocalVariableDeclaration.class);
            localVariableDeclarations.forEach(declaration -> {
                NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
                constructorCalls.forEach(call -> addViolation(data, call));

                NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
                arrayAllocations.forEach(allocation -> addViolation(data, allocation));
            });
        } else if (body instanceof ASTLocalVariableDeclaration) {
            NodeStream<ASTConstructorCall> constructorCalls = body.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = body.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        }

        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        NodeStream<ASTConstructorCall> constructorCallsInCondition = node.getCondition().descendants(ASTConstructorCall.class);
        constructorCallsInCondition.forEach(call -> addViolation(data, call));

        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        NodeStream<ASTLocalVariableDeclaration> localVariableDeclarations = node.getBody().descendants(ASTLocalVariableDeclaration.class);
        localVariableDeclarations.forEach(declaration -> {
            NodeStream<ASTConstructorCall> constructorCalls = declaration.descendants(ASTConstructorCall.class);
            constructorCalls.forEach(call -> addViolation(data, call));

            NodeStream<ASTArrayAllocation> arrayAllocations = declaration.descendants(ASTArrayAllocation.class);
            arrayAllocations.forEach(allocation -> addViolation(data, allocation));
        });
        return super.visit(node, data);
    }

    private boolean isLocalVariableArrayType(ASTLocalVariableDeclaration node) {
        ASTType type = node.getTypeNode();
        return type.getTypeMirror().isArray();
    }

    @Override
    public Object visit(ASTArrayAllocation node, Object data) {
        ASTNode parent = node.getParent();
        if (parent instanceof ASTLocalVariableDeclaration && isLocalVariableArrayType((ASTLocalVariableDeclaration) parent)) {
            ASTNode grandParent = parent.getParent();
            if (grandParent instanceof ASTBlock) {
                ASTNode loopNode = grandParent.getParent();
                if (loopNode instanceof ASTWhileStatement || loopNode instanceof ASTDoStatement || loopNode instanceof ASTForStatement || loopNode instanceof ASTForeachStatement) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 13
测试用例全部通过
最终通过 17 个测试用例
正例 11 个
反例 6 个
输入token：1090031
输出token：756953
结束

规则执行完毕，时间总花销： 6040.068593263626 秒
