开始

========================================== Rule BrokenNullCheckRule ===========================================
一共 25 个测试用例
正例 15 个
反例 10 个
2455
1976
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the method name.
        2. Get the condition of if statement.
        3. Check whether the condition is an infix expression.
        4. Get the operator of infix expression.
        5. Check whether the operator in infix expression is ||.
        6. Get the left operand of infix expression.
        7. Check whether the left operand is an inequality expression.
        8. Get the right operand of inequality expression.
        9. Check whether the right operand is a literal value.
        10. Get the literal value that the right operand is initialized to.
        11. Check whether the literal value is null.
        12. Get the right operand of infix expression.
        13. Check whether the right operand is a method call.
        14. Get the name of called method.
        15. Check whether the called method name is equals.
        16. Get the method caller.
        17. Check whether the method caller is the same operand as the left operand of the infix expression (i.e., the variable `list`).

If steps 11, 13, 14, and 15 are true, and the method caller (`list`) is the same as the left operand of the infix expression, this indicates a broken null check because `list.equals(buz)` will throw a `NullPointerException` if `list` is `null`. Then, this test case violates the rule.
['Get the method name.', 'Get the condition of if statement.', 'Check whether the condition is an infix expression.', 'Get the operator of infix expression.', 'Check whether the operator in infix expression is ||.', 'Get the left operand of infix expression.', 'Check whether the left operand is an inequality expression.', 'Get the right operand of inequality expression.', 'Check whether the right operand is a literal value.', 'Get the literal value that the right operand is initialized to.', 'Check whether the literal value is null.', 'Get the right operand of infix expression.', 'Check whether the right operand is a method call.', 'Get the name of called method.', 'Check whether the called method name is equals.', 'Get the method caller.', 'Check whether the method caller is the same operand as the left operand of the infix expression (i.e., the variable `list`).']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTFieldDeclaration', 'ASTFormalParameter', 'ASTMethodDeclaration', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'ASTNullLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the method name.* 匹配到的元操作或API：
logic: Get the method name.
most similar meta operation: Get the name of method
cosine Similarity: 0.9567613005638123
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Check whether the condition is an infix expression.* 匹配到的元操作或API：
logic: Check whether the condition is an infix expression.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9103512763977051
*Get the operator of infix expression.* 匹配到的元操作或API：
logic: Get the operator of infix expression.
most similar meta operation: Get the operator of infix expression
cosine Similarity: 0.9891121983528137
*Check whether the operator in infix expression is ||.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is ||.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9215893149375916
*Get the left operand of infix expression.* 匹配到的元操作或API：
logic: Get the left operand of infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9903916120529175
*Check whether the left operand is an inequality expression.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the right operand of inequality expression.* 匹配到的元操作或API：
logic: Get the right operand of inequality expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.8709957599639893
*Check whether the right operand is a literal value.* 匹配到的元操作或API：
query: Check whether the right operand is a literal value.
most similar API: Check whether is literal int
cosine Similarity: 0.8313963413238525
*Get the literal value that the right operand is initialized to.* 匹配到的元操作或API：
logic: Get the literal value that the right operand is initialized to.
most similar meta operation: Get the literal value that the local variable is initialized to
cosine Similarity: 0.8818901777267456
*Check whether the literal value is null.* 匹配到的元操作或API：
query: Check whether the literal value is null.
most similar API: Check whether is null literal
cosine Similarity: 0.93576979637146
*Get the right operand of infix expression.* 匹配到的元操作或API：
logic: Get the right operand of infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9884670972824097
*Check whether the right operand is a method call.* 匹配到的元操作或API：
query: Check whether the right operand is a method call.
most similar API: Check whether the method call equals
cosine Similarity: 0.8639539480209351
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9280144572257996
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796932339668274
*Check whether the method caller is the same operand as the left operand of the infix expression (i.e., the variable `list`).* 匹配到的元操作或API：
query: Check whether the method caller is the same operand as the left operand of the infix expression (i.e., the variable `list`).
most similar API: get left operand of infix expression
cosine Similarity: 0.8010659217834473
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
The test case corresponding to the rule:
```
// should be &&
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'buz')
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'Object')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'list')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'list')
              ——ASTNullLiteral
            ——ASTUnaryExpression
              ——ASTMethodCall (called method name = 'equals')
                ——ASTVariableAccess (referenced variable name = 'list')
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'buz')
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTVariableAccess (referenced variable name = 'list')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
3. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.BinaryOp getOperator()
4. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLeftOperand()
5. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
6. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isLiteralInt(net.sourceforge.pmd.lang.java.ast.JavaNode, int), //Returns true if this is a numeric literal with the given int value. This also considers long literals.
7. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isNullLiteral(net.sourceforge.pmd.lang.java.ast.ASTExpression)
8. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
9. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
10. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
11. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()
12. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLeftOperand(), //Returns the left-hand-side operand.

1.  //Check whether the operator in infix expression is ''
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils;
public boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op){
    //enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
    return JavaAstUtils.isInfixExprWithOperator(node, op);
}
```
2.  //Get the literal value that the local variable is initialized to
```java
import net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTLiteral;
import net.sourceforge.pmd.lang.ast.NodeStream;
public ASTLiteral getInitializedValue(ASTLocalVariableDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a local declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTLiteral) {
                    return (ASTLiteral)init;
                }
            }
        }
    }
    return null;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            BinaryOp operator = infixExpression.getOperator();
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR) || isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isPotentialNullCheck(leftOperand, rightOperand) || isPotentialNullCheck(rightOperand, leftOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    //Check whether the operator in infix expression is ''
    public boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isPotentialNullCheck(ASTExpression nullCheck, ASTExpression methodCall) {
        return JavaAstUtils.isNullLiteral(nullCheck) && methodCall instanceof ASTUnaryExpression &&
                ((ASTUnaryExpression) methodCall).getOperand() instanceof ASTMethodCall &&
                isMethodCallOnNonNullObject((ASTMethodCall) ((ASTUnaryExpression) methodCall).getOperand());
    }

    private boolean isMethodCallOnNonNullObject(ASTMethodCall methodCall) {
        return methodCall.getQualifier() instanceof ASTVariableAccess &&
                !methodCall.getQualifier().getImage().equals("null") &&
                "equals".equals(methodCall.getMethodName());
    }

    //Get the literal value that the local variable is initialized to
    public ASTLiteral getInitializedValue(ASTLocalVariableDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            // a local declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the condition of if statement.
        2. Get the left operand of the assignment expression in the condition.
        3. Check whether the operator in infix expression is !=.
        4. Get the right operand of the assignment expression in the condition.
        5. Check whether the right operand is a string literal "null".
        6. Get the right operand of the assignment expression in the condition.
        7. Check whether the operator in infix expression is ||.
        8. Get the right operand of the assignment expression in the condition.
        9. Check whether the right operand is a method call.
        10. Get the name of called method.
        11. Check whether the name of called method is equals.
        12. Check whether the method call has a negation operator !.
        If the condition of the if statement uses != and ||, and the right operand of the condition is a negated method call to equals, then this test case violates the rule.
            
['Get the condition of if statement.', 'Get the left operand of the assignment expression in the condition.', 'Check whether the operator in infix expression is !=.', 'Get the right operand of the assignment expression in the condition.', 'Check whether the right operand is a string literal "null".', 'Get the right operand of the assignment expression in the condition.', 'Check whether the operator in infix expression is ||.', 'Get the right operand of the assignment expression in the condition.', 'Check whether the right operand is a method call.', 'Get the name of called method.', 'Check whether the name of called method is equals.', 'Check whether the method call has a negation operator !.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTFieldDeclaration', 'ASTFormalParameter', 'ASTMethodDeclaration', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'ASTNullLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Get the left operand of the assignment expression in the condition.* 匹配到的元操作或API：
logic: Get the left operand of the assignment expression in the condition.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.9679614901542664
*Check whether the operator in infix expression is !=.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is !=.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9049140810966492
*Get the right operand of the assignment expression in the condition.* 匹配到的元操作或API：
logic: Get the right operand of the assignment expression in the condition.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.9581664800643921
*Check whether the right operand is a string literal "null".* 匹配到的元操作或API：
query: Check whether the right operand is a string literal "null".
most similar API: Check whether the null literal is string literal
cosine Similarity: 0.8903626203536987
*Get the right operand of the assignment expression in the condition.* 匹配到的元操作或API：
logic: Get the right operand of the assignment expression in the condition.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.9581664800643921
*Check whether the operator in infix expression is ||.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is ||.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9215893149375916
*Get the right operand of the assignment expression in the condition.* 匹配到的元操作或API：
logic: Get the right operand of the assignment expression in the condition.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.9581664800643921
*Check whether the right operand is a method call.* 匹配到的元操作或API：
query: Check whether the right operand is a method call.
most similar API: Check whether the method call equals
cosine Similarity: 0.8639539480209351
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the name of called method is equals.* 匹配到的元操作或API：
query: Check whether the name of called method is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9213377237319946
*Check whether the method call has a negation operator !.* 匹配到的元操作或API：
query: Check whether the method call has a negation operator !.
most similar API: Check whether is boolean negation
cosine Similarity: 0.8236510157585144
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
The test case corresponding to the rule:
```
// should be &&
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'buz')
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'Object')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'list')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'list')
              ——ASTNullLiteral
            ——ASTUnaryExpression
              ——ASTMethodCall (called method name = 'equals')
                ——ASTVariableAccess (referenced variable name = 'list')
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'buz')
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTVariableAccess (referenced variable name = 'list')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr getLeftOperand()
3. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
4. net.sourceforge.pmd.lang.java.ast.ASTNullLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
5. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
7. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isBooleanNegation(net.sourceforge.pmd.lang.java.ast.JavaNode)

1.  //Check whether the operator in infix expression is ''
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils;
public boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op){
    //enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
    return JavaAstUtils.isInfixExprWithOperator(node, op);
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.List;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                List<ASTExpression> operands = infixExpression.getOperands();
                for (ASTExpression operand : operands) {
                    if (operand instanceof ASTInfixExpression) {
                        ASTInfixExpression subInfixExpression = (ASTInfixExpression) operand;
                        if (isInfixExpressionWithOperator(subInfixExpression, BinaryOp.NE)) {
                            List<ASTExpression> subOperands = subInfixExpression.getOperands();
                            if (subOperands.get(0) instanceof ASTVariableAccess && subOperands.get(1) instanceof ASTNullLiteral) {
                                ASTVariableAccess variableAccess = (ASTVariableAccess) subOperands.get(0);
                                String variableName = variableAccess.getName();
                                ASTMethodCall methodCall = JavaAstUtils.findMethodCallInExpr(infixExpression, "equals");
                                if (methodCall != null && methodCall.getFirstChildOfType(ASTVariableAccess.class).getName().equals(variableName)) {
                                    addViolation(data, node);
                                }
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    public enum BinaryOp {
        CONDITIONAL_OR("||"),
        CONDITIONAL_AND("&&"),
        OR("|"),
        XOR("^"),
        AND("&"),
        EQ("=="),
        NE("!="),
        LE("<="),
        GE(">="),
        GT(">"),
        LT("<"),
        INSTANCEOF("instanceof"),
        LEFT_SHIFT("<<"),
        RIGHT_SHIFT(">>"),
        UNSIGNED_RIGHT_SHIFT(">>>"),
        ADD("+"),
        SUB("-"),
        MUL("*"),
        DIV("/"),
        MOD("%");

        private final String op;

        BinaryOp(String op) {
            this.op = op;
        }

        @Override
        public String toString() {
            return op;
        }
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the condition of if statement.
2. Check whether the condition is an infix expression.
3. Get the operator of infix expression.
4. Check whether the operator in infix expression is ||.
5. Get the left operand of infix expression.
6. Check whether the left operand is a method call.
7. Get the name of called method.
8. Check whether the name is equals.
9. Get the method caller.
10. Check whether the method caller is a field access.
11. Get the name of accessed field.
12. Check whether the name is buz.
13. Get the right operand of infix expression.
14. Check whether the right operand is a method call.
15. Get the name of called method.
16. Check whether the name is equals.
17. Get the method caller.
18. Check whether the method caller is a parameter.
19. Get the name of parameter.
20. Check whether the name is list.
21. Check whether the parameter is being read.
22. Check whether the parameter is being written.
23. Get the right operand of first infix expression.
24. Check whether the right operand is a not expression.
25. Get the operand of not expression.
26. Check whether the operand is a method call.
27. Get the name of called method.
28. Check whether the name is equals.
29. Get the method caller.
30. Check whether the method caller is a parameter.
31. Get the name of parameter.
32. Check whether the name is list.
33. Check whether the parameter is being read.
34. Check whether the parameter is being written.

If the condition of the if statement is an infix expression with the operator ||, and the left operand is a method call to `equals` on a field `buz`, and the right operand is a not expression containing a method call to `equals` on a parameter `list`, then this test case violates the rule. The correct operator should be && to prevent a NullPointerException.
            
['Get the condition of if statement.', 'Check whether the condition is an infix expression.', 'Get the operator of infix expression.', 'Check whether the operator in infix expression is ||.', 'Get the left operand of infix expression.', 'Check whether the left operand is a method call.', 'Get the name of called method.', 'Check whether the name is equals.', 'Get the method caller.', 'Check whether the method caller is a field access.', 'Get the name of accessed field.', 'Check whether the name is buz.', 'Get the right operand of infix expression.', 'Check whether the right operand is a method call.', 'Get the name of called method.', 'Check whether the name is equals.', 'Get the method caller.', 'Check whether the method caller is a parameter.', 'Get the name of parameter.', 'Check whether the name is list.', 'Check whether the parameter is being read.', 'Check whether the parameter is being written.', 'Get the right operand of first infix expression.', 'Check whether the right operand is a not expression.', 'Get the operand of not expression.', 'Check whether the operand is a method call.', 'Get the name of called method.', 'Check whether the name is equals.', 'Get the method caller.', 'Check whether the method caller is a parameter.', 'Get the name of parameter.', 'Check whether the name is list.', 'Check whether the parameter is being read.', 'Check whether the parameter is being written.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTFieldDeclaration', 'ASTFormalParameter', 'ASTMethodDeclaration', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'ASTNullLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Check whether the condition is an infix expression.* 匹配到的元操作或API：
logic: Check whether the condition is an infix expression.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9103512763977051
*Get the operator of infix expression.* 匹配到的元操作或API：
logic: Get the operator of infix expression.
most similar meta operation: Get the operator of infix expression
cosine Similarity: 0.9891121983528137
*Check whether the operator in infix expression is ||.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is ||.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9215893149375916
*Get the left operand of infix expression.* 匹配到的元操作或API：
logic: Get the left operand of infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9903916120529175
*Check whether the left operand is a method call.* 匹配到的元操作或API：
query: Check whether the left operand is a method call.
most similar API: Check whether the method call is expression
cosine Similarity: 0.8237406015396118
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the name is equals.* 匹配到的元操作或API：
query: Check whether the name is equals.
most similar API: Check whether the field equals
cosine Similarity: 0.8173662424087524
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796932339668274
*Check whether the method caller is a field access.* 匹配到的元操作或API：
query: Check whether the method caller is a field access.
most similar API: Check whether is this field access
cosine Similarity: 0.8332379460334778
*Get the name of accessed field.* 匹配到的元操作或API：
logic: Get the name of accessed field.
most similar meta operation: Get the name of field
cosine Similarity: 0.8872999548912048
*Check whether the name is buz.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the right operand of infix expression.* 匹配到的元操作或API：
logic: Get the right operand of infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9884670972824097
*Check whether the right operand is a method call.* 匹配到的元操作或API：
query: Check whether the right operand is a method call.
most similar API: Check whether the method call equals
cosine Similarity: 0.8639539480209351
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the name is equals.* 匹配到的元操作或API：
query: Check whether the name is equals.
most similar API: Check whether the field equals
cosine Similarity: 0.8173662424087524
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796932339668274
*Check whether the method caller is a parameter.* 匹配到的元操作或API：
logic: Check whether the method caller is a parameter.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.8507368564605713
*Get the name of parameter.* 匹配到的元操作或API：
logic: Get the name of parameter.
most similar meta operation: Get the name of formal parameter
cosine Similarity: 0.8852279782295227
*Check whether the name is list.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the parameter is being read.* 匹配到的元操作或API：
query: Check whether the parameter is being read.
most similar API: Check whether has parameters
cosine Similarity: 0.8070535659790039
*Check whether the parameter is being written.* 匹配到的元操作或API：
query: Check whether the parameter is being written.
most similar API: Check whether has parameters
cosine Similarity: 0.8148900866508484
*Get the right operand of first infix expression.* 匹配到的元操作或API：
logic: Get the right operand of first infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9607837200164795
*Check whether the right operand is a not expression.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the operand of not expression.* 匹配到的元操作或API：
query: Get the operand of not expression.
most similar API: get operand of unary expression
cosine Similarity: 0.8279529213905334
*Check whether the operand is a method call.* 匹配到的元操作或API：
query: Check whether the operand is a method call.
most similar API: Check whether the method call is expression
cosine Similarity: 0.8564256429672241
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the name is equals.* 匹配到的元操作或API：
query: Check whether the name is equals.
most similar API: Check whether the field equals
cosine Similarity: 0.8173662424087524
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796932339668274
*Check whether the method caller is a parameter.* 匹配到的元操作或API：
logic: Check whether the method caller is a parameter.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.8507368564605713
*Get the name of parameter.* 匹配到的元操作或API：
logic: Get the name of parameter.
most similar meta operation: Get the name of formal parameter
cosine Similarity: 0.8852279782295227
*Check whether the name is list.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the parameter is being read.* 匹配到的元操作或API：
query: Check whether the parameter is being read.
most similar API: Check whether has parameters
cosine Similarity: 0.8070535659790039
*Check whether the parameter is being written.* 匹配到的元操作或API：
query: Check whether the parameter is being written.
most similar API: Check whether has parameters
cosine Similarity: 0.8148900866508484
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
The test case corresponding to the rule:
```
// should be &&
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'buz')
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'Object')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'list')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'list')
              ——ASTNullLiteral
            ——ASTUnaryExpression
              ——ASTMethodCall (called method name = 'equals')
                ——ASTVariableAccess (referenced variable name = 'list')
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'buz')
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTVariableAccess (referenced variable name = 'list')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.BinaryOp getOperator()
3. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLeftOperand()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
5. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
6. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean equals(java.lang.Object)
7. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()
8. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isThisFieldAccess(net.sourceforge.pmd.lang.java.ast.ASTExpression), //Whether the expression is an access to a field of this instance, not inherited, qualified or not ({@code this.field} or just {@code field}).
9. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
10. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
11. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean hasParameters(net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration, [Ljava.lang.Class;)
12. net.sourceforge.pmd.lang.java.ast.ASTUnaryExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getOperand(), //Returns the expression nested within this expression.

1.  //Check whether the operator in infix expression is ''
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils;
public boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op){
    //enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
    return JavaAstUtils.isInfixExprWithOperator(node, op);
}
```
2.  //Get the name of field
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.ast.NodeStream;
public String getFieldName(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId variableDeclaratorId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(variableDeclaratorId.getName().equals("x")){
            String variableName = variableDeclaratorId.getName();
            return variableName;
        }
    }
    return null;
}
```
3.  //Check whether the method caller is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallerStringType(ASTMethodCall node){
    return TypeTestUtil.isA(String.class, node.getQualifier());
}
```
4.  //Get the name of formal parameter
```java
import net.sourceforge.pmd.lang.java.ast.*;
public String getFormalParameterName(ASTFormalParameter node) {
    return node.getVarId().getName();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        // enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && infixExpression.getRightOperand() instanceof ASTNullLiteral;
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            return methodCall.getMethodName().equals("equals") && methodCall.getQualifier() instanceof ASTVariableAccess;
        }
        return false;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
True
此测试用例生成了first checker: bad 1


======================接下来开始迭代=====================
[ERROR]   "bad 2" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
97
81
114
98
=========================error_testcase_logics=========================
1. Get the name of the method.
2. Get the signature of the method.
3. Get the body of the method.
4. Get the number of conditional statements in the method body.
5. Get the first conditional statement in the method body.
6. Get the condition of the if statement.
7. Get the number of operands in the condition.
8. Get the first operand in the condition.
9. Get the operator of the first operand.
10. Check whether the operator in the first operand is a method call.
11. Get the name of the called method in the first operand.
12. Get the second operand in the condition.
13. Get the operator of the second operand.
14. Check whether the operator in the second operand is a method call.
15. Get the name of the called method in the second operand.
16. Check whether the first operand is a null check.
17. Check whether the operator in the condition is a logical OR (||).
18. Check whether the second operand contains a method call that accesses a field or method of the object being checked for null.

In this test case:
- The first operand is `books.getJane() != null`, which is a null check.
- The operator in the condition is `||`, a logical OR.
- The second operand is `!books.getJane().equals("")`, which contains a method call that accesses a field or method of the object being checked for null.

Therefore, the null check is broken since it will throw a NullPointerException itself due to the use of `||` instead of `&&`. The number of violations of the rule in this test case is: 1.
['Get the name of the method.', 'Get the signature of the method.', 'Get the body of the method.', 'Get the number of conditional statements in the method body.', 'Get the first conditional statement in the method body.', 'Get the condition of the if statement.', 'Get the number of operands in the condition.', 'Get the first operand in the condition.', 'Get the operator of the first operand.', 'Check whether the operator in the first operand is a method call.', 'Get the name of the called method in the first operand.', 'Get the second operand in the condition.', 'Get the operator of the second operand.', 'Check whether the operator in the second operand is a method call.', 'Get the name of the called method in the second operand.', 'Check whether the first operand is a null check.', 'Check whether the operator in the condition is a logical OR (||).', 'Check whether the second operand contains a method call that accesses a field or method of the object being checked for null.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTInfixExpression', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTNullLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of the method.* 匹配到的元操作或API：
logic: Get the name of the method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9713990092277527
*Get the signature of the method.* 匹配到的元操作或API：
logic: Get the signature of the method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9734326601028442
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Get the number of conditional statements in the method body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first conditional statement in the method body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the condition of the if statement.* 匹配到的元操作或API：
logic: Get the condition of the if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9738380908966064
*Get the number of operands in the condition.* 匹配到的元操作或API：
query: Get the number of operands in the condition.
most similar API: get operand of unary expression
cosine Similarity: 0.8014739155769348
*Get the first operand in the condition.* 匹配到的元操作或API：
query: Get the first operand in the condition.
most similar API: get operand of unary expression
cosine Similarity: 0.821504533290863
*Get the operator of the first operand.* 匹配到的元操作或API：
query: Get the operator of the first operand.
most similar API: get operator of infix expression: Returns the operator.
cosine Similarity: 0.8242931365966797
*Check whether the operator in the first operand is a method call.* 匹配到的元操作或API：
query: Check whether the operator in the first operand is a method call.
most similar API: Check whether the method call is expression
cosine Similarity: 0.8441140651702881
*Get the name of the called method in the first operand.* 匹配到的元操作或API：
logic: Get the name of the called method in the first operand.
most similar meta operation: Get the name of called method
cosine Similarity: 0.8772518634796143
*Get the second operand in the condition.* 匹配到的元操作或API：
query: Get the second operand in the condition.
most similar API: get other operand if in assignment expr
cosine Similarity: 0.8243328332901001
*Get the operator of the second operand.* 匹配到的元操作或API：
query: Get the operator of the second operand.
most similar API: get operator of infix expression: Returns the operator.
cosine Similarity: 0.831324577331543
*Check whether the operator in the second operand is a method call.* 匹配到的元操作或API：
query: Check whether the operator in the second operand is a method call.
most similar API: Check whether the method call is expression
cosine Similarity: 0.8394426107406616
*Get the name of the called method in the second operand.* 匹配到的元操作或API：
logic: Get the name of the called method in the second operand.
most similar meta operation: Get the name of called method
cosine Similarity: 0.885117769241333
*Check whether the first operand is a null check.* 匹配到的元操作或API：
query: Check whether the first operand is a null check.
most similar API: Check whether is null check
cosine Similarity: 0.865947425365448
*Check whether the operator in the condition is a logical OR (||).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the second operand contains a method call that accesses a field or method of the object being checked for null.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        // enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && infixExpression.getRightOperand() instanceof ASTNullLiteral;
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            return methodCall.getMethodName().equals("equals") && methodCall.getQualifier() instanceof ASTVariableAccess;
        }
        return false;
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}


This checker is failed(false negative) on this negative test case:
```
// should be &&, but now with a longer expression
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Books')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'getJane')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTNullLiteral
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'books')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTMethodCall (called method name = 'getJane')
                ——ASTVariableAccess (referenced variable name = 'books')
                ——ASTArgumentList (size = 0)
              ——ASTNullLiteral
            ——ASTUnaryExpression
              ——ASTMethodCall (called method name = 'equals')
                ——ASTMethodCall (called method name = 'getJane')
                  ——ASTVariableAccess (referenced variable name = 'books')
                  ——ASTArgumentList (size = 0)
                ——ASTArgumentList (size = 1)
                  ——ASTStringLiteral
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
4. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
5. net.sourceforge.pmd.lang.java.ast.ASTUnaryExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getOperand(), //Returns the expression nested within this expression.
6. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.BinaryOp getOperator(), //Returns the operator.
7. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
8. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
9. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public net.sourceforge.pmd.lang.java.ast.ASTExpression getOtherOperandIfInAssignmentExpr(net.sourceforge.pmd.lang.java.ast.JavaNode)
10. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullCheck(net.sourceforge.pmd.lang.java.ast.ASTExpression, net.sourceforge.pmd.lang.java.rule.internal.StablePathMatcher)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
            checkNestedNullCheck(infixExpression, data);
        }
        return super.visit(node, data);
    }

    private void checkNestedNullCheck(ASTInfixExpression node, Object data) {
        if (isInfixExpressionWithOperator(node, BinaryOp.CONDITIONAL_OR)) {
            if (node.getLeftOperand() instanceof ASTInfixExpression) {
                ASTInfixExpression leftInfix = (ASTInfixExpression) node.getLeftOperand();
                if (isInfixExpressionWithOperator(leftInfix, BinaryOp.NE) && leftInfix.getRightOperand() instanceof ASTNullLiteral) {
                    if (node.getRightOperand() instanceof ASTUnaryExpression) {
                        ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node.getRightOperand();
                        if (unaryExpression.getOperand() instanceof ASTMethodCall) {
                            addViolation(data, node);
                        }
                    }
                }
            }
            if (node.getRightOperand() instanceof ASTInfixExpression) {
                ASTInfixExpression rightInfix = (ASTInfixExpression) node.getRightOperand();
                if (isInfixExpressionWithOperator(rightInfix, BinaryOp.NE) && rightInfix.getRightOperand() instanceof ASTNullLiteral) {
                    if (node.getLeftOperand() instanceof ASTUnaryExpression) {
                        ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node.getLeftOperand();
                        if (unaryExpression.getOperand() instanceof ASTMethodCall) {
                            addViolation(data, node);
                        }
                    }
                }
            }
        }
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && infixExpression.getRightOperand() instanceof ASTNullLiteral;
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            return methodCall.getMethodName().equals("equals") && methodCall.getQualifier() instanceof ASTVariableAccess;
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 1" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 1" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the method declaration of `bar` in class `Books`.
2. Get the body of method `bar`.
3. Get the if statement in the body of method `bar`.
4. Get the condition of the if statement.
5. Get the first part of the condition (left of ||).
6. Get the second part of the condition (right of ||).
7. Get the method call in the first part of the condition.
8. Check whether the method call is `books.getJane() != null`.
9. Get the method call in the second part of the condition.
10. Check whether the method call is `!books.getJane().equals("")`.
11. Check whether the second part of the condition calls `books.getJane()` before the null check.

If the second part of the condition calls `books.getJane()` before the null check, then this test case violates the rule.
['Get the method declaration of `bar` in class `Books`.', 'Get the body of method `bar`.', 'Get the if statement in the body of method `bar`.', 'Get the condition of the if statement.', 'Get the first part of the condition (left of ||).', 'Get the second part of the condition (right of ||).', 'Get the method call in the first part of the condition.', 'Check whether the method call is `books.getJane() != null`.', 'Get the method call in the second part of the condition.', 'Check whether the method call is `!books.getJane().equals("")`.', 'Check whether the second part of the condition calls `books.getJane()` before the null check.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTInfixExpression', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTNullLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the method declaration of `bar` in class `Books`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of method `bar`.* 匹配到的元操作或API：
query: Get the body of method `bar`.
most similar API: get body of method
cosine Similarity: 0.8641096353530884
*Get the if statement in the body of method `bar`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the condition of the if statement.* 匹配到的元操作或API：
logic: Get the condition of the if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9738380908966064
*Get the first part of the condition (left of ||).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the second part of the condition (right of ||).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the method call in the first part of the condition.* 匹配到的元操作或API：
query: Get the method call in the first part of the condition.
most similar API: get first parent of type of method call
cosine Similarity: 0.8183426856994629
*Check whether the method call is `books.getJane() != null`.* 匹配到的元操作或API：
query: Check whether the method call is `books.getJane() != null`.
most similar API: Check whether is getter call
cosine Similarity: 0.8057031631469727
*Get the method call in the second part of the condition.* 匹配到的元操作或API：
query: Get the method call in the second part of the condition.
most similar API: get method name of method call
cosine Similarity: 0.8110668659210205
*Check whether the method call is `!books.getJane().equals("")`.* 匹配到的元操作或API：
query: Check whether the method call is `!books.getJane().equals("")`.
most similar API: Check whether the method call equals
cosine Similarity: 0.8845505118370056
*Check whether the second part of the condition calls `books.getJane()` before the null check.* 匹配到的元操作或API：
query: Check whether the second part of the condition calls `books.getJane()` before the null check.
most similar API: Check whether is null checked
cosine Similarity: 0.8006196022033691
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        // enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && infixExpression.getRightOperand() instanceof ASTNullLiteral;
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            return methodCall.getMethodName().equals("equals") && methodCall.getQualifier() instanceof ASTVariableAccess;
        }
        return false;
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}


This checker is failed(false negative) on this negative test case:
```
// should be &&, but now with a longer expression
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Books')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'getJane')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTNullLiteral
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'books')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTMethodCall (called method name = 'getJane')
                ——ASTVariableAccess (referenced variable name = 'books')
                ——ASTArgumentList (size = 0)
              ——ASTNullLiteral
            ——ASTUnaryExpression
              ——ASTMethodCall (called method name = 'equals')
                ——ASTMethodCall (called method name = 'getJane')
                  ——ASTVariableAccess (referenced variable name = 'books')
                  ——ASTArgumentList (size = 0)
                ——ASTArgumentList (size = 1)
                  ——ASTStringLiteral
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public T getFirstParentOfType(java.lang.Class)
4. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isGetterCall(net.sourceforge.pmd.lang.java.ast.ASTMethodCall)
5. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
7. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullChecked(net.sourceforge.pmd.lang.java.ast.ASTExpression), //Returns true if the expr is in a null check (its parent is a null check).



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && infixExpression.getRightOperand() instanceof ASTNullLiteral;
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals") && methodCall.getQualifier() != null) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier.getFirstParentOfType(ASTIfStatement.class) != null) {
                    ASTIfStatement ifStatement = qualifier.getFirstParentOfType(ASTIfStatement.class);
                    ASTExpression condition = ifStatement.getCondition();
                    if (condition instanceof ASTInfixExpression) {
                        ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
                        if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR) && !JavaRuleUtil.isNullChecked(qualifier)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the condition of if statement.
2. Check whether the condition is a logical OR expression (||).
3. Get the left operand of the logical OR expression.
4. Check whether the left operand is a not null check (e.g., `books.getJane() != null`).
5. Get the right operand of the logical OR expression.
6. Get the method call in the right operand.
7. Get the name of called method.
8. Check whether the called method is equals.
9. Check whether the method caller is the result of a previous method call.
10. Get the name of the method called on the method caller.
11. Check whether the method caller is a string type.
12. Check whether the method caller is null.
13. Check whether the method call is on a null object.

In this specific test case:
- The condition of the if statement is a logical OR expression (||).
- The left operand of the logical OR expression is a not null check (`books.getJane() != null`).
- The right operand of the logical OR expression is a method call (`books.getJane().equals("")`).
- The called method is equals.
- The method caller is the result of a previous method call (`books.getJane()`).
- The method caller is a string type.
- Since the left operand of the OR expression is a not null check, the right operand should logically use the same method caller without re-evaluating it. However, the right operand re-evaluates `books.getJane()` which can lead to a NullPointerException if the result is null.

Therefore, the test case violates the rule because it uses `||` instead of `&&` and does not handle the null check properly to avoid a NullPointerException. It should be rewritten to use `&&` and ensure that the null check is handled before calling methods on the object. Here is a granular check to confirm this:
- Check whether the right operand of the logical OR expression could be evaluated when the left operand is false (i.e., `books.getJane()` is null).

In this test case, the right operand could be evaluated when the left operand is false, causing a potential NullPointerException.
['Get the condition of if statement.', 'Check whether the condition is a logical OR expression (||).', 'Get the left operand of the logical OR expression.', 'Check whether the left operand is a not null check (e.g., `books.getJane() != null`).', 'Get the right operand of the logical OR expression.', 'Get the method call in the right operand.', 'Get the name of called method.', 'Check whether the called method is equals.', 'Check whether the method caller is the result of a previous method call.', 'Get the name of the method called on the method caller.', 'Check whether the method caller is a string type.', 'Check whether the method caller is null.', 'Check whether the method call is on a null object.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTInfixExpression', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTNullLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Check whether the condition is a logical OR expression (||).* 匹配到的元操作或API：
query: Check whether the condition is a logical OR expression (||).
most similar API: Check whether the unary expression is expression
cosine Similarity: 0.8228344321250916
*Get the left operand of the logical OR expression.* 匹配到的元操作或API：
logic: Get the left operand of the logical OR expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8923843502998352
*Check whether the left operand is a not null check (e.g., `books.getJane() != null`).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the right operand of the logical OR expression.* 匹配到的元操作或API：
logic: Get the right operand of the logical OR expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.8644448518753052
*Get the method call in the right operand.* 匹配到的元操作或API：
query: Get the method call in the right operand.
most similar API: get method name of method call
cosine Similarity: 0.800758957862854
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the called method is equals.* 匹配到的元操作或API：
query: Check whether the called method is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9604323506355286
*Check whether the method caller is the result of a previous method call.* 匹配到的元操作或API：
query: Check whether the method caller is the result of a previous method call.
most similar API: Check whether the method call equals
cosine Similarity: 0.841071605682373
*Get the name of the method called on the method caller.* 匹配到的元操作或API：
logic: Get the name of the method called on the method caller.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9509729743003845
*Check whether the method caller is a string type.* 匹配到的元操作或API：
logic: Check whether the method caller is a string type.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.9876717329025269
*Check whether the method caller is null.* 匹配到的元操作或API：
query: Check whether the method caller is null.
most similar API: Check whether is null check
cosine Similarity: 0.8236192464828491
*Check whether the method call is on a null object.* 匹配到的元操作或API：
query: Check whether the method call is on a null object.
most similar API: Check whether is null check
cosine Similarity: 0.8600633144378662
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        // enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && infixExpression.getRightOperand() instanceof ASTNullLiteral;
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            return methodCall.getMethodName().equals("equals") && methodCall.getQualifier() instanceof ASTVariableAccess;
        }
        return false;
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}


This checker is failed(false negative) on this negative test case:
```
// should be &&, but now with a longer expression
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Books')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'getJane')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTNullLiteral
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'books')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTMethodCall (called method name = 'getJane')
                ——ASTVariableAccess (referenced variable name = 'books')
                ——ASTArgumentList (size = 0)
              ——ASTNullLiteral
            ——ASTUnaryExpression
              ——ASTMethodCall (called method name = 'equals')
                ——ASTMethodCall (called method name = 'getJane')
                  ——ASTVariableAccess (referenced variable name = 'books')
                  ——ASTArgumentList (size = 0)
                ——ASTArgumentList (size = 1)
                  ——ASTStringLiteral
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTUnaryExpression: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
3. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr getLeftOperand()
4. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
7. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullCheck(net.sourceforge.pmd.lang.java.ast.ASTExpression, net.sourceforge.pmd.lang.java.rule.internal.StablePathMatcher)

1.  //Check whether the method caller is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallerStringType(ASTMethodCall node){
    return TypeTestUtil.isA(String.class, node.getQualifier());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && infixExpression.getRightOperand() instanceof ASTNullLiteral;
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals") && isMethodCallerStringType(methodCall)) {
                return true;
            }
        }
        return false;
    }

    public boolean isMethodCallerStringType(ASTMethodCall node){
        return TypeTestUtil.isA(String.class, node.getQualifier());
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 1" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 1" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method is bar.
3. Get the signature of method.
4. Get the method body.
5. Get all control statements in the method body.
6. Get the if statement in the method body.
7. Get the condition of if statement.
8. Check whether the condition is infix expression.
9. Get the left operand of infix expression.
10. Check whether the left operand is a method call.
11. Get the name of called method.
12. Check whether the name is getJane.
13. Get the method caller.
14. Check whether the method caller is an instance of Books class type.
15. Get the right operand of infix expression.
16. Check whether the right operand is a method call.
17. Get the name of called method.
18. Check whether the name is equals.
19. Get the method caller.
20. Check whether the method caller is an instance of Books class type.
21. Get the return type of called method (getJane).
22. Check whether the return type is string type.
23. Check whether the operator in infix expression is ||.
24. Get the left operand of the left infix expression.
25. Check whether the left operand of the left infix expression is a method call.
26. Get the name of called method.
27. Check whether the name is getJane.
28. Get the right operand of the left infix expression.
29. Check whether the right operand of the left infix expression is a literal.
30. Check whether the literal value is null.
31. Get the left operand of the right infix expression.
32. Check whether the left operand of the right infix expression is a method call.
33. Get the name of called method.
34. Check whether the name is getJane.
35. Get the right operand of the right infix expression.
36. Check whether the right operand of the right infix expression is a literal.
37. Get the value of string literal.
38. Check whether the string literal is empty.

If the operator in the infix expression is || and the left operand of the left infix expression is a method call to getJane which is not checked for null, and the right operand of the right infix expression is an empty string literal, it indicates a null check is broken. This test case violates the rule.
['Get the name of method.', 'Check whether the method is bar.', 'Get the signature of method.', 'Get the method body.', 'Get all control statements in the method body.', 'Get the if statement in the method body.', 'Get the condition of if statement.', 'Check whether the condition is infix expression.', 'Get the left operand of infix expression.', 'Check whether the left operand is a method call.', 'Get the name of called method.', 'Check whether the name is getJane.', 'Get the method caller.', 'Check whether the method caller is an instance of Books class type.', 'Get the right operand of infix expression.', 'Check whether the right operand is a method call.', 'Get the name of called method.', 'Check whether the name is equals.', 'Get the method caller.', 'Check whether the method caller is an instance of Books class type.', 'Get the return type of called method (getJane).', 'Check whether the return type is string type.', 'Check whether the operator in infix expression is ||.', 'Get the left operand of the left infix expression.', 'Check whether the left operand of the left infix expression is a method call.', 'Get the name of called method.', 'Check whether the name is getJane.', 'Get the right operand of the left infix expression.', 'Check whether the right operand of the left infix expression is a literal.', 'Check whether the literal value is null.', 'Get the left operand of the right infix expression.', 'Check whether the left operand of the right infix expression is a method call.', 'Get the name of called method.', 'Check whether the name is getJane.', 'Get the right operand of the right infix expression.', 'Check whether the right operand of the right infix expression is a literal.', 'Get the value of string literal.', 'Check whether the string literal is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTInfixExpression', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTNullLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is bar.* 匹配到的元操作或API：
query: Check whether the method is bar.
most similar API: Check whether is test method
cosine Similarity: 0.832916259765625
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Get the method body.* 匹配到的元操作或API：
query: Get the method body.
most similar API: get body of method
cosine Similarity: 0.952139139175415
*Get all control statements in the method body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the if statement in the method body.* 匹配到的元操作或API：
query: Get the if statement in the method body.
most similar API: get text of if statement
cosine Similarity: 0.8151984810829163
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Check whether the condition is infix expression.* 匹配到的元操作或API：
logic: Check whether the condition is infix expression.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9096700549125671
*Get the left operand of infix expression.* 匹配到的元操作或API：
logic: Get the left operand of infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9903916120529175
*Check whether the left operand is a method call.* 匹配到的元操作或API：
query: Check whether the left operand is a method call.
most similar API: Check whether the method call is expression
cosine Similarity: 0.8237406015396118
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the name is getJane.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796932339668274
*Check whether the method caller is an instance of Books class type.* 匹配到的元操作或API：
logic: Check whether the method caller is an instance of Books class type.
most similar meta operation: Check whether the method caller is x class type
cosine Similarity: 0.8563858866691589
*Get the right operand of infix expression.* 匹配到的元操作或API：
logic: Get the right operand of infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9884670972824097
*Check whether the right operand is a method call.* 匹配到的元操作或API：
query: Check whether the right operand is a method call.
most similar API: Check whether the method call equals
cosine Similarity: 0.8639539480209351
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the name is equals.* 匹配到的元操作或API：
query: Check whether the name is equals.
most similar API: Check whether is equals method
cosine Similarity: 0.8145300149917603
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796932339668274
*Check whether the method caller is an instance of Books class type.* 匹配到的元操作或API：
logic: Check whether the method caller is an instance of Books class type.
most similar meta operation: Check whether the method caller is x class type
cosine Similarity: 0.8563858866691589
*Get the return type of called method (getJane).* 匹配到的元操作或API：
logic: Get the return type of called method (getJane).
most similar meta operation: Get the return type of called method
cosine Similarity: 0.921105682849884
*Check whether the return type is string type.* 匹配到的元操作或API：
logic: Check whether the return type is string type.
most similar meta operation: Check whether the return type of method is string type
cosine Similarity: 0.9509028792381287
*Check whether the operator in infix expression is ||.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is ||.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9215893149375916
*Get the left operand of the left infix expression.* 匹配到的元操作或API：
logic: Get the left operand of the left infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9823737144470215
*Check whether the left operand of the left infix expression is a method call.* 匹配到的元操作或API：
query: Check whether the left operand of the left infix expression is a method call.
most similar API: Check whether the method call is expression
cosine Similarity: 0.8537370562553406
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the name is getJane.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the right operand of the left infix expression.* 匹配到的元操作或API：
logic: Get the right operand of the left infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9488746523857117
*Check whether the right operand of the left infix expression is a literal.* 匹配到的元操作或API：
logic: Check whether the right operand of the left infix expression is a literal.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.8554636836051941
*Check whether the literal value is null.* 匹配到的元操作或API：
query: Check whether the literal value is null.
most similar API: Check whether is null literal
cosine Similarity: 0.93576979637146
*Get the left operand of the right infix expression.* 匹配到的元操作或API：
logic: Get the left operand of the right infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9611098170280457
*Check whether the left operand of the right infix expression is a method call.* 匹配到的元操作或API：
query: Check whether the left operand of the right infix expression is a method call.
most similar API: Check whether the method call is expression
cosine Similarity: 0.8450784683227539
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the name is getJane.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the right operand of the right infix expression.* 匹配到的元操作或API：
logic: Get the right operand of the right infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9771825075149536
*Check whether the right operand of the right infix expression is a literal.* 匹配到的元操作或API：
logic: Check whether the right operand of the right infix expression is a literal.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.8717921376228333
*Get the value of string literal.* 匹配到的元操作或API：
logic: Get the value of string literal.
most similar meta operation: Get the value of string literal
cosine Similarity: 0.983224630355835
*Check whether the string literal is empty.* 匹配到的元操作或API：
logic: Check whether the string literal is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.9120838642120361
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        // enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && infixExpression.getRightOperand() instanceof ASTNullLiteral;
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            return methodCall.getMethodName().equals("equals") && methodCall.getQualifier() instanceof ASTVariableAccess;
        }
        return false;
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}


This checker is failed(false negative) on this negative test case:
```
// should be &&, but now with a longer expression
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Books')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'getJane')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTNullLiteral
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'books')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTMethodCall (called method name = 'getJane')
                ——ASTVariableAccess (referenced variable name = 'books')
                ——ASTArgumentList (size = 0)
              ——ASTNullLiteral
            ——ASTUnaryExpression
              ——ASTMethodCall (called method name = 'equals')
                ——ASTMethodCall (called method name = 'getJane')
                  ——ASTVariableAccess (referenced variable name = 'books')
                  ——ASTArgumentList (size = 0)
                ——ASTArgumentList (size = 1)
                  ——ASTStringLiteral
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
5. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.document.Chars getText()
6. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
7. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLeftOperand()
8. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
9. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
10. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()
11. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
12. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
13. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isEqualsMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
14. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isNullLiteral(net.sourceforge.pmd.lang.java.ast.ASTExpression)
15. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.String getConstValue()
16. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()

1.  //Check whether the operator in infix expression is ''
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils;
public boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op){
    //enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
    return JavaAstUtils.isInfixExprWithOperator(node, op);
}
```
2.  //Check whether the method caller is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallerClassType(ASTMethodCall node){
    return TypeTestUtil.isA(x.class, node.getQualifier());
}
```
3.  //Get the return type of called method
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.JMethodSig;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getReturnType(ASTMethodCall call) {
    JMethodSig m = call.getMethodType();
    return m.getReturnType();
}
```
4.  //Check whether the return type of method is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnValueStringType(ASTMethodDeclaration method) {
    return TypeTestUtil.isA(String.class, method.getResultTypeNode());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the method declaration from method call.
        2. Get the name of method.
        3. Check whether the method name is equals.
        4. Get the method call's arguments.
        5. Get the number of arguments of called method.
        6. Get an argument of called method.
        7. Check whether the argument is a local variable.
        8. Get the name of local variable.
        9. Check whether the local variable is null.
        10. Get the condition of if statement.
        11. Get the operator of infix expression.
        12. Check whether the operator in infix expression is &&.
        13. Check whether the left operand of infix expression is null check.
        14. Check whether the right operand of infix expression calls equals method on null.

If the method name is equals, and one of its arguments is null, and the operator in the if statement's condition is &&, and the left operand of the condition checks for null, and the right operand calls the equals method on a null object, then this test case violates the rule. In this specific test case, the right operand of the infix expression is `list.equals(buz)` and `list` is null when `list == null` is true, which would cause a NullPointerException.
['Get the method declaration from method call.', 'Get the name of method.', 'Check whether the method name is equals.', "Get the method call's arguments.", 'Get the number of arguments of called method.', 'Get an argument of called method.', 'Check whether the argument is a local variable.', 'Get the name of local variable.', 'Check whether the local variable is null.', 'Get the condition of if statement.', 'Get the operator of infix expression.', 'Check whether the operator in infix expression is &&.', 'Check whether the left operand of infix expression is null check.', 'Check whether the right operand of infix expression calls equals method on null.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTFieldDeclaration', 'ASTFormalParameter', 'ASTMethodDeclaration', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'ASTNullLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the method declaration from method call.* 匹配到的元操作或API：
logic: Get the method declaration from method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9787436127662659
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name is equals.* 匹配到的元操作或API：
query: Check whether the method name is equals.
most similar API: Check whether the method equals
cosine Similarity: 0.922903299331665
*Get the method call's arguments.* 匹配到的元操作或API：
logic: Get the method call's arguments.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9041337966918945
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846129417419434
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a local variable.* 匹配到的元操作或API：
logic: Check whether the argument is a local variable.
most similar meta operation: Check whether the accessed variable is a local variable
cosine Similarity: 0.8919025659561157
*Get the name of local variable.* 匹配到的元操作或API：
logic: Get the name of local variable.
most similar meta operation: Get the name of local variable
cosine Similarity: 0.9835154414176941
*Check whether the local variable is null.* 匹配到的元操作或API：
query: Check whether the local variable is null.
most similar API: Check whether is null check
cosine Similarity: 0.8563770055770874
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Get the operator of infix expression.* 匹配到的元操作或API：
logic: Get the operator of infix expression.
most similar meta operation: Get the operator of infix expression
cosine Similarity: 0.9891121983528137
*Check whether the operator in infix expression is &&.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is &&.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9346855282783508
*Check whether the left operand of infix expression is null check.* 匹配到的元操作或API：
logic: Check whether the left operand of infix expression is null check.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.8665033578872681
*Check whether the right operand of infix expression calls equals method on null.* 匹配到的元操作或API：
query: Check whether the right operand of infix expression calls equals method on null.
most similar API: Check whether the infix expression equals
cosine Similarity: 0.8575354814529419
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
This checker has passed this negative testcase:
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}


This checker is failed(false negative) on this negative test case:
```
// should be ||
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list == null && list.equals(buz)) {
            return list;
        }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'buz')
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'Object')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'list')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'list')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'list')
              ——ASTArgumentList (size = 1)
                ——ASTVariableAccess (referenced variable name = 'buz')
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTVariableAccess (referenced variable name = 'list')


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
4. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullCheck(net.sourceforge.pmd.lang.java.ast.ASTExpression, net.sourceforge.pmd.lang.java.rule.internal.StablePathMatcher)
5. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
6. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.BinaryOp getOperator()
7. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLeftOperand()
8. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public boolean equals(java.lang.Object)

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
3.  //Check whether the accessed variable is a local variable
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JLocalVariableSymbol;
public boolean isVariableAccessLocalVariable(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JLocalVariableSymbol) {
        JLocalVariableSymbol localVariableSymbol = (JLocalVariableSymbol) sym;
        return true;
    }
    return false;
}
```
4.  //Get the name of local variable
```java
import net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.ast.NodeStream;
public String getLocalVariableName(ASTLocalVariableDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId variableDeclaratorId : varIds){
        // a local declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(variableDeclaratorId.getName().equals("x")){
            String variableName = variableDeclaratorId.getName();
            return variableName;
        }
    }
    return null;
}
```
5.  //Check whether the operator in infix expression is ''
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils;
public boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op){
    //enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
    return JavaAstUtils.isInfixExprWithOperator(node, op);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                } else if (isNullCheck(rightOperand) && isEqualsCall(leftOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.EQ) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 1" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}, {'error_rules_info': '[ERROR]   "bad 2" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 1" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the condition of if statement.
2. Check whether the condition is an infix expression.
3. Get the operator of infix expression.
4. Check whether the operator in infix expression is &&.
5. Get the left operand of infix expression.
6. Check whether the left operand is an equality expression.
7. Get the operator of left equality expression.
8. Check whether the operator in left equality expression is ==.
9. Get the right operand of left equality expression.
10. Check whether the right operand is null.
11. Get the right operand of infix expression.
12. Check whether the right operand is a method call.
13. Get the name of called method.
14. Check whether the called method name is equals.
15. Get the method caller.
16. Check whether the method caller is the same variable as the left operand of the main condition.

If the condition of the if statement is an infix expression with the operator "&&", and the left operand is an equality expression with "==" and null as the right operand, and the right operand of the infix expression is a method call to "equals" on the same variable, then this test case violates the rule.
            
['Get the condition of if statement.', 'Check whether the condition is an infix expression.', 'Get the operator of infix expression.', 'Check whether the operator in infix expression is &&.', 'Get the left operand of infix expression.', 'Check whether the left operand is an equality expression.', 'Get the operator of left equality expression.', 'Check whether the operator in left equality expression is ==.', 'Get the right operand of left equality expression.', 'Check whether the right operand is null.', 'Get the right operand of infix expression.', 'Check whether the right operand is a method call.', 'Get the name of called method.', 'Check whether the called method name is equals.', 'Get the method caller.', 'Check whether the method caller is the same variable as the left operand of the main condition.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTFieldDeclaration', 'ASTFormalParameter', 'ASTMethodDeclaration', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'ASTNullLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Check whether the condition is an infix expression.* 匹配到的元操作或API：
logic: Check whether the condition is an infix expression.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9103512763977051
*Get the operator of infix expression.* 匹配到的元操作或API：
logic: Get the operator of infix expression.
most similar meta operation: Get the operator of infix expression
cosine Similarity: 0.9891121983528137
*Check whether the operator in infix expression is &&.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is &&.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9346855282783508
*Get the left operand of infix expression.* 匹配到的元操作或API：
logic: Get the left operand of infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9903916120529175
*Check whether the left operand is an equality expression.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the operator of left equality expression.* 匹配到的元操作或API：
query: Get the operator of left equality expression.
most similar API: get operator of infix expression: Returns the operator.
cosine Similarity: 0.8159887194633484
*Check whether the operator in left equality expression is ==.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the right operand of left equality expression.* 匹配到的元操作或API：
logic: Get the right operand of left equality expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8768652081489563
*Check whether the right operand is null.* 匹配到的元操作或API：
query: Check whether the right operand is null.
most similar API: Check whether the null literal equals
cosine Similarity: 0.8364773988723755
*Get the right operand of infix expression.* 匹配到的元操作或API：
logic: Get the right operand of infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9884670972824097
*Check whether the right operand is a method call.* 匹配到的元操作或API：
query: Check whether the right operand is a method call.
most similar API: Check whether the method call equals
cosine Similarity: 0.8639539480209351
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9280144572257996
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796932339668274
*Check whether the method caller is the same variable as the left operand of the main condition.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
This checker has passed this negative testcase:
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}


This checker is failed(false negative) on this negative test case:
```
// should be ||
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list == null && list.equals(buz)) {
            return list;
        }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'buz')
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'Object')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'list')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'list')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'list')
              ——ASTArgumentList (size = 1)
                ——ASTVariableAccess (referenced variable name = 'buz')
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTVariableAccess (referenced variable name = 'list')


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.BinaryOp getOperator()
3. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLeftOperand()
4. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.BinaryOp getOperator(), //Returns the operator.
5. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr getLeftOperand()
6. net.sourceforge.pmd.lang.java.ast.ASTNullLiteral: public boolean equals(java.lang.Object)
7. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
8. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
9. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
10. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()

1.  //Check whether the operator in infix expression is ''
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils;
public boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op){
    //enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
    return JavaAstUtils.isInfixExprWithOperator(node, op);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
                if (isInfixExpressionWithOperator((ASTInfixExpression) leftOperand, BinaryOp.EQ) && 
                    JavaAstUtils.isNullLiteral(((ASTInfixExpression) leftOperand).getRightOperand()) && 
                    isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
                if (isInfixExpressionWithOperator((ASTInfixExpression) rightOperand, BinaryOp.EQ) && 
                    JavaAstUtils.isNullLiteral(((ASTInfixExpression) rightOperand).getRightOperand()) && 
                    isEqualsCall(leftOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand()) ||
                   isInfixExpressionWithOperator(infixExpression, BinaryOp.EQ) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 3" failed'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 3" failed不通过
=========================error_testcase_logics=========================
1. Get the condition of if statement.
2. Check whether the condition is an infix expression.
3. Get the operator of infix expression.
4. Check whether the operator in infix expression is &&.
5. Get the left operand of infix expression.
6. Check whether the left operand is an equality expression.
7. Get the left operand of the equality expression.
8. Check whether the left operand is a formal parameter.
9. Get the name of formal parameter.
10. Check whether the name of formal parameter is list.
11. Get the right operand of the equality expression.
12. Check whether the right operand is null.
13. Get the right operand of infix expression.
14. Check whether the right operand is a method call.
15. Get the name of called method.
16. Check whether the name of called method is equals.
17. Get the method caller.
18. Check whether the type of method caller is x class type (Object).
19. Get the argument list of method.
20. Get the size of the argument list.
21. Check whether the size of the argument list is 1.
22. Get the argument of method.
23. Check whether the argument is a field access.
24. Get the name of accessed field.
25. Check whether the name of accessed field is buz.
If the operator in the infix expression is &&, the left operand of the infix expression is an equality expression with list == null, and the right operand of the infix expression is a method call list.equals(buz), then this test case violates the rule. The null check should use || instead of && to avoid a NullPointerException.
['Get the condition of if statement.', 'Check whether the condition is an infix expression.', 'Get the operator of infix expression.', 'Check whether the operator in infix expression is &&.', 'Get the left operand of infix expression.', 'Check whether the left operand is an equality expression.', 'Get the left operand of the equality expression.', 'Check whether the left operand is a formal parameter.', 'Get the name of formal parameter.', 'Check whether the name of formal parameter is list.', 'Get the right operand of the equality expression.', 'Check whether the right operand is null.', 'Get the right operand of infix expression.', 'Check whether the right operand is a method call.', 'Get the name of called method.', 'Check whether the name of called method is equals.', 'Get the method caller.', 'Check whether the type of method caller is x class type (Object).', 'Get the argument list of method.', 'Get the size of the argument list.', 'Check whether the size of the argument list is 1.', 'Get the argument of method.', 'Check whether the argument is a field access.', 'Get the name of accessed field.', 'Check whether the name of accessed field is buz.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTFieldDeclaration', 'ASTFormalParameter', 'ASTMethodDeclaration', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'ASTNullLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Check whether the condition is an infix expression.* 匹配到的元操作或API：
logic: Check whether the condition is an infix expression.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9103512763977051
*Get the operator of infix expression.* 匹配到的元操作或API：
logic: Get the operator of infix expression.
most similar meta operation: Get the operator of infix expression
cosine Similarity: 0.9891121983528137
*Check whether the operator in infix expression is &&.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is &&.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9346855282783508
*Get the left operand of infix expression.* 匹配到的元操作或API：
logic: Get the left operand of infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9903916120529175
*Check whether the left operand is an equality expression.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the left operand of the equality expression.* 匹配到的元操作或API：
logic: Get the left operand of the equality expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.9049126505851746
*Check whether the left operand is a formal parameter.* 匹配到的元操作或API：
query: Check whether the left operand is a formal parameter.
most similar API: Check whether the formal parameter equals
cosine Similarity: 0.8239849805831909
*Get the name of formal parameter.* 匹配到的元操作或API：
logic: Get the name of formal parameter.
most similar meta operation: Get the name of formal parameter
cosine Similarity: 0.9837440252304077
*Check whether the name of formal parameter is list.* 匹配到的元操作或API：
logic: Check whether the name of formal parameter is list.
most similar meta operation: Check whether the formal parameter is string type
cosine Similarity: 0.8520101308822632
*Get the right operand of the equality expression.* 匹配到的元操作或API：
logic: Get the right operand of the equality expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.8890010118484497
*Check whether the right operand is null.* 匹配到的元操作或API：
query: Check whether the right operand is null.
most similar API: Check whether the null literal equals
cosine Similarity: 0.8364773988723755
*Get the right operand of infix expression.* 匹配到的元操作或API：
logic: Get the right operand of infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9884670972824097
*Check whether the right operand is a method call.* 匹配到的元操作或API：
query: Check whether the right operand is a method call.
most similar API: Check whether the method call equals
cosine Similarity: 0.8639539480209351
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the name of called method is equals.* 匹配到的元操作或API：
query: Check whether the name of called method is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9213377237319946
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796932339668274
*Check whether the type of method caller is x class type (Object).* 匹配到的元操作或API：
logic: Check whether the type of method caller is x class type (Object).
most similar meta operation: Check whether the method caller is x class type
cosine Similarity: 0.9656590223312378
*Get the argument list of method.* 匹配到的元操作或API：
logic: Get the argument list of method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8603729009628296
*Get the size of the argument list.* 匹配到的元操作或API：
query: Get the size of the argument list.
most similar API: size of argument list
cosine Similarity: 0.9323435425758362
*Check whether the size of the argument list is 1.* 匹配到的元操作或API：
query: Check whether the size of the argument list is 1.
most similar API: size of argument list
cosine Similarity: 0.8514923453330994
*Get the argument of method.* 匹配到的元操作或API：
logic: Get the argument of method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9354660511016846
*Check whether the argument is a field access.* 匹配到的元操作或API：
logic: Check whether the argument is a field access.
most similar meta operation: Check whether the accessed variable is a field
cosine Similarity: 0.869860827922821
*Get the name of accessed field.* 匹配到的元操作或API：
logic: Get the name of accessed field.
most similar meta operation: Get the name of field
cosine Similarity: 0.8872999548912048
*Check whether the name of accessed field is buz.* 匹配到的元操作或API：
query: Check whether the name of accessed field is buz.
most similar API: Check whether is this field access
cosine Similarity: 0.8451977372169495
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
This checker has passed this negative testcase:
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}


This checker is failed(false negative) on this negative test case:
```
// should be ||
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list == null && list.equals(buz)) {
            return list;
        }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'buz')
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'Object')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'list')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'list')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'list')
              ——ASTArgumentList (size = 1)
                ——ASTVariableAccess (referenced variable name = 'buz')
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTVariableAccess (referenced variable name = 'list')


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.BinaryOp getOperator()
3. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLeftOperand()
4. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr getLeftOperand()
5. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public boolean equals(java.lang.Object)
6. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
7. net.sourceforge.pmd.lang.java.ast.ASTNullLiteral: public boolean equals(java.lang.Object)
8. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
9. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
10. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
11. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()
12. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
13. net.sourceforge.pmd.lang.java.ast.ASTArgumentList: public int size(), //Returns the number of nodes in this list. This must be the number of nodes yielded by the {@link #iterator()}.
14. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isThisFieldAccess(net.sourceforge.pmd.lang.java.ast.ASTExpression), //Whether the expression is an access to a field of this instance, not inherited, qualified or not ({@code this.field} or just {@code field}).

1.  //Check whether the operator in infix expression is ''
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils;
public boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op){
    //enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
    return JavaAstUtils.isInfixExprWithOperator(node, op);
}
```
2.  //Get the name of formal parameter
```java
import net.sourceforge.pmd.lang.java.ast.*;
public String getFormalParameterName(ASTFormalParameter node) {
    return node.getVarId().getName();
}
```
3.  //Check whether the formal parameter is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFormalParameterStringType(ASTFormalParameter node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```
4.  //Check whether the method caller is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallerClassType(ASTMethodCall node){
    return TypeTestUtil.isA(x.class, node.getQualifier());
}
```
5.  //Check whether the accessed variable is a field
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;
public boolean isVariableAccessField(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JFieldSymbol) {
        JFieldSymbol fieldSym = (JFieldSymbol) sym;
        return true;
    }
    return false;
}
```
6.  //Get the name of field
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.ast.NodeStream;
public String getFieldName(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId variableDeclaratorId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(variableDeclaratorId.getName().equals("x")){
            String variableName = variableDeclaratorId.getName();
            return variableName;
        }
    }
    return null;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand) || isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.EQ) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 1" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}, {'error_rules_info': '[ERROR]   "bad 2" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 1" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the condition of if statement.
2. Get the left operand of infix expression.
3. Get the right operand of infix expression.
4. Get the operator of infix expression.
5. Check whether the operator in infix expression is &&.
6. Check whether the left operand of infix expression is a null check.
7. Check whether the right operand of infix expression accesses a method or field on the same variable as the null check.
8. If the operator is &&, the left operand is a null check, and the right operand accesses a method or field on the same variable as the null check, then this test case violates the rule.

Let's perform these checks on the provided test case:

1. Get the condition of if statement. -> Condition is `list == null && list.equals(buz)`
2. Get the left operand of infix expression. -> Left operand is `list == null`
3. Get the right operand of infix expression. -> Right operand is `list.equals(buz)`
4. Get the operator of infix expression. -> Operator is `&&`
5. Check whether the operator in infix expression is &&. -> True, the operator is `&&`
6. Check whether the left operand of infix expression is a null check. -> True, `list == null` is a null check
7. Check whether the right operand of infix expression accesses a method or field on the same variable as the null check. -> True, `list.equals(buz)` accesses a method on the same variable `list` as the null check
8. If the operator is &&, the left operand is a null check, and the right operand accesses a method or field on the same variable as the null check, then this test case violates the rule. -> True, the test case violates the rule

The test case violates the rule because it uses `&&` instead of `||`, which will throw a `NullPointerException` if `list` is `null`.
['Get the condition of if statement.', 'Get the left operand of infix expression.', 'Get the right operand of infix expression.', 'Get the operator of infix expression.', 'Check whether the operator in infix expression is &&.', 'Check whether the left operand of infix expression is a null check.', 'Check whether the right operand of infix expression accesses a method or field on the same variable as the null check.', 'If the operator is &&, the left operand is a null check, and the right operand accesses a method or field on the same variable as the null check, then this test case violates the rule.', 'Get the condition of if statement. -> Condition is `list == null && list.equals(buz)`', 'Get the left operand of infix expression. -> Left operand is `list == null`', 'Get the right operand of infix expression. -> Right operand is `list.equals(buz)`', 'Get the operator of infix expression. -> Operator is `&&`', 'Check whether the operator in infix expression is &&. -> True, the operator is `&&`', 'Check whether the left operand of infix expression is a null check. -> True, `list == null` is a null check', 'Check whether the right operand of infix expression accesses a method or field on the same variable as the null check. -> True, `list.equals(buz)` accesses a method on the same variable `list` as the null check', 'If the operator is &&, the left operand is a null check, and the right operand accesses a method or field on the same variable as the null check, then this test case violates the rule. -> True, the test case violates the rule']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTFieldDeclaration', 'ASTFormalParameter', 'ASTMethodDeclaration', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'ASTNullLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Get the left operand of infix expression.* 匹配到的元操作或API：
logic: Get the left operand of infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9903916120529175
*Get the right operand of infix expression.* 匹配到的元操作或API：
logic: Get the right operand of infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9884670972824097
*Get the operator of infix expression.* 匹配到的元操作或API：
logic: Get the operator of infix expression.
most similar meta operation: Get the operator of infix expression
cosine Similarity: 0.9891121983528137
*Check whether the operator in infix expression is &&.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is &&.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9346855282783508
*Check whether the left operand of infix expression is a null check.* 匹配到的元操作或API：
logic: Check whether the left operand of infix expression is a null check.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.8590563535690308
*Check whether the right operand of infix expression accesses a method or field on the same variable as the null check.* 匹配到的元操作或API：
query: Check whether the right operand of infix expression accesses a method or field on the same variable as the null check.
most similar API: Check whether the infix expression equals
cosine Similarity: 0.8202543258666992
*If the operator is &&, the left operand is a null check, and the right operand accesses a method or field on the same variable as the null check, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the condition of if statement. -> Condition is `list == null && list.equals(buz)`* 匹配到的元操作或API：
query: Get the condition of if statement. -> Condition is `list == null && list.equals(buz)`
most similar API: get condition of if statement
cosine Similarity: 0.8357315063476562
*Get the left operand of infix expression. -> Left operand is `list == null`* 匹配到的元操作或API：
logic: Get the left operand of infix expression. -> Left operand is `list == null`
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9193317890167236
*Get the right operand of infix expression. -> Right operand is `list.equals(buz)`* 匹配到的元操作或API：
logic: Get the right operand of infix expression. -> Right operand is `list.equals(buz)`
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.8842674493789673
*Get the operator of infix expression. -> Operator is `&&`* 匹配到的元操作或API：
logic: Get the operator of infix expression. -> Operator is `&&`
most similar meta operation: Get the operator of infix expression
cosine Similarity: 0.9493281245231628
*Check whether the operator in infix expression is &&. -> True, the operator is `&&`* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is &&. -> True, the operator is `&&`
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9095372557640076
*Check whether the left operand of infix expression is a null check. -> True, `list == null` is a null check* 匹配到的元操作或API：
query: Check whether the left operand of infix expression is a null check. -> True, `list == null` is a null check
most similar API: Check whether is null check: Returns true if the expression is a null check on the given variable.
cosine Similarity: 0.8020626902580261
*Check whether the right operand of infix expression accesses a method or field on the same variable as the null check. -> True, `list.equals(buz)` accesses a method on the same variable `list` as the null check* 匹配到的元操作或API：
未匹配成功元操作或API
*If the operator is &&, the left operand is a null check, and the right operand accesses a method or field on the same variable as the null check, then this test case violates the rule. -> True, the test case violates the rule* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
This checker has passed this negative testcase:
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}


This checker is failed(false negative) on this negative test case:
```
// should be ||
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list == null && list.equals(buz)) {
            return list;
        }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'buz')
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'Object')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'list')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'list')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'list')
              ——ASTArgumentList (size = 1)
                ——ASTVariableAccess (referenced variable name = 'buz')
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTVariableAccess (referenced variable name = 'list')


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLeftOperand()
3. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
4. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.BinaryOp getOperator()
5. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public boolean equals(java.lang.Object)
6. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition(), //Returns the node that represents the guard of this conditional. This may be any expression of type boolean.
7. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullCheck(net.sourceforge.pmd.lang.java.ast.ASTExpression, net.sourceforge.pmd.lang.java.symbols.JVariableSymbol), //Returns true if the expression is a null check on the given variable.

1.  //Check whether the operator in infix expression is ''
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils;
public boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op){
    //enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
    return JavaAstUtils.isInfixExprWithOperator(node, op);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
                if (isInfixExpressionWithOperator((ASTInfixExpression) leftOperand, BinaryOp.EQ) && JavaAstUtils.isNullLiteral(((ASTInfixExpression) leftOperand).getRightOperand()) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
                if (isInfixExpressionWithOperator((ASTInfixExpression) rightOperand, BinaryOp.EQ) && JavaAstUtils.isNullLiteral(((ASTInfixExpression) rightOperand).getRightOperand()) && isEqualsCall(leftOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand()) ||
                   isInfixExpressionWithOperator(infixExpression, BinaryOp.EQ) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 3" failed'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 3" failed不通过
=========================error_testcase_logics=========================
1. Get the condition of if statement.
        2. Get the left operand of infix expression.
        3. Check whether the operator in infix expression is &&.
        4. Check whether the left operand of infix expression is a null check.
        5. Get the right operand of infix expression.
        6. Check whether the right operand of infix expression is a method call.
        7. Get the name of called method.
        8. Check whether the name of called method is equals.
        9. Get the method caller.
        10. Check whether the method caller is the same as the left operand of the null check.
        If the operator is &&, the left operand is a null check, the right operand is a method call, the name of the method call is equals, and the method caller is the same as the left operand of the null check, then this test case violates the rule.
            
['Get the condition of if statement.', 'Get the left operand of infix expression.', 'Check whether the operator in infix expression is &&.', 'Check whether the left operand of infix expression is a null check.', 'Get the right operand of infix expression.', 'Check whether the right operand of infix expression is a method call.', 'Get the name of called method.', 'Check whether the name of called method is equals.', 'Get the method caller.', 'Check whether the method caller is the same as the left operand of the null check.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTFieldDeclaration', 'ASTFormalParameter', 'ASTMethodDeclaration', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'ASTFormalParameters', 'ASTNullLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Get the left operand of infix expression.* 匹配到的元操作或API：
logic: Get the left operand of infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9903916120529175
*Check whether the operator in infix expression is &&.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is &&.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9346855282783508
*Check whether the left operand of infix expression is a null check.* 匹配到的元操作或API：
logic: Check whether the left operand of infix expression is a null check.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.8590563535690308
*Get the right operand of infix expression.* 匹配到的元操作或API：
logic: Get the right operand of infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9884670972824097
*Check whether the right operand of infix expression is a method call.* 匹配到的元操作或API：
query: Check whether the right operand of infix expression is a method call.
most similar API: Check whether the method call is expression
cosine Similarity: 0.865786075592041
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the name of called method is equals.* 匹配到的元操作或API：
query: Check whether the name of called method is equals.
most similar API: Check whether the method call equals
cosine Similarity: 0.9213377237319946
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796932339668274
*Check whether the method caller is the same as the left operand of the null check.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
This checker has passed this negative testcase:
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}


This checker is failed(false negative) on this negative test case:
```
// should be ||
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list == null && list.equals(buz)) {
            return list;
        }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'buz')
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'Object')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'list')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'list')
              ——ASTNullLiteral
            ——ASTMethodCall (called method name = 'equals')
              ——ASTVariableAccess (referenced variable name = 'list')
              ——ASTArgumentList (size = 1)
                ——ASTVariableAccess (referenced variable name = 'buz')
          ——ASTBlock
            ——ASTReturnStatement
              ——ASTVariableAccess (referenced variable name = 'list')


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLeftOperand()
3. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
5. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
7. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()

1.  //Check whether the operator in infix expression is ''
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils;
public boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op){
    //enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
    return JavaAstUtils.isInfixExprWithOperator(node, op);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.EQ)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                } else if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 3
[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
97
81
111
94
=========================error_testcase_logics=========================
1. Get the condition of if statement.
2. Check whether the condition is an infix expression.
3. Get the left operand of infix expression.
4. Check whether the left operand is a null check.
5. Get the right operand of infix expression.
6. Check whether the right operand is a method call.
7. Get the name of called method.
8. Check whether the called method is length.
9. Get the type of method caller.
10. Check whether the type of method caller is string type.
11. Check whether the operator in infix expression is &&.

If the condition is an infix expression, the left operand is a null check, the right operand is a method call to `length()` on a string type, and the operator is `&&`, then this test case violates the rule. 

In this specific test case:
- The condition of the if statement is `str == null && str.length() == 0`.
- The left operand is `str == null`, which is a null check.
- The right operand is `str.length() == 0`, where `str.length()` is a method call on a string type.
- The operator is `&&`.

This means the null check is broken since it will throw a `NullPointerException` if `str` is `null` before it reaches `str.length() == 0`.
            
['Get the condition of if statement.', 'Check whether the condition is an infix expression.', 'Get the left operand of infix expression.', 'Check whether the left operand is a null check.', 'Get the right operand of infix expression.', 'Check whether the right operand is a method call.', 'Get the name of called method.', 'Check whether the called method is length.', 'Get the type of method caller.', 'Check whether the type of method caller is string type.', 'Check whether the operator in infix expression is &&.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTNullLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Check whether the condition is an infix expression.* 匹配到的元操作或API：
logic: Check whether the condition is an infix expression.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9103512763977051
*Get the left operand of infix expression.* 匹配到的元操作或API：
logic: Get the left operand of infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9903916120529175
*Check whether the left operand is a null check.* 匹配到的元操作或API：
query: Check whether the left operand is a null check.
most similar API: Check whether is null check
cosine Similarity: 0.8328814506530762
*Get the right operand of infix expression.* 匹配到的元操作或API：
logic: Get the right operand of infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9884670972824097
*Check whether the right operand is a method call.* 匹配到的元操作或API：
query: Check whether the right operand is a method call.
most similar API: Check whether the method call equals
cosine Similarity: 0.8639539480209351
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the called method is length.* 匹配到的元操作或API：
query: Check whether the called method is length.
most similar API: Check whether the method call equals
cosine Similarity: 0.8269822001457214
*Get the type of method caller.* 匹配到的元操作或API：
logic: Get the type of method caller.
most similar meta operation: Get the type of method caller
cosine Similarity: 0.9859350323677063
*Check whether the type of method caller is string type.* 匹配到的元操作或API：
logic: Check whether the type of method caller is string type.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.983098566532135
*Check whether the operator in infix expression is &&.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is &&.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9346855282783508
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
This checker has passed this negative testcase:
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}


This checker is failed(false negative) on this negative test case:
```
// 1633683, should be ||, but now with another compare
public class Foo {
    void bar(String str) {
        if (str == null && str.length() == 0) { }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTInfixExpression
              ——ASTMethodCall (called method name = 'length')
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTArgumentList (size = 0)
              ——ASTNumericLiteral
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLeftOperand()
3. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullCheck(net.sourceforge.pmd.lang.java.ast.ASTExpression, net.sourceforge.pmd.lang.java.rule.internal.StablePathMatcher)
4. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()

1.  //Check whether the operator in infix expression is ''
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils;
public boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op){
    //enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
    return JavaAstUtils.isInfixExprWithOperator(node, op);
}
```
2.  //Get the type of method caller
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getMethodCallerType(ASTMethodCall node){
    ASTExpression expression = node.getQualifier();
    if(expression != null){
        return expression.getTypeMirror();
    }
    return null;
}
```
3.  //Check whether the method caller is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallerStringType(ASTMethodCall node){
    return TypeTestUtil.isA(String.class, node.getQualifier());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isMethodCallOnNullableObject(rightOperand)) {
                    addViolation(data, node);
                } else if (isMethodCallOnNullableObject(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }

    private boolean isMethodCallOnNullableObject(ASTExpression node) {
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            ASTExpression qualifier = methodCall.getQualifier();
            JTypeMirror typeMirror = getMethodCallerType(methodCall);
            if (typeMirror != null && TypeTestUtil.isA(String.class, typeMirror) && qualifier instanceof ASTVariableAccess) {
                return true;
            }
        }
        return false;
    }

    private JTypeMirror getMethodCallerType(ASTMethodCall node) {
        ASTExpression expression = node.getQualifier();
        if (expression != null) {
            return expression.getTypeMirror();
        }
        return null;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the condition of if statement.
2. Check whether the condition is an infix expression.
3. Get the left operand of infix expression.
4. Check whether the left operand is a null check.
5. Get the right operand of infix expression.
6. Check whether the right operand is a method call.
7. Get the name of called method.
8. Check whether the name of called method is length.
9. Get the method caller.
10. Check whether the method caller is the same as the operand in the null check.
11. Check whether the operator in infix expression is &&.

If the condition of the if statement is an infix expression with the left operand being a null check and the right operand being a method call to `length()` on the same object and the operator is `&&`, then this test case violates the rule.
['Get the condition of if statement.', 'Check whether the condition is an infix expression.', 'Get the left operand of infix expression.', 'Check whether the left operand is a null check.', 'Get the right operand of infix expression.', 'Check whether the right operand is a method call.', 'Get the name of called method.', 'Check whether the name of called method is length.', 'Get the method caller.', 'Check whether the method caller is the same as the operand in the null check.', 'Check whether the operator in infix expression is &&.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTNullLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Check whether the condition is an infix expression.* 匹配到的元操作或API：
logic: Check whether the condition is an infix expression.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9103512763977051
*Get the left operand of infix expression.* 匹配到的元操作或API：
logic: Get the left operand of infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9903916120529175
*Check whether the left operand is a null check.* 匹配到的元操作或API：
query: Check whether the left operand is a null check.
most similar API: Check whether is null check
cosine Similarity: 0.8328814506530762
*Get the right operand of infix expression.* 匹配到的元操作或API：
logic: Get the right operand of infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9884670972824097
*Check whether the right operand is a method call.* 匹配到的元操作或API：
query: Check whether the right operand is a method call.
most similar API: Check whether the method call equals
cosine Similarity: 0.8639539480209351
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the name of called method is length.* 匹配到的元操作或API：
query: Check whether the name of called method is length.
most similar API: Check whether the method call equals
cosine Similarity: 0.8038016557693481
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796932339668274
*Check whether the method caller is the same as the operand in the null check.* 匹配到的元操作或API：
query: Check whether the method caller is the same as the operand in the null check.
most similar API: Check whether the method call equals
cosine Similarity: 0.8435330390930176
*Check whether the operator in infix expression is &&.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is &&.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9346855282783508
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
This checker has passed this negative testcase:
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}


This checker is failed(false negative) on this negative test case:
```
// 1633683, should be ||, but now with another compare
public class Foo {
    void bar(String str) {
        if (str == null && str.length() == 0) { }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTInfixExpression
              ——ASTMethodCall (called method name = 'length')
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTArgumentList (size = 0)
              ——ASTNumericLiteral
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLeftOperand()
3. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullCheck(net.sourceforge.pmd.lang.java.ast.ASTExpression, net.sourceforge.pmd.lang.java.rule.internal.StablePathMatcher)
4. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
7. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()

1.  //Check whether the operator in infix expression is ''
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils;
public boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op){
    //enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
    return JavaAstUtils.isInfixExprWithOperator(node, op);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isMethodCallOnNullCheckedVariable(rightOperand, leftOperand)) {
                    addViolation(data, node);
                } else if (isNullCheck(rightOperand) && isMethodCallOnNullCheckedVariable(leftOperand, rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        return JavaRuleUtil.isNullCheck(node, new StablePathMatcher());
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }

    private boolean isMethodCallOnNullCheckedVariable(ASTExpression node, ASTExpression nullCheckedVariable) {
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            ASTExpression qualifier = methodCall.getQualifier();
            return qualifier != null && qualifier.equals(nullCheckedVariable);
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the condition of if statement.
2. Check whether the condition is an infix expression.
3. If the condition is an infix expression, get the left operand of infix expression.
4. Check whether the left operand is an infix expression.
5. If the left operand is an infix expression, get the operator of infix expression.
6. Check whether the operator in infix expression is ==.
7. If the operator is ==, get the left operand of infix expression.
8. Check whether the left operand is string type.
9. Get the right operand of infix expression.
10. Check whether the right operand is null.
11. If the left operand is a string and the right operand is null, get the right operand of the outer infix expression.
12. Check whether the right operand is an infix expression.
13. If the right operand is an infix expression, get the operator of infix expression.
14. Check whether the operator in infix expression is ==.
15. If the operator is ==, get the left operand of the inner infix expression.
16. Check whether the left operand is the same as the left operand of the outer infix expression.
17. If the left operand is the same, get the right operand of the inner infix expression.
18. Check whether the right operand is a method call.
19. Get the name of called method.
20. Check whether the called method name is length.
21. If the called method name is length, check whether the operator in the outer infix expression is &&.

If the operator in the outer infix expression is &&, and the left operand of the outer infix expression is the same as the left operand of the inner infix expression (which is a string and compared to null), and the called method name in the inner infix expression is length, then this test case violates the rule. The rule suggests that the null check is broken because it uses && instead of ||, and accessing the length method on a null string will throw a NullPointerException.
['Get the condition of if statement.', 'Check whether the condition is an infix expression.', 'If the condition is an infix expression, get the left operand of infix expression.', 'Check whether the left operand is an infix expression.', 'If the left operand is an infix expression, get the operator of infix expression.', 'Check whether the operator in infix expression is ==.', 'If the operator is ==, get the left operand of infix expression.', 'Check whether the left operand is string type.', 'Get the right operand of infix expression.', 'Check whether the right operand is null.', 'If the left operand is a string and the right operand is null, get the right operand of the outer infix expression.', 'Check whether the right operand is an infix expression.', 'If the right operand is an infix expression, get the operator of infix expression.', 'Check whether the operator in infix expression is ==.', 'If the operator is ==, get the left operand of the inner infix expression.', 'Check whether the left operand is the same as the left operand of the outer infix expression.', 'If the left operand is the same, get the right operand of the inner infix expression.', 'Check whether the right operand is a method call.', 'Get the name of called method.', 'Check whether the called method name is length.', 'If the called method name is length, check whether the operator in the outer infix expression is &&.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTNullLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Check whether the condition is an infix expression.* 匹配到的元操作或API：
logic: Check whether the condition is an infix expression.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9103512763977051
*If the condition is an infix expression, get the left operand of infix expression.* 匹配到的元操作或API：
logic: If the condition is an infix expression, get the left operand of infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9531686902046204
*Check whether the left operand is an infix expression.* 匹配到的元操作或API：
logic: Check whether the left operand is an infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9058529138565063
*If the left operand is an infix expression, get the operator of infix expression.* 匹配到的元操作或API：
logic: If the left operand is an infix expression, get the operator of infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9285339713096619
*Check whether the operator in infix expression is ==.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is ==.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9310508966445923
*If the operator is ==, get the left operand of infix expression.* 匹配到的元操作或API：
logic: If the operator is ==, get the left operand of infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9391376972198486
*Check whether the left operand is string type.* 匹配到的元操作或API：
query: Check whether the left operand is string type.
most similar API: Check whether the numeric literal is string literal
cosine Similarity: 0.8083845973014832
*Get the right operand of infix expression.* 匹配到的元操作或API：
logic: Get the right operand of infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9884670972824097
*Check whether the right operand is null.* 匹配到的元操作或API：
query: Check whether the right operand is null.
most similar API: Check whether the null literal equals
cosine Similarity: 0.8364773988723755
*If the left operand is a string and the right operand is null, get the right operand of the outer infix expression.* 匹配到的元操作或API：
logic: If the left operand is a string and the right operand is null, get the right operand of the outer infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.8768242001533508
*Check whether the right operand is an infix expression.* 匹配到的元操作或API：
logic: Check whether the right operand is an infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9103248119354248
*If the right operand is an infix expression, get the operator of infix expression.* 匹配到的元操作或API：
logic: If the right operand is an infix expression, get the operator of infix expression.
most similar meta operation: Get the operator of infix expression
cosine Similarity: 0.9361151456832886
*Check whether the operator in infix expression is ==.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is ==.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9310508966445923
*If the operator is ==, get the left operand of the inner infix expression.* 匹配到的元操作或API：
logic: If the operator is ==, get the left operand of the inner infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.921891987323761
*Check whether the left operand is the same as the left operand of the outer infix expression.* 匹配到的元操作或API：
logic: Check whether the left operand is the same as the left operand of the outer infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.8571495413780212
*If the left operand is the same, get the right operand of the inner infix expression.* 匹配到的元操作或API：
logic: If the left operand is the same, get the right operand of the inner infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9106571674346924
*Check whether the right operand is a method call.* 匹配到的元操作或API：
query: Check whether the right operand is a method call.
most similar API: Check whether the method call equals
cosine Similarity: 0.8639539480209351
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the called method name is length.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the called method name is length, check whether the operator in the outer infix expression is &&.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
This checker has passed this negative testcase:
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}


This checker is failed(false negative) on this negative test case:
```
// 1633683, should be ||, but now with another compare
public class Foo {
    void bar(String str) {
        if (str == null && str.length() == 0) { }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTInfixExpression
              ——ASTMethodCall (called method name = 'length')
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTArgumentList (size = 0)
              ——ASTNumericLiteral
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLeftOperand()
3. net.sourceforge.pmd.lang.java.ast.ASTNumericLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
4. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
5. net.sourceforge.pmd.lang.java.ast.ASTNullLiteral: public boolean equals(java.lang.Object)
6. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.BinaryOp getOperator()
7. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
8. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()

1.  //Check whether the operator in infix expression is ''
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils;
public boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op){
    //enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
    return JavaAstUtils.isInfixExprWithOperator(node, op);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isMethodCallOnNullable(leftOperand, rightOperand)) {
                    addViolation(data, node);
                } else if (isMethodCallOnNullable(rightOperand, leftOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean isMethodCallOnNullable(ASTExpression nullableCheck, ASTExpression methodCallExpr) {
        if (nullableCheck instanceof ASTInfixExpression && methodCallExpr instanceof ASTMethodCall) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) nullableCheck;
            ASTMethodCall methodCall = (ASTMethodCall) methodCallExpr;
            ASTExpression qualifier = methodCall.getQualifier();
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.EQ) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand())) {
                return qualifier != null && qualifier.equals(infixExpression.getLeftOperand());
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the condition of if statement.
        2. Get the left operand of infix expression.
        3. Check whether the operator in infix expression is ==.
        4. Get the right operand of infix expression.
        5. Check whether the right operand is a null literal.
        6. Get the left operand of the right infix expression.
        7. Check whether the operator in infix expression is ==.
        8. Get the right operand of the right infix expression.
        9. Check whether the right operand is a numeric literal with value 0.
        10. Get the operator of the infix expression that combines the two conditions.
        11. Check whether the operator in the combined infix expression is &&.
        12. Get the method call from the right operand of the infix expression.
        13. Get the name of called method.
        14. Check whether the method name is length.
        15. Get the method caller.
        16. Check whether the method caller is a string type.
        17. Check whether the method caller is the same as the accessed field in the previous infix expression.

If the condition of the if statement contains a null check using `==` and the second condition is a method call to `length()` on the same variable, and the operator combining these conditions is `&&`, then this test case violates the rule.
            
['Get the condition of if statement.', 'Get the left operand of infix expression.', 'Check whether the operator in infix expression is ==.', 'Get the right operand of infix expression.', 'Check whether the right operand is a null literal.', 'Get the left operand of the right infix expression.', 'Check whether the operator in infix expression is ==.', 'Get the right operand of the right infix expression.', 'Check whether the right operand is a numeric literal with value 0.', 'Get the operator of the infix expression that combines the two conditions.', 'Check whether the operator in the combined infix expression is &&.', 'Get the method call from the right operand of the infix expression.', 'Get the name of called method.', 'Check whether the method name is length.', 'Get the method caller.', 'Check whether the method caller is a string type.', 'Check whether the method caller is the same as the accessed field in the previous infix expression.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTNullLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Get the left operand of infix expression.* 匹配到的元操作或API：
logic: Get the left operand of infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9903916120529175
*Check whether the operator in infix expression is ==.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is ==.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9310508966445923
*Get the right operand of infix expression.* 匹配到的元操作或API：
logic: Get the right operand of infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9884670972824097
*Check whether the right operand is a null literal.* 匹配到的元操作或API：
query: Check whether the right operand is a null literal.
most similar API: Check whether the null literal is null literal
cosine Similarity: 0.9019619822502136
*Get the left operand of the right infix expression.* 匹配到的元操作或API：
logic: Get the left operand of the right infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9611098170280457
*Check whether the operator in infix expression is ==.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is ==.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9310508966445923
*Get the right operand of the right infix expression.* 匹配到的元操作或API：
logic: Get the right operand of the right infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9771825075149536
*Check whether the right operand is a numeric literal with value 0.* 匹配到的元操作或API：
logic: Check whether the right operand is a numeric literal with value 0.
most similar meta operation: Check whether the numeric literal is int literal
cosine Similarity: 0.8508974313735962
*Get the operator of the infix expression that combines the two conditions.* 匹配到的元操作或API：
logic: Get the operator of the infix expression that combines the two conditions.
most similar meta operation: Get the operator of infix expression
cosine Similarity: 0.9201876521110535
*Check whether the operator in the combined infix expression is &&.* 匹配到的元操作或API：
logic: Check whether the operator in the combined infix expression is &&.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9127931594848633
*Get the method call from the right operand of the infix expression.* 匹配到的元操作或API：
logic: Get the method call from the right operand of the infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.8676435351371765
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the method name is length.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796932339668274
*Check whether the method caller is a string type.* 匹配到的元操作或API：
logic: Check whether the method caller is a string type.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.9876717329025269
*Check whether the method caller is the same as the accessed field in the previous infix expression.* 匹配到的元操作或API：
query: Check whether the method caller is the same as the accessed field in the previous infix expression.
most similar API: Check whether the infix expression equals
cosine Similarity: 0.800818681716919
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
This checker has passed this negative testcase:
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}


This checker is failed(false negative) on this negative test case:
```
// 1633683, should be ||, but now with another compare
public class Foo {
    void bar(String str) {
        if (str == null && str.length() == 0) { }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTInfixExpression
              ——ASTMethodCall (called method name = 'length')
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTArgumentList (size = 0)
              ——ASTNumericLiteral
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLeftOperand()
3. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
4. net.sourceforge.pmd.lang.java.ast.ASTNullLiteral: public boolean isNullLiteral(), //Returns true if this is the {@linkplain ASTNullLiteral null literal}.
5. net.sourceforge.pmd.lang.java.ast.ASTNumericLiteral: public boolean isIntLiteral()
6. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.BinaryOp getOperator()
7. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
8. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()
9. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public boolean equals(java.lang.Object)

1.  //Check whether the operator in infix expression is ''
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils;
public boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op){
    //enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
    return JavaAstUtils.isInfixExprWithOperator(node, op);
}
```
2.  //Check whether the method caller is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallerStringType(ASTMethodCall node){
    return TypeTestUtil.isA(String.class, node.getQualifier());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isMethodCallOnNullable(rightOperand)) {
                    addViolation(data, node);
                } else if (isMethodCallOnNullable(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean isMethodCallOnNullable(ASTExpression node) {
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            ASTExpression qualifier = methodCall.getQualifier();
            if (qualifier != null && qualifier instanceof ASTVariableAccess) {
                return true;
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the condition of if statement.
2. Check whether the condition is an infix expression.
3. Get the operator of infix expression.
4. Check whether the operator in infix expression is &&.
5. Get the left operand of infix expression.
6. Check whether the left operand is an equality expression.
7. Get the left operand of equality expression.
8. Check whether the left operand is an accessed variable.
9. Get the name of accessed variable.
10. Check whether the name of accessed variable is `str`.
11. Get the right operand of equality expression.
12. Check whether the right operand is a literal value.
13. Get the literal value that the right operand is initialized to.
14. Check whether the literal value is `null`.
15. Get the right operand of infix expression.
16. Check whether the right operand is an equality expression.
17. Get the left operand of equality expression.
18. Check whether the left operand is an accessed variable.
19. Get the name of accessed variable.
20. Check whether the name of accessed variable is `str`.
21. Get the right operand of equality expression.
22. Check whether the right operand is a literal value.
23. Get the literal value that the right operand is initialized to.
24. Check whether the literal value is `0`.

If the condition of the if statement is an infix expression with the && operator, and the left operand is an equality expression checking if `str == null`, and the right operand is an equality expression that attempts to access a method on `str` (in this case, `str.length() == 0`), then this test case violates the rule. The null check is broken since it will throw a `NullPointerException` itself if `str` is `null`. To fix this, the condition should use `||` instead of `&&` to ensure that `str.length()` is not called if `str` is `null`.
['Get the condition of if statement.', 'Check whether the condition is an infix expression.', 'Get the operator of infix expression.', 'Check whether the operator in infix expression is &&.', 'Get the left operand of infix expression.', 'Check whether the left operand is an equality expression.', 'Get the left operand of equality expression.', 'Check whether the left operand is an accessed variable.', 'Get the name of accessed variable.', 'Check whether the name of accessed variable is `str`.', 'Get the right operand of equality expression.', 'Check whether the right operand is a literal value.', 'Get the literal value that the right operand is initialized to.', 'Check whether the literal value is `null`.', 'Get the right operand of infix expression.', 'Check whether the right operand is an equality expression.', 'Get the left operand of equality expression.', 'Check whether the left operand is an accessed variable.', 'Get the name of accessed variable.', 'Check whether the name of accessed variable is `str`.', 'Get the right operand of equality expression.', 'Check whether the right operand is a literal value.', 'Get the literal value that the right operand is initialized to.', 'Check whether the literal value is `0`.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTNullLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Check whether the condition is an infix expression.* 匹配到的元操作或API：
logic: Check whether the condition is an infix expression.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9103512763977051
*Get the operator of infix expression.* 匹配到的元操作或API：
logic: Get the operator of infix expression.
most similar meta operation: Get the operator of infix expression
cosine Similarity: 0.9891121983528137
*Check whether the operator in infix expression is &&.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is &&.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9346855282783508
*Get the left operand of infix expression.* 匹配到的元操作或API：
logic: Get the left operand of infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9903916120529175
*Check whether the left operand is an equality expression.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the left operand of equality expression.* 匹配到的元操作或API：
logic: Get the left operand of equality expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.9036953449249268
*Check whether the left operand is an accessed variable.* 匹配到的元操作或API：
logic: Check whether the left operand is an accessed variable.
most similar meta operation: Check whether the accessed variable is double type
cosine Similarity: 0.8555494546890259
*Get the name of accessed variable.* 匹配到的元操作或API：
logic: Get the name of accessed variable.
most similar meta operation: Get the name of accessed variable
cosine Similarity: 0.986038088798523
*Check whether the name of accessed variable is `str`.* 匹配到的元操作或API：
logic: Check whether the name of accessed variable is `str`.
most similar meta operation: Check whether the accessed variable is string type
cosine Similarity: 0.8825159072875977
*Get the right operand of equality expression.* 匹配到的元操作或API：
logic: Get the right operand of equality expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.8882208466529846
*Check whether the right operand is a literal value.* 匹配到的元操作或API：
query: Check whether the right operand is a literal value.
most similar API: Check whether the numeric literal equals
cosine Similarity: 0.8486288785934448
*Get the literal value that the right operand is initialized to.* 匹配到的元操作或API：
logic: Get the literal value that the right operand is initialized to.
most similar meta operation: Get the literal value that the local variable is initialized to
cosine Similarity: 0.8818901777267456
*Check whether the literal value is `null`.* 匹配到的元操作或API：
query: Check whether the literal value is `null`.
most similar API: Check whether is null literal
cosine Similarity: 0.9286289215087891
*Get the right operand of infix expression.* 匹配到的元操作或API：
logic: Get the right operand of infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9884670972824097
*Check whether the right operand is an equality expression.* 匹配到的元操作或API：
query: Check whether the right operand is an equality expression.
most similar API: Check whether the infix expression equals
cosine Similarity: 0.8083102703094482
*Get the left operand of equality expression.* 匹配到的元操作或API：
logic: Get the left operand of equality expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.9036953449249268
*Check whether the left operand is an accessed variable.* 匹配到的元操作或API：
logic: Check whether the left operand is an accessed variable.
most similar meta operation: Check whether the accessed variable is double type
cosine Similarity: 0.8555494546890259
*Get the name of accessed variable.* 匹配到的元操作或API：
logic: Get the name of accessed variable.
most similar meta operation: Get the name of accessed variable
cosine Similarity: 0.986038088798523
*Check whether the name of accessed variable is `str`.* 匹配到的元操作或API：
logic: Check whether the name of accessed variable is `str`.
most similar meta operation: Check whether the accessed variable is string type
cosine Similarity: 0.8825159072875977
*Get the right operand of equality expression.* 匹配到的元操作或API：
logic: Get the right operand of equality expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.8882208466529846
*Check whether the right operand is a literal value.* 匹配到的元操作或API：
query: Check whether the right operand is a literal value.
most similar API: Check whether the numeric literal equals
cosine Similarity: 0.8486288785934448
*Get the literal value that the right operand is initialized to.* 匹配到的元操作或API：
logic: Get the literal value that the right operand is initialized to.
most similar meta operation: Get the literal value that the local variable is initialized to
cosine Similarity: 0.8818901777267456
*Check whether the literal value is `0`.* 匹配到的元操作或API：
query: Check whether the literal value is `0`.
most similar API: Check whether is zero checked
cosine Similarity: 0.8336485624313354
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
This checker has passed this negative testcase:
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}


This checker is failed(false negative) on this negative test case:
```
// 1633683, should be ||, but now with another compare
public class Foo {
    void bar(String str) {
        if (str == null && str.length() == 0) { }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'str')
              ——ASTNullLiteral
            ——ASTInfixExpression
              ——ASTMethodCall (called method name = 'length')
                ——ASTVariableAccess (referenced variable name = 'str')
                ——ASTArgumentList (size = 0)
              ——ASTNumericLiteral
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.BinaryOp getOperator()
3. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLeftOperand()
4. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr getLeftOperand()
5. net.sourceforge.pmd.lang.java.ast.ASTVariableAccess: public java.lang.String getName()
6. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
7. net.sourceforge.pmd.lang.java.ast.ASTNumericLiteral: public boolean equals(java.lang.Object)
8. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isNullLiteral(net.sourceforge.pmd.lang.java.ast.ASTExpression)
9. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
10. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public boolean equals(java.lang.Object)
11. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isZeroChecked(net.sourceforge.pmd.lang.java.ast.ASTExpression), //Return true if the given expression is enclosed in a zero check. The expression must evaluate to a natural number (ie >= 0), so that {@code e < 1} actually means {@code e == 0}. @param e Expression

1.  //Check whether the operator in infix expression is ''
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils;
public boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op){
    //enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
    return JavaAstUtils.isInfixExprWithOperator(node, op);
}
```
2.  //Check whether the accessed variable is double type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isVariableAccessDoubleType(ASTVariableAccess var) {
    return var.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.DOUBLE);
}
```
3.  //Check whether the accessed variable is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTVariableAccess var){
    return TypeTestUtil.isA(String.class, var.getTypeMirror());
}
```
4.  //Get the literal value that the local variable is initialized to
```java
import net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTLiteral;
import net.sourceforge.pmd.lang.ast.NodeStream;
public ASTLiteral getInitializedValue(ASTLocalVariableDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a local declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTLiteral) {
                    return (ASTLiteral)init;
                }
            }
        }
    }
    return null;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                } else if (isNullCheck(leftOperand) && isNullSensitiveOperation(rightOperand)) {
                    addViolation(data, node);
                } else if (isNullCheck(rightOperand) && isNullSensitiveOperation(leftOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }

    private boolean isNullSensitiveOperation(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            ASTExpression leftOperand = infixExpression.getLeftOperand();
            ASTExpression rightOperand = infixExpression.getRightOperand();
            if (isVariableAccess(leftOperand) && isNullSensitiveMethod(infixExpression)) {
                return true;
            } else if (isVariableAccess(rightOperand) && isNullSensitiveMethod(infixExpression)) {
                return true;
            }
        } else if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (isNullSensitiveMethod(methodCall)) {
                return true;
            }
        }
        return false;
    }

    private boolean isVariableAccess(ASTExpression node) {
        return node instanceof ASTVariableAccess;
    }

    private boolean isNullSensitiveMethod(ASTExpression node) {
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            String methodName = methodCall.getMethodName();
            return "length".equals(methodName) || "charAt".equals(methodName) || "substring".equals(methodName) || "toLowerCase".equals(methodName) || "toUpperCase".equals(methodName) || "trim".equals(methodName) || "isEmpty".equals(methodName) || "indexOf".equals(methodName) || "lastIndexOf".equals(methodName) || "contains".equals(methodName) || "startsWith".equals(methodName) || "endsWith".equals(methodName);
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 4
[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <4> but was: <0>不通过
97
81
97
80
99
82
77
63
107
91
116
101
=========================error_testcase_logics=========================
1. Get the name of the class.
2. Get all methods declared in class.
3. Get the method named testPMD.
4. Get all statements in the method named testPMD.
5. Get the assignment expression from the first statement in the method.
6. Get the left operand of the assignment expression.
7. Get the right operand of the assignment expression.
8. Check whether the right operand is an infix expression.
9. Get the operator of the infix expression.
10. Check whether the operator is &&.
11. Get the left operand of the infix expression.
12. Check whether the left operand is a comparison (==) expression.
13. Get the left operand of the comparison expression.
14. Check whether the left operand is a field access.
15. Get the name of the accessed field.
16. Check whether the name of the accessed field is boo.
17. Get the right operand of the comparison expression.
18. Check whether the right operand is a null literal.
19. Get the right operand of the infix expression.
20. Check whether the right operand is a comparison (!=) expression.
21. Get the left operand of the comparison expression.
22. Check whether the left operand is a field access.
23. Get the name of the accessed field.
24. Check whether the name of the accessed field is boo.
25. Get the right operand of the comparison expression.
26. Check whether the right operand is a boolean literal.
27. Check whether the boolean literal is true.

Perform the same checks for the other three assignment statements in the method.

1. Get the assignment expression from the second statement in the method.
2. Get the right operand of the assignment expression.
28. Check whether the right operand is an infix expression.
29. Get the left operand of the infix expression.
30. Check whether the left operand is a comparison (==) expression.
31. Get the left operand of the comparison expression.
32. Check whether the left operand is a field access.
33. Get the name of the accessed field.
34. Check whether the name of the accessed field is boo.
35. Get the right operand of the comparison expression.
36. Check whether the right operand is a null literal.
37. Get the right operand of the infix expression.
38. Check whether the right operand is a comparison (!=) expression.
39. Get the left operand of the comparison expression.
40. Check whether the left operand is a field access.
41. Get the name of the accessed field.
42. Check whether the name of the accessed field is boo.
43. Get the right operand of the comparison expression.
44. Check whether the right operand is a boolean literal.
45. Check whether the boolean literal is false.

1. Get the assignment expression from the third statement in the method.
46. Get the right operand of the assignment expression.
47. Check whether the right operand is an infix expression.
48. Get the left operand of the infix expression.
49. Check whether the left operand is a comparison (==) expression.
50. Get the left operand of the comparison expression.
51. Check whether the left operand is a field access.
52. Get the name of the accessed field.
53. Check whether the name of the accessed field is boo.
54. Get the right operand of the comparison expression.
55. Check whether the right operand is a null literal.
56. Get the right operand of the infix expression.
57. Check whether the right operand is a comparison (==) expression.
58. Get the left operand of the comparison expression.
59. Check whether the left operand is a field access.
60. Get the name of the accessed field.
61. Check whether the name of the accessed field is boo.
62. Get the right operand of the comparison expression.
63. Check whether the right operand is a boolean literal.
64. Check whether the boolean literal is true.

1. Get the assignment expression from the fourth statement in the method.
65. Get the right operand of the assignment expression.
66. Check whether the right operand is an infix expression.
67. Get the left operand of the infix expression.
68. Check whether the left operand is a comparison (==) expression.
69. Get the left operand of the comparison expression.
70. Check whether the left operand is a field access.
71. Get the name of the accessed field.
72. Check whether the name of the accessed field is boo.
73. Get the right operand of the comparison expression.
74. Check whether the right operand is a null literal.
75. Get the right operand of the infix expression.
76. Check whether the right operand is a comparison (==) expression.
77. Get the left operand of the comparison expression.
78. Check whether the left operand is a field access.
79. Get the name of the accessed field.
80. Check whether the name of the accessed field is boo.
81. Get the right operand of the comparison expression.
82. Check whether the right operand is a boolean literal.
83. Check whether the boolean literal is false.

These checks will confirm if the null check is broken due to unboxing and verify the number of violations in the test case.
['Get the name of the class.', 'Get all methods declared in class.', 'Get the method named testPMD.', 'Get all statements in the method named testPMD.', 'Get the assignment expression from the first statement in the method.', 'Get the left operand of the assignment expression.', 'Get the right operand of the assignment expression.', 'Check whether the right operand is an infix expression.', 'Get the operator of the infix expression.', 'Check whether the operator is &&.', 'Get the left operand of the infix expression.', 'Check whether the left operand is a comparison (==) expression.', 'Get the left operand of the comparison expression.', 'Check whether the left operand is a field access.', 'Get the name of the accessed field.', 'Check whether the name of the accessed field is boo.', 'Get the right operand of the comparison expression.', 'Check whether the right operand is a null literal.', 'Get the right operand of the infix expression.', 'Check whether the right operand is a comparison (!=) expression.', 'Get the left operand of the comparison expression.', 'Check whether the left operand is a field access.', 'Get the name of the accessed field.', 'Check whether the name of the accessed field is boo.', 'Get the right operand of the comparison expression.', 'Check whether the right operand is a boolean literal.', 'Check whether the boolean literal is true.', 'Get the assignment expression from the second statement in the method.', 'Get the right operand of the assignment expression.', 'Check whether the right operand is an infix expression.', 'Get the left operand of the infix expression.', 'Check whether the left operand is a comparison (==) expression.', 'Get the left operand of the comparison expression.', 'Check whether the left operand is a field access.', 'Get the name of the accessed field.', 'Check whether the name of the accessed field is boo.', 'Get the right operand of the comparison expression.', 'Check whether the right operand is a null literal.', 'Get the right operand of the infix expression.', 'Check whether the right operand is a comparison (!=) expression.', 'Get the left operand of the comparison expression.', 'Check whether the left operand is a field access.', 'Get the name of the accessed field.', 'Check whether the name of the accessed field is boo.', 'Get the right operand of the comparison expression.', 'Check whether the right operand is a boolean literal.', 'Check whether the boolean literal is false.', 'Get the assignment expression from the third statement in the method.', 'Get the right operand of the assignment expression.', 'Check whether the right operand is an infix expression.', 'Get the left operand of the infix expression.', 'Check whether the left operand is a comparison (==) expression.', 'Get the left operand of the comparison expression.', 'Check whether the left operand is a field access.', 'Get the name of the accessed field.', 'Check whether the name of the accessed field is boo.', 'Get the right operand of the comparison expression.', 'Check whether the right operand is a null literal.', 'Get the right operand of the infix expression.', 'Check whether the right operand is a comparison (==) expression.', 'Get the left operand of the comparison expression.', 'Check whether the left operand is a field access.', 'Get the name of the accessed field.', 'Check whether the name of the accessed field is boo.', 'Get the right operand of the comparison expression.', 'Check whether the right operand is a boolean literal.', 'Check whether the boolean literal is true.', 'Get the assignment expression from the fourth statement in the method.', 'Get the right operand of the assignment expression.', 'Check whether the right operand is an infix expression.', 'Get the left operand of the infix expression.', 'Check whether the left operand is a comparison (==) expression.', 'Get the left operand of the comparison expression.', 'Check whether the left operand is a field access.', 'Get the name of the accessed field.', 'Check whether the name of the accessed field is boo.', 'Get the right operand of the comparison expression.', 'Check whether the right operand is a null literal.', 'Get the right operand of the infix expression.', 'Check whether the right operand is a comparison (==) expression.', 'Get the left operand of the comparison expression.', 'Check whether the left operand is a field access.', 'Get the name of the accessed field.', 'Check whether the name of the accessed field is boo.', 'Get the right operand of the comparison expression.', 'Check whether the right operand is a boolean literal.', 'Check whether the boolean literal is false.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTVariableDeclaratorId', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTAssignmentExpression', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTNullLiteral', 'ASTExpressionStatement', 'ASTBooleanLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of the class.* 匹配到的元操作或API：
logic: Get the name of the class.
most similar meta operation: Get the name of class
cosine Similarity: 0.968898594379425
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Get the method named testPMD.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all statements in the method named testPMD.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the assignment expression from the first statement in the method.* 匹配到的元操作或API：
query: Get the assignment expression from the first statement in the method.
most similar API: get first token of assignment expression
cosine Similarity: 0.8843845129013062
*Get the left operand of the assignment expression.* 匹配到的元操作或API：
logic: Get the left operand of the assignment expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.9864992499351501
*Get the right operand of the assignment expression.* 匹配到的元操作或API：
logic: Get the right operand of the assignment expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.9825876355171204
*Check whether the right operand is an infix expression.* 匹配到的元操作或API：
logic: Check whether the right operand is an infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9103248119354248
*Get the operator of the infix expression.* 匹配到的元操作或API：
logic: Get the operator of the infix expression.
most similar meta operation: Get the operator of infix expression
cosine Similarity: 0.9841877222061157
*Check whether the operator is &&.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the left operand of the infix expression.* 匹配到的元操作或API：
logic: Get the left operand of the infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9858164191246033
*Check whether the left operand is a comparison (==) expression.* 匹配到的元操作或API：
query: Check whether the left operand is a comparison (==) expression.
most similar API: Check whether the assignment expression equals
cosine Similarity: 0.8269333839416504
*Get the left operand of the comparison expression.* 匹配到的元操作或API：
logic: Get the left operand of the comparison expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.9186041355133057
*Check whether the left operand is a field access.* 匹配到的元操作或API：
query: Check whether the left operand is a field access.
most similar API: Check whether is this field access
cosine Similarity: 0.8388791084289551
*Get the name of the accessed field.* 匹配到的元操作或API：
logic: Get the name of the accessed field.
most similar meta operation: Get the name of field
cosine Similarity: 0.8816796541213989
*Check whether the name of the accessed field is boo.* 匹配到的元操作或API：
query: Check whether the name of the accessed field is boo.
most similar API: Check whether is this field access
cosine Similarity: 0.8241909742355347
*Get the right operand of the comparison expression.* 匹配到的元操作或API：
logic: Get the right operand of the comparison expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.902172327041626
*Check whether the right operand is a null literal.* 匹配到的元操作或API：
query: Check whether the right operand is a null literal.
most similar API: Check whether the null literal is null literal
cosine Similarity: 0.9019619822502136
*Get the right operand of the infix expression.* 匹配到的元操作或API：
logic: Get the right operand of the infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9822914600372314
*Check whether the right operand is a comparison (!=) expression.* 匹配到的元操作或API：
query: Check whether the right operand is a comparison (!=) expression.
most similar API: Check whether the expression statement equals
cosine Similarity: 0.8495399951934814
*Get the left operand of the comparison expression.* 匹配到的元操作或API：
logic: Get the left operand of the comparison expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.9186041355133057
*Check whether the left operand is a field access.* 匹配到的元操作或API：
query: Check whether the left operand is a field access.
most similar API: Check whether is this field access
cosine Similarity: 0.8388791084289551
*Get the name of the accessed field.* 匹配到的元操作或API：
logic: Get the name of the accessed field.
most similar meta operation: Get the name of field
cosine Similarity: 0.8816796541213989
*Check whether the name of the accessed field is boo.* 匹配到的元操作或API：
query: Check whether the name of the accessed field is boo.
most similar API: Check whether is this field access
cosine Similarity: 0.8241909742355347
*Get the right operand of the comparison expression.* 匹配到的元操作或API：
logic: Get the right operand of the comparison expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.902172327041626
*Check whether the right operand is a boolean literal.* 匹配到的元操作或API：
logic: Check whether the right operand is a boolean literal.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.8810778260231018
*Check whether the boolean literal is true.* 匹配到的元操作或API：
logic: Check whether the boolean literal is true.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.983268141746521
*Get the assignment expression from the second statement in the method.* 匹配到的元操作或API：
logic: Get the assignment expression from the second statement in the method.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8517893552780151
*Get the right operand of the assignment expression.* 匹配到的元操作或API：
logic: Get the right operand of the assignment expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.9825876355171204
*Check whether the right operand is an infix expression.* 匹配到的元操作或API：
logic: Check whether the right operand is an infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9103248119354248
*Get the left operand of the infix expression.* 匹配到的元操作或API：
logic: Get the left operand of the infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9858164191246033
*Check whether the left operand is a comparison (==) expression.* 匹配到的元操作或API：
query: Check whether the left operand is a comparison (==) expression.
most similar API: Check whether the assignment expression equals
cosine Similarity: 0.8269333839416504
*Get the left operand of the comparison expression.* 匹配到的元操作或API：
logic: Get the left operand of the comparison expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.9186041355133057
*Check whether the left operand is a field access.* 匹配到的元操作或API：
query: Check whether the left operand is a field access.
most similar API: Check whether is this field access
cosine Similarity: 0.8388791084289551
*Get the name of the accessed field.* 匹配到的元操作或API：
logic: Get the name of the accessed field.
most similar meta operation: Get the name of field
cosine Similarity: 0.8816796541213989
*Check whether the name of the accessed field is boo.* 匹配到的元操作或API：
query: Check whether the name of the accessed field is boo.
most similar API: Check whether is this field access
cosine Similarity: 0.8241909742355347
*Get the right operand of the comparison expression.* 匹配到的元操作或API：
logic: Get the right operand of the comparison expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.902172327041626
*Check whether the right operand is a null literal.* 匹配到的元操作或API：
query: Check whether the right operand is a null literal.
most similar API: Check whether the null literal is null literal
cosine Similarity: 0.9019619822502136
*Get the right operand of the infix expression.* 匹配到的元操作或API：
logic: Get the right operand of the infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9822914600372314
*Check whether the right operand is a comparison (!=) expression.* 匹配到的元操作或API：
query: Check whether the right operand is a comparison (!=) expression.
most similar API: Check whether the expression statement equals
cosine Similarity: 0.8495399951934814
*Get the left operand of the comparison expression.* 匹配到的元操作或API：
logic: Get the left operand of the comparison expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.9186041355133057
*Check whether the left operand is a field access.* 匹配到的元操作或API：
query: Check whether the left operand is a field access.
most similar API: Check whether is this field access
cosine Similarity: 0.8388791084289551
*Get the name of the accessed field.* 匹配到的元操作或API：
logic: Get the name of the accessed field.
most similar meta operation: Get the name of field
cosine Similarity: 0.8816796541213989
*Check whether the name of the accessed field is boo.* 匹配到的元操作或API：
query: Check whether the name of the accessed field is boo.
most similar API: Check whether is this field access
cosine Similarity: 0.8241909742355347
*Get the right operand of the comparison expression.* 匹配到的元操作或API：
logic: Get the right operand of the comparison expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.902172327041626
*Check whether the right operand is a boolean literal.* 匹配到的元操作或API：
logic: Check whether the right operand is a boolean literal.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.8810778260231018
*Check whether the boolean literal is false.* 匹配到的元操作或API：
logic: Check whether the boolean literal is false.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.9612721800804138
*Get the assignment expression from the third statement in the method.* 匹配到的元操作或API：
query: Get the assignment expression from the third statement in the method.
most similar API: get text of assignment expression
cosine Similarity: 0.8623151779174805
*Get the right operand of the assignment expression.* 匹配到的元操作或API：
logic: Get the right operand of the assignment expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.9825876355171204
*Check whether the right operand is an infix expression.* 匹配到的元操作或API：
logic: Check whether the right operand is an infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9103248119354248
*Get the left operand of the infix expression.* 匹配到的元操作或API：
logic: Get the left operand of the infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9858164191246033
*Check whether the left operand is a comparison (==) expression.* 匹配到的元操作或API：
query: Check whether the left operand is a comparison (==) expression.
most similar API: Check whether the assignment expression equals
cosine Similarity: 0.8269333839416504
*Get the left operand of the comparison expression.* 匹配到的元操作或API：
logic: Get the left operand of the comparison expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.9186041355133057
*Check whether the left operand is a field access.* 匹配到的元操作或API：
query: Check whether the left operand is a field access.
most similar API: Check whether is this field access
cosine Similarity: 0.8388791084289551
*Get the name of the accessed field.* 匹配到的元操作或API：
logic: Get the name of the accessed field.
most similar meta operation: Get the name of field
cosine Similarity: 0.8816796541213989
*Check whether the name of the accessed field is boo.* 匹配到的元操作或API：
query: Check whether the name of the accessed field is boo.
most similar API: Check whether is this field access
cosine Similarity: 0.8241909742355347
*Get the right operand of the comparison expression.* 匹配到的元操作或API：
logic: Get the right operand of the comparison expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.902172327041626
*Check whether the right operand is a null literal.* 匹配到的元操作或API：
query: Check whether the right operand is a null literal.
most similar API: Check whether the null literal is null literal
cosine Similarity: 0.9019619822502136
*Get the right operand of the infix expression.* 匹配到的元操作或API：
logic: Get the right operand of the infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9822914600372314
*Check whether the right operand is a comparison (==) expression.* 匹配到的元操作或API：
query: Check whether the right operand is a comparison (==) expression.
most similar API: Check whether the expression statement equals
cosine Similarity: 0.856623649597168
*Get the left operand of the comparison expression.* 匹配到的元操作或API：
logic: Get the left operand of the comparison expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.9186041355133057
*Check whether the left operand is a field access.* 匹配到的元操作或API：
query: Check whether the left operand is a field access.
most similar API: Check whether is this field access
cosine Similarity: 0.8388791084289551
*Get the name of the accessed field.* 匹配到的元操作或API：
logic: Get the name of the accessed field.
most similar meta operation: Get the name of field
cosine Similarity: 0.8816796541213989
*Check whether the name of the accessed field is boo.* 匹配到的元操作或API：
query: Check whether the name of the accessed field is boo.
most similar API: Check whether is this field access
cosine Similarity: 0.8241909742355347
*Get the right operand of the comparison expression.* 匹配到的元操作或API：
logic: Get the right operand of the comparison expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.902172327041626
*Check whether the right operand is a boolean literal.* 匹配到的元操作或API：
logic: Check whether the right operand is a boolean literal.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.8810778260231018
*Check whether the boolean literal is true.* 匹配到的元操作或API：
logic: Check whether the boolean literal is true.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.983268141746521
*Get the assignment expression from the fourth statement in the method.* 匹配到的元操作或API：
query: Get the assignment expression from the fourth statement in the method.
most similar API: get text of assignment expression
cosine Similarity: 0.8486491441726685
*Get the right operand of the assignment expression.* 匹配到的元操作或API：
logic: Get the right operand of the assignment expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.9825876355171204
*Check whether the right operand is an infix expression.* 匹配到的元操作或API：
logic: Check whether the right operand is an infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9103248119354248
*Get the left operand of the infix expression.* 匹配到的元操作或API：
logic: Get the left operand of the infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9858164191246033
*Check whether the left operand is a comparison (==) expression.* 匹配到的元操作或API：
query: Check whether the left operand is a comparison (==) expression.
most similar API: Check whether the assignment expression equals
cosine Similarity: 0.8269333839416504
*Get the left operand of the comparison expression.* 匹配到的元操作或API：
logic: Get the left operand of the comparison expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.9186041355133057
*Check whether the left operand is a field access.* 匹配到的元操作或API：
query: Check whether the left operand is a field access.
most similar API: Check whether is this field access
cosine Similarity: 0.8388791084289551
*Get the name of the accessed field.* 匹配到的元操作或API：
logic: Get the name of the accessed field.
most similar meta operation: Get the name of field
cosine Similarity: 0.8816796541213989
*Check whether the name of the accessed field is boo.* 匹配到的元操作或API：
query: Check whether the name of the accessed field is boo.
most similar API: Check whether is this field access
cosine Similarity: 0.8241909742355347
*Get the right operand of the comparison expression.* 匹配到的元操作或API：
logic: Get the right operand of the comparison expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.902172327041626
*Check whether the right operand is a null literal.* 匹配到的元操作或API：
query: Check whether the right operand is a null literal.
most similar API: Check whether the null literal is null literal
cosine Similarity: 0.9019619822502136
*Get the right operand of the infix expression.* 匹配到的元操作或API：
logic: Get the right operand of the infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9822914600372314
*Check whether the right operand is a comparison (==) expression.* 匹配到的元操作或API：
query: Check whether the right operand is a comparison (==) expression.
most similar API: Check whether the expression statement equals
cosine Similarity: 0.856623649597168
*Get the left operand of the comparison expression.* 匹配到的元操作或API：
logic: Get the left operand of the comparison expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.9186041355133057
*Check whether the left operand is a field access.* 匹配到的元操作或API：
query: Check whether the left operand is a field access.
most similar API: Check whether is this field access
cosine Similarity: 0.8388791084289551
*Get the name of the accessed field.* 匹配到的元操作或API：
logic: Get the name of the accessed field.
most similar meta operation: Get the name of field
cosine Similarity: 0.8816796541213989
*Check whether the name of the accessed field is boo.* 匹配到的元操作或API：
query: Check whether the name of the accessed field is boo.
most similar API: Check whether is this field access
cosine Similarity: 0.8241909742355347
*Get the right operand of the comparison expression.* 匹配到的元操作或API：
logic: Get the right operand of the comparison expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.902172327041626
*Check whether the right operand is a boolean literal.* 匹配到的元操作或API：
logic: Check whether the right operand is a boolean literal.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.8810778260231018
*Check whether the boolean literal is false.* 匹配到的元操作或API：
logic: Check whether the boolean literal is false.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.9612721800804138
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
This checker has passed this negative testcase:
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}


This checker is failed(false negative) on this negative test case:
```
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;
                    result = boo == null && boo != true;  // boo != true would throw NPE because of unboxing
                    result = boo == null && boo != false; // same
                    result = boo == null && boo == true;  // same
                    result = boo == null && boo == false; // same
                }
            }
The number of violating the rule in this test case is: 4

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Test')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testPMD')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'boo')
            ——ASTNullLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'result')
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.ast.impl.javacc.JavaccToken getFirstToken()
4. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr getLeftOperand()
5. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
6. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
7. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.BinaryOp getOperator()
8. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLeftOperand()
9. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public boolean equals(java.lang.Object)
10. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isThisFieldAccess(net.sourceforge.pmd.lang.java.ast.ASTExpression), //Whether the expression is an access to a field of this instance, not inherited, qualified or not ({@code this.field} or just {@code field}).
11. net.sourceforge.pmd.lang.java.ast.ASTNullLiteral: public boolean isNullLiteral(), //Returns true if this is the {@linkplain ASTNullLiteral null literal}.
12. net.sourceforge.pmd.lang.java.ast.ASTExpressionStatement: public boolean equals(java.lang.Object)
13. net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral: public boolean isTrue()
14. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.document.Chars getText()

1.  //Get the name of field
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.ast.NodeStream;
public String getFieldName(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId variableDeclaratorId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(variableDeclaratorId.getName().equals("x")){
            String variableName = variableDeclaratorId.getName();
            return variableName;
        }
    }
    return null;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                } else if (isNullCheck(rightOperand) && isEqualsCall(leftOperand)) {
                    addViolation(data, node);
                } else if (isPotentialNPEInfixExpression(leftOperand) || isPotentialNPEInfixExpression(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        } else if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            ASTExpression leftOperand = infixExpression.getLeftOperand();
            ASTExpression rightOperand = infixExpression.getRightOperand();
            if (isVariableAccess(leftOperand) && isBooleanLiteral(rightOperand)) {
                return true;
            } else if (isVariableAccess(rightOperand) && isBooleanLiteral(leftOperand)) {
                return true;
            }
        }
        return false;
    }

    private boolean isPotentialNPEInfixExpression(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            ASTExpression leftOperand = infixExpression.getLeftOperand();
            ASTExpression rightOperand = infixExpression.getRightOperand();
            if (isVariableAccess(leftOperand) && isBooleanLiteral(rightOperand)) {
                return true;
            } else if (isVariableAccess(rightOperand) && isBooleanLiteral(leftOperand)) {
                return true;
            }
        }
        return false;
    }

    private boolean isVariableAccess(ASTExpression node) {
        return node instanceof ASTVariableAccess;
    }

    private boolean isBooleanLiteral(ASTExpression node) {
        return node instanceof ASTBooleanLiteral;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <4> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <4> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the condition of if statement.
2. Check whether the condition is an assignment expression.
3. Get the left operand of the assignment expression.
4. Check whether the left operand is an accessed variable.
5. Get the type of accessed variable.
6. Check whether the type is Boolean.
7. Get the right operand of the assignment expression.
8. Check whether the right operand is a logical expression.
9. Get the operator of logical expression.
10. Check whether the operator is && or ||.
11. Get the left operand of the logical expression.
12. Check whether the left operand is a null check.
13. Get the right operand of the logical expression.
14. Check whether the right operand is an unboxing operation.
15. Check whether the unboxing operation will throw NullPointerException.

Since the test case involves multiple similar assignments, we will perform these checks for each assignment expression:

For `result = boo == null && boo != true;`:
1. Get the condition of the assignment expression (which is `boo == null && boo != true`).
2. Check whether the condition is a logical expression.
3. Get the left operand of the logical expression (which is `boo == null`).
4. Check whether the left operand is a null check.
5. Get the right operand of the logical expression (which is `boo != true`).
6. Check whether the right operand is an unboxing operation.
7. Check whether the unboxing operation will throw NullPointerException.

For `result = boo == null && boo != false;`:
1. Get the condition of the assignment expression (which is `boo == null && boo != false`).
2. Check whether the condition is a logical expression.
3. Get the left operand of the logical expression (which is `boo == null`).
4. Check whether the left operand is a null check.
5. Get the right operand of the logical expression (which is `boo != false`).
6. Check whether the right operand is an unboxing operation.
7. Check whether the unboxing operation will throw NullPointerException.

For `result = boo == null && boo == true;`:
1. Get the condition of the assignment expression (which is `boo == null && boo == true`).
2. Check whether the condition is a logical expression.
3. Get the left operand of the logical expression (which is `boo == null`).
4. Check whether the left operand is a null check.
5. Get the right operand of the logical expression (which is `boo == true`).
6. Check whether the right operand is an unboxing operation.
7. Check whether the unboxing operation will throw NullPointerException.

For `result = boo == null && boo == false;`:
1. Get the condition of the assignment expression (which is `boo == null && boo == false`).
2. Check whether the condition is a logical expression.
3. Get the left operand of the logical expression (which is `boo == null`).
4. Check whether the left operand is a null check.
5. Get the right operand of the logical expression (which is `boo == false`).
6. Check whether the right operand is an unboxing operation.
7. Check whether the unboxing operation will throw NullPointerException.

Each of these assignments will violate the rule because the right operand of each logical expression performs an unboxing operation that can throw a `NullPointerException`.
['Get the condition of if statement.', 'Check whether the condition is an assignment expression.', 'Get the left operand of the assignment expression.', 'Check whether the left operand is an accessed variable.', 'Get the type of accessed variable.', 'Check whether the type is Boolean.', 'Get the right operand of the assignment expression.', 'Check whether the right operand is a logical expression.', 'Get the operator of logical expression.', 'Check whether the operator is && or ||.', 'Get the left operand of the logical expression.', 'Check whether the left operand is a null check.', 'Get the right operand of the logical expression.', 'Check whether the right operand is an unboxing operation.', 'Check whether the unboxing operation will throw NullPointerException.', 'Get the condition of the assignment expression (which is `boo == null && boo != true`).', 'Check whether the condition is a logical expression.', 'Get the left operand of the logical expression (which is `boo == null`).', 'Check whether the left operand is a null check.', 'Get the right operand of the logical expression (which is `boo != true`).', 'Check whether the right operand is an unboxing operation.', 'Check whether the unboxing operation will throw NullPointerException.', 'Get the condition of the assignment expression (which is `boo == null && boo != false`).', 'Check whether the condition is a logical expression.', 'Get the left operand of the logical expression (which is `boo == null`).', 'Check whether the left operand is a null check.', 'Get the right operand of the logical expression (which is `boo != false`).', 'Check whether the right operand is an unboxing operation.', 'Check whether the unboxing operation will throw NullPointerException.', 'Get the condition of the assignment expression (which is `boo == null && boo == true`).', 'Check whether the condition is a logical expression.', 'Get the left operand of the logical expression (which is `boo == null`).', 'Check whether the left operand is a null check.', 'Get the right operand of the logical expression (which is `boo == true`).', 'Check whether the right operand is an unboxing operation.', 'Check whether the unboxing operation will throw NullPointerException.', 'Get the condition of the assignment expression (which is `boo == null && boo == false`).', 'Check whether the condition is a logical expression.', 'Get the left operand of the logical expression (which is `boo == null`).', 'Check whether the left operand is a null check.', 'Get the right operand of the logical expression (which is `boo == false`).', 'Check whether the right operand is an unboxing operation.', 'Check whether the unboxing operation will throw NullPointerException.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTVariableDeclaratorId', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTAssignmentExpression', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTNullLiteral', 'ASTExpressionStatement', 'ASTBooleanLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Check whether the condition is an assignment expression.* 匹配到的元操作或API：
query: Check whether the condition is an assignment expression.
most similar API: Check whether the assignment expression is expression
cosine Similarity: 0.9582128524780273
*Get the left operand of the assignment expression.* 匹配到的元操作或API：
logic: Get the left operand of the assignment expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.9864992499351501
*Check whether the left operand is an accessed variable.* 匹配到的元操作或API：
logic: Check whether the left operand is an accessed variable.
most similar meta operation: Check whether the accessed variable is double type
cosine Similarity: 0.8555494546890259
*Get the type of accessed variable.* 匹配到的元操作或API：
logic: Get the type of accessed variable.
most similar meta operation: Get the type of accessed variable
cosine Similarity: 0.9871194362640381
*Check whether the type is Boolean.* 匹配到的元操作或API：
logic: Check whether the type is Boolean.
most similar meta operation: Check whether the argument is boolean type
cosine Similarity: 0.8953446745872498
*Get the right operand of the assignment expression.* 匹配到的元操作或API：
logic: Get the right operand of the assignment expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.9825876355171204
*Check whether the right operand is a logical expression.* 匹配到的元操作或API：
query: Check whether the right operand is a logical expression.
most similar API: Check whether the boolean literal is expression
cosine Similarity: 0.8229268789291382
*Get the operator of logical expression.* 匹配到的元操作或API：
logic: Get the operator of logical expression.
most similar meta operation: Get the operator of infix expression
cosine Similarity: 0.854354977607727
*Check whether the operator is && or ||.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the left operand of the logical expression.* 匹配到的元操作或API：
logic: Get the left operand of the logical expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.918310284614563
*Check whether the left operand is a null check.* 匹配到的元操作或API：
query: Check whether the left operand is a null check.
most similar API: Check whether is null check
cosine Similarity: 0.8328814506530762
*Get the right operand of the logical expression.* 匹配到的元操作或API：
logic: Get the right operand of the logical expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.8976452350616455
*Check whether the right operand is an unboxing operation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the unboxing operation will throw NullPointerException.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the condition of the assignment expression (which is `boo == null && boo != true`).* 匹配到的元操作或API：
query: Get the condition of the assignment expression (which is `boo == null && boo != true`).
most similar API: get operator of assignment expression
cosine Similarity: 0.8129702806472778
*Check whether the condition is a logical expression.* 匹配到的元操作或API：
query: Check whether the condition is a logical expression.
most similar API: Check whether the boolean literal is expression
cosine Similarity: 0.8702107667922974
*Get the left operand of the logical expression (which is `boo == null`).* 匹配到的元操作或API：
logic: Get the left operand of the logical expression (which is `boo == null`).
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8610669374465942
*Check whether the left operand is a null check.* 匹配到的元操作或API：
query: Check whether the left operand is a null check.
most similar API: Check whether is null check
cosine Similarity: 0.8328814506530762
*Get the right operand of the logical expression (which is `boo != true`).* 匹配到的元操作或API：
query: Get the right operand of the logical expression (which is `boo != true`).
most similar API: get right operand of assignment expression
cosine Similarity: 0.8289005756378174
*Check whether the right operand is an unboxing operation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the unboxing operation will throw NullPointerException.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the condition of the assignment expression (which is `boo == null && boo != false`).* 匹配到的元操作或API：
query: Get the condition of the assignment expression (which is `boo == null && boo != false`).
most similar API: get operator of assignment expression
cosine Similarity: 0.8124513030052185
*Check whether the condition is a logical expression.* 匹配到的元操作或API：
query: Check whether the condition is a logical expression.
most similar API: Check whether the boolean literal is expression
cosine Similarity: 0.8702107667922974
*Get the left operand of the logical expression (which is `boo == null`).* 匹配到的元操作或API：
logic: Get the left operand of the logical expression (which is `boo == null`).
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8610669374465942
*Check whether the left operand is a null check.* 匹配到的元操作或API：
query: Check whether the left operand is a null check.
most similar API: Check whether is null check
cosine Similarity: 0.8328814506530762
*Get the right operand of the logical expression (which is `boo != false`).* 匹配到的元操作或API：
query: Get the right operand of the logical expression (which is `boo != false`).
most similar API: get right operand of assignment expression
cosine Similarity: 0.8311192989349365
*Check whether the right operand is an unboxing operation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the unboxing operation will throw NullPointerException.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the condition of the assignment expression (which is `boo == null && boo == true`).* 匹配到的元操作或API：
query: Get the condition of the assignment expression (which is `boo == null && boo == true`).
most similar API: get operator of assignment expression
cosine Similarity: 0.8120269775390625
*Check whether the condition is a logical expression.* 匹配到的元操作或API：
query: Check whether the condition is a logical expression.
most similar API: Check whether the boolean literal is expression
cosine Similarity: 0.8702107667922974
*Get the left operand of the logical expression (which is `boo == null`).* 匹配到的元操作或API：
logic: Get the left operand of the logical expression (which is `boo == null`).
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8610669374465942
*Check whether the left operand is a null check.* 匹配到的元操作或API：
query: Check whether the left operand is a null check.
most similar API: Check whether is null check
cosine Similarity: 0.8328814506530762
*Get the right operand of the logical expression (which is `boo == true`).* 匹配到的元操作或API：
query: Get the right operand of the logical expression (which is `boo == true`).
most similar API: get right operand of assignment expression
cosine Similarity: 0.8292065858840942
*Check whether the right operand is an unboxing operation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the unboxing operation will throw NullPointerException.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the condition of the assignment expression (which is `boo == null && boo == false`).* 匹配到的元操作或API：
query: Get the condition of the assignment expression (which is `boo == null && boo == false`).
most similar API: get operator of assignment expression
cosine Similarity: 0.8118269443511963
*Check whether the condition is a logical expression.* 匹配到的元操作或API：
query: Check whether the condition is a logical expression.
most similar API: Check whether the boolean literal is expression
cosine Similarity: 0.8702107667922974
*Get the left operand of the logical expression (which is `boo == null`).* 匹配到的元操作或API：
logic: Get the left operand of the logical expression (which is `boo == null`).
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8610669374465942
*Check whether the left operand is a null check.* 匹配到的元操作或API：
query: Check whether the left operand is a null check.
most similar API: Check whether is null check
cosine Similarity: 0.8328814506530762
*Get the right operand of the logical expression (which is `boo == false`).* 匹配到的元操作或API：
query: Get the right operand of the logical expression (which is `boo == false`).
most similar API: get right operand of assignment expression
cosine Similarity: 0.8317076563835144
*Check whether the right operand is an unboxing operation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the unboxing operation will throw NullPointerException.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
This checker has passed this negative testcase:
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}


This checker is failed(false negative) on this negative test case:
```
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;
                    result = boo == null && boo != true;  // boo != true would throw NPE because of unboxing
                    result = boo == null && boo != false; // same
                    result = boo == null && boo == true;  // same
                    result = boo == null && boo == false; // same
                }
            }
The number of violating the rule in this test case is: 4

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Test')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testPMD')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'boo')
            ——ASTNullLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'result')
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
3. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr getLeftOperand()
4. net.sourceforge.pmd.lang.java.ast.ASTVariableAccess: public net.sourceforge.pmd.lang.java.types.JTypeMirror getTypeMirror()
5. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
6. net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
7. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.BinaryOp getOperator()
8. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean isNullCheck(net.sourceforge.pmd.lang.java.ast.ASTExpression, net.sourceforge.pmd.lang.java.rule.internal.StablePathMatcher)
9. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.InternalInterfaces$OperatorLike getOperator()
10. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand(), //Returns the right-hand side operand.

1.  //Check whether the accessed variable is double type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isVariableAccessDoubleType(ASTVariableAccess var) {
    return var.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.DOUBLE);
}
```
2.  //Check whether the argument is boolean type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isMethodCallArgumentStringType(ASTMethodCall call) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class, ASTAssignmentExpression.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTAssignmentExpression node, Object data) {
        ASTExpression rightOperand = node.getRightOperand();
        if (rightOperand instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) rightOperand;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperandInfix = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isBooleanUnboxing(rightOperandInfix)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }

    private boolean isBooleanUnboxing(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            ASTExpression leftOperand = infixExpression.getLeftOperand();
            ASTExpression rightOperand = infixExpression.getRightOperand();
            return (isBooleanVariableAccess(leftOperand) && isBooleanLiteral(rightOperand)) ||
                   (isBooleanVariableAccess(rightOperand) && isBooleanLiteral(leftOperand));
        }
        return false;
    }

    private boolean isBooleanVariableAccess(ASTExpression node) {
        if (node instanceof ASTVariableAccess) {
            ASTVariableAccess varAccess = (ASTVariableAccess) node;
            JTypeMirror type = varAccess.getTypeMirror();
            return type.isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN) || TypeTestUtil.isA(Boolean.class, type);
        }
        return false;
    }

    private boolean isBooleanLiteral(ASTExpression node) {
        return node instanceof ASTBooleanLiteral;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <4> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <4> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all methods declared in class.
3. Check whether the method name is testPMD.
4. Get all statements in method testPMD.
5. Check whether the statement is an assignment expression.
6. Get the right-hand side operand of the assignment expression.
7. Check whether the operand is a logical expression.
8. Get the operator of the logical expression.
9. Check whether the operator is &&.
10. Get the operands of the logical expression.
11. Check whether the first operand is a null check (i.e., `boo == null`).
12. Check whether the second operand involves unboxing (i.e., `boo != true`, `boo != false`, `boo == true`, `boo == false`).
13. If the first operand is a null check and the second operand involves unboxing, then this test case violates the rule.

Let's perform these checks on the test case:

1. Get the name of class.
   - The name of the class is Test.

2. Get all methods declared in class.
   - There is one method declared in class Test: `testPMD`.

3. Check whether the method name is testPMD.
   - The method name is testPMD.

4. Get all statements in method testPMD.
   - The statements in method testPMD are:
     - `Boolean boo = null;`
     - `boolean result;`
     - `result = boo == null && boo != true;`
     - `result = boo == null && boo != false;`
     - `result = boo == null && boo == true;`
     - `result = boo == null && boo == false;`

5. Check whether the statement is an assignment expression.
   - The statements `result = boo == null && boo != true;`, `result = boo == null && boo != false;`, `result = boo == null && boo == true;`, and `result = boo == null && boo == false;` are assignment expressions.

6. Get the right-hand side operand of the assignment expression.
   - For `result = boo == null && boo != true;`, the right-hand side operand is `boo == null && boo != true`.
   - For `result = boo == null && boo != false;`, the right-hand side operand is `boo == null && boo != false`.
   - For `result = boo == null && boo == true;`, the right-hand side operand is `boo == null && boo == true`.
   - For `result = boo == null && boo == false;`, the right-hand side operand is `boo == null && boo == false`.

7. Check whether the operand is a logical expression.
   - The right-hand side operands are logical expressions.

8. Get the operator of the logical expression.
   - The operator of the logical expressions is &&.

9. Check whether the operator is &&.
   - The operator is &&.

10. Get the operands of the logical expression.
    - For `boo == null && boo != true`, the operands are `boo == null` and `boo != true`.
    - For `boo == null && boo != false`, the operands are `boo == null` and `boo != false`.
    - For `boo == null && boo == true`, the operands are `boo == null` and `boo == true`.
    - For `boo == null && boo == false`, the operands are `boo == null` and `boo == false`.

11. Check whether the first operand is a null check (i.e., `boo == null`).
    - The first operand in all cases is `boo == null`.

12. Check whether the second operand involves unboxing (i.e., `boo != true`, `boo != false`, `boo == true`, `boo == false`).
    - For `boo != true`, `boo != false`, `boo == true`, and `boo == false`, the second operand involves unboxing because `boo` is a Boolean object and these comparisons unbox the Boolean to a primitive boolean.

13. If the first operand is a null check and the second operand involves unboxing, then this test case violates the rule.
    - All four assignment expressions have a null check as the first operand and involve unboxing in the second operand, so all four violate the rule.

Therefore, the number of violations in this test case is indeed 4.
['Get the name of class.', 'Get all methods declared in class.', 'Check whether the method name is testPMD.', 'Get all statements in method testPMD.', 'Check whether the statement is an assignment expression.', 'Get the right-hand side operand of the assignment expression.', 'Check whether the operand is a logical expression.', 'Get the operator of the logical expression.', 'Check whether the operator is &&.', 'Get the operands of the logical expression.', 'Check whether the first operand is a null check (i.e., `boo == null`).', 'Check whether the second operand involves unboxing (i.e., `boo != true`, `boo != false`, `boo == true`, `boo == false`).', 'If the first operand is a null check and the second operand involves unboxing, then this test case violates the rule.', 'Get the name of class.', 'Get all methods declared in class.', 'Check whether the method name is testPMD.', 'Get all statements in method testPMD.', 'Check whether the statement is an assignment expression.', 'Get the right-hand side operand of the assignment expression.', 'Check whether the operand is a logical expression.', 'Get the operator of the logical expression.', 'Check whether the operator is &&.', 'Get the operands of the logical expression.', 'Check whether the first operand is a null check (i.e., `boo == null`).', 'Check whether the second operand involves unboxing (i.e., `boo != true`, `boo != false`, `boo == true`, `boo == false`).', 'If the first operand is a null check and the second operand involves unboxing, then this test case violates the rule.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTVariableDeclaratorId', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTAssignmentExpression', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTNullLiteral', 'ASTExpressionStatement', 'ASTBooleanLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether the method name is testPMD.* 匹配到的元操作或API：
query: Check whether the method name is testPMD.
most similar API: Check whether is test method
cosine Similarity: 0.8272207379341125
*Get all statements in method testPMD.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the statement is an assignment expression.* 匹配到的元操作或API：
query: Check whether the statement is an assignment expression.
most similar API: Check whether the assignment expression is expression
cosine Similarity: 0.9503116607666016
*Get the right-hand side operand of the assignment expression.* 匹配到的元操作或API：
logic: Get the right-hand side operand of the assignment expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.9076520800590515
*Check whether the operand is a logical expression.* 匹配到的元操作或API：
query: Check whether the operand is a logical expression.
most similar API: Check whether the boolean literal is expression
cosine Similarity: 0.8661144971847534
*Get the operator of the logical expression.* 匹配到的元操作或API：
logic: Get the operator of the logical expression.
most similar meta operation: Get the operator of infix expression
cosine Similarity: 0.85832679271698
*Check whether the operator is &&.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the operands of the logical expression.* 匹配到的元操作或API：
query: Get the operands of the logical expression.
most similar API: get left operand of assignment expression
cosine Similarity: 0.8207665681838989
*Check whether the first operand is a null check (i.e., `boo == null`).* 匹配到的元操作或API：
query: Check whether the first operand is a null check (i.e., `boo == null`).
most similar API: Check whether the boolean literal is null literal
cosine Similarity: 0.8238602876663208
*Check whether the second operand involves unboxing (i.e., `boo != true`, `boo != false`, `boo == true`, `boo == false`).* 匹配到的元操作或API：
未匹配成功元操作或API
*If the first operand is a null check and the second operand involves unboxing, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether the method name is testPMD.* 匹配到的元操作或API：
query: Check whether the method name is testPMD.
most similar API: Check whether is test method
cosine Similarity: 0.8272207379341125
*Get all statements in method testPMD.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the statement is an assignment expression.* 匹配到的元操作或API：
query: Check whether the statement is an assignment expression.
most similar API: Check whether the assignment expression is expression
cosine Similarity: 0.9503116607666016
*Get the right-hand side operand of the assignment expression.* 匹配到的元操作或API：
logic: Get the right-hand side operand of the assignment expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.9076520800590515
*Check whether the operand is a logical expression.* 匹配到的元操作或API：
query: Check whether the operand is a logical expression.
most similar API: Check whether the boolean literal is expression
cosine Similarity: 0.8661144971847534
*Get the operator of the logical expression.* 匹配到的元操作或API：
logic: Get the operator of the logical expression.
most similar meta operation: Get the operator of infix expression
cosine Similarity: 0.85832679271698
*Check whether the operator is &&.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the operands of the logical expression.* 匹配到的元操作或API：
query: Get the operands of the logical expression.
most similar API: get left operand of assignment expression
cosine Similarity: 0.8207665681838989
*Check whether the first operand is a null check (i.e., `boo == null`).* 匹配到的元操作或API：
query: Check whether the first operand is a null check (i.e., `boo == null`).
most similar API: Check whether the boolean literal is null literal
cosine Similarity: 0.8238602876663208
*Check whether the second operand involves unboxing (i.e., `boo != true`, `boo != false`, `boo == true`, `boo == false`).* 匹配到的元操作或API：
未匹配成功元操作或API
*If the first operand is a null check and the second operand involves unboxing, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
This checker has passed this negative testcase:
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}


This checker is failed(false negative) on this negative test case:
```
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;
                    result = boo == null && boo != true;  // boo != true would throw NPE because of unboxing
                    result = boo == null && boo != false; // same
                    result = boo == null && boo == true;  // same
                    result = boo == null && boo == false; // same
                }
            }
The number of violating the rule in this test case is: 4

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Test')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testPMD')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'boo')
            ——ASTNullLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'result')
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
4. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
5. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
6. net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
7. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.BinaryOp getOperator()
8. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr getLeftOperand(), //Returns the left-hand side, ie the expression being assigned to.
9. net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral: public boolean isNullLiteral(), //Returns true if this is the {@linkplain ASTNullLiteral null literal}.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTAssignmentExpression node, Object data) {
        ASTExpression rightOperand = node.getRightOperand();
        if (rightOperand instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) rightOperand;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand2 = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isUnboxingCall(rightOperand2)) {
                    addViolation(data, node);
                } else if (isUnboxingCall(leftOperand) && isNullCheck(rightOperand2)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean isUnboxingCall(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            BinaryOp operator = infixExpression.getOperator();
            if (operator == BinaryOp.EQ || operator == BinaryOp.NE) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                return isNullLiteral(leftOperand) && isBooleanLiteral(rightOperand) ||
                       isNullLiteral(rightOperand) && isBooleanLiteral(leftOperand);
            }
        }
        return false;
    }

    private boolean isNullLiteral(ASTExpression node) {
        return JavaAstUtils.isNullLiteral(node);
    }

    private boolean isBooleanLiteral(ASTExpression node) {
        return node instanceof ASTBooleanLiteral;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <4> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <4> but was: <0>不通过
=========================error_testcase_logics=========================
1. Check whether the class is abstract.
        2. Check whether the class has declared annotations.
        3. Get the javadoc comment of class.
        4. Get the name of method.
        5. Get the signature of method.
        6. Get the javadoc comment of method.
        7. Check whether the method is abstract.
        8. Check whether the method is private.
        9. Check whether the method is public.
        10. Check whether the method is default package-private.
        11. Check whether the method is protected.
        12. Check whether the method is main method.
        13. Get a formal parameter of method.
        14. Get the number of formal parameters of method.
        15. Get the name of formal parameter.
        16. Get the type of formal parameter.
        17. Check whether the formal parameter is string type.
        18. Check whether the formal parameter is boolean type.
        19. Check whether the formal parameter is char type.
        20. Check whether the formal parameter is byte type.
        21. Check whether the formal parameter is short type.
        22. Check whether the formal parameter is int type.
        23. Check whether the formal parameter is long type.
        24. Check whether the formal parameter is float type.
        25. Check whether the formal parameter is double type.
        26. Check whether the formal parameter is boxed type.
        27. Check whether the formal parameter is a x class type.
        28. Check whether the formal parameter is array type.
        29. Check whether the formal parameter is enum type.
        30. Check whether the formal parameter is record type.
        31. Check whether formal parameter has declared annotations.
        32. Get a declared annotation of formal parameter.
        33. Check whether the formal parameter has x annotation.
        34. Get an usage of formal parameter.
        35. Check whether the formal parameter is final.
        36. Get the return type of method.
        37. Check whether the return type of method is void.
        38. Check whether the return type of method is string type.
        39. Check whether the return type of method is boolean type.
        40. Check whether the return type of method is char type.
        41. Check whether the return type of method is byte type.
        42. Check whether the return type of method is short type.
        43. Check whether the return type of method is int type.
        44. Check whether the return type of method is long type.
        45. Check whether the return type of method is float type.
        46. Check whether the return type of method is double type.
        47. Check whether the return type of method is boxed type.
        48. Check whether the return type of method is x class type.
        49. Check whether the return type of method is array type.
        50. Check whether the return type of method is enum type.
        51. Check whether the return type of method is record type.
        52. Get a throw exception in method signature.
        53. Check whether the method signature throws x Exception.
        54. Check whether method has declared annotations.
        55. Get a declared annotation of method.
        56. Check whether the method has x annotation.
        57. Get the name of constructor.
        58. Get the signature of constructor.
        59. Get the javadoc comment of constructor.
        60. Check whether the constructor is private.
        61. Check whether the constructor is public.
        62. Check whether the constructor is default package-private.
        63. Check whether the constructor is protected.
        64. Get a formal parameter of constructor.
        65. Get the number of formal parameters of constructor.
        66. Get the throw exception in constructor signature.
        67. Check whether the constructor signature throws x Exception.
        68. Check whether constructor has declared annotations.
        69. Get a declared annotation of constructor.
        70. Check whether the constructor has x annotation.
        71. Check whether the method is synchronized.
        72. Check whether the method is static.
        73. Check whether the method is final.
        74. Check whether the method is native.
        75. Check whether the method is overridable.
        76. Check whether the method is overridden.
        77. Get the original method of this overridden method.
        78. Get the class that method located in.
        79. Check whether the method is a junit method.
        80. Get the return expression in return statement.

From the provided test case, let's focus on the relevant checks:

1. Get the class that method located in.
2. Get the name of method.
3. Get the signature of method.
4. Get all expressions in the method.
5. For each expression, check whether it is an infix expression with the operator &&.
6. If infix expression with && is found, get the left operand of the infix expression.
7. Check whether the left operand is an infix expression with the operator ==.
8. If infix expression with == is found, get the left and right operands of this expression.
9. Check whether the right operand is null.
10. If right operand is null, get the right operand of the infix expression with &&.
11. Check whether the right operand is an infix expression with the operator !=.
12. If infix expression with != is found, get the left and right operands of this expression.
13. Check whether the left operand is the same as the field declared in the class.
14. Check whether the type of the field is a boxed type.
15. If the type of the field is a boxed type, this test case violates the rule.

Now, let's apply these checks to each assignment:

- For `result = boo == null && boo != true;`:
  5. Check whether the expression is an infix expression with the operator &&.
  6. Get the left operand of the infix expression.
  7. Check whether the left operand is an infix expression with the operator ==.
  8. Get the left and right operands of this expression.
  9. Check whether the right operand is null.
  10. Get the right operand of the infix expression with &&.
  11. Check whether the right operand is an infix expression with the operator !=.
  12. Get the left and right operands of this expression.
  13. Check whether the left operand is the same as the field declared in the class.
  14. Check whether the type of the field is a boxed type.
  (This violates the rule)

- For `result = boo == null && boo != false;`:
  5. Check whether the expression is an infix expression with the operator &&.
  6. Get the left operand of the infix expression.
  7. Check whether the left operand is an infix expression with the operator ==.
  8. Get the left and right operands of this expression.
  9. Check whether the right operand is null.
  10. Get the right operand of the infix expression with &&.
  11. Check whether the right operand is an infix expression with the operator !=.
  12. Get the left and right operands of this expression.
  13. Check whether the left operand is the same as the field declared in the class.
  14. Check whether the type of the field is a boxed type.
  (This violates the rule)

- For `result = boo == null && boo == true;`:
  5. Check whether the expression is an infix expression with the operator &&.
  6. Get the left operand of the infix expression.
  7. Check whether the left operand is an infix expression with the operator ==.
  8. Get the left and right operands of this expression.
  9. Check whether the right operand is null.
  10. Get the right operand of the infix expression with &&.
  11. Check whether the right operand is an infix expression with the operator ==.
  12. Get the left and right operands of this expression.
  13. Check whether the left operand is the same as the field declared in the class.
  14. Check whether the type of the field is a boxed type.
  (This violates the rule)

- For `result = boo == null && boo == false;`:
  5. Check whether the expression is an infix expression with the operator &&.
  6. Get the left operand of the infix expression.
  7. Check whether the left operand is an infix expression with the operator ==.
  8. Get the left and right operands of this expression.
  9. Check whether the right operand is null.
  10. Get the right operand of the infix expression with &&.
  11. Check whether the right operand is an infix expression with the operator ==.
  12. Get the left and right operands of this expression.
  13. Check whether the left operand is the same as the field declared in the class.
  14. Check whether the type of the field is a boxed type.
  (This violates the rule)

Each assignment expression violates the rule as described.
['Check whether the class is abstract.', 'Check whether the class has declared annotations.', 'Get the javadoc comment of class.', 'Get the name of method.', 'Get the signature of method.', 'Get the javadoc comment of method.', 'Check whether the method is abstract.', 'Check whether the method is private.', 'Check whether the method is public.', 'Check whether the method is default package-private.', 'Check whether the method is protected.', 'Check whether the method is main method.', 'Get a formal parameter of method.', 'Get the number of formal parameters of method.', 'Get the name of formal parameter.', 'Get the type of formal parameter.', 'Check whether the formal parameter is string type.', 'Check whether the formal parameter is boolean type.', 'Check whether the formal parameter is char type.', 'Check whether the formal parameter is byte type.', 'Check whether the formal parameter is short type.', 'Check whether the formal parameter is int type.', 'Check whether the formal parameter is long type.', 'Check whether the formal parameter is float type.', 'Check whether the formal parameter is double type.', 'Check whether the formal parameter is boxed type.', 'Check whether the formal parameter is a x class type.', 'Check whether the formal parameter is array type.', 'Check whether the formal parameter is enum type.', 'Check whether the formal parameter is record type.', 'Check whether formal parameter has declared annotations.', 'Get a declared annotation of formal parameter.', 'Check whether the formal parameter has x annotation.', 'Get an usage of formal parameter.', 'Check whether the formal parameter is final.', 'Get the return type of method.', 'Check whether the return type of method is void.', 'Check whether the return type of method is string type.', 'Check whether the return type of method is boolean type.', 'Check whether the return type of method is char type.', 'Check whether the return type of method is byte type.', 'Check whether the return type of method is short type.', 'Check whether the return type of method is int type.', 'Check whether the return type of method is long type.', 'Check whether the return type of method is float type.', 'Check whether the return type of method is double type.', 'Check whether the return type of method is boxed type.', 'Check whether the return type of method is x class type.', 'Check whether the return type of method is array type.', 'Check whether the return type of method is enum type.', 'Check whether the return type of method is record type.', 'Get a throw exception in method signature.', 'Check whether the method signature throws x Exception.', 'Check whether method has declared annotations.', 'Get a declared annotation of method.', 'Check whether the method has x annotation.', 'Get the name of constructor.', 'Get the signature of constructor.', 'Get the javadoc comment of constructor.', 'Check whether the constructor is private.', 'Check whether the constructor is public.', 'Check whether the constructor is default package-private.', 'Check whether the constructor is protected.', 'Get a formal parameter of constructor.', 'Get the number of formal parameters of constructor.', 'Get the throw exception in constructor signature.', 'Check whether the constructor signature throws x Exception.', 'Check whether constructor has declared annotations.', 'Get a declared annotation of constructor.', 'Check whether the constructor has x annotation.', 'Check whether the method is synchronized.', 'Check whether the method is static.', 'Check whether the method is final.', 'Check whether the method is native.', 'Check whether the method is overridable.', 'Check whether the method is overridden.', 'Get the original method of this overridden method.', 'Get the class that method located in.', 'Check whether the method is a junit method.', 'Get the return expression in return statement.', 'Get the class that method located in.', 'Get the name of method.', 'Get the signature of method.', 'Get all expressions in the method.', 'For each expression, check whether it is an infix expression with the operator &&.', 'If infix expression with && is found, get the left operand of the infix expression.', 'Check whether the left operand is an infix expression with the operator ==.', 'If infix expression with == is found, get the left and right operands of this expression.', 'Check whether the right operand is null.', 'If right operand is null, get the right operand of the infix expression with &&.', 'Check whether the right operand is an infix expression with the operator !=.', 'If infix expression with != is found, get the left and right operands of this expression.', 'Check whether the left operand is the same as the field declared in the class.', 'Check whether the type of the field is a boxed type.', 'If the type of the field is a boxed type, this test case violates the rule.', 'Check whether the expression is an infix expression with the operator &&.', 'Get the left operand of the infix expression.', 'Check whether the left operand is an infix expression with the operator ==.', 'Get the left and right operands of this expression.', 'Check whether the right operand is null.', 'Get the right operand of the infix expression with &&.', 'Check whether the right operand is an infix expression with the operator !=.', 'Get the left and right operands of this expression.', 'Check whether the left operand is the same as the field declared in the class.', 'Check whether the type of the field is a boxed type.', 'Check whether the expression is an infix expression with the operator &&.', 'Get the left operand of the infix expression.', 'Check whether the left operand is an infix expression with the operator ==.', 'Get the left and right operands of this expression.', 'Check whether the right operand is null.', 'Get the right operand of the infix expression with &&.', 'Check whether the right operand is an infix expression with the operator !=.', 'Get the left and right operands of this expression.', 'Check whether the left operand is the same as the field declared in the class.', 'Check whether the type of the field is a boxed type.', 'Check whether the expression is an infix expression with the operator &&.', 'Get the left operand of the infix expression.', 'Check whether the left operand is an infix expression with the operator ==.', 'Get the left and right operands of this expression.', 'Check whether the right operand is null.', 'Get the right operand of the infix expression with &&.', 'Check whether the right operand is an infix expression with the operator ==.', 'Get the left and right operands of this expression.', 'Check whether the left operand is the same as the field declared in the class.', 'Check whether the type of the field is a boxed type.', 'Check whether the expression is an infix expression with the operator &&.', 'Get the left operand of the infix expression.', 'Check whether the left operand is an infix expression with the operator ==.', 'Get the left and right operands of this expression.', 'Check whether the right operand is null.', 'Get the right operand of the infix expression with &&.', 'Check whether the right operand is an infix expression with the operator ==.', 'Get the left and right operands of this expression.', 'Check whether the left operand is the same as the field declared in the class.', 'Check whether the type of the field is a boxed type.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTVariableDeclaratorId', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTAssignmentExpression', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTNullLiteral', 'ASTExpressionStatement', 'ASTBooleanLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Get the javadoc comment of method.* 匹配到的元操作或API：
logic: Get the javadoc comment of method.
most similar meta operation: Get the javadoc comment of method
cosine Similarity: 0.9902204871177673
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Check whether the method is private.* 匹配到的元操作或API：
logic: Check whether the method is private.
most similar meta operation: Check whether the method is private
cosine Similarity: 0.9821236729621887
*Check whether the method is public.* 匹配到的元操作或API：
logic: Check whether the method is public.
most similar meta operation: Check whether the method is public
cosine Similarity: 0.982057511806488
*Check whether the method is default package-private.* 匹配到的元操作或API：
logic: Check whether the method is default package-private.
most similar meta operation: Check whether the method is default package-private
cosine Similarity: 0.972201406955719
*Check whether the method is protected.* 匹配到的元操作或API：
logic: Check whether the method is protected.
most similar meta operation: Check whether the method is protected
cosine Similarity: 0.9815421104431152
*Check whether the method is main method.* 匹配到的元操作或API：
logic: Check whether the method is main method.
most similar meta operation: Check whether the method is main method
cosine Similarity: 0.9875174760818481
*Get a formal parameter of method.* 匹配到的元操作或API：
logic: Get a formal parameter of method.
most similar meta operation: Get a formal parameter of method
cosine Similarity: 0.9826655983924866
*Get the number of formal parameters of method.* 匹配到的元操作或API：
logic: Get the number of formal parameters of method.
most similar meta operation: Get the number of formal parameters of method
cosine Similarity: 0.9860840439796448
*Get the name of formal parameter.* 匹配到的元操作或API：
logic: Get the name of formal parameter.
most similar meta operation: Get the name of formal parameter
cosine Similarity: 0.9837440252304077
*Get the type of formal parameter.* 匹配到的元操作或API：
logic: Get the type of formal parameter.
most similar meta operation: Get the type of formal parameter
cosine Similarity: 0.9854808449745178
*Check whether the formal parameter is string type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is string type.
most similar meta operation: Check whether the formal parameter is string type
cosine Similarity: 0.9882045984268188
*Check whether the formal parameter is boolean type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is boolean type.
most similar meta operation: Check whether the formal parameter is boolean type
cosine Similarity: 0.9861541986465454
*Check whether the formal parameter is char type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is char type.
most similar meta operation: Check whether the formal parameter is char type
cosine Similarity: 0.9883654713630676
*Check whether the formal parameter is byte type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is byte type.
most similar meta operation: Check whether the formal parameter is byte type
cosine Similarity: 0.989282488822937
*Check whether the formal parameter is short type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is short type.
most similar meta operation: Check whether the formal parameter is short type
cosine Similarity: 0.9876381158828735
*Check whether the formal parameter is int type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is int type.
most similar meta operation: Check whether the formal parameter is int type
cosine Similarity: 0.9879910945892334
*Check whether the formal parameter is long type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is long type.
most similar meta operation: Check whether the formal parameter is long type
cosine Similarity: 0.988408625125885
*Check whether the formal parameter is float type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is float type.
most similar meta operation: Check whether the formal parameter is float type
cosine Similarity: 0.9876444935798645
*Check whether the formal parameter is double type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is double type.
most similar meta operation: Check whether the formal parameter is double type
cosine Similarity: 0.9877136945724487
*Check whether the formal parameter is boxed type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is boxed type.
most similar meta operation: Check whether the formal parameter is boxed primitive type
cosine Similarity: 0.9612672328948975
*Check whether the formal parameter is a x class type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is a x class type.
most similar meta operation: Check whether the formal parameter is a x class type
cosine Similarity: 0.9905358552932739
*Check whether the formal parameter is array type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is array type.
most similar meta operation: Check whether the formal parameter is array type
cosine Similarity: 0.9873113036155701
*Check whether the formal parameter is enum type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is enum type.
most similar meta operation: Check whether the formal parameter is enum type
cosine Similarity: 0.9871471524238586
*Check whether the formal parameter is record type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is record type.
most similar meta operation: Check whether the formal parameter is record type
cosine Similarity: 0.9890471696853638
*Check whether formal parameter has declared annotations.* 匹配到的元操作或API：
logic: Check whether formal parameter has declared annotations.
most similar meta operation: Check whether formal parameter has declared annotations
cosine Similarity: 0.9899719953536987
*Get a declared annotation of formal parameter.* 匹配到的元操作或API：
logic: Get a declared annotation of formal parameter.
most similar meta operation: Get a declared annotation of formal parameter
cosine Similarity: 0.9871978759765625
*Check whether the formal parameter has x annotation.* 匹配到的元操作或API：
logic: Check whether the formal parameter has x annotation.
most similar meta operation: Check whether the formal parameter has x annotation
cosine Similarity: 0.9898931980133057
*Get an usage of formal parameter.* 匹配到的元操作或API：
logic: Get an usage of formal parameter.
most similar meta operation: Get an usage of formal parameter
cosine Similarity: 0.986284613609314
*Check whether the formal parameter is final.* 匹配到的元操作或API：
logic: Check whether the formal parameter is final.
most similar meta operation: Check whether the formal parameter is final
cosine Similarity: 0.9881319403648376
*Get the return type of method.* 匹配到的元操作或API：
logic: Get the return type of method.
most similar meta operation: Get the return type of method
cosine Similarity: 0.983596682548523
*Check whether the return type of method is void.* 匹配到的元操作或API：
logic: Check whether the return type of method is void.
most similar meta operation: Check whether the return type of method is void
cosine Similarity: 0.9854096174240112
*Check whether the return type of method is string type.* 匹配到的元操作或API：
logic: Check whether the return type of method is string type.
most similar meta operation: Check whether the return type of method is string type
cosine Similarity: 0.9892082214355469
*Check whether the return type of method is boolean type.* 匹配到的元操作或API：
logic: Check whether the return type of method is boolean type.
most similar meta operation: Check whether the return type of method is boolean
cosine Similarity: 0.9835399389266968
*Check whether the return type of method is char type.* 匹配到的元操作或API：
logic: Check whether the return type of method is char type.
most similar meta operation: Check whether the return type of method is char
cosine Similarity: 0.9825600981712341
*Check whether the return type of method is byte type.* 匹配到的元操作或API：
logic: Check whether the return type of method is byte type.
most similar meta operation: Check whether the return type of method is byte
cosine Similarity: 0.984508216381073
*Check whether the return type of method is short type.* 匹配到的元操作或API：
logic: Check whether the return type of method is short type.
most similar meta operation: Check whether the return type of called method is short type
cosine Similarity: 0.9720065593719482
*Check whether the return type of method is int type.* 匹配到的元操作或API：
logic: Check whether the return type of method is int type.
most similar meta operation: Check whether the return type of method is int
cosine Similarity: 0.9842365384101868
*Check whether the return type of method is long type.* 匹配到的元操作或API：
logic: Check whether the return type of method is long type.
most similar meta operation: Check whether the return type of method is long
cosine Similarity: 0.9787604212760925
*Check whether the return type of method is float type.* 匹配到的元操作或API：
logic: Check whether the return type of method is float type.
most similar meta operation: Check whether the return type of method is float
cosine Similarity: 0.9870142936706543
*Check whether the return type of method is double type.* 匹配到的元操作或API：
logic: Check whether the return type of method is double type.
most similar meta operation: Check whether the return type of method is double
cosine Similarity: 0.9748761653900146
*Check whether the return type of method is boxed type.* 匹配到的元操作或API：
logic: Check whether the return type of method is boxed type.
most similar meta operation: Check whether the return type of called method is boxed type
cosine Similarity: 0.9796503782272339
*Check whether the return type of method is x class type.* 匹配到的元操作或API：
logic: Check whether the return type of method is x class type.
most similar meta operation: Check whether the return type of method is x class type
cosine Similarity: 0.9898589849472046
*Check whether the return type of method is array type.* 匹配到的元操作或API：
logic: Check whether the return type of method is array type.
most similar meta operation: Check whether the return type of method is array type
cosine Similarity: 0.9890990853309631
*Check whether the return type of method is enum type.* 匹配到的元操作或API：
logic: Check whether the return type of method is enum type.
most similar meta operation: Check whether the return type of method is enum type
cosine Similarity: 0.9887509346008301
*Check whether the return type of method is record type.* 匹配到的元操作或API：
logic: Check whether the return type of method is record type.
most similar meta operation: Check whether the return type of method is record type
cosine Similarity: 0.9906391501426697
*Get a throw exception in method signature.* 匹配到的元操作或API：
logic: Get a throw exception in method signature.
most similar meta operation: Get a throw exception in method signature
cosine Similarity: 0.9811146259307861
*Check whether the method signature throws x Exception.* 匹配到的元操作或API：
logic: Check whether the method signature throws x Exception.
most similar meta operation: Check whether the method signature throws x Exception
cosine Similarity: 0.9918776750564575
*Check whether method has declared annotations.* 匹配到的元操作或API：
logic: Check whether method has declared annotations.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9891549348831177
*Get a declared annotation of method.* 匹配到的元操作或API：
logic: Get a declared annotation of method.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9867770671844482
*Check whether the method has x annotation.* 匹配到的元操作或API：
logic: Check whether the method has x annotation.
most similar meta operation: Check whether the method has x annotation
cosine Similarity: 0.9902997016906738
*Get the name of constructor.* 匹配到的元操作或API：
logic: Get the name of constructor.
most similar meta operation: Get the name of constructor
cosine Similarity: 0.9789292812347412
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828827381134033
*Get the javadoc comment of constructor.* 匹配到的元操作或API：
logic: Get the javadoc comment of constructor.
most similar meta operation: Get the javadoc comment of constructor
cosine Similarity: 0.9908277988433838
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Check whether the constructor is default package-private.* 匹配到的元操作或API：
logic: Check whether the constructor is default package-private.
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.9616611003875732
*Check whether the constructor is protected.* 匹配到的元操作或API：
logic: Check whether the constructor is protected.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9850410223007202
*Get a formal parameter of constructor.* 匹配到的元操作或API：
logic: Get a formal parameter of constructor.
most similar meta operation: Get a formal parameter of constructor
cosine Similarity: 0.98207688331604
*Get the number of formal parameters of constructor.* 匹配到的元操作或API：
logic: Get the number of formal parameters of constructor.
most similar meta operation: Get the number of formal parameters of constructor
cosine Similarity: 0.9865633845329285
*Get the throw exception in constructor signature.* 匹配到的元操作或API：
logic: Get the throw exception in constructor signature.
most similar meta operation: Get a throw exception in constructor signature
cosine Similarity: 0.9500002861022949
*Check whether the constructor signature throws x Exception.* 匹配到的元操作或API：
logic: Check whether the constructor signature throws x Exception.
most similar meta operation: Check whether the constructor signature throws x Exception
cosine Similarity: 0.9923062324523926
*Check whether constructor has declared annotations.* 匹配到的元操作或API：
logic: Check whether constructor has declared annotations.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.9901279807090759
*Get a declared annotation of constructor.* 匹配到的元操作或API：
logic: Get a declared annotation of constructor.
most similar meta operation: Get a declared annotation of constructor
cosine Similarity: 0.9872554540634155
*Check whether the constructor has x annotation.* 匹配到的元操作或API：
logic: Check whether the constructor has x annotation.
most similar meta operation: Check whether the constructor has x annotation
cosine Similarity: 0.9916678667068481
*Check whether the method is synchronized.* 匹配到的元操作或API：
logic: Check whether the method is synchronized.
most similar meta operation: Check whether the method is synchronized
cosine Similarity: 0.9820958375930786
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is final.* 匹配到的元操作或API：
logic: Check whether the method is final.
most similar meta operation: Check whether the method is final
cosine Similarity: 0.985183835029602
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is overridable.* 匹配到的元操作或API：
logic: Check whether the method is overridable.
most similar meta operation: Check whether the method is overridable
cosine Similarity: 0.9839692115783691
*Check whether the method is overridden.* 匹配到的元操作或API：
logic: Check whether the method is overridden.
most similar meta operation: Check whether the method is overridden
cosine Similarity: 0.9829655885696411
*Get the original method of this overridden method.* 匹配到的元操作或API：
logic: Get the original method of this overridden method.
most similar meta operation: Get the original method of this overridden method
cosine Similarity: 0.9831136465072632
*Get the class that method located in.* 匹配到的元操作或API：
logic: Get the class that method located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9805244207382202
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Get the return expression in return statement.* 匹配到的元操作或API：
logic: Get the return expression in return statement.
most similar meta operation: Get the return expression in return statement
cosine Similarity: 0.9881546497344971
*Get the class that method located in.* 匹配到的元操作或API：
logic: Get the class that method located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9805244207382202
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Get all expressions in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each expression, check whether it is an infix expression with the operator &&.* 匹配到的元操作或API：
logic: For each expression, check whether it is an infix expression with the operator &&.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9001193642616272
*If infix expression with && is found, get the left operand of the infix expression.* 匹配到的元操作或API：
logic: If infix expression with && is found, get the left operand of the infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9511681199073792
*Check whether the left operand is an infix expression with the operator ==.* 匹配到的元操作或API：
logic: Check whether the left operand is an infix expression with the operator ==.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.886795699596405
*If infix expression with == is found, get the left and right operands of this expression.* 匹配到的元操作或API：
logic: If infix expression with == is found, get the left and right operands of this expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9098556637763977
*Check whether the right operand is null.* 匹配到的元操作或API：
query: Check whether the right operand is null.
most similar API: Check whether the null literal equals
cosine Similarity: 0.8364773988723755
*If right operand is null, get the right operand of the infix expression with &&.* 匹配到的元操作或API：
logic: If right operand is null, get the right operand of the infix expression with &&.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9193975925445557
*Check whether the right operand is an infix expression with the operator !=.* 匹配到的元操作或API：
logic: Check whether the right operand is an infix expression with the operator !=.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.8918845653533936
*If infix expression with != is found, get the left and right operands of this expression.* 匹配到的元操作或API：
logic: If infix expression with != is found, get the left and right operands of this expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.8997522592544556
*Check whether the left operand is the same as the field declared in the class.* 匹配到的元操作或API：
query: Check whether the left operand is the same as the field declared in the class.
most similar API: get left operand of assignment expression
cosine Similarity: 0.8047218918800354
*Check whether the type of the field is a boxed type.* 匹配到的元操作或API：
logic: Check whether the type of the field is a boxed type.
most similar meta operation: Check whether the field is boxed primitive type
cosine Similarity: 0.9327374696731567
*If the type of the field is a boxed type, this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the expression is an infix expression with the operator &&.* 匹配到的元操作或API：
logic: Check whether the expression is an infix expression with the operator &&.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.927524745464325
*Get the left operand of the infix expression.* 匹配到的元操作或API：
logic: Get the left operand of the infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9858164191246033
*Check whether the left operand is an infix expression with the operator ==.* 匹配到的元操作或API：
logic: Check whether the left operand is an infix expression with the operator ==.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.886795699596405
*Get the left and right operands of this expression.* 匹配到的元操作或API：
logic: Get the left and right operands of this expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8793166279792786
*Check whether the right operand is null.* 匹配到的元操作或API：
query: Check whether the right operand is null.
most similar API: Check whether the null literal equals
cosine Similarity: 0.8364773988723755
*Get the right operand of the infix expression with &&.* 匹配到的元操作或API：
logic: Get the right operand of the infix expression with &&.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9579029083251953
*Check whether the right operand is an infix expression with the operator !=.* 匹配到的元操作或API：
logic: Check whether the right operand is an infix expression with the operator !=.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.8918845653533936
*Get the left and right operands of this expression.* 匹配到的元操作或API：
logic: Get the left and right operands of this expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8793166279792786
*Check whether the left operand is the same as the field declared in the class.* 匹配到的元操作或API：
query: Check whether the left operand is the same as the field declared in the class.
most similar API: get left operand of assignment expression
cosine Similarity: 0.8047218918800354
*Check whether the type of the field is a boxed type.* 匹配到的元操作或API：
logic: Check whether the type of the field is a boxed type.
most similar meta operation: Check whether the field is boxed primitive type
cosine Similarity: 0.9327374696731567
*Check whether the expression is an infix expression with the operator &&.* 匹配到的元操作或API：
logic: Check whether the expression is an infix expression with the operator &&.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.927524745464325
*Get the left operand of the infix expression.* 匹配到的元操作或API：
logic: Get the left operand of the infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9858164191246033
*Check whether the left operand is an infix expression with the operator ==.* 匹配到的元操作或API：
logic: Check whether the left operand is an infix expression with the operator ==.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.886795699596405
*Get the left and right operands of this expression.* 匹配到的元操作或API：
logic: Get the left and right operands of this expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8793166279792786
*Check whether the right operand is null.* 匹配到的元操作或API：
query: Check whether the right operand is null.
most similar API: Check whether the null literal equals
cosine Similarity: 0.8364773988723755
*Get the right operand of the infix expression with &&.* 匹配到的元操作或API：
logic: Get the right operand of the infix expression with &&.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9579029083251953
*Check whether the right operand is an infix expression with the operator !=.* 匹配到的元操作或API：
logic: Check whether the right operand is an infix expression with the operator !=.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.8918845653533936
*Get the left and right operands of this expression.* 匹配到的元操作或API：
logic: Get the left and right operands of this expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8793166279792786
*Check whether the left operand is the same as the field declared in the class.* 匹配到的元操作或API：
query: Check whether the left operand is the same as the field declared in the class.
most similar API: get left operand of assignment expression
cosine Similarity: 0.8047218918800354
*Check whether the type of the field is a boxed type.* 匹配到的元操作或API：
logic: Check whether the type of the field is a boxed type.
most similar meta operation: Check whether the field is boxed primitive type
cosine Similarity: 0.9327374696731567
*Check whether the expression is an infix expression with the operator &&.* 匹配到的元操作或API：
logic: Check whether the expression is an infix expression with the operator &&.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.927524745464325
*Get the left operand of the infix expression.* 匹配到的元操作或API：
logic: Get the left operand of the infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9858164191246033
*Check whether the left operand is an infix expression with the operator ==.* 匹配到的元操作或API：
logic: Check whether the left operand is an infix expression with the operator ==.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.886795699596405
*Get the left and right operands of this expression.* 匹配到的元操作或API：
logic: Get the left and right operands of this expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8793166279792786
*Check whether the right operand is null.* 匹配到的元操作或API：
query: Check whether the right operand is null.
most similar API: Check whether the null literal equals
cosine Similarity: 0.8364773988723755
*Get the right operand of the infix expression with &&.* 匹配到的元操作或API：
logic: Get the right operand of the infix expression with &&.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9579029083251953
*Check whether the right operand is an infix expression with the operator ==.* 匹配到的元操作或API：
logic: Check whether the right operand is an infix expression with the operator ==.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9018911719322205
*Get the left and right operands of this expression.* 匹配到的元操作或API：
logic: Get the left and right operands of this expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8793166279792786
*Check whether the left operand is the same as the field declared in the class.* 匹配到的元操作或API：
query: Check whether the left operand is the same as the field declared in the class.
most similar API: get left operand of assignment expression
cosine Similarity: 0.8047218918800354
*Check whether the type of the field is a boxed type.* 匹配到的元操作或API：
logic: Check whether the type of the field is a boxed type.
most similar meta operation: Check whether the field is boxed primitive type
cosine Similarity: 0.9327374696731567
*Check whether the expression is an infix expression with the operator &&.* 匹配到的元操作或API：
logic: Check whether the expression is an infix expression with the operator &&.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.927524745464325
*Get the left operand of the infix expression.* 匹配到的元操作或API：
logic: Get the left operand of the infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9858164191246033
*Check whether the left operand is an infix expression with the operator ==.* 匹配到的元操作或API：
logic: Check whether the left operand is an infix expression with the operator ==.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.886795699596405
*Get the left and right operands of this expression.* 匹配到的元操作或API：
logic: Get the left and right operands of this expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8793166279792786
*Check whether the right operand is null.* 匹配到的元操作或API：
query: Check whether the right operand is null.
most similar API: Check whether the null literal equals
cosine Similarity: 0.8364773988723755
*Get the right operand of the infix expression with &&.* 匹配到的元操作或API：
logic: Get the right operand of the infix expression with &&.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9579029083251953
*Check whether the right operand is an infix expression with the operator ==.* 匹配到的元操作或API：
logic: Check whether the right operand is an infix expression with the operator ==.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9018911719322205
*Get the left and right operands of this expression.* 匹配到的元操作或API：
logic: Get the left and right operands of this expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8793166279792786
*Check whether the left operand is the same as the field declared in the class.* 匹配到的元操作或API：
query: Check whether the left operand is the same as the field declared in the class.
most similar API: get left operand of assignment expression
cosine Similarity: 0.8047218918800354
*Check whether the type of the field is a boxed type.* 匹配到的元操作或API：
logic: Check whether the type of the field is a boxed type.
most similar meta operation: Check whether the field is boxed primitive type
cosine Similarity: 0.9327374696731567
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
This checker has passed this negative testcase:
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}


This checker is failed(false negative) on this negative test case:
```
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;
                    result = boo == null && boo != true;  // boo != true would throw NPE because of unboxing
                    result = boo == null && boo != false; // same
                    result = boo == null && boo == true;  // same
                    result = boo == null && boo == false; // same
                }
            }
The number of violating the rule in this test case is: 4

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Test')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testPMD')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'boo')
            ——ASTNullLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'result')
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPrivate()
8. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPublic()
9. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPackagePrivate()
10. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isProtected()
11. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isMainMethod()
12. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTFormalParameters getFormalParameters()
13. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
14. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
15. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public boolean isAnyAnnotationPresent(java.util.Collection)
16. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public boolean isFinal()
17. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getResultTypeNode()
18. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isVoid()
19. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTThrowsList getThrowsList()
20. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
21. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
22. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.String getName()
23. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
24. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
25. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
26. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()
27. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPackagePrivate()
28. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isProtected()
29. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTFormalParameters getFormalParameters()
30. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTThrowsList getThrowsList()
31. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
32. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
33. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isSynchronized()
34. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
35. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isFinal()
36. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
37. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isOverridden()
38. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getOverriddenMethod()
39. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType()
40. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
41. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getExpr()
42. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLeftOperand()
43. net.sourceforge.pmd.lang.java.ast.ASTNullLiteral: public boolean equals(java.lang.Object)
44. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
45. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr getLeftOperand(), //Returns the left-hand side, ie the expression being assigned to.
46. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr getLeftOperand()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Get the number of formal parameters of method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTMethodDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```
3.  //Get the name of formal parameter
```java
import net.sourceforge.pmd.lang.java.ast.*;
public String getFormalParameterName(ASTFormalParameter node) {
    return node.getVarId().getName();
}
```
4.  //Check whether the formal parameter is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFormalParameterStringType(ASTFormalParameter node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```
5.  //Check whether the formal parameter is boolean type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterBooleanType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN);
}
```
6.  //Check whether the formal parameter is char type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterCharType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.CHAR);
}
```
7.  //Check whether the formal parameter is byte type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterByteType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
}
```
8.  //Check whether the formal parameter is short type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterShortType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.SHORT);
}
```
9.  //Check whether the formal parameter is int type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterIntType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.INT);
}
```
10.  //Check whether the formal parameter is long type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterLongType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.LONG);
}
```
11.  //Check whether the formal parameter is float type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterFloatType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.FLOAT);
}
```
12.  //Check whether the formal parameter is double type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterDoubleType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.DOUBLE);
}
```
13.  //Check whether the formal parameter is boxed primitive type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public boolean isFormalParameterBoxedPrimitiveType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isBoxedPrimitive();
}
```
14.  //Check whether the formal parameter is a x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFormalParameterClassType(ASTFormalParameter node) {
    return TypeTestUtil.isA(x.class, node.getTypeNode());
}
```
15.  //Check whether the formal parameter is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isFormalParameterArrayType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```
16.  //Check whether the formal parameter is enum type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isFormalParameterEnumType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) type.getTypeMirror().getSymbol()).isEnum();
}
```
17.  //Check whether the formal parameter is record type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isFormalParameterRecordType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) type.getTypeMirror().getSymbol()).isRecord();
}
```
18.  //Check whether formal parameter has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotation(ASTFormalParameter node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```
19.  //Get an usage of formal parameter
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr;
import java.util.List;
public List<ASTAssignableExpr.ASTNamedReferenceExpr> getAUsage(ASTFormalParameter node){
    List<ASTAssignableExpr.ASTNamedReferenceExpr> localUsages = node.getVarId().getLocalUsages();
    return localUsages;
}
```
20.  //Check whether the return type of method is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnValueStringType(ASTMethodDeclaration method) {
    return TypeTestUtil.isA(String.class, method.getResultTypeNode());
}
```
21.  //Check whether the return type of method is boolean
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueBooleanType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN)) {
        return true;
    }
    return false;
}
```
22.  //Check whether the return type of method is char
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueCharType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.CHAR)) {
        return true;
    }
    return false;
}
```
23.  //Check whether the return type of method is byte
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueByteType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE)) {
        return true;
    }
    return false;
}
```
24.  //Check whether the return type of called method is short type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.JMethodSig;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnShortType(ASTMethodCall call) {
    JMethodSig m = call.getMethodType();
    return m.getReturnType().isPrimitive(JPrimitiveType.PrimitiveTypeKind.SHORT);
}
```
25.  //Check whether the return type of method is int
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueIntType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.INT)) {
        return true;
    }
    return false;
}
```
26.  //Check whether the return type of method is long
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueLongType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.LONG)) {
        return true;
    }
    return false;
}
```
27.  //Check whether the return type of method is float
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueFloatType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.FLOAT)) {
        return true;
    }
    return false;
}
```
28.  //Check whether the return type of method is double
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueDoubleType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.DOUBLE)) {
        return true;
    }
    return false;
}
```
29.  //Check whether the return type of called method is boxed type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.JMethodSig;
public boolean isReturnBoxedPrimitiveType(ASTMethodCall call) {
    JMethodSig m = call.getMethodType();
    return m.getReturnType().isBoxedPrimitive();
}
```
30.  //Check whether the return type of method is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnValueClassType(ASTMethodDeclaration method) {
    return TypeTestUtil.isA(x.class, method.getResultTypeNode());
}
```
31.  //Check whether the return type of method is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
public boolean isReturnValueArrayType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isArray()) {
        return true;
    }
    return false;
}
```
32.  //Check whether the return type of method is enum type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isReturnValueEnumType(ASTMethodDeclaration method) {
    return method.getResultTypeNode().getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) method.getResultTypeNode().getTypeMirror().getSymbol()).isEnum();
}
```
33.  //Check whether the return type of method is record type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isReturnValueRecordType(ASTMethodDeclaration method) {
    return method.getResultTypeNode().getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) method.getResultTypeNode().getTypeMirror().getSymbol()).isRecord();
}
```
34.  //Check whether the method signature throws x Exception
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean throwsSpecificException(ASTMethodDeclaration node){
    ASTThrowsList list = node.getThrowsList();
    if(list == null){
        return false;
    }else{
        for(ASTClassOrInterfaceType classOrInterfaceType : list){
            if(TypeTestUtil.isA(x.class, classOrInterfaceType)){
                return true;
            }
        }
    }
    return false;
}
```
35.  //Check whether method has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTMethodDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```
36.  //Get the number of formal parameters of constructor
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTConstructorDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```
37.  //Check whether the constructor signature throws x Exception
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean throwsSpecificException(ASTConstructorDeclaration node){
    ASTThrowsList list = node.getThrowsList();
    if(list == null){
        return false;
    }else{
        for(ASTClassOrInterfaceType classOrInterfaceType : list){
            if(TypeTestUtil.isA(x.class, classOrInterfaceType)){
                return true;
            }
        }
    }
    return false;
}
```
38.  //Check whether constructor has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTConstructorDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```
39.  //Check whether the method is overridable
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.ast.JModifier;
public boolean isOverridable(ASTMethodDeclaration method){
    return method.hasModifiers(JModifier.STATIC, JModifier.PRIVATE, JModifier.FINAL);
}
```
40.  //Check whether the operator in infix expression is ''
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils;
public boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op){
    //enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
    return JavaAstUtils.isInfixExprWithOperator(node, op);
}
```
41.  //Check whether the field is boxed primitive type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public boolean isFieldBoxedPrimitiveType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isBoxedPrimitive();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                } else if (isNullCheck(leftOperand) && isBoxedBooleanUnboxingCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }

    private boolean isBoxedBooleanUnboxingCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            ASTExpression leftOperand = infixExpression.getLeftOperand();
            ASTExpression rightOperand = infixExpression.getRightOperand();
            if (leftOperand instanceof ASTVariableAccess) {
                ASTType type = ((ASTVariableAccess) leftOperand).getType();
                JTypeMirror t = type.getTypeMirror();
                if (t.isBoxedPrimitive() && t.getBoxedType().getUnboxedType().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN)) {
                    return JavaAstUtils.isBooleanLiteral(rightOperand);
                }
            }
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
Let's analyze each line of the test case to check for violations of the rule.

1. Get the left operand of infix expression.
2. Check whether the left operand is an accessed field.
3. Get the name of accessed variable.
4. Check whether the accessed variable is a Boolean type.
5. Check whether the accessed variable is null.
6. Get the right operand of infix expression.
7. Check whether the right operand is an infix expression.
8. Get the left operand of the nested infix expression.
9. Check whether the left operand is an accessed field.
10. Get the name of accessed variable.
11. Check whether the accessed variable is a Boolean type.
12. Get the operator of the nested infix expression.
13. Check whether the operator in the nested infix expression is !=.
14. Get the right operand of the nested infix expression.
15. Check whether the right operand is a boolean literal.
16. Check whether the boolean literal is true.
17. Get the right operand of the outer infix expression.
18. Check whether the right operand is an infix expression.
19. Get the left operand of the nested infix expression.
20. Check whether the left operand is an accessed field.
21. Get the name of accessed variable.
22. Check whether the accessed variable is a Boolean type.
23. Get the operator of the nested infix expression.
24. Check whether the operator in the nested infix expression is !=.
25. Get the right operand of the nested infix expression.
26. Check whether the right operand is a boolean literal.
27. Check whether the boolean literal is false.
28. Get the right operand of the outer infix expression.
29. Check whether the right operand is an infix expression.
30. Get the left operand of the nested infix expression.
31. Check whether the left operand is an accessed field.
32. Get the name of accessed variable.
33. Check whether the accessed variable is a Boolean type.
34. Get the operator of the nested infix expression.
35. Check whether the operator in the nested infix expression is ==.
36. Get the right operand of the nested infix expression.
37. Check whether the right operand is a boolean literal.
38. Check whether the boolean literal is true.
39. Get the right operand of the outer infix expression.
40. Check whether the right operand is an infix expression.
41. Get the left operand of the nested infix expression.
42. Check whether the left operand is an accessed field.
43. Get the name of accessed variable.
44. Check whether the accessed variable is a Boolean type.
45. Get the operator of the nested infix expression.
46. Check whether the operator in the nested infix expression is ==.
47. Get the right operand of the nested infix expression.
48. Check whether the right operand is a boolean literal.
49. Check whether the boolean literal is false.

Each of these lines checks one of the four assignment expressions in the test case:

- For `result = boo == null && boo != true;`:
  - 1-5: Check the left operand of the `&&` expression (`boo == null`).
  - 6-17: Check the right operand of the `&&` expression (`boo != true`).

- For `result = boo == null && boo != false;`:
  - 18-27: Check the right operand of the `&&` expression (`boo != false`).

- For `result = boo == null && boo == true;`:
  - 28-38: Check the right operand of the `&&` expression (`boo == true`).

- For `result = boo == null && boo == false;`:
  - 39-49: Check the right operand of the `&&` expression (`boo == false`).

Each of these checks will confirm that `boo` is a `Boolean` type and is being compared to a boolean literal (`true` or `false`) without a preceding null check, which can lead to a `NullPointerException` when `boo` is `null`. Therefore, each of these four lines is a violation of the rule.
['Get the left operand of infix expression.', 'Check whether the left operand is an accessed field.', 'Get the name of accessed variable.', 'Check whether the accessed variable is a Boolean type.', 'Check whether the accessed variable is null.', 'Get the right operand of infix expression.', 'Check whether the right operand is an infix expression.', 'Get the left operand of the nested infix expression.', 'Check whether the left operand is an accessed field.', 'Get the name of accessed variable.', 'Check whether the accessed variable is a Boolean type.', 'Get the operator of the nested infix expression.', 'Check whether the operator in the nested infix expression is !=.', 'Get the right operand of the nested infix expression.', 'Check whether the right operand is a boolean literal.', 'Check whether the boolean literal is true.', 'Get the right operand of the outer infix expression.', 'Check whether the right operand is an infix expression.', 'Get the left operand of the nested infix expression.', 'Check whether the left operand is an accessed field.', 'Get the name of accessed variable.', 'Check whether the accessed variable is a Boolean type.', 'Get the operator of the nested infix expression.', 'Check whether the operator in the nested infix expression is !=.', 'Get the right operand of the nested infix expression.', 'Check whether the right operand is a boolean literal.', 'Check whether the boolean literal is false.', 'Get the right operand of the outer infix expression.', 'Check whether the right operand is an infix expression.', 'Get the left operand of the nested infix expression.', 'Check whether the left operand is an accessed field.', 'Get the name of accessed variable.', 'Check whether the accessed variable is a Boolean type.', 'Get the operator of the nested infix expression.', 'Check whether the operator in the nested infix expression is ==.', 'Get the right operand of the nested infix expression.', 'Check whether the right operand is a boolean literal.', 'Check whether the boolean literal is true.', 'Get the right operand of the outer infix expression.', 'Check whether the right operand is an infix expression.', 'Get the left operand of the nested infix expression.', 'Check whether the left operand is an accessed field.', 'Get the name of accessed variable.', 'Check whether the accessed variable is a Boolean type.', 'Get the operator of the nested infix expression.', 'Check whether the operator in the nested infix expression is ==.', 'Get the right operand of the nested infix expression.', 'Check whether the right operand is a boolean literal.', 'Check whether the boolean literal is false.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTVariableDeclaratorId', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTAssignmentExpression', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTNullLiteral', 'ASTExpressionStatement', 'ASTBooleanLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the left operand of infix expression.* 匹配到的元操作或API：
logic: Get the left operand of infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9903916120529175
*Check whether the left operand is an accessed field.* 匹配到的元操作或API：
logic: Check whether the left operand is an accessed field.
most similar meta operation: Check whether the accessed variable is a field
cosine Similarity: 0.8513689041137695
*Get the name of accessed variable.* 匹配到的元操作或API：
logic: Get the name of accessed variable.
most similar meta operation: Get the name of accessed variable
cosine Similarity: 0.986038088798523
*Check whether the accessed variable is a Boolean type.* 匹配到的元操作或API：
logic: Check whether the accessed variable is a Boolean type.
most similar meta operation: Check whether the accessed variable is boolean type
cosine Similarity: 0.9845060706138611
*Check whether the accessed variable is null.* 匹配到的元操作或API：
logic: Check whether the accessed variable is null.
most similar meta operation: Check whether the accessed variable is being read
cosine Similarity: 0.8577583432197571
*Get the right operand of infix expression.* 匹配到的元操作或API：
logic: Get the right operand of infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9884670972824097
*Check whether the right operand is an infix expression.* 匹配到的元操作或API：
logic: Check whether the right operand is an infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9103248119354248
*Get the left operand of the nested infix expression.* 匹配到的元操作或API：
logic: Get the left operand of the nested infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9677199721336365
*Check whether the left operand is an accessed field.* 匹配到的元操作或API：
logic: Check whether the left operand is an accessed field.
most similar meta operation: Check whether the accessed variable is a field
cosine Similarity: 0.8513689041137695
*Get the name of accessed variable.* 匹配到的元操作或API：
logic: Get the name of accessed variable.
most similar meta operation: Get the name of accessed variable
cosine Similarity: 0.986038088798523
*Check whether the accessed variable is a Boolean type.* 匹配到的元操作或API：
logic: Check whether the accessed variable is a Boolean type.
most similar meta operation: Check whether the accessed variable is boolean type
cosine Similarity: 0.9845060706138611
*Get the operator of the nested infix expression.* 匹配到的元操作或API：
logic: Get the operator of the nested infix expression.
most similar meta operation: Get the operator of infix expression
cosine Similarity: 0.9625810980796814
*Check whether the operator in the nested infix expression is !=.* 匹配到的元操作或API：
logic: Check whether the operator in the nested infix expression is !=.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.8911067247390747
*Get the right operand of the nested infix expression.* 匹配到的元操作或API：
logic: Get the right operand of the nested infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9626295566558838
*Check whether the right operand is a boolean literal.* 匹配到的元操作或API：
logic: Check whether the right operand is a boolean literal.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.8810778260231018
*Check whether the boolean literal is true.* 匹配到的元操作或API：
logic: Check whether the boolean literal is true.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.983268141746521
*Get the right operand of the outer infix expression.* 匹配到的元操作或API：
logic: Get the right operand of the outer infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9494107961654663
*Check whether the right operand is an infix expression.* 匹配到的元操作或API：
logic: Check whether the right operand is an infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9103248119354248
*Get the left operand of the nested infix expression.* 匹配到的元操作或API：
logic: Get the left operand of the nested infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9677199721336365
*Check whether the left operand is an accessed field.* 匹配到的元操作或API：
logic: Check whether the left operand is an accessed field.
most similar meta operation: Check whether the accessed variable is a field
cosine Similarity: 0.8513689041137695
*Get the name of accessed variable.* 匹配到的元操作或API：
logic: Get the name of accessed variable.
most similar meta operation: Get the name of accessed variable
cosine Similarity: 0.986038088798523
*Check whether the accessed variable is a Boolean type.* 匹配到的元操作或API：
logic: Check whether the accessed variable is a Boolean type.
most similar meta operation: Check whether the accessed variable is boolean type
cosine Similarity: 0.9845060706138611
*Get the operator of the nested infix expression.* 匹配到的元操作或API：
logic: Get the operator of the nested infix expression.
most similar meta operation: Get the operator of infix expression
cosine Similarity: 0.9625810980796814
*Check whether the operator in the nested infix expression is !=.* 匹配到的元操作或API：
logic: Check whether the operator in the nested infix expression is !=.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.8911067247390747
*Get the right operand of the nested infix expression.* 匹配到的元操作或API：
logic: Get the right operand of the nested infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9626295566558838
*Check whether the right operand is a boolean literal.* 匹配到的元操作或API：
logic: Check whether the right operand is a boolean literal.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.8810778260231018
*Check whether the boolean literal is false.* 匹配到的元操作或API：
logic: Check whether the boolean literal is false.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.9612721800804138
*Get the right operand of the outer infix expression.* 匹配到的元操作或API：
logic: Get the right operand of the outer infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9494107961654663
*Check whether the right operand is an infix expression.* 匹配到的元操作或API：
logic: Check whether the right operand is an infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9103248119354248
*Get the left operand of the nested infix expression.* 匹配到的元操作或API：
logic: Get the left operand of the nested infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9677199721336365
*Check whether the left operand is an accessed field.* 匹配到的元操作或API：
logic: Check whether the left operand is an accessed field.
most similar meta operation: Check whether the accessed variable is a field
cosine Similarity: 0.8513689041137695
*Get the name of accessed variable.* 匹配到的元操作或API：
logic: Get the name of accessed variable.
most similar meta operation: Get the name of accessed variable
cosine Similarity: 0.986038088798523
*Check whether the accessed variable is a Boolean type.* 匹配到的元操作或API：
logic: Check whether the accessed variable is a Boolean type.
most similar meta operation: Check whether the accessed variable is boolean type
cosine Similarity: 0.9845060706138611
*Get the operator of the nested infix expression.* 匹配到的元操作或API：
logic: Get the operator of the nested infix expression.
most similar meta operation: Get the operator of infix expression
cosine Similarity: 0.9625810980796814
*Check whether the operator in the nested infix expression is ==.* 匹配到的元操作或API：
logic: Check whether the operator in the nested infix expression is ==.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9043372869491577
*Get the right operand of the nested infix expression.* 匹配到的元操作或API：
logic: Get the right operand of the nested infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9626295566558838
*Check whether the right operand is a boolean literal.* 匹配到的元操作或API：
logic: Check whether the right operand is a boolean literal.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.8810778260231018
*Check whether the boolean literal is true.* 匹配到的元操作或API：
logic: Check whether the boolean literal is true.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.983268141746521
*Get the right operand of the outer infix expression.* 匹配到的元操作或API：
logic: Get the right operand of the outer infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9494107961654663
*Check whether the right operand is an infix expression.* 匹配到的元操作或API：
logic: Check whether the right operand is an infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9103248119354248
*Get the left operand of the nested infix expression.* 匹配到的元操作或API：
logic: Get the left operand of the nested infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9677199721336365
*Check whether the left operand is an accessed field.* 匹配到的元操作或API：
logic: Check whether the left operand is an accessed field.
most similar meta operation: Check whether the accessed variable is a field
cosine Similarity: 0.8513689041137695
*Get the name of accessed variable.* 匹配到的元操作或API：
logic: Get the name of accessed variable.
most similar meta operation: Get the name of accessed variable
cosine Similarity: 0.986038088798523
*Check whether the accessed variable is a Boolean type.* 匹配到的元操作或API：
logic: Check whether the accessed variable is a Boolean type.
most similar meta operation: Check whether the accessed variable is boolean type
cosine Similarity: 0.9845060706138611
*Get the operator of the nested infix expression.* 匹配到的元操作或API：
logic: Get the operator of the nested infix expression.
most similar meta operation: Get the operator of infix expression
cosine Similarity: 0.9625810980796814
*Check whether the operator in the nested infix expression is ==.* 匹配到的元操作或API：
logic: Check whether the operator in the nested infix expression is ==.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9043372869491577
*Get the right operand of the nested infix expression.* 匹配到的元操作或API：
logic: Get the right operand of the nested infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9626295566558838
*Check whether the right operand is a boolean literal.* 匹配到的元操作或API：
logic: Check whether the right operand is a boolean literal.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.8810778260231018
*Check whether the boolean literal is false.* 匹配到的元操作或API：
logic: Check whether the boolean literal is false.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.9612721800804138
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
This checker has passed this negative testcase:
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}


This checker is failed(false negative) on this negative test case:
```
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;
                    result = boo == null && boo != true;  // boo != true would throw NPE because of unboxing
                    result = boo == null && boo != false; // same
                    result = boo == null && boo == true;  // same
                    result = boo == null && boo == false; // same
                }
            }
The number of violating the rule in this test case is: 4

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Test')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testPMD')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'boo')
            ——ASTNullLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'result')
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLeftOperand()
2. net.sourceforge.pmd.lang.java.ast.ASTVariableAccess: public java.lang.String getName()
3. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
4. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.BinaryOp getOperator()
5. net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral: public boolean isTrue()

1.  //Check whether the accessed variable is a field
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;
public boolean isVariableAccessField(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JFieldSymbol) {
        JFieldSymbol fieldSym = (JFieldSymbol) sym;
        return true;
    }
    return false;
}
```
2.  //Check whether the accessed variable is boolean type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isVariableAccessBooleanType(ASTVariableAccess var) {
    return var.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN);
}
```
3.  //Check whether the accessed variable is being read
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr;
public boolean variableIsBeingRead(ASTVariableAccess var) {
    if(var.getAccessType() == ASTAssignableExpr.AccessType.READ){
        return true;
    }
    return false;
}
```
4.  //Check whether the operator in infix expression is ''
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils;
public boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op){
    //enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
    return JavaAstUtils.isInfixExprWithOperator(node, op);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && (isEqualsCall(rightOperand) || isBooleanUnboxingCheck(rightOperand))) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }

    private boolean isBooleanUnboxingCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            BinaryOp operator = infixExpression.getOperator();
            if (operator == BinaryOp.NE || operator == BinaryOp.EQ) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                return (isBooleanVariableAccess(leftOperand) && isBooleanLiteral(rightOperand)) ||
                       (isBooleanLiteral(leftOperand) && isBooleanVariableAccess(rightOperand));
            }
        }
        return false;
    }

    private boolean isBooleanVariableAccess(ASTExpression node) {
        if (node instanceof ASTVariableAccess) {
            ASTVariableAccess varAccess = (ASTVariableAccess) node;
            return variableIsBeingRead(varAccess) && isVariableAccessBooleanType(varAccess);
        }
        return false;
    }

    private boolean isBooleanLiteral(ASTExpression node) {
        return node instanceof ASTBooleanLiteral;
    }

    public boolean isVariableAccessField(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym instanceof JFieldSymbol) {
            return true;
        }
        return false;
    }

    public boolean isVariableAccessBooleanType(ASTVariableAccess var) {
        return var.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN);
    }

    public boolean variableIsBeingRead(ASTVariableAccess var) {
        if(var.getAccessType() == ASTAssignableExpr.AccessType.READ){
            return true;
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <4> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <4> but was: <0>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 5
[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <4> but was: <0>不通过
97
81
97
80
99
82
77
63
107
91
116
101
=========================error_testcase_logics=========================
To perform granular checks on the given test case, we need to analyze each null check expression separately. Here's how we can do it:

1. Get the name of class.
2. Check whether the class is abstract.
3. Check whether the class is public.
4. Check whether the class has declared annotations.
5. Get a formal parameter of method.
6. Get the number of formal parameters of method.
7. Check whether the method is abstract.
8. Check whether the method is private.
9. Check whether the method is public.
10. Check whether the method is default package-private.
11. Check whether the method is protected.
12. Get the return type of method.
13. Check whether the return type of method is void.
14. Get the name of formal parameter.
15. Get the type of formal parameter.
16. Check whether the formal parameter is string type.
17. Check whether the formal parameter is boolean type.
18. Check whether the formal parameter is char type.
19. Check whether the formal parameter is byte type.
20. Check whether the formal parameter is short type.
21. Check whether the formal parameter is int type.
22. Check whether the formal parameter is long type.
23. Check whether the formal parameter is float type.
24. Check whether the formal parameter is double type.
25. Check whether the formal parameter is boxed type.
26. Check whether the formal parameter is a x class type.
27. Check whether the formal parameter is array type.
28. Check whether the formal parameter is enum type.
29. Check whether the formal parameter is record type.
30. Get an usage of formal parameter.
31. Check whether the formal parameter is final.
32. Get a declared annotation of formal parameter.
33. Check whether the formal parameter has x annotation.
34. Get the javadoc comment of field.
35. Check whether the field is private.
36. Check whether the field is public.
37. Check whether the field is default package-private.
38. Check whether the field is protected.
39. Check whether the field is static.
40. Check whether the field is final.
41. Check whether the field is volatile.
42. Check whether the field is transient.
43. Get the type of field.
44. Check whether the field is string type.
45. Check whether the field is boolean type.
46. Check whether the field is char type.
47. Check whether the field is byte type.
48. Check whether the field is short type.
49. Check whether the field is int type.
50. Check whether the field is long type.
51. Check whether the field is float type.
52. Check whether the field is double type.
53. Check whether the field is boxed type.
54. Check whether the field is x class type.
55. Check whether the field is array type.
56. Check whether the field is enum type.
57. Check whether the field is record type.
58. Check whether field has declared annotations.
59. Get a declared annotation of field.
60. Check whether the field has x annotation.
61. Check whether the field is initialized.
62. Check whether the field is initialized to literal value.
63. Check whether the field is initialized to variable value.
64. Get the literal value that the field is initialized to.
65. Get an access of field.
66. Get the expression in assignment expression.
67. Get the left-hand side operand of the assignment expression.
68. Get the right-hand side operand of the assignment expression.
69. Check whether the left-hand side operand of the assignment expression is an accessed variable.
70. Check whether the accessed variable is a field.
71. Check whether the field is final.
72. Get the type of accessed variable.
73. Check whether the type of accessed variable is string type.
74. Check whether the type of accessed variable is boolean type.
75. Check whether the type of accessed variable is char type.
76. Check whether the type of accessed variable is byte type.
77. Check whether the type of accessed variable is short type.
78. Check whether the type of accessed variable is int type.
79. Check whether the type of accessed variable is long type.
80. Check whether the type of accessed variable is float type.
81. Check whether the type of accessed variable is double type.
82. Check whether the type of accessed variable is boxed type.
83. Check whether the type of accessed variable is x class type.
84. Check whether the type of accessed variable is array type.
85. Check whether the type of accessed variable is enum type.
86. Check whether the type of accessed variable is record type.
87. Get the right-hand side operand of the assignment expression.
88. Check whether the right-hand side operand of the assignment expression is a method call.
89. Get the name of called method.
90. Check whether the called method name is append.
91. Get the method caller.
92. Check whether the type of method caller is StringBuilder/StringBuffer class type.
93. Get the argument list of method.
94. Get the size of argument list.
95. Check whether the size of argument list is 1.
96. Check whether the argument is a string literal.
97. Get the length of string literal.
98. Check whether the length of string literal is 1.
99. Get the operator of infix expression.
100. Check whether the operator in infix expression is ||.
101. Get the left-hand side operand of the infix expression.
102. Get the right-hand side operand of the infix expression.
103. Check whether the right-hand side operand of the infix expression is a method call.
104. Get the name of called method.
105. Check whether the called method name is equals.
106. Get the method caller.
107. Check whether the type of method caller is Boolean class type.
108. Get the argument list of method.
109. Get the size of argument list.
110. Check whether the size of argument list is 1.
111. Get an argument of called method.
112. Check whether the argument is a literal value.
113. Get the literal value that the argument is initialized to.
114. Check whether the literal value is true.
115. Check whether the literal value is false.

For each of the four expressions in the test case, the checks will be as follows:

### Expression 1: `result = boo != null || boo != true;`
1. Get the expression in assignment expression.
2. Get the right-hand side operand of the assignment expression.
3. Check whether the operator in infix expression is ||.
4. Get the right-hand side operand of the infix expression.
5. Check whether the right-hand side operand of the infix expression is a method call.
6. Get the name of called method.
7. Check whether the called method name is equals.
8. Get the method caller.
9. Check whether the type of method caller is Boolean class type.
10. Get the argument list of method.
11. Get the size of argument list.
12. Check whether the size of argument list is 1.
13. Get an argument of called method.
14. Check whether the argument is a literal value.
15. Get the literal value that the argument is initialized to.
16. Check whether the literal value is true.

### Expression 2: `result = boo != null || boo != false;`
1. Get the expression in assignment expression.
2. Get the right-hand side operand of the assignment expression.
3. Check whether the operator in infix expression is ||.
4. Get the right-hand side operand of the infix expression.
5. Check whether the right-hand side operand of the infix expression is a method call.
6. Get the name of called method.
7. Check whether the called method name is equals.
8. Get the method caller.
9. Check whether the type of method caller is Boolean class type.
10. Get the argument list of method.
11. Get the size of argument list.
12. Check whether the size of argument list is 1.
13. Get an argument of called method.
14. Check whether the argument is a literal value.
15. Get the literal value that the argument is initialized to.
16. Check whether the literal value is false.

### Expression 3: `result = boo != null || boo == true;`
1. Get the expression in assignment expression.
2. Get the right-hand side operand of the assignment expression.
3. Check whether the operator in infix expression is ||.
4. Get the right-hand side operand of the infix expression.
5. Check whether the right-hand side operand of the infix expression is a method call.
6. Get the name of called method.
7. Check whether the called method name is equals.
8. Get the method caller.
9. Check whether the type of method caller is Boolean class type.
10. Get the argument list of method.
11. Get the size of argument list.
12. Check whether the size of argument list is 1.
13. Get an argument of called method.
14. Check whether the argument is a literal value.
15. Get the literal value that the argument is initialized to.
16. Check whether the literal value is true.

### Expression 4: `result = boo != null || boo == false;`
1. Get the expression in assignment expression.
2. Get the right-hand side operand of the assignment expression.
3. Check whether the operator in infix expression is ||.
4. Get the right-hand side operand of the infix expression.
5. Check whether the right-hand side operand of the infix expression is a method call.
6. Get the name of called method.
7. Check whether the called method name is equals.
8. Get the method caller.
9. Check whether the type of method caller is Boolean class type.
10. Get the argument list of method.
11. Get the size of argument list.
12. Check whether the size of argument list is 1.
13. Get an argument of called method.
14. Check whether the argument is a literal value.
15. Get the literal value that the argument is initialized to.
16. Check whether the literal value is false.

Each of these expressions uses the `||` operator to combine a null check with a call to `Boolean.equals`, which will throw a `NullPointerException` if `boo` is null. This indicates that the null check is broken. Therefore, the test case violates the rule for all four expressions.
['Get the name of class.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class has declared annotations.', 'Get a formal parameter of method.', 'Get the number of formal parameters of method.', 'Check whether the method is abstract.', 'Check whether the method is private.', 'Check whether the method is public.', 'Check whether the method is default package-private.', 'Check whether the method is protected.', 'Get the return type of method.', 'Check whether the return type of method is void.', 'Get the name of formal parameter.', 'Get the type of formal parameter.', 'Check whether the formal parameter is string type.', 'Check whether the formal parameter is boolean type.', 'Check whether the formal parameter is char type.', 'Check whether the formal parameter is byte type.', 'Check whether the formal parameter is short type.', 'Check whether the formal parameter is int type.', 'Check whether the formal parameter is long type.', 'Check whether the formal parameter is float type.', 'Check whether the formal parameter is double type.', 'Check whether the formal parameter is boxed type.', 'Check whether the formal parameter is a x class type.', 'Check whether the formal parameter is array type.', 'Check whether the formal parameter is enum type.', 'Check whether the formal parameter is record type.', 'Get an usage of formal parameter.', 'Check whether the formal parameter is final.', 'Get a declared annotation of formal parameter.', 'Check whether the formal parameter has x annotation.', 'Get the javadoc comment of field.', 'Check whether the field is private.', 'Check whether the field is public.', 'Check whether the field is default package-private.', 'Check whether the field is protected.', 'Check whether the field is static.', 'Check whether the field is final.', 'Check whether the field is volatile.', 'Check whether the field is transient.', 'Get the type of field.', 'Check whether the field is string type.', 'Check whether the field is boolean type.', 'Check whether the field is char type.', 'Check whether the field is byte type.', 'Check whether the field is short type.', 'Check whether the field is int type.', 'Check whether the field is long type.', 'Check whether the field is float type.', 'Check whether the field is double type.', 'Check whether the field is boxed type.', 'Check whether the field is x class type.', 'Check whether the field is array type.', 'Check whether the field is enum type.', 'Check whether the field is record type.', 'Check whether field has declared annotations.', 'Get a declared annotation of field.', 'Check whether the field has x annotation.', 'Check whether the field is initialized.', 'Check whether the field is initialized to literal value.', 'Check whether the field is initialized to variable value.', 'Get the literal value that the field is initialized to.', 'Get an access of field.', 'Get the expression in assignment expression.', 'Get the left-hand side operand of the assignment expression.', 'Get the right-hand side operand of the assignment expression.', 'Check whether the left-hand side operand of the assignment expression is an accessed variable.', 'Check whether the accessed variable is a field.', 'Check whether the field is final.', 'Get the type of accessed variable.', 'Check whether the type of accessed variable is string type.', 'Check whether the type of accessed variable is boolean type.', 'Check whether the type of accessed variable is char type.', 'Check whether the type of accessed variable is byte type.', 'Check whether the type of accessed variable is short type.', 'Check whether the type of accessed variable is int type.', 'Check whether the type of accessed variable is long type.', 'Check whether the type of accessed variable is float type.', 'Check whether the type of accessed variable is double type.', 'Check whether the type of accessed variable is boxed type.', 'Check whether the type of accessed variable is x class type.', 'Check whether the type of accessed variable is array type.', 'Check whether the type of accessed variable is enum type.', 'Check whether the type of accessed variable is record type.', 'Get the right-hand side operand of the assignment expression.', 'Check whether the right-hand side operand of the assignment expression is a method call.', 'Get the name of called method.', 'Check whether the called method name is append.', 'Get the method caller.', 'Check whether the type of method caller is StringBuilder/StringBuffer class type.', 'Get the argument list of method.', 'Get the size of argument list.', 'Check whether the size of argument list is 1.', 'Check whether the argument is a string literal.', 'Get the length of string literal.', 'Check whether the length of string literal is 1.', 'Get the operator of infix expression.', 'Check whether the operator in infix expression is ||.', 'Get the left-hand side operand of the infix expression.', 'Get the right-hand side operand of the infix expression.', 'Check whether the right-hand side operand of the infix expression is a method call.', 'Get the name of called method.', 'Check whether the called method name is equals.', 'Get the method caller.', 'Check whether the type of method caller is Boolean class type.', 'Get the argument list of method.', 'Get the size of argument list.', 'Check whether the size of argument list is 1.', 'Get an argument of called method.', 'Check whether the argument is a literal value.', 'Get the literal value that the argument is initialized to.', 'Check whether the literal value is true.', 'Check whether the literal value is false.', 'Get the expression in assignment expression.', 'Get the right-hand side operand of the assignment expression.', 'Check whether the operator in infix expression is ||.', 'Get the right-hand side operand of the infix expression.', 'Check whether the right-hand side operand of the infix expression is a method call.', 'Get the name of called method.', 'Check whether the called method name is equals.', 'Get the method caller.', 'Check whether the type of method caller is Boolean class type.', 'Get the argument list of method.', 'Get the size of argument list.', 'Check whether the size of argument list is 1.', 'Get an argument of called method.', 'Check whether the argument is a literal value.', 'Get the literal value that the argument is initialized to.', 'Check whether the literal value is true.', 'Get the expression in assignment expression.', 'Get the right-hand side operand of the assignment expression.', 'Check whether the operator in infix expression is ||.', 'Get the right-hand side operand of the infix expression.', 'Check whether the right-hand side operand of the infix expression is a method call.', 'Get the name of called method.', 'Check whether the called method name is equals.', 'Get the method caller.', 'Check whether the type of method caller is Boolean class type.', 'Get the argument list of method.', 'Get the size of argument list.', 'Check whether the size of argument list is 1.', 'Get an argument of called method.', 'Check whether the argument is a literal value.', 'Get the literal value that the argument is initialized to.', 'Check whether the literal value is false.', 'Get the expression in assignment expression.', 'Get the right-hand side operand of the assignment expression.', 'Check whether the operator in infix expression is ||.', 'Get the right-hand side operand of the infix expression.', 'Check whether the right-hand side operand of the infix expression is a method call.', 'Get the name of called method.', 'Check whether the called method name is equals.', 'Get the method caller.', 'Check whether the type of method caller is Boolean class type.', 'Get the argument list of method.', 'Get the size of argument list.', 'Check whether the size of argument list is 1.', 'Get an argument of called method.', 'Check whether the argument is a literal value.', 'Get the literal value that the argument is initialized to.', 'Check whether the literal value is true.', 'Get the expression in assignment expression.', 'Get the right-hand side operand of the assignment expression.', 'Check whether the operator in infix expression is ||.', 'Get the right-hand side operand of the infix expression.', 'Check whether the right-hand side operand of the infix expression is a method call.', 'Get the name of called method.', 'Check whether the called method name is equals.', 'Get the method caller.', 'Check whether the type of method caller is Boolean class type.', 'Get the argument list of method.', 'Get the size of argument list.', 'Check whether the size of argument list is 1.', 'Get an argument of called method.', 'Check whether the argument is a literal value.', 'Get the literal value that the argument is initialized to.', 'Check whether the literal value is false.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTVariableDeclaratorId', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTAssignmentExpression', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTNullLiteral', 'ASTExpressionStatement', 'ASTBooleanLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get a formal parameter of method.* 匹配到的元操作或API：
logic: Get a formal parameter of method.
most similar meta operation: Get a formal parameter of method
cosine Similarity: 0.9826655983924866
*Get the number of formal parameters of method.* 匹配到的元操作或API：
logic: Get the number of formal parameters of method.
most similar meta operation: Get the number of formal parameters of method
cosine Similarity: 0.9860840439796448
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Check whether the method is private.* 匹配到的元操作或API：
logic: Check whether the method is private.
most similar meta operation: Check whether the method is private
cosine Similarity: 0.9821236729621887
*Check whether the method is public.* 匹配到的元操作或API：
logic: Check whether the method is public.
most similar meta operation: Check whether the method is public
cosine Similarity: 0.982057511806488
*Check whether the method is default package-private.* 匹配到的元操作或API：
logic: Check whether the method is default package-private.
most similar meta operation: Check whether the method is default package-private
cosine Similarity: 0.972201406955719
*Check whether the method is protected.* 匹配到的元操作或API：
logic: Check whether the method is protected.
most similar meta operation: Check whether the method is protected
cosine Similarity: 0.9815421104431152
*Get the return type of method.* 匹配到的元操作或API：
logic: Get the return type of method.
most similar meta operation: Get the return type of method
cosine Similarity: 0.983596682548523
*Check whether the return type of method is void.* 匹配到的元操作或API：
logic: Check whether the return type of method is void.
most similar meta operation: Check whether the return type of method is void
cosine Similarity: 0.9854096174240112
*Get the name of formal parameter.* 匹配到的元操作或API：
logic: Get the name of formal parameter.
most similar meta operation: Get the name of formal parameter
cosine Similarity: 0.9837440252304077
*Get the type of formal parameter.* 匹配到的元操作或API：
logic: Get the type of formal parameter.
most similar meta operation: Get the type of formal parameter
cosine Similarity: 0.9854808449745178
*Check whether the formal parameter is string type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is string type.
most similar meta operation: Check whether the formal parameter is string type
cosine Similarity: 0.9882045984268188
*Check whether the formal parameter is boolean type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is boolean type.
most similar meta operation: Check whether the formal parameter is boolean type
cosine Similarity: 0.9861541986465454
*Check whether the formal parameter is char type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is char type.
most similar meta operation: Check whether the formal parameter is char type
cosine Similarity: 0.9883654713630676
*Check whether the formal parameter is byte type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is byte type.
most similar meta operation: Check whether the formal parameter is byte type
cosine Similarity: 0.989282488822937
*Check whether the formal parameter is short type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is short type.
most similar meta operation: Check whether the formal parameter is short type
cosine Similarity: 0.9876381158828735
*Check whether the formal parameter is int type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is int type.
most similar meta operation: Check whether the formal parameter is int type
cosine Similarity: 0.9879910945892334
*Check whether the formal parameter is long type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is long type.
most similar meta operation: Check whether the formal parameter is long type
cosine Similarity: 0.988408625125885
*Check whether the formal parameter is float type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is float type.
most similar meta operation: Check whether the formal parameter is float type
cosine Similarity: 0.9876444935798645
*Check whether the formal parameter is double type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is double type.
most similar meta operation: Check whether the formal parameter is double type
cosine Similarity: 0.9877136945724487
*Check whether the formal parameter is boxed type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is boxed type.
most similar meta operation: Check whether the formal parameter is boxed primitive type
cosine Similarity: 0.9612672328948975
*Check whether the formal parameter is a x class type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is a x class type.
most similar meta operation: Check whether the formal parameter is a x class type
cosine Similarity: 0.9905358552932739
*Check whether the formal parameter is array type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is array type.
most similar meta operation: Check whether the formal parameter is array type
cosine Similarity: 0.9873113036155701
*Check whether the formal parameter is enum type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is enum type.
most similar meta operation: Check whether the formal parameter is enum type
cosine Similarity: 0.9871471524238586
*Check whether the formal parameter is record type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is record type.
most similar meta operation: Check whether the formal parameter is record type
cosine Similarity: 0.9890471696853638
*Get an usage of formal parameter.* 匹配到的元操作或API：
logic: Get an usage of formal parameter.
most similar meta operation: Get an usage of formal parameter
cosine Similarity: 0.986284613609314
*Check whether the formal parameter is final.* 匹配到的元操作或API：
logic: Check whether the formal parameter is final.
most similar meta operation: Check whether the formal parameter is final
cosine Similarity: 0.9881319403648376
*Get a declared annotation of formal parameter.* 匹配到的元操作或API：
logic: Get a declared annotation of formal parameter.
most similar meta operation: Get a declared annotation of formal parameter
cosine Similarity: 0.9871978759765625
*Check whether the formal parameter has x annotation.* 匹配到的元操作或API：
logic: Check whether the formal parameter has x annotation.
most similar meta operation: Check whether the formal parameter has x annotation
cosine Similarity: 0.9898931980133057
*Get the javadoc comment of field.* 匹配到的元操作或API：
logic: Get the javadoc comment of field.
most similar meta operation: Get the javadoc comment of field
cosine Similarity: 0.9902395606040955
*Check whether the field is private.* 匹配到的元操作或API：
logic: Check whether the field is private.
most similar meta operation: Check whether the field is private
cosine Similarity: 0.9845259785652161
*Check whether the field is public.* 匹配到的元操作或API：
logic: Check whether the field is public.
most similar meta operation: Check whether the field is public
cosine Similarity: 0.9851202964782715
*Check whether the field is default package-private.* 匹配到的元操作或API：
logic: Check whether the field is default package-private.
most similar meta operation: Check whether the field is default package-private
cosine Similarity: 0.9663878083229065
*Check whether the field is protected.* 匹配到的元操作或API：
logic: Check whether the field is protected.
most similar meta operation: Check whether the field is protected
cosine Similarity: 0.9839198589324951
*Check whether the field is static.* 匹配到的元操作或API：
logic: Check whether the field is static.
most similar meta operation: Check whether the field is static
cosine Similarity: 0.9852341413497925
*Check whether the field is final.* 匹配到的元操作或API：
logic: Check whether the field is final.
most similar meta operation: Check whether the field is final
cosine Similarity: 0.9875956177711487
*Check whether the field is volatile.* 匹配到的元操作或API：
logic: Check whether the field is volatile.
most similar meta operation: Check whether the field is volatile
cosine Similarity: 0.9884835481643677
*Check whether the field is transient.* 匹配到的元操作或API：
logic: Check whether the field is transient.
most similar meta operation: Check whether the field is transient
cosine Similarity: 0.9895565509796143
*Get the type of field.* 匹配到的元操作或API：
logic: Get the type of field.
most similar meta operation: Get the type of field
cosine Similarity: 0.9832500219345093
*Check whether the field is string type.* 匹配到的元操作或API：
logic: Check whether the field is string type.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.988373875617981
*Check whether the field is boolean type.* 匹配到的元操作或API：
logic: Check whether the field is boolean type.
most similar meta operation: Check whether the field is boolean type
cosine Similarity: 0.9866046905517578
*Check whether the field is char type.* 匹配到的元操作或API：
logic: Check whether the field is char type.
most similar meta operation: Check whether the field is char type
cosine Similarity: 0.989357590675354
*Check whether the field is byte type.* 匹配到的元操作或API：
logic: Check whether the field is byte type.
most similar meta operation: Check whether the field is byte type
cosine Similarity: 0.9907138347625732
*Check whether the field is short type.* 匹配到的元操作或API：
logic: Check whether the field is short type.
most similar meta operation: Check whether the field is short type
cosine Similarity: 0.9883869886398315
*Check whether the field is int type.* 匹配到的元操作或API：
logic: Check whether the field is int type.
most similar meta operation: Check whether the field is int type
cosine Similarity: 0.9881454706192017
*Check whether the field is long type.* 匹配到的元操作或API：
logic: Check whether the field is long type.
most similar meta operation: Check whether the field is long type
cosine Similarity: 0.9879834055900574
*Check whether the field is float type.* 匹配到的元操作或API：
logic: Check whether the field is float type.
most similar meta operation: Check whether the field is float type
cosine Similarity: 0.9873677492141724
*Check whether the field is double type.* 匹配到的元操作或API：
logic: Check whether the field is double type.
most similar meta operation: Check whether the field is double type
cosine Similarity: 0.9888980388641357
*Check whether the field is boxed type.* 匹配到的元操作或API：
logic: Check whether the field is boxed type.
most similar meta operation: Check whether the field is boxed primitive type
cosine Similarity: 0.9384516477584839
*Check whether the field is x class type.* 匹配到的元操作或API：
logic: Check whether the field is x class type.
most similar meta operation: Check whether the field is a x class type
cosine Similarity: 0.9860230088233948
*Check whether the field is array type.* 匹配到的元操作或API：
logic: Check whether the field is array type.
most similar meta operation: Check whether the field is array type
cosine Similarity: 0.9860299825668335
*Check whether the field is enum type.* 匹配到的元操作或API：
logic: Check whether the field is enum type.
most similar meta operation: Check whether the field is enum type
cosine Similarity: 0.9872546195983887
*Check whether the field is record type.* 匹配到的元操作或API：
logic: Check whether the field is record type.
most similar meta operation: Check whether the field is record type
cosine Similarity: 0.9888904690742493
*Check whether field has declared annotations.* 匹配到的元操作或API：
logic: Check whether field has declared annotations.
most similar meta operation: Check whether field has declared annotations
cosine Similarity: 0.9904201030731201
*Get a declared annotation of field.* 匹配到的元操作或API：
logic: Get a declared annotation of field.
most similar meta operation: Get a declared annotation of field
cosine Similarity: 0.9871520400047302
*Check whether the field has x annotation.* 匹配到的元操作或API：
logic: Check whether the field has x annotation.
most similar meta operation: Check whether the field has x annotation
cosine Similarity: 0.9902318716049194
*Check whether the field is initialized.* 匹配到的元操作或API：
logic: Check whether the field is initialized.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.9865798950195312
*Check whether the field is initialized to literal value.* 匹配到的元操作或API：
logic: Check whether the field is initialized to literal value.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.9092312455177307
*Check whether the field is initialized to variable value.* 匹配到的元操作或API：
logic: Check whether the field is initialized to variable value.
most similar meta operation: Check whether the field is initialized to variable value
cosine Similarity: 0.9891040325164795
*Get the literal value that the field is initialized to.* 匹配到的元操作或API：
logic: Get the literal value that the field is initialized to.
most similar meta operation: Get the literal value that the field is initialized to
cosine Similarity: 0.9854511022567749
*Get an access of field.* 匹配到的元操作或API：
logic: Get an access of field.
most similar meta operation: Get an access of field
cosine Similarity: 0.9836357831954956
*Get the expression in assignment expression.* 匹配到的元操作或API：
logic: Get the expression in assignment expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8580915331840515
*Get the left-hand side operand of the assignment expression.* 匹配到的元操作或API：
logic: Get the left-hand side operand of the assignment expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.9638152122497559
*Get the right-hand side operand of the assignment expression.* 匹配到的元操作或API：
logic: Get the right-hand side operand of the assignment expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.9076520800590515
*Check whether the left-hand side operand of the assignment expression is an accessed variable.* 匹配到的元操作或API：
logic: Check whether the left-hand side operand of the assignment expression is an accessed variable.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8627821207046509
*Check whether the accessed variable is a field.* 匹配到的元操作或API：
logic: Check whether the accessed variable is a field.
most similar meta operation: Check whether the accessed variable is a field
cosine Similarity: 0.9899091124534607
*Check whether the field is final.* 匹配到的元操作或API：
logic: Check whether the field is final.
most similar meta operation: Check whether the field is final
cosine Similarity: 0.9875956177711487
*Get the type of accessed variable.* 匹配到的元操作或API：
logic: Get the type of accessed variable.
most similar meta operation: Get the type of accessed variable
cosine Similarity: 0.9871194362640381
*Check whether the type of accessed variable is string type.* 匹配到的元操作或API：
logic: Check whether the type of accessed variable is string type.
most similar meta operation: Check whether the accessed variable is string type
cosine Similarity: 0.9810447096824646
*Check whether the type of accessed variable is boolean type.* 匹配到的元操作或API：
logic: Check whether the type of accessed variable is boolean type.
most similar meta operation: Check whether the accessed variable is boolean type
cosine Similarity: 0.9761917591094971
*Check whether the type of accessed variable is char type.* 匹配到的元操作或API：
logic: Check whether the type of accessed variable is char type.
most similar meta operation: Check whether the accessed variable is char type
cosine Similarity: 0.9819445610046387
*Check whether the type of accessed variable is byte type.* 匹配到的元操作或API：
logic: Check whether the type of accessed variable is byte type.
most similar meta operation: Check whether the accessed variable is byte type
cosine Similarity: 0.9837192893028259
*Check whether the type of accessed variable is short type.* 匹配到的元操作或API：
logic: Check whether the type of accessed variable is short type.
most similar meta operation: Check whether the accessed variable is short type
cosine Similarity: 0.9811156988143921
*Check whether the type of accessed variable is int type.* 匹配到的元操作或API：
logic: Check whether the type of accessed variable is int type.
most similar meta operation: Check whether the accessed variable is int type
cosine Similarity: 0.9812271595001221
*Check whether the type of accessed variable is long type.* 匹配到的元操作或API：
logic: Check whether the type of accessed variable is long type.
most similar meta operation: Check whether the accessed variable is long type
cosine Similarity: 0.9829856753349304
*Check whether the type of accessed variable is float type.* 匹配到的元操作或API：
logic: Check whether the type of accessed variable is float type.
most similar meta operation: Check whether the accessed variable is float type
cosine Similarity: 0.9827390313148499
*Check whether the type of accessed variable is double type.* 匹配到的元操作或API：
logic: Check whether the type of accessed variable is double type.
most similar meta operation: Check whether the accessed variable is double type
cosine Similarity: 0.9835717678070068
*Check whether the type of accessed variable is boxed type.* 匹配到的元操作或API：
logic: Check whether the type of accessed variable is boxed type.
most similar meta operation: Check whether the accessed variable is boxed primitive type
cosine Similarity: 0.9459456205368042
*Check whether the type of accessed variable is x class type.* 匹配到的元操作或API：
logic: Check whether the type of accessed variable is x class type.
most similar meta operation: Check whether the accessed variable is a x class type
cosine Similarity: 0.9805805087089539
*Check whether the type of accessed variable is array type.* 匹配到的元操作或API：
logic: Check whether the type of accessed variable is array type.
most similar meta operation: Check whether the accessed variable is array type
cosine Similarity: 0.9820245504379272
*Check whether the type of accessed variable is enum type.* 匹配到的元操作或API：
logic: Check whether the type of accessed variable is enum type.
most similar meta operation: Check whether the accessed variable is enum type
cosine Similarity: 0.9823064208030701
*Check whether the type of accessed variable is record type.* 匹配到的元操作或API：
logic: Check whether the type of accessed variable is record type.
most similar meta operation: Check whether the accessed variable is record type
cosine Similarity: 0.9821269512176514
*Get the right-hand side operand of the assignment expression.* 匹配到的元操作或API：
logic: Get the right-hand side operand of the assignment expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.9076520800590515
*Check whether the right-hand side operand of the assignment expression is a method call.* 匹配到的元操作或API：
query: Check whether the right-hand side operand of the assignment expression is a method call.
most similar API: Check whether the assignment expression is expression
cosine Similarity: 0.836641788482666
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the called method name is append.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796932339668274
*Check whether the type of method caller is StringBuilder/StringBuffer class type.* 匹配到的元操作或API：
logic: Check whether the type of method caller is StringBuilder/StringBuffer class type.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.9216220378875732
*Get the argument list of method.* 匹配到的元操作或API：
logic: Get the argument list of method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8603729009628296
*Get the size of argument list.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the size of argument list is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9077170491218567
*Get the length of string literal.* 匹配到的元操作或API：
logic: Get the length of string literal.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.9875898361206055
*Check whether the length of string literal is 1.* 匹配到的元操作或API：
logic: Check whether the length of string literal is 1.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.8637055158615112
*Get the operator of infix expression.* 匹配到的元操作或API：
logic: Get the operator of infix expression.
most similar meta operation: Get the operator of infix expression
cosine Similarity: 0.9891121983528137
*Check whether the operator in infix expression is ||.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is ||.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9215893149375916
*Get the left-hand side operand of the infix expression.* 匹配到的元操作或API：
logic: Get the left-hand side operand of the infix expression.
most similar meta operation: Get the left operand of infix expression
cosine Similarity: 0.9652805328369141
*Get the right-hand side operand of the infix expression.* 匹配到的元操作或API：
logic: Get the right-hand side operand of the infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9134360551834106
*Check whether the right-hand side operand of the infix expression is a method call.* 匹配到的元操作或API：
query: Check whether the right-hand side operand of the infix expression is a method call.
most similar API: Check whether the infix expression is expression
cosine Similarity: 0.8279882669448853
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method equals
cosine Similarity: 0.8982508182525635
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796932339668274
*Check whether the type of method caller is Boolean class type.* 匹配到的元操作或API：
logic: Check whether the type of method caller is Boolean class type.
most similar meta operation: Check whether the return type of called method is boolean type
cosine Similarity: 0.9385319352149963
*Get the argument list of method.* 匹配到的元操作或API：
logic: Get the argument list of method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8603729009628296
*Get the size of argument list.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the size of argument list is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a literal value.* 匹配到的元操作或API：
query: Check whether the argument is a literal value.
most similar API: Check whether is boolean literal
cosine Similarity: 0.838320255279541
*Get the literal value that the argument is initialized to.* 匹配到的元操作或API：
logic: Get the literal value that the argument is initialized to.
most similar meta operation: Get the literal value that the local variable is initialized to
cosine Similarity: 0.9127628803253174
*Check whether the literal value is true.* 匹配到的元操作或API：
logic: Check whether the literal value is true.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.9055524468421936
*Check whether the literal value is false.* 匹配到的元操作或API：
logic: Check whether the literal value is false.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.8935639262199402
*Get the expression in assignment expression.* 匹配到的元操作或API：
logic: Get the expression in assignment expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8580915331840515
*Get the right-hand side operand of the assignment expression.* 匹配到的元操作或API：
logic: Get the right-hand side operand of the assignment expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.9076520800590515
*Check whether the operator in infix expression is ||.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is ||.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9215893149375916
*Get the right-hand side operand of the infix expression.* 匹配到的元操作或API：
logic: Get the right-hand side operand of the infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9134360551834106
*Check whether the right-hand side operand of the infix expression is a method call.* 匹配到的元操作或API：
query: Check whether the right-hand side operand of the infix expression is a method call.
most similar API: Check whether the infix expression is expression
cosine Similarity: 0.8279882669448853
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method equals
cosine Similarity: 0.8982508182525635
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796932339668274
*Check whether the type of method caller is Boolean class type.* 匹配到的元操作或API：
logic: Check whether the type of method caller is Boolean class type.
most similar meta operation: Check whether the return type of called method is boolean type
cosine Similarity: 0.9385319352149963
*Get the argument list of method.* 匹配到的元操作或API：
logic: Get the argument list of method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8603729009628296
*Get the size of argument list.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the size of argument list is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a literal value.* 匹配到的元操作或API：
query: Check whether the argument is a literal value.
most similar API: Check whether is boolean literal
cosine Similarity: 0.838320255279541
*Get the literal value that the argument is initialized to.* 匹配到的元操作或API：
logic: Get the literal value that the argument is initialized to.
most similar meta operation: Get the literal value that the local variable is initialized to
cosine Similarity: 0.9127628803253174
*Check whether the literal value is true.* 匹配到的元操作或API：
logic: Check whether the literal value is true.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.9055524468421936
*Get the expression in assignment expression.* 匹配到的元操作或API：
logic: Get the expression in assignment expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8580915331840515
*Get the right-hand side operand of the assignment expression.* 匹配到的元操作或API：
logic: Get the right-hand side operand of the assignment expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.9076520800590515
*Check whether the operator in infix expression is ||.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is ||.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9215893149375916
*Get the right-hand side operand of the infix expression.* 匹配到的元操作或API：
logic: Get the right-hand side operand of the infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9134360551834106
*Check whether the right-hand side operand of the infix expression is a method call.* 匹配到的元操作或API：
query: Check whether the right-hand side operand of the infix expression is a method call.
most similar API: Check whether the infix expression is expression
cosine Similarity: 0.8279882669448853
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method equals
cosine Similarity: 0.8982508182525635
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796932339668274
*Check whether the type of method caller is Boolean class type.* 匹配到的元操作或API：
logic: Check whether the type of method caller is Boolean class type.
most similar meta operation: Check whether the return type of called method is boolean type
cosine Similarity: 0.9385319352149963
*Get the argument list of method.* 匹配到的元操作或API：
logic: Get the argument list of method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8603729009628296
*Get the size of argument list.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the size of argument list is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a literal value.* 匹配到的元操作或API：
query: Check whether the argument is a literal value.
most similar API: Check whether is boolean literal
cosine Similarity: 0.838320255279541
*Get the literal value that the argument is initialized to.* 匹配到的元操作或API：
logic: Get the literal value that the argument is initialized to.
most similar meta operation: Get the literal value that the local variable is initialized to
cosine Similarity: 0.9127628803253174
*Check whether the literal value is false.* 匹配到的元操作或API：
logic: Check whether the literal value is false.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.8935639262199402
*Get the expression in assignment expression.* 匹配到的元操作或API：
logic: Get the expression in assignment expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8580915331840515
*Get the right-hand side operand of the assignment expression.* 匹配到的元操作或API：
logic: Get the right-hand side operand of the assignment expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.9076520800590515
*Check whether the operator in infix expression is ||.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is ||.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9215893149375916
*Get the right-hand side operand of the infix expression.* 匹配到的元操作或API：
logic: Get the right-hand side operand of the infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9134360551834106
*Check whether the right-hand side operand of the infix expression is a method call.* 匹配到的元操作或API：
query: Check whether the right-hand side operand of the infix expression is a method call.
most similar API: Check whether the infix expression is expression
cosine Similarity: 0.8279882669448853
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method equals
cosine Similarity: 0.8982508182525635
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796932339668274
*Check whether the type of method caller is Boolean class type.* 匹配到的元操作或API：
logic: Check whether the type of method caller is Boolean class type.
most similar meta operation: Check whether the return type of called method is boolean type
cosine Similarity: 0.9385319352149963
*Get the argument list of method.* 匹配到的元操作或API：
logic: Get the argument list of method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8603729009628296
*Get the size of argument list.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the size of argument list is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a literal value.* 匹配到的元操作或API：
query: Check whether the argument is a literal value.
most similar API: Check whether is boolean literal
cosine Similarity: 0.838320255279541
*Get the literal value that the argument is initialized to.* 匹配到的元操作或API：
logic: Get the literal value that the argument is initialized to.
most similar meta operation: Get the literal value that the local variable is initialized to
cosine Similarity: 0.9127628803253174
*Check whether the literal value is true.* 匹配到的元操作或API：
logic: Check whether the literal value is true.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.9055524468421936
*Get the expression in assignment expression.* 匹配到的元操作或API：
logic: Get the expression in assignment expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.8580915331840515
*Get the right-hand side operand of the assignment expression.* 匹配到的元操作或API：
logic: Get the right-hand side operand of the assignment expression.
most similar meta operation: Get the right operand of assignment expression
cosine Similarity: 0.9076520800590515
*Check whether the operator in infix expression is ||.* 匹配到的元操作或API：
logic: Check whether the operator in infix expression is ||.
most similar meta operation: Check whether the operator in infix expression is ''
cosine Similarity: 0.9215893149375916
*Get the right-hand side operand of the infix expression.* 匹配到的元操作或API：
logic: Get the right-hand side operand of the infix expression.
most similar meta operation: Get the right operand of infix expression
cosine Similarity: 0.9134360551834106
*Check whether the right-hand side operand of the infix expression is a method call.* 匹配到的元操作或API：
query: Check whether the right-hand side operand of the infix expression is a method call.
most similar API: Check whether the infix expression is expression
cosine Similarity: 0.8279882669448853
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the called method name is equals.* 匹配到的元操作或API：
query: Check whether the called method name is equals.
most similar API: Check whether the method equals
cosine Similarity: 0.8982508182525635
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796932339668274
*Check whether the type of method caller is Boolean class type.* 匹配到的元操作或API：
logic: Check whether the type of method caller is Boolean class type.
most similar meta operation: Check whether the return type of called method is boolean type
cosine Similarity: 0.9385319352149963
*Get the argument list of method.* 匹配到的元操作或API：
logic: Get the argument list of method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8603729009628296
*Get the size of argument list.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the size of argument list is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a literal value.* 匹配到的元操作或API：
query: Check whether the argument is a literal value.
most similar API: Check whether is boolean literal
cosine Similarity: 0.838320255279541
*Get the literal value that the argument is initialized to.* 匹配到的元操作或API：
logic: Get the literal value that the argument is initialized to.
most similar meta operation: Get the literal value that the local variable is initialized to
cosine Similarity: 0.9127628803253174
*Check whether the literal value is false.* 匹配到的元操作或API：
logic: Check whether the literal value is false.
most similar meta operation: Check whether the boolean literal is true
cosine Similarity: 0.8935639262199402
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTExpression condition = node.getCondition();
        if (condition instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) condition;
            if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_OR)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isNullCheck(leftOperand) && isEqualsCall(rightOperand)) {
                    addViolation(data, node);
                }
            } else if (isInfixExpressionWithOperator(infixExpression, BinaryOp.CONDITIONAL_AND)) {
                ASTExpression leftOperand = infixExpression.getLeftOperand();
                ASTExpression rightOperand = infixExpression.getRightOperand();
                if (isEqualsCall(leftOperand) && isNullCheck(rightOperand)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op) {
        return JavaAstUtils.isInfixExprWithOperator(node, op);
    }

    private boolean isNullCheck(ASTExpression node) {
        if (node instanceof ASTInfixExpression) {
            ASTInfixExpression infixExpression = (ASTInfixExpression) node;
            return isInfixExpressionWithOperator(infixExpression, BinaryOp.NE) && JavaAstUtils.isNullLiteral(infixExpression.getRightOperand());
        }
        return false;
    }

    private boolean isEqualsCall(ASTExpression node) {
        if (node instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) node;
            node = unaryExpression.getOperand();
        }
        if (node instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) node;
            if (methodCall.getMethodName().equals("equals")) {
                ASTExpression qualifier = methodCall.getQualifier();
                if (qualifier instanceof ASTMethodCall) {
                    ASTMethodCall innerMethodCall = (ASTMethodCall) qualifier;
                    JTypeMirror returnType = getReturnType(innerMethodCall);
                    if (TypeTestUtil.isA(String.class, returnType)) {
                        return true;
                    }
                } else if (qualifier instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    private JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
This checker has passed this negative testcase:
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}


This checker is failed(false negative) on this negative test case:
```
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo != null || boo != true;  // second expression will throw
                    result = boo != null || boo != false; // second expression will throw
                    result = boo != null || boo == true;  // second expression will throw
                    result = boo != null || boo == false; // second expression will throw

                }
            }
The number of violating the rule in this test case is: 4

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Test')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testPMD')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'boo')
            ——ASTNullLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'result')
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral
        ——ASTExpressionStatement
          ——ASTAssignmentExpression
            ——ASTVariableAccess (referenced variable name = 'result')
            ——ASTInfixExpression
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTNullLiteral
              ——ASTInfixExpression
                ——ASTVariableAccess (referenced variable name = 'boo')
                ——ASTBooleanLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTFormalParameters getFormalParameters()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPublic()
8. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPackagePrivate()
9. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isProtected()
10. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getResultTypeNode()
11. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isVoid()
12. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
13. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public boolean isFinal()
14. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
15. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public boolean isAnyAnnotationPresent(java.util.Collection)
16. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
17. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isPrivate()
18. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isPublic()
19. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isPackagePrivate()
20. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isProtected()
21. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isStatic()
22. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isFinal()
23. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isVolatile()
24. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isTransient()
25. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
26. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
27. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
28. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr getLeftOperand()
29. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
30. net.sourceforge.pmd.lang.java.ast.ASTVariableAccess: public net.sourceforge.pmd.lang.java.types.JTypeMirror getTypeMirror()
31. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
32. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
33. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()
34. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
35. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length()
36. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.BinaryOp getOperator()
37. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLeftOperand()
38. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public net.sourceforge.pmd.lang.java.ast.ASTExpression getRightOperand()
39. net.sourceforge.pmd.lang.java.ast.ASTInfixExpression: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
40. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean equals(java.lang.Object)
41. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isBooleanLiteral(net.sourceforge.pmd.lang.java.ast.JavaNode), //Returns true if the node is a boolean literal with any value.
42. net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral: public boolean isTrue()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Get the number of formal parameters of method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTMethodDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```
3.  //Get the name of formal parameter
```java
import net.sourceforge.pmd.lang.java.ast.*;
public String getFormalParameterName(ASTFormalParameter node) {
    return node.getVarId().getName();
}
```
4.  //Check whether the formal parameter is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFormalParameterStringType(ASTFormalParameter node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```
5.  //Check whether the formal parameter is boolean type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterBooleanType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN);
}
```
6.  //Check whether the formal parameter is char type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterCharType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.CHAR);
}
```
7.  //Check whether the formal parameter is byte type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterByteType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
}
```
8.  //Check whether the formal parameter is short type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterShortType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.SHORT);
}
```
9.  //Check whether the formal parameter is int type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterIntType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.INT);
}
```
10.  //Check whether the formal parameter is long type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterLongType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.LONG);
}
```
11.  //Check whether the formal parameter is float type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterFloatType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.FLOAT);
}
```
12.  //Check whether the formal parameter is double type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterDoubleType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.DOUBLE);
}
```
13.  //Check whether the formal parameter is boxed primitive type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public boolean isFormalParameterBoxedPrimitiveType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isBoxedPrimitive();
}
```
14.  //Check whether the formal parameter is a x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFormalParameterClassType(ASTFormalParameter node) {
    return TypeTestUtil.isA(x.class, node.getTypeNode());
}
```
15.  //Check whether the formal parameter is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isFormalParameterArrayType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```
16.  //Check whether the formal parameter is enum type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isFormalParameterEnumType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) type.getTypeMirror().getSymbol()).isEnum();
}
```
17.  //Check whether the formal parameter is record type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isFormalParameterRecordType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) type.getTypeMirror().getSymbol()).isRecord();
}
```
18.  //Get an usage of formal parameter
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr;
import java.util.List;
public List<ASTAssignableExpr.ASTNamedReferenceExpr> getAUsage(ASTFormalParameter node){
    List<ASTAssignableExpr.ASTNamedReferenceExpr> localUsages = node.getVarId().getLocalUsages();
    return localUsages;
}
```
19.  //Check whether the field is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFieldStringType(ASTFieldDeclaration node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```
20.  //Check whether the field is boolean type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFieldBooleanType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN);
}
```
21.  //Check whether the field is char type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFieldCharType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.CHAR);
}
```
22.  //Check whether the field is byte type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFieldByteType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
}
```
23.  //Check whether the field is short type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFieldShortType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.SHORT);
}
```
24.  //Check whether the field is int type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFieldIntType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.INT);
}
```
25.  //Check whether the field is long type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFieldLongType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.LONG);
}
```
26.  //Check whether the field is float type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFieldFloatType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.FLOAT);
}
```
27.  //Check whether the field is double type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFieldDoubleType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.DOUBLE);
}
```
28.  //Check whether the field is boxed primitive type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public boolean isFieldBoxedPrimitiveType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isBoxedPrimitive();
}
```
29.  //Check whether the field is a x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFieldClassType(ASTFieldDeclaration node) {
    return TypeTestUtil.isA(x.class, node.getTypeNode());
}
```
30.  //Check whether the field is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isFieldArrayType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```
31.  //Check whether the field is enum type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isFieldEnumType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) type.getTypeMirror().getSymbol()).isEnum();
}
```
32.  //Check whether the field is record type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isFieldRecordType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) type.getTypeMirror().getSymbol()).isRecord();
}
```
33.  //Check whether field has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTFieldDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```
34.  //Check whether the field is initialized
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean isInitialized(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                return true;
            }
        }
    }
    return false;
}
```
35.  //Check whether the field is initialized to variable value
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean isInitializedToVariableValue(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
    }
    return false;
}
```
36.  //Get the literal value that the field is initialized to
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTLiteral;
import net.sourceforge.pmd.lang.ast.NodeStream;
public ASTLiteral getInitializedValue(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTLiteral) {
                    return (ASTLiteral)init;
                }
            }
        }
    }
    return null;
}
```
37.  //Get an access of field
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr;
import java.util.List;
public List<ASTAssignableExpr.ASTNamedReferenceExpr> getAUsage(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId var : varIds){
        if(var.getName().equals("x")){
            List<ASTAssignableExpr.ASTNamedReferenceExpr> localUsages = var.getLocalUsages();
            return localUsages;
        }
    }
    return null;
}
```
38.  //Check whether the accessed variable is a field
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;
public boolean isVariableAccessField(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JFieldSymbol) {
        JFieldSymbol fieldSym = (JFieldSymbol) sym;
        return true;
    }
    return false;
}
```
39.  //Check whether the accessed variable is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTVariableAccess var){
    return TypeTestUtil.isA(String.class, var.getTypeMirror());
}
```
40.  //Check whether the accessed variable is boolean type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isVariableAccessBooleanType(ASTVariableAccess var) {
    return var.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN);
}
```
41.  //Check whether the accessed variable is char type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isVariableAccessCharType(ASTVariableAccess var) {
    return var.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.CHAR);
}
```
42.  //Check whether the accessed variable is byte type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isVariableAccessByteType(ASTVariableAccess var) {
    return var.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
}
```
43.  //Check whether the accessed variable is short type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isVariableAccessShortType(ASTVariableAccess var) {
    return var.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.SHORT);
}
```
44.  //Check whether the accessed variable is int type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isVariableAccessIntType(ASTVariableAccess var) {
    return var.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.INT);
}
```
45.  //Check whether the accessed variable is long type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isVariableAccessLongType(ASTVariableAccess var) {
    return var.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.LONG);
}
```
46.  //Check whether the accessed variable is float type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isVariableAccessFloatType(ASTVariableAccess var) {
    return var.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.FLOAT);
}
```
47.  //Check whether the accessed variable is double type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isVariableAccessDoubleType(ASTVariableAccess var) {
    return var.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.DOUBLE);
}
```
48.  //Check whether the accessed variable is boxed primitive type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public boolean isFieldBoxedPrimitiveType(ASTVariableAccess var) {
    JTypeMirror t = var.getTypeMirror();
    return t.isBoxedPrimitive();
}
```
49.  //Check whether the accessed variable is a x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTVariableAccess var){
    return TypeTestUtil.isA(x.class, var.getTypeMirror());
}
```
50.  //Check whether the accessed variable is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
public boolean isVariableAccessArrayType(ASTVariableAccess var) {
    return var.getTypeMirror().isArray();
}
```
51.  //Check whether the accessed variable is enum type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
import net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;
public boolean isVariableAccessEnumType(ASTVariableAccess var){
    JTypeDeclSymbol symbol = var.getTypeMirror().getSymbol();
    return symbol instanceof JClassSymbol && ((JClassSymbol) symbol).isEnum();
}
```
52.  //Check whether the accessed variable is record type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
import net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;
public boolean isVariableAccessRecordType(ASTVariableAccess var){
    JTypeDeclSymbol symbol = var.getTypeMirror().getSymbol();
    return symbol instanceof JClassSymbol && ((JClassSymbol) symbol).isRecord();
}
```
53.  //Check whether the method caller is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallerStringType(ASTMethodCall node){
    return TypeTestUtil.isA(String.class, node.getQualifier());
}
```
54.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```
55.  //Check whether the operator in infix expression is ''
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils;
public boolean isInfixExpressionWithOperator(ASTInfixExpression node, BinaryOp op){
    //enum BinaryOp{CONDITIONAL_OR("||"), CONDITIONAL_AND("&&"), OR("|"), XOR("^"), AND("&"), EQ("=="), NE("!="), LE("<="), GE(">="), GT(">"), LT("<"), INSTANCEOF("instanceof"), LEFT_SHIFT("<<"), RIGHT_SHIFT(">>"), UNSIGNED_RIGHT_SHIFT(">>>"), ADD("+"), SUB("-"), MUL("*"), DIV("/"), MOD("%")}
    return JavaAstUtils.isInfixExprWithOperator(node, op);
}
```
56.  //Check whether the return type of called method is boolean type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.JMethodSig;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnBooleanType(ASTMethodCall call) {
    JMethodSig m = call.getMethodType();
    return m.getReturnType().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN);
}
```
57.  //Get the literal value that the local variable is initialized to
```java
import net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTLiteral;
import net.sourceforge.pmd.lang.ast.NodeStream;
public ASTLiteral getInitializedValue(ASTLocalVariableDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a local declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTLiteral) {
                    return (ASTLiteral)init;
                }
            }
        }
    }
    return null;
}
```


执行到这里，测试用例太多了，超出了最大长度
测试用例太多了，超出了最大长度
结束

规则执行完毕，时间总花销： 3852.3862800598145 秒
