开始

========================================== Rule EmptyControlStatementRule ===========================================
一共 31 个测试用例
正例 9 个
反例 22 个
2129
1700
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Check whether the class has a method named foo.
2. Get the method declaration of foo.
3. Get the body of method foo.
4. Check whether the body of method foo contains a try statement.
5. Get the try statement from the body of method foo.
6. Get the body of the try statement.
7. Check whether the body of the try statement is empty.

If the body of the try statement is empty, then this test case violates the rule.
['Check whether the class has a method named foo.', 'Get the method declaration of foo.', 'Get the body of method foo.', 'Check whether the body of method foo contains a try statement.', 'Get the try statement from the body of method foo.', 'Get the body of the try statement.', 'Check whether the body of the try statement is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTExpressionStatement', 'ASTTryStatement', 'TokenUtils', 'ASTCatchClause', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTCatchParameter', 'JavaSemanticErrors']
*Check whether the class has a method named foo.* 匹配到的元操作或API：
query: Check whether the class has a method named foo.
most similar API: Check whether is test method
cosine Similarity: 0.8302556276321411
*Get the method declaration of foo.* 匹配到的元操作或API：
logic: Get the method declaration of foo.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.8988851308822632
*Get the body of method foo.* 匹配到的元操作或API：
query: Get the body of method foo.
most similar API: get body of method
cosine Similarity: 0.9337466955184937
*Check whether the body of method foo contains a try statement.* 匹配到的元操作或API：
query: Check whether the body of method foo contains a try statement.
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.8446516990661621
*Get the try statement from the body of method foo.* 匹配到的元操作或API：
query: Get the try statement from the body of method foo.
most similar API: get body of try statement
cosine Similarity: 0.9084784984588623
*Get the body of the try statement.* 匹配到的元操作或API：
query: Get the body of the try statement.
most similar API: get body of try statement
cosine Similarity: 0.9787788391113281
*Check whether the body of the try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8486953377723694
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
The test case corresponding to the rule:
```
// pos, empty try block
public class EmptyTryBlock1 {
                public void foo() {
                    try {
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock1')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTExpressionStatement
                ——ASTMethodCall (called method name = 'printStackTrace')
                  ——ASTVariableAccess (referenced variable name = 'e')
                  ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean isTryWithResources(), //Returns true if this node is a try-with-resources, in which case it has a ResourceSpecification child node.
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlockStatement.class);
    }
    
    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (!node.isTryWithResources() && node.getBody().getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBody().getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getBody().getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBody().getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTIfStatement node, Object data) {
        if (node.getFirstChildOfType(ASTBlock.class).getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        if (node.getFirstChildOfType(ASTBlock.class).getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTForStatement node, Object data) {
        if (node.getFirstChildOfType(ASTBlock.class).getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTDoStatement node, Object data) {
        if (node.getFirstChildOfType(ASTBlock.class).getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
    
    @Override
    public Object visit(ASTBlockStatement node, Object data) {
        if (node.getFirstChildOfType(ASTBlock.class).getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    // Method to get method declaration from method call
    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method) {
        JMethodSymbol symbol = (JMethodSymbol) method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the method declaration from method call.
2. Get the name of method.
3. Get the body of the method.
4. Get a control statement from the method body.
5. Check whether the control statement is a try statement.
6. Get the finally branch of try statement.
7. Check whether the finally branch is empty.
8. Get the try block of try statement.
9. Check whether the try block is empty.
10. Get a catch branch of try statement.
11. Check whether the catch branch is empty.

In this test case, the granular check sequence focuses on the try statement within the method `foo`:
1. Get the method declaration from method call. (foo)
2. Get the name of method. (foo)
3. Get the body of the method. 
4. Get a control statement from the method body. (try-catch)
5. Check whether the control statement is a try statement. (true)
6. Get the finally branch of try statement. (present, but not empty)
7. Check whether the finally branch is empty. (false)
8. Get the try block of try statement. 
9. Check whether the try block is empty. (true)
10. Get a catch branch of try statement. (present)
11. Check whether the catch branch is empty. (false)

The check shows that the try block is empty, which violates the rule. The finally branch and catch branch are not empty, so they do not violate the rule. Therefore, the number of violations in this test case is 1.
['Get the method declaration from method call.', 'Get the name of method.', 'Get the body of the method.', 'Get a control statement from the method body.', 'Check whether the control statement is a try statement.', 'Get the finally branch of try statement.', 'Check whether the finally branch is empty.', 'Get the try block of try statement.', 'Check whether the try block is empty.', 'Get a catch branch of try statement.', 'Check whether the catch branch is empty.', 'Get the method declaration from method call. (foo)', 'Get the name of method. (foo)', 'Get the body of the method.', 'Get a control statement from the method body. (try-catch)', 'Check whether the control statement is a try statement. (true)', 'Get the finally branch of try statement. (present, but not empty)', 'Check whether the finally branch is empty. (false)', 'Get the try block of try statement.', 'Check whether the try block is empty. (true)', 'Get a catch branch of try statement. (present)', 'Check whether the catch branch is empty. (false)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTExpressionStatement', 'ASTTryStatement', 'TokenUtils', 'ASTCatchClause', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTCatchParameter', 'JavaSemanticErrors']
*Get the method declaration from method call.* 匹配到的元操作或API：
logic: Get the method declaration from method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9787436127662659
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Get a control statement from the method body.* 匹配到的元操作或API：
query: Get a control statement from the method body.
most similar API: get body of method
cosine Similarity: 0.8042162656784058
*Check whether the control statement is a try statement.* 匹配到的元操作或API：
query: Check whether the control statement is a try statement.
most similar API: Check whether the try statement equals
cosine Similarity: 0.8672431111335754
*Get the finally branch of try statement.* 匹配到的元操作或API：
logic: Get the finally branch of try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9912986755371094
*Check whether the finally branch is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the try block of try statement.* 匹配到的元操作或API：
logic: Get the try block of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.856391966342926
*Check whether the try block is empty.* 匹配到的元操作或API：
query: Check whether the try block is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8674911260604858
*Get a catch branch of try statement.* 匹配到的元操作或API：
logic: Get a catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9905791282653809
*Check whether the catch branch is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the method declaration from method call. (foo)* 匹配到的元操作或API：
logic: Get the method declaration from method call. (foo)
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9628278017044067
*Get the name of method. (foo)* 匹配到的元操作或API：
logic: Get the name of method. (foo)
most similar meta operation: Get the name of method
cosine Similarity: 0.9423699975013733
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Get a control statement from the method body. (try-catch)* 匹配到的元操作或API：
query: Get a control statement from the method body. (try-catch)
most similar API: get body of try statement
cosine Similarity: 0.8481375575065613
*Check whether the control statement is a try statement. (true)* 匹配到的元操作或API：
query: Check whether the control statement is a try statement. (true)
most similar API: Check whether the try statement equals
cosine Similarity: 0.863955020904541
*Get the finally branch of try statement. (present, but not empty)* 匹配到的元操作或API：
logic: Get the finally branch of try statement. (present, but not empty)
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.97478187084198
*Check whether the finally branch is empty. (false)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the try block of try statement.* 匹配到的元操作或API：
logic: Get the try block of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.856391966342926
*Check whether the try block is empty. (true)* 匹配到的元操作或API：
query: Check whether the try block is empty. (true)
most similar API: Check whether the block is empty
cosine Similarity: 0.8652392625808716
*Get a catch branch of try statement. (present)* 匹配到的元操作或API：
logic: Get a catch branch of try statement. (present)
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9768677353858948
*Check whether the catch branch is empty. (false)* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
The test case corresponding to the rule:
```
// pos, empty try block
public class EmptyTryBlock1 {
                public void foo() {
                    try {
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock1')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTExpressionStatement
                ——ASTMethodCall (called method name = 'printStackTrace')
                  ——ASTVariableAccess (referenced variable name = 'e')
                  ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()
5. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
6. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()
7. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTCatchClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTLoopStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBlock = node.getBody();
        if (tryBlock != null && tryBlock.isEmpty()) {
            addViolation(data, tryBlock);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.isEmpty()) {
            addViolation(data, finallyClause);
        }
        for (ASTCatchClause catchClause : node.getCatchClauses()) {
            ASTBlock catchBlock = catchClause.getBody();
            if (catchBlock != null && catchBlock.isEmpty()) {
                addViolation(data, catchBlock);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTCatchClause node, Object data) {
        ASTBlock catchBlock = node.getBody();
        if (catchBlock != null && catchBlock.isEmpty()) {
            addViolation(data, catchBlock);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock switchBlock = node.getFirstChildOfType(ASTBlock.class);
        if (switchBlock != null && switchBlock.isEmpty()) {
            addViolation(data, switchBlock);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock syncBlock = node.getFirstChildOfType(ASTBlock.class);
        if (syncBlock != null && syncBlock.isEmpty()) {
            addViolation(data, syncBlock);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBlock = node.getFirstChildOfType(ASTBlock.class);
        if (ifBlock != null && ifBlock.isEmpty()) {
            addViolation(data, ifBlock);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTLoopStatement node, Object data) {
        ASTBlock loopBlock = node.getFirstChildOfType(ASTBlock.class);
        if (loopBlock != null && loopBlock.isEmpty()) {
            addViolation(data, loopBlock);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTMethodDeclaration) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    // Utility method to get method declaration from method call
    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method) {
        JMethodSymbol symbol = (JMethodSymbol) method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the body of the try statement.
2. Check whether the body of the try statement is empty.
3. Get the body of the catch clause.
4. Check whether the body of the catch clause is empty.
5. Get the body of the finally clause.
6. Check whether the body of the finally clause is empty.
7. Get the body of the switch statement.
8. Check whether the body of the switch statement is empty.
9. Get the body of the synchronized statement.
10. Check whether the body of the synchronized statement is empty.
11. Get the body of the if statement.
12. Check whether the body of the if statement is empty.
13. Get the body of the else statement.
14. Check whether the body of the else statement is empty.
15. Get the body of the for statement.
16. Check whether the body of the for statement is empty.
17. Get the body of the while statement.
18. Check whether the body of the while statement is empty.
19. Get the body of the do-while statement.
20. Check whether the body of the do-while statement is empty.
21. Check whether the initializer block is empty.

For the provided test case:
1. Get the body of the try statement.
2. Check whether the body of the try statement is empty. (This should be true, indicating a violation of the rule.)
3. Get the body of the catch clause.
4. Check whether the body of the catch clause is empty. (This should be false, as it contains `e.printStackTrace();`)
5. Get the body of the finally clause.
6. Check whether the body of the finally clause is empty. (This should be true, but there is no finally block in the provided test case, so this check is not applicable here.)
7. Get the body of the switch statement.
8. Check whether the body of the switch statement is empty. (This should be false, as there is no switch statement in the provided test case.)
9. Get the body of the synchronized statement.
10. Check whether the body of the synchronized statement is empty. (This should be false, as there is no synchronized statement in the provided test case.)
11. Get the body of the if statement.
12. Check whether the body of the if statement is empty. (This should be false, as there is no if statement in the provided test case.)
13. Get the body of the else statement.
14. Check whether the body of the else statement is empty. (This should be false, as there is no else statement in the provided test case.)
15. Get the body of the for statement.
16. Check whether the body of the for statement is empty. (This should be false, as there is no for statement in the provided test case.)
17. Get the body of the while statement.
18. Check whether the body of the while statement is empty. (This should be false, as there is no while statement in the provided test case.)
19. Get the body of the do-while statement.
20. Check whether the body of the do-while statement is empty. (This should be false, as there is no do-while statement in the provided test case.)
21. Check whether the initializer block is empty. (This should be false, as there is no initializer block in the provided test case.)

The number of violating the rule in this test case is: 1, as confirmed by the second granular check.
['Get the body of the try statement.', 'Check whether the body of the try statement is empty.', 'Get the body of the catch clause.', 'Check whether the body of the catch clause is empty.', 'Get the body of the finally clause.', 'Check whether the body of the finally clause is empty.', 'Get the body of the switch statement.', 'Check whether the body of the switch statement is empty.', 'Get the body of the synchronized statement.', 'Check whether the body of the synchronized statement is empty.', 'Get the body of the if statement.', 'Check whether the body of the if statement is empty.', 'Get the body of the else statement.', 'Check whether the body of the else statement is empty.', 'Get the body of the for statement.', 'Check whether the body of the for statement is empty.', 'Get the body of the while statement.', 'Check whether the body of the while statement is empty.', 'Get the body of the do-while statement.', 'Check whether the body of the do-while statement is empty.', 'Check whether the initializer block is empty.', 'Get the body of the try statement.', 'Check whether the body of the try statement is empty. (This should be true, indicating a violation of the rule.)', 'Get the body of the catch clause.', 'Check whether the body of the catch clause is empty. (This should be false, as it contains `e.printStackTrace();`)', 'Get the body of the finally clause.', 'Check whether the body of the finally clause is empty. (This should be true, but there is no finally block in the provided test case, so this check is not applicable here.)', 'Get the body of the switch statement.', 'Check whether the body of the switch statement is empty. (This should be false, as there is no switch statement in the provided test case.)', 'Get the body of the synchronized statement.', 'Check whether the body of the synchronized statement is empty. (This should be false, as there is no synchronized statement in the provided test case.)', 'Get the body of the if statement.', 'Check whether the body of the if statement is empty. (This should be false, as there is no if statement in the provided test case.)', 'Get the body of the else statement.', 'Check whether the body of the else statement is empty. (This should be false, as there is no else statement in the provided test case.)', 'Get the body of the for statement.', 'Check whether the body of the for statement is empty. (This should be false, as there is no for statement in the provided test case.)', 'Get the body of the while statement.', 'Check whether the body of the while statement is empty. (This should be false, as there is no while statement in the provided test case.)', 'Get the body of the do-while statement.', 'Check whether the body of the do-while statement is empty. (This should be false, as there is no do-while statement in the provided test case.)', 'Check whether the initializer block is empty. (This should be false, as there is no initializer block in the provided test case.)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTExpressionStatement', 'ASTTryStatement', 'TokenUtils', 'ASTCatchClause', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTCatchParameter', 'JavaSemanticErrors']
*Get the body of the try statement.* 匹配到的元操作或API：
query: Get the body of the try statement.
most similar API: get body of try statement
cosine Similarity: 0.9787788391113281
*Check whether the body of the try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8486953377723694
*Get the body of the catch clause.* 匹配到的元操作或API：
logic: Get the body of the catch clause.
most similar meta operation: Get a parameter of catch clause
cosine Similarity: 0.8557884693145752
*Check whether the body of the catch clause is empty.* 匹配到的元操作或API：
query: Check whether the body of the catch clause is empty.
most similar API: Check whether the catch clause equals
cosine Similarity: 0.8271180987358093
*Get the body of the finally clause.* 匹配到的元操作或API：
query: Get the body of the finally clause.
most similar API: get finally clause of try statement
cosine Similarity: 0.8548771739006042
*Check whether the body of the finally clause is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the switch statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the switch statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the switch statement is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8094784021377563
*Get the body of the synchronized statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the synchronized statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the if statement.* 匹配到的元操作或API：
query: Get the body of the if statement.
most similar API: get body of try statement
cosine Similarity: 0.8455290198326111
*Check whether the body of the if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of the if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8603639006614685
*Get the body of the else statement.* 匹配到的元操作或API：
logic: Get the body of the else statement.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.8584789633750916
*Check whether the body of the else statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the for statement.* 匹配到的元操作或API：
query: Get the body of the for statement.
most similar API: get body of try statement: Returns the body of this try statement.
cosine Similarity: 0.8025227785110474
*Check whether the body of the for statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the for statement is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8181264400482178
*Get the body of the while statement.* 匹配到的元操作或API：
query: Get the body of the while statement.
most similar API: get body of try statement
cosine Similarity: 0.8494763970375061
*Check whether the body of the while statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the do-while statement.* 匹配到的元操作或API：
query: Get the body of the do-while statement.
most similar API: get body of try statement
cosine Similarity: 0.8317018151283264
*Check whether the body of the do-while statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the initializer block is empty.* 匹配到的元操作或API：
query: Check whether the initializer block is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.862004280090332
*Get the body of the try statement.* 匹配到的元操作或API：
query: Get the body of the try statement.
most similar API: get body of try statement
cosine Similarity: 0.9787788391113281
*Check whether the body of the try statement is empty. (This should be true, indicating a violation of the rule.)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the catch clause.* 匹配到的元操作或API：
logic: Get the body of the catch clause.
most similar meta operation: Get a parameter of catch clause
cosine Similarity: 0.8557884693145752
*Check whether the body of the catch clause is empty. (This should be false, as it contains `e.printStackTrace();`)* 匹配到的元操作或API：
query: Check whether the body of the catch clause is empty. (This should be false, as it contains `e.printStackTrace();`)
most similar API: get body of catch clause
cosine Similarity: 0.8055488467216492
*Get the body of the finally clause.* 匹配到的元操作或API：
query: Get the body of the finally clause.
most similar API: get finally clause of try statement
cosine Similarity: 0.8548771739006042
*Check whether the body of the finally clause is empty. (This should be true, but there is no finally block in the provided test case, so this check is not applicable here.)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the switch statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the switch statement is empty. (This should be false, as there is no switch statement in the provided test case.)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the synchronized statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the synchronized statement is empty. (This should be false, as there is no synchronized statement in the provided test case.)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the if statement.* 匹配到的元操作或API：
query: Get the body of the if statement.
most similar API: get body of try statement
cosine Similarity: 0.8455290198326111
*Check whether the body of the if statement is empty. (This should be false, as there is no if statement in the provided test case.)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the else statement.* 匹配到的元操作或API：
logic: Get the body of the else statement.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.8584789633750916
*Check whether the body of the else statement is empty. (This should be false, as there is no else statement in the provided test case.)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the for statement.* 匹配到的元操作或API：
query: Get the body of the for statement.
most similar API: get body of try statement: Returns the body of this try statement.
cosine Similarity: 0.8025227785110474
*Check whether the body of the for statement is empty. (This should be false, as there is no for statement in the provided test case.)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the while statement.* 匹配到的元操作或API：
query: Get the body of the while statement.
most similar API: get body of try statement
cosine Similarity: 0.8494763970375061
*Check whether the body of the while statement is empty. (This should be false, as there is no while statement in the provided test case.)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the do-while statement.* 匹配到的元操作或API：
query: Get the body of the do-while statement.
most similar API: get body of try statement
cosine Similarity: 0.8317018151283264
*Check whether the body of the do-while statement is empty. (This should be false, as there is no do-while statement in the provided test case.)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the initializer block is empty. (This should be false, as there is no initializer block in the provided test case.)* 匹配到的元操作或API：
query: Check whether the initializer block is empty. (This should be false, as there is no initializer block in the provided test case.)
most similar API: Check whether the block is empty
cosine Similarity: 0.8000512719154358
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
The test case corresponding to the rule:
```
// pos, empty try block
public class EmptyTryBlock1 {
                public void foo() {
                    try {
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock1')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTExpressionStatement
                ——ASTMethodCall (called method name = 'printStackTrace')
                  ——ASTVariableAccess (referenced variable name = 'e')
                  ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
2. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTCatchParameter getParameter()
3. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause(), //Returns the {@code finally} clause of this try statement, if any. @return The finally statement, or null if there is none
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
7. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch()
8. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()
9. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this catch branch.



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTLoopStatement.class, ASTInitializer.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, body);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause.getBody());
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock thenBranch = node.getFirstChildOfType(ASTBlock.class);
        if (thenBranch != null && thenBranch.isEmpty()) {
            addViolation(data, thenBranch);
        }
        ASTBlock elseBranch = node.getElseBranch();
        if (elseBranch instanceof ASTBlock && ((ASTBlock) elseBranch).isEmpty()) {
            addViolation(data, elseBranch);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTLoopStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof JavaNode && !(node.getParent() instanceof ASTClassOrInterfaceBody)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the body of try statement.
2. Check whether the body of try statement is empty.
3. Get the catch branch of try statement.
4. Check whether the catch branch of try statement is empty.
5. Get the finally branch of try statement.
6. Check whether the finally branch of try statement is empty.

For the given test case:
1. Get the body of try statement.
   - The body of the try statement is empty.
   - This violates the rule.

2. Get the catch branch of try statement.
   - The catch branch is not empty as it contains `e.printStackTrace();`.

3. Get the finally branch of try statement.
   - There is no finally branch in the given test case.

Since the body of the try statement is empty, the number of violations in this test case is 1.
['Get the body of try statement.', 'Check whether the body of try statement is empty.', 'Get the catch branch of try statement.', 'Check whether the catch branch of try statement is empty.', 'Get the finally branch of try statement.', 'Check whether the finally branch of try statement is empty.', 'Get the body of try statement.', 'Get the catch branch of try statement.', 'Get the finally branch of try statement.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTExpressionStatement', 'ASTTryStatement', 'TokenUtils', 'ASTCatchClause', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTCatchParameter', 'JavaSemanticErrors']
*Get the body of try statement.* 匹配到的元操作或API：
query: Get the body of try statement.
most similar API: get body of try statement
cosine Similarity: 0.9849936962127686
*Check whether the body of try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8571391105651855
*Get the catch branch of try statement.* 匹配到的元操作或API：
logic: Get the catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9813414812088013
*Check whether the catch branch of try statement is empty.* 匹配到的元操作或API：
logic: Check whether the catch branch of try statement is empty.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8558295965194702
*Get the finally branch of try statement.* 匹配到的元操作或API：
logic: Get the finally branch of try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9912986755371094
*Check whether the finally branch of try statement is empty.* 匹配到的元操作或API：
logic: Check whether the finally branch of try statement is empty.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.879764199256897
*Get the body of try statement.* 匹配到的元操作或API：
query: Get the body of try statement.
most similar API: get body of try statement
cosine Similarity: 0.9849936962127686
*Get the catch branch of try statement.* 匹配到的元操作或API：
logic: Get the catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9813414812088013
*Get the finally branch of try statement.* 匹配到的元操作或API：
logic: Get the finally branch of try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9912986755371094
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
The test case corresponding to the rule:
```
// pos, empty try block
public class EmptyTryBlock1 {
                public void foo() {
                    try {
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock1')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTExpressionStatement
                ——ASTMethodCall (called method name = 'printStackTrace')
                  ——ASTVariableAccess (referenced variable name = 'e')
                  ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTCatchClause.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoWhileStatement.class, ASTInitializer.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBlock = node.getBody();
        if (tryBlock.getNumChildren() == 0) {
            addViolation(data, tryBlock);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock finallyBlock = node.getFirstChildOfType(ASTBlock.class);
        if (finallyBlock != null && finallyBlock.getNumChildren() == 0) {
            addViolation(data, finallyBlock);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTCatchClause node, Object data) {
        ASTBlock catchBlock = node.getFirstChildOfType(ASTBlock.class);
        if (catchBlock != null && catchBlock.getNumChildren() == 0) {
            addViolation(data, catchBlock);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock switchBlock = node.getFirstChildOfType(ASTBlock.class);
        if (switchBlock != null && switchBlock.getNumChildren() == 0) {
            addViolation(data, switchBlock);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock syncBlock = node.getFirstChildOfType(ASTBlock.class);
        if (syncBlock != null && syncBlock.getNumChildren() == 0) {
            addViolation(data, syncBlock);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBlock = node.getFirstChildOfType(ASTBlock.class);
        if (ifBlock != null && ifBlock.getNumChildren() == 0) {
            addViolation(data, ifBlock);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock forBlock = node.getFirstChildOfType(ASTBlock.class);
        if (forBlock != null && forBlock.getNumChildren() == 0) {
            addViolation(data, forBlock);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock whileBlock = node.getFirstChildOfType(ASTBlock.class);
        if (whileBlock != null && whileBlock.getNumChildren() == 0) {
            addViolation(data, whileBlock);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoWhileStatement node, Object data) {
        ASTBlock doBlock = node.getFirstChildOfType(ASTBlock.class);
        if (doBlock != null && doBlock.getNumChildren() == 0) {
            addViolation(data, doBlock);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock initBlock = node.getFirstChildOfType(ASTBlock.class);
        if (initBlock != null && initBlock.getNumChildren() == 0) {
            addViolation(data, initBlock);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.getParent() instanceof ASTMethodDeclaration && node.getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the left-hand side operand of the assignment expression.
2. Check whether the operand is an accessed field.
3. Check whether the accessed field is final.
4. Get all control statements in the method.
5. Check whether the control statement is a try statement.
6. Get the body of the try statement.
7. Check whether the body of the try statement is empty.
8. Get the finally clause of the try statement.
9. Check whether the finally clause of the try statement is empty.
10. Get all switch statements in the method.
11. Check whether the switch statement is empty.
12. Get all synchronized statements in the method.
13. Check whether the synchronized statement is empty.
14. Get all if statements in the method.
15. Get the body of the if statement.
16. Check whether the body of the if statement is empty.
17. Get the else branch of the if statement.
18. Check whether the else branch of the if statement is empty.
19. Get all loop statements in the method.
20. Check whether the loop statement is a while loop.
21. Get the body of the while loop.
22. Check whether the body of the while loop is empty.
23. Check whether the loop statement is a for loop.
24. Get the body of the for loop.
25. Check whether the body of the for loop is empty.
26. Check whether the loop statement is a do-while loop.
27. Get the body of the do-while loop.
28. Check whether the body of the do-while loop is empty.
29. Get all initializers and blocks used as statements in the method.
30. Check whether the initializer or block is empty.

For the provided test case:
1. Get the left-hand side operand of the assignment expression.
2. Check whether the operand is an accessed field.
3. Check whether the accessed field is final.
4. Get all control statements in the method.
5. Check whether the control statement is a try statement.
6. Get the body of the try statement.
7. Check whether the body of the try statement is empty.  // This is the violation in the test case.

The test case violates the rule because there is an empty try block.
['Get the left-hand side operand of the assignment expression.', 'Check whether the operand is an accessed field.', 'Check whether the accessed field is final.', 'Get all control statements in the method.', 'Check whether the control statement is a try statement.', 'Get the body of the try statement.', 'Check whether the body of the try statement is empty.', 'Get the finally clause of the try statement.', 'Check whether the finally clause of the try statement is empty.', 'Get all switch statements in the method.', 'Check whether the switch statement is empty.', 'Get all synchronized statements in the method.', 'Check whether the synchronized statement is empty.', 'Get all if statements in the method.', 'Get the body of the if statement.', 'Check whether the body of the if statement is empty.', 'Get the else branch of the if statement.', 'Check whether the else branch of the if statement is empty.', 'Get all loop statements in the method.', 'Check whether the loop statement is a while loop.', 'Get the body of the while loop.', 'Check whether the body of the while loop is empty.', 'Check whether the loop statement is a for loop.', 'Get the body of the for loop.', 'Check whether the body of the for loop is empty.', 'Check whether the loop statement is a do-while loop.', 'Get the body of the do-while loop.', 'Check whether the body of the do-while loop is empty.', 'Get all initializers and blocks used as statements in the method.', 'Check whether the initializer or block is empty.', 'Get the left-hand side operand of the assignment expression.', 'Check whether the operand is an accessed field.', 'Check whether the accessed field is final.', 'Get all control statements in the method.', 'Check whether the control statement is a try statement.', 'Get the body of the try statement.', 'Check whether the body of the try statement is empty.  // This is the violation in the test case.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTExpressionStatement', 'ASTTryStatement', 'TokenUtils', 'ASTCatchClause', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTCatchParameter', 'JavaSemanticErrors']
*Get the left-hand side operand of the assignment expression.* 匹配到的元操作或API：
logic: Get the left-hand side operand of the assignment expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.9638152122497559
*Check whether the operand is an accessed field.* 匹配到的元操作或API：
logic: Check whether the operand is an accessed field.
most similar meta operation: Check whether the accessed variable is a field
cosine Similarity: 0.8818295001983643
*Check whether the accessed field is final.* 匹配到的元操作或API：
logic: Check whether the accessed field is final.
most similar meta operation: Check whether the field is final
cosine Similarity: 0.9394943118095398
*Get all control statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is a try statement.* 匹配到的元操作或API：
query: Check whether the control statement is a try statement.
most similar API: Check whether the try statement equals
cosine Similarity: 0.8672431111335754
*Get the body of the try statement.* 匹配到的元操作或API：
query: Get the body of the try statement.
most similar API: get body of try statement
cosine Similarity: 0.9787788391113281
*Check whether the body of the try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8486953377723694
*Get the finally clause of the try statement.* 匹配到的元操作或API：
logic: Get the finally clause of the try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.8998424410820007
*Check whether the finally clause of the try statement is empty.* 匹配到的元操作或API：
query: Check whether the finally clause of the try statement is empty.
most similar API: get finally clause of try statement
cosine Similarity: 0.8729100823402405
*Get all switch statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the switch statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all synchronized statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the synchronized statement is empty.* 匹配到的元操作或API：
query: Check whether the synchronized statement is empty.
most similar API: Check whether the method is synchronized
cosine Similarity: 0.8055706024169922
*Get all if statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the if statement.* 匹配到的元操作或API：
query: Get the body of the if statement.
most similar API: get body of try statement
cosine Similarity: 0.8455290198326111
*Check whether the body of the if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of the if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8603639006614685
*Get the else branch of the if statement.* 匹配到的元操作或API：
logic: Get the else branch of the if statement.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.9849298000335693
*Check whether the else branch of the if statement is empty.* 匹配到的元操作或API：
logic: Check whether the else branch of the if statement is empty.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9060104489326477
*Get all loop statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the loop statement is a while loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the while loop.* 匹配到的元操作或API：
query: Get the body of the while loop.
most similar API: get body of try statement
cosine Similarity: 0.8167147636413574
*Check whether the body of the while loop is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the loop statement is a for loop.* 匹配到的元操作或API：
query: Check whether the loop statement is a for loop.
most similar API: Check whether the variable declarator id is for loop variable
cosine Similarity: 0.8139293789863586
*Get the body of the for loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the for loop is empty.* 匹配到的元操作或API：
query: Check whether the body of the for loop is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8098464608192444
*Check whether the loop statement is a do-while loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the do-while loop.* 匹配到的元操作或API：
query: Get the body of the do-while loop.
most similar API: get body of try statement
cosine Similarity: 0.8072474002838135
*Check whether the body of the do-while loop is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all initializers and blocks used as statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the initializer or block is empty.* 匹配到的元操作或API：
query: Check whether the initializer or block is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.89825838804245
*Get the left-hand side operand of the assignment expression.* 匹配到的元操作或API：
logic: Get the left-hand side operand of the assignment expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.9638152122497559
*Check whether the operand is an accessed field.* 匹配到的元操作或API：
logic: Check whether the operand is an accessed field.
most similar meta operation: Check whether the accessed variable is a field
cosine Similarity: 0.8818295001983643
*Check whether the accessed field is final.* 匹配到的元操作或API：
logic: Check whether the accessed field is final.
most similar meta operation: Check whether the field is final
cosine Similarity: 0.9394943118095398
*Get all control statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is a try statement.* 匹配到的元操作或API：
query: Check whether the control statement is a try statement.
most similar API: Check whether the try statement equals
cosine Similarity: 0.8672431111335754
*Get the body of the try statement.* 匹配到的元操作或API：
query: Get the body of the try statement.
most similar API: get body of try statement
cosine Similarity: 0.9787788391113281
*Check whether the body of the try statement is empty.  // This is the violation in the test case.* 匹配到的元操作或API：
query: Check whether the body of the try statement is empty.  // This is the violation in the test case.
most similar API: get body of try statement
cosine Similarity: 0.8097096085548401
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
The test case corresponding to the rule:
```
// pos, empty try block
public class EmptyTryBlock1 {
                public void foo() {
                    try {
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock1')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTExpressionStatement
                ——ASTMethodCall (called method name = 'printStackTrace')
                  ——ASTVariableAccess (referenced variable name = 'e')
                  ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr getLeftOperand()
2. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isFinal()
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
5. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()
6. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause(), //Returns the {@code finally} clause of this try statement, if any. @return The finally statement, or null if there is none
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isSynchronized()
8. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
9. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch()
10. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
11. net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId: public boolean isForLoopVariable(), //Returns true if this node is a variable declared in the init clause of a {@linkplain ASTForStatement for loop}.
12. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()
13. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()

1.  //Check whether the accessed variable is a field
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;
public boolean isVariableAccessField(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JFieldSymbol) {
        JFieldSymbol fieldSym = (JFieldSymbol) sym;
        return true;
    }
    return false;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTCatchClause.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBlock().isEmpty()) {
            addViolation(data, finallyClause.getBlock());
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTCatchClause node, Object data) {
        // No need to check catch clauses for emptiness in this rule
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        // Handled in visit(ASTTryStatement)
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getBlock().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBlock().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        if (node.getFirstBranch().isEmpty()) {
            addViolation(data, node);
        }
        ASTElseClause elseClause = node.getElseClause();
        if (elseClause != null && elseClause.getElseBlock().isEmpty()) {
            addViolation(data, elseClause.getElseBlock());
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        if (node.getBlock().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        if (node.getBlock().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        if (node.getBlock().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    // Utility method to check whether the accessed variable is a field
    public boolean isVariableAccessField(ASTVariableAccess node) {
        JVariableSymbol sym = node.getReferencedSym();
        if (sym instanceof JFieldSymbol) {
            return true;
        }
        return false;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 1
1954
1552
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Get the method declaration from class.
3. Get the name of method.
4. Get the body of method.
5. Check whether the body of method contains a try statement.
6. Get the try statement body.
7. Check whether the try statement body is empty.
8. Get the finally clause of try statement.
9. Check whether the finally clause body is empty.

Based on the provided test case, the granular checks follow as:

1. Get the name of class.
   - The name of the class is `EmptyTryBlock2`.
2. Get the method declaration from class.
   - The method declaration is `public void foo()`.
3. Get the name of method.
   - The name of the method is `foo`.
4. Get the body of method.
   - The body of method `foo` contains a try statement and a finally clause.
5. Check whether the body of method contains a try statement.
   - The body contains a try statement.
6. Get the try statement body.
   - The try statement body is empty.
7. Check whether the try statement body is empty.
   - The try statement body is indeed empty, which violates the rule.
8. Get the finally clause of try statement.
   - The finally clause body contains `int x = 5;`.
9. Check whether the finally clause body is empty.
   - The finally clause body is not empty.

The number of violating the rule in this test case is: 1, as the try block is empty.
['Get the name of class.', 'Get the method declaration from class.', 'Get the name of method.', 'Get the body of method.', 'Check whether the body of method contains a try statement.', 'Get the try statement body.', 'Check whether the try statement body is empty.', 'Get the finally clause of try statement.', 'Check whether the finally clause body is empty.', 'Get the name of class.', 'Get the method declaration from class.', 'Get the name of method.', 'Get the body of method.', 'Check whether the body of method contains a try statement.', 'Get the try statement body.', 'Check whether the try statement body is empty.', 'Get the finally clause of try statement.', 'Check whether the finally clause body is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'ASTTryStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTFinallyClause', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the method declaration from class.* 匹配到的元操作或API：
logic: Get the method declaration from class.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9198675155639648
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752806425094604
*Check whether the body of method contains a try statement.* 匹配到的元操作或API：
query: Check whether the body of method contains a try statement.
most similar API: get body of try statement
cosine Similarity: 0.8438893556594849
*Get the try statement body.* 匹配到的元操作或API：
query: Get the try statement body.
most similar API: get body of try statement
cosine Similarity: 0.9669273495674133
*Check whether the try statement body is empty.* 匹配到的元操作或API：
query: Check whether the try statement body is empty.
most similar API: get body of try statement
cosine Similarity: 0.8382277488708496
*Get the finally clause of try statement.* 匹配到的元操作或API：
logic: Get the finally clause of try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9046209454536438
*Check whether the finally clause body is empty.* 匹配到的元操作或API：
query: Check whether the finally clause body is empty.
most similar API: get body of finally clause
cosine Similarity: 0.8640286326408386
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the method declaration from class.* 匹配到的元操作或API：
logic: Get the method declaration from class.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9198675155639648
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752806425094604
*Check whether the body of method contains a try statement.* 匹配到的元操作或API：
query: Check whether the body of method contains a try statement.
most similar API: get body of try statement
cosine Similarity: 0.8438893556594849
*Get the try statement body.* 匹配到的元操作或API：
query: Get the try statement body.
most similar API: get body of try statement
cosine Similarity: 0.9669273495674133
*Check whether the try statement body is empty.* 匹配到的元操作或API：
query: Check whether the try statement body is empty.
most similar API: get body of try statement
cosine Similarity: 0.8382277488708496
*Get the finally clause of try statement.* 匹配到的元操作或API：
logic: Get the finally clause of try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9046209454536438
*Check whether the finally clause body is empty.* 匹配到的元操作或API：
query: Check whether the finally clause body is empty.
most similar API: get body of finally clause
cosine Similarity: 0.8640286326408386
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
The test case corresponding to the rule:
```
// pos, empty try block
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock2')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTFinallyClause
            ——ASTBlock
              ——ASTLocalVariableDeclaration
                ——ASTModifierList
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTVariableDeclarator
                  ——ASTVariableDeclaratorId (declared variable name = 'x')
                  ——ASTNumericLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
5. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()
6. net.sourceforge.pmd.lang.java.ast.ASTFinallyClause: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this finally clause.

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileLoop.class, ASTForLoop.class, ASTDoWhileLoop.class, ASTInitializer.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock thenBlock = node.getFirstChildOfType(ASTBlock.class);
        if (thenBlock != null && thenBlock.getNumChildren() == 0) {
            addViolation(data, thenBlock);
        }
        ASTBlock elseBlock = node.getFirstDescendantOfType(ASTBlock.class, "elseBranch");
        if (elseBlock != null && elseBlock.getNumChildren() == 0) {
            addViolation(data, elseBlock);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileLoop node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForLoop node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoWhileLoop node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.getNumChildren() == 0) {
            addViolation(data, body);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.getParent() instanceof ASTBlock && node.getNumChildren() == 0) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    // Utility method to get method declaration from method call
    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method) {
        JMethodSymbol symbol = (JMethodSymbol) method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Check whether the body of try statement is empty.
2. Check whether the finally clause of try statement is empty.
3. Check whether the body of synchronized statement is empty.
4. Check whether the body of if statement is empty.
5. Check whether the body of while loop statement is empty.
6. Check whether the body of for loop statement is empty.
7. Check whether the body of do-while loop statement is empty.
8. Check whether the body of switch statement is empty.
9. Check whether the body of initializer block is empty.
10. Check whether the body of block used as statement is empty.

In this test case:
1. Check whether the body of try statement is empty.
    - The body of the try statement is indeed empty, so this violates the rule.
2. Check whether the finally clause of try statement is empty.
    - The finally clause contains an assignment (`int x = 5;`), so it does not violate the rule.
3. Check whether the body of synchronized statement is empty.
    - There is no synchronized statement in the test case.
4. Check whether the body of if statement is empty.
    - There is no if statement in the test case.
5. Check whether the body of while loop statement is empty.
    - There is no while loop statement in the test case.
6. Check whether the body of for loop statement is empty.
    - There is no for loop statement in the test case.
7. Check whether the body of do-while loop statement is empty.
    - There is no do-while loop statement in the test case.
8. Check whether the body of switch statement is empty.
    - There is no switch statement in the test case.
9. Check whether the body of initializer block is empty.
    - There is no initializer block in the test case.
10. Check whether the body of block used as statement is empty.
    - There is no block used as a statement in the test case.

The number of violating the rule in this test case is: 1 (due to the empty try block).
['Check whether the body of try statement is empty.', 'Check whether the finally clause of try statement is empty.', 'Check whether the body of synchronized statement is empty.', 'Check whether the body of if statement is empty.', 'Check whether the body of while loop statement is empty.', 'Check whether the body of for loop statement is empty.', 'Check whether the body of do-while loop statement is empty.', 'Check whether the body of switch statement is empty.', 'Check whether the body of initializer block is empty.', 'Check whether the body of block used as statement is empty.', 'Check whether the body of try statement is empty.', 'Check whether the finally clause of try statement is empty.', 'Check whether the body of synchronized statement is empty.', 'Check whether the body of if statement is empty.', 'Check whether the body of while loop statement is empty.', 'Check whether the body of for loop statement is empty.', 'Check whether the body of do-while loop statement is empty.', 'Check whether the body of switch statement is empty.', 'Check whether the body of initializer block is empty.', 'Check whether the body of block used as statement is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'ASTTryStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTFinallyClause', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Check whether the body of try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8571391105651855
*Check whether the finally clause of try statement is empty.* 匹配到的元操作或API：
query: Check whether the finally clause of try statement is empty.
most similar API: get finally clause of try statement
cosine Similarity: 0.8805499076843262
*Check whether the body of synchronized statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8571328520774841
*Check whether the body of while loop statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of for loop statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of do-while loop statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of switch statement is empty.* 匹配到的元操作或API：
query: Check whether the body of switch statement is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8093868494033813
*Check whether the body of initializer block is empty.* 匹配到的元操作或API：
query: Check whether the body of initializer block is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8572171926498413
*Check whether the body of block used as statement is empty.* 匹配到的元操作或API：
query: Check whether the body of block used as statement is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.9012241363525391
*Check whether the body of try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8571391105651855
*Check whether the finally clause of try statement is empty.* 匹配到的元操作或API：
query: Check whether the finally clause of try statement is empty.
most similar API: get finally clause of try statement
cosine Similarity: 0.8805499076843262
*Check whether the body of synchronized statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8571328520774841
*Check whether the body of while loop statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of for loop statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of do-while loop statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of switch statement is empty.* 匹配到的元操作或API：
query: Check whether the body of switch statement is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8093868494033813
*Check whether the body of initializer block is empty.* 匹配到的元操作或API：
query: Check whether the body of initializer block is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8572171926498413
*Check whether the body of block used as statement is empty.* 匹配到的元操作或API：
query: Check whether the body of block used as statement is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.9012241363525391
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
The test case corresponding to the rule:
```
// pos, empty try block
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock2')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTFinallyClause
            ——ASTBlock
              ——ASTLocalVariableDeclaration
                ——ASTModifierList
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTVariableDeclarator
                  ——ASTVariableDeclaratorId (declared variable name = 'x')
                  ——ASTNumericLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause(), //Returns the {@code finally} clause of this try statement, if any. @return The finally statement, or null if there is none
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()
5. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTWhileStatement.class, ASTForStatement.class, ASTDoStatement.class, ASTBlock.class, ASTClassOrInterfaceBody.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        if (node.getBody() != null && node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBlock().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        if (node.getBlock().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        if (node.getBlock().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        if (node.getBlock().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock block = node.getFirstChildOfType(ASTBlock.class);
        if (block != null && block.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        if (node.getBlock().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        if (node.getBlock().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        if (node.getBlock().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTMethodDeclaration) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        if (node.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.getBody().isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the body of try statement.
2. Check whether the try body is empty.
3. Get the finally branch of try statement.
4. Check whether the finally branch is empty.
5. Get the body of finally branch.
6. Check whether the finally branch body is empty.

In this test case:
1. Get the body of try statement: The try block is `{}`.
2. Check whether the try body is empty: This check will return true because the try block is empty.
3. Get the finally branch of try statement: The finally block is `} finally { int x = 5; }`.
4. Check whether the finally branch is empty: This check will return false because the finally block contains code.
5. Get the body of finally branch: The body of the finally branch is `int x = 5;`.
6. Check whether the finally branch body is empty: This check will return false because the finally branch body contains the declaration and initialization of `x`.

The number of violating the rule in this test case is: 1 (only the try block is empty, not the finally block).
['Get the body of try statement.', 'Check whether the try body is empty.', 'Get the finally branch of try statement.', 'Check whether the finally branch is empty.', 'Get the body of finally branch.', 'Check whether the finally branch body is empty.', 'Get the body of try statement: The try block is `{}`.', 'Check whether the try body is empty: This check will return true because the try block is empty.', 'Get the finally branch of try statement: The finally block is `} finally { int x = 5; }`.', 'Check whether the finally branch is empty: This check will return false because the finally block contains code.', 'Get the body of finally branch: The body of the finally branch is `int x = 5;`.', 'Check whether the finally branch body is empty: This check will return false because the finally branch body contains the declaration and initialization of `x`.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'ASTTryStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTFinallyClause', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the body of try statement.* 匹配到的元操作或API：
query: Get the body of try statement.
most similar API: get body of try statement
cosine Similarity: 0.9849936962127686
*Check whether the try body is empty.* 匹配到的元操作或API：
query: Check whether the try body is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8291358351707458
*Get the finally branch of try statement.* 匹配到的元操作或API：
logic: Get the finally branch of try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9912986755371094
*Check whether the finally branch is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of finally branch.* 匹配到的元操作或API：
query: Get the body of finally branch.
most similar API: get body of finally clause: Returns the body of this finally clause.
cosine Similarity: 0.8325282335281372
*Check whether the finally branch body is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of try statement: The try block is `{}`.* 匹配到的元操作或API：
query: Get the body of try statement: The try block is `{}`.
most similar API: get body of try statement: Returns the body of this try statement.
cosine Similarity: 0.917291522026062
*Check whether the try body is empty: This check will return true because the try block is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the finally branch of try statement: The finally block is `} finally { int x = 5; }`.* 匹配到的元操作或API：
logic: Get the finally branch of try statement: The finally block is `} finally { int x = 5; }`.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9047207832336426
*Check whether the finally branch is empty: This check will return false because the finally block contains code.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of finally branch: The body of the finally branch is `int x = 5;`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the finally branch body is empty: This check will return false because the finally branch body contains the declaration and initialization of `x`.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
The test case corresponding to the rule:
```
// pos, empty try block
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock2')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTFinallyClause
            ——ASTBlock
              ——ASTLocalVariableDeclaration
                ——ASTModifierList
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTVariableDeclarator
                  ——ASTVariableDeclaratorId (declared variable name = 'x')
                  ——ASTNumericLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class EmptyControlStatementRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()
4. net.sourceforge.pmd.lang.java.ast.ASTFinallyClause: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this finally clause.



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
True
此测试用例生成了first checker: bad 2


======================接下来开始迭代=====================
[ERROR]   "ok 2" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
96
80
109
93
82
68
106
91
94
78
106
91
=========================error_testcase_logics=========================
1. Get the control statement from the method.
2. Check whether the control statement is a try statement.
3. Check whether the try statement has an empty body.
4. Check whether the try statement has a finally clause.
5. Check whether the finally clause has an empty body.
6. Check whether the control statement is a switch statement.
7. Check whether the switch statement has an empty body.
8. Check whether the control statement is a synchronized statement.
9. Check whether the synchronized statement has an empty body.
10. Check whether the control statement is an if statement.
11. Check whether the if statement has an empty body.
12. Check whether the if statement has an else branch.
13. Check whether the else branch of if statement has an empty body.
14. Check whether the control statement is a loop statement.
15. Check whether the loop statement is a while loop.
16. Check whether the while loop has an empty body.
17. Check whether the loop statement is a for loop.
18. Check whether the for loop has an empty body.
19. Check whether the loop statement is a do-while loop.
20. Check whether the do-while loop has an empty body.
21. Check whether the control statement is an initializer or block.
22. Check whether the initializer or block has an empty body.

For the given test case:
1. Get the control statement from the method. -> The control statement is a try-with-resources statement.
2. Check whether the control statement is a try statement. -> It is a try statement.
3. Check whether the try statement has an empty body. -> The body is indeed empty.
4. Check whether the try statement has a finally clause. -> There is no finally clause.
5. Check whether the switch statement has an empty body. -> There is no switch statement.
6. Check whether the synchronized statement has an empty body. -> There is no synchronized statement.
7. Check whether the if statement has an empty body. -> There is no if statement.
8. Check whether the loop statement is a while loop. -> There is no while loop.
9. Check whether the loop statement is a for loop. -> There is no for loop.
10. Check whether the loop statement is a do-while loop. -> There is no do-while loop.
11. Check whether the control statement is an initializer or block. -> There is no initializer or block used as a statement.

The test case has one control statement (try-with-resources) with an empty body. According to the rule description, this would be a violation. However, the rule specifies that empty try-with-resources blocks are acceptable if the variable is unused, which is indicated by the comment and the name "ignored" of the variable. Therefore, the test case does not violate the rule as per the provided description and context.

The number of violating the rule in this test case is: 0
['Get the control statement from the method.', 'Check whether the control statement is a try statement.', 'Check whether the try statement has an empty body.', 'Check whether the try statement has a finally clause.', 'Check whether the finally clause has an empty body.', 'Check whether the control statement is a switch statement.', 'Check whether the switch statement has an empty body.', 'Check whether the control statement is a synchronized statement.', 'Check whether the synchronized statement has an empty body.', 'Check whether the control statement is an if statement.', 'Check whether the if statement has an empty body.', 'Check whether the if statement has an else branch.', 'Check whether the else branch of if statement has an empty body.', 'Check whether the control statement is a loop statement.', 'Check whether the loop statement is a while loop.', 'Check whether the while loop has an empty body.', 'Check whether the loop statement is a for loop.', 'Check whether the for loop has an empty body.', 'Check whether the loop statement is a do-while loop.', 'Check whether the do-while loop has an empty body.', 'Check whether the control statement is an initializer or block.', 'Check whether the initializer or block has an empty body.', 'Get the control statement from the method. -> The control statement is a try-with-resources statement.', 'Check whether the control statement is a try statement. -> It is a try statement.', 'Check whether the try statement has an empty body. -> The body is indeed empty.', 'Check whether the try statement has a finally clause. -> There is no finally clause.', 'Check whether the switch statement has an empty body. -> There is no switch statement.', 'Check whether the synchronized statement has an empty body. -> There is no synchronized statement.', 'Check whether the if statement has an empty body. -> There is no if statement.', 'Check whether the loop statement is a while loop. -> There is no while loop.', 'Check whether the loop statement is a for loop. -> There is no for loop.', 'Check whether the loop statement is a do-while loop. -> There is no do-while loop.', 'Check whether the control statement is an initializer or block. -> There is no initializer or block used as a statement.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTResourceList', 'ASTAmbiguousName', 'ASTVariableAccess', 'ASTResource', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTLambdaExpression', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTTryStatement', 'TokenUtils', 'ASTLambdaParameterList', 'ASTClassOrInterfaceDeclaration', 'ASTConstructorCall', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the control statement from the method.* 匹配到的元操作或API：
query: Get the control statement from the method.
most similar API: get text of method call
cosine Similarity: 0.8094965815544128
*Check whether the control statement is a try statement.* 匹配到的元操作或API：
query: Check whether the control statement is a try statement.
most similar API: Check whether the try statement equals
cosine Similarity: 0.8672431111335754
*Check whether the try statement has an empty body.* 匹配到的元操作或API：
query: Check whether the try statement has an empty body.
most similar API: get body of try statement
cosine Similarity: 0.837001383304596
*Check whether the try statement has a finally clause.* 匹配到的元操作或API：
query: Check whether the try statement has a finally clause.
most similar API: get finally clause of try statement
cosine Similarity: 0.9059702157974243
*Check whether the finally clause has an empty body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is a switch statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the switch statement has an empty body.* 匹配到的元操作或API：
query: Check whether the switch statement has an empty body.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8109264373779297
*Check whether the control statement is a synchronized statement.* 匹配到的元操作或API：
query: Check whether the control statement is a synchronized statement.
most similar API: Check whether the method is synchronized
cosine Similarity: 0.8282577991485596
*Check whether the synchronized statement has an empty body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is an if statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the if statement has an empty body.* 匹配到的元操作或API：
query: Check whether the if statement has an empty body.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8336375951766968
*Check whether the if statement has an else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9772751331329346
*Check whether the else branch of if statement has an empty body.* 匹配到的元操作或API：
logic: Check whether the else branch of if statement has an empty body.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.8812769651412964
*Check whether the control statement is a loop statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the loop statement is a while loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the while loop has an empty body.* 匹配到的元操作或API：
query: Check whether the while loop has an empty body.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8069109916687012
*Check whether the loop statement is a for loop.* 匹配到的元操作或API：
query: Check whether the loop statement is a for loop.
most similar API: Check whether the variable declarator id is for loop variable
cosine Similarity: 0.8139293789863586
*Check whether the for loop has an empty body.* 匹配到的元操作或API：
query: Check whether the for loop has an empty body.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8127671480178833
*Check whether the loop statement is a do-while loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the do-while loop has an empty body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is an initializer or block.* 匹配到的元操作或API：
query: Check whether the control statement is an initializer or block.
most similar API: Check whether the variable declarator has initializer
cosine Similarity: 0.8089017271995544
*Check whether the initializer or block has an empty body.* 匹配到的元操作或API：
query: Check whether the initializer or block has an empty body.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8580710887908936
*Get the control statement from the method. -> The control statement is a try-with-resources statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is a try statement. -> It is a try statement.* 匹配到的元操作或API：
query: Check whether the control statement is a try statement. -> It is a try statement.
most similar API: Check whether the try statement equals
cosine Similarity: 0.8494153618812561
*Check whether the try statement has an empty body. -> The body is indeed empty.* 匹配到的元操作或API：
query: Check whether the try statement has an empty body. -> The body is indeed empty.
most similar API: get body of try statement
cosine Similarity: 0.8279385566711426
*Check whether the try statement has a finally clause. -> There is no finally clause.* 匹配到的元操作或API：
query: Check whether the try statement has a finally clause. -> There is no finally clause.
most similar API: get finally clause of try statement
cosine Similarity: 0.8683903217315674
*Check whether the switch statement has an empty body. -> There is no switch statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the synchronized statement has an empty body. -> There is no synchronized statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the if statement has an empty body. -> There is no if statement.* 匹配到的元操作或API：
query: Check whether the if statement has an empty body. -> There is no if statement.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8066921234130859
*Check whether the loop statement is a while loop. -> There is no while loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the loop statement is a for loop. -> There is no for loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the loop statement is a do-while loop. -> There is no do-while loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is an initializer or block. -> There is no initializer or block used as a statement.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }


This checker is failed(false positive) on this positive test case:
```
// #432 empty try-with-resource - ok with unused var name
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'X')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'method')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTResourceList
            ——ASTResource
              ——ASTLocalVariableDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTVariableDeclarator
                  ——ASTVariableDeclaratorId (declared variable name = 'ignored')
                  ——ASTMethodCall (called method name = 'execute')
                    ——ASTArgumentList (size = 3)
                      ——ASTLambdaExpression
                        ——ASTLambdaParameterList
                        ——ASTMethodCall (called method name = 'delete')
                          ——ASTMethodCall (called method name = 'request')
                            ——ASTAmbiguousName (this is a primitive type)
                            ——ASTArgumentList (size = 1)
                              ——ASTVariableAccess (referenced variable name = 'mediaTypes')
                          ——ASTArgumentList (size = 0)
                      ——ASTVariableAccess (referenced variable name = 'DELETE')
                      ——ASTConstructorCall
                        ——ASTClassOrInterfaceType (this is a class type)
                        ——ASTArgumentList (size = 2)
                          ——ASTVariableAccess (referenced variable name = 'status')
                          ——ASTVariableAccess (referenced variable name = 'required')
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.document.Chars getText()
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause(), //Returns the {@code finally} clause of this try statement, if any. @return The finally statement, or null if there is none
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isSynchronized()
7. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
8. net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId: public boolean isForLoopVariable(), //Returns true if this node is a variable declared in the init clause of a {@linkplain ASTForStatement for loop}.
9. net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator: public boolean hasInitializer(), //Returns true if the declared variable is initialized. Otherwise, {@link #getInitializer()} returns null.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && node.getResourceList() == null) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the signature of the called method.
2. Check whether the called method is execute.
3. Get the method caller.
4. Check whether the method caller is the current class instance.
5. Get the loop variable of the try-with-resources statement.
6. Check whether the loop variable is ignored.
7. Get the body of the try-with-resources statement.
8. Check whether the body of the try-with-resources statement is empty.
9. Get the finally branch of the try statement.
10. Check whether the finally branch is present.
11. If the finally branch is present, check whether the body of the finally branch is empty.

In this specific test case:

- The try-with-resources statement is being checked.
- The body of the try-with-resources statement is indeed empty.
- There is no finally block present, so no additional checks for an empty finally block are needed.

Since the body of the try-with-resources statement is empty, this test case does violate the rule as described. However, based on the comment indicating that it is "ok with unused var name," it seems the rule checker might have a special exception for such cases. Therefore, the number of violations reported by the rule checker is 0, which aligns with the provided comment.

If the rule checker does not have such an exception, then the number of violations would be 1. But given the comment, we assume the rule checker handles this case as an exception, resulting in 0 violations.
['Get the signature of the called method.', 'Check whether the called method is execute.', 'Get the method caller.', 'Check whether the method caller is the current class instance.', 'Get the loop variable of the try-with-resources statement.', 'Check whether the loop variable is ignored.', 'Get the body of the try-with-resources statement.', 'Check whether the body of the try-with-resources statement is empty.', 'Get the finally branch of the try statement.', 'Check whether the finally branch is present.', 'If the finally branch is present, check whether the body of the finally branch is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTResourceList', 'ASTAmbiguousName', 'ASTVariableAccess', 'ASTResource', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTLambdaExpression', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTTryStatement', 'TokenUtils', 'ASTLambdaParameterList', 'ASTClassOrInterfaceDeclaration', 'ASTConstructorCall', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the signature of the called method.* 匹配到的元操作或API：
logic: Get the signature of the called method.
most similar meta operation: Get the signature of the called method
cosine Similarity: 0.9828987717628479
*Check whether the called method is execute.* 匹配到的元操作或API：
query: Check whether the called method is execute.
most similar API: Check whether the method call equals
cosine Similarity: 0.8553768992424011
*Get the method caller.* 匹配到的元操作或API：
logic: Get the method caller.
most similar meta operation: Get the method caller
cosine Similarity: 0.9796932339668274
*Check whether the method caller is the current class instance.* 匹配到的元操作或API：
query: Check whether the method caller is the current class instance.
most similar API: Check whether is call on this instance
cosine Similarity: 0.857650101184845
*Get the loop variable of the try-with-resources statement.* 匹配到的元操作或API：
query: Get the loop variable of the try-with-resources statement.
most similar API: get resources of try statement
cosine Similarity: 0.8351951837539673
*Check whether the loop variable is ignored.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the try-with-resources statement.* 匹配到的元操作或API：
query: Get the body of the try-with-resources statement.
most similar API: get resources of try statement
cosine Similarity: 0.8845175504684448
*Check whether the body of the try-with-resources statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the try-with-resources statement is empty.
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.863269567489624
*Get the finally branch of the try statement.* 匹配到的元操作或API：
logic: Get the finally branch of the try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9862933158874512
*Check whether the finally branch is present.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the finally branch is present, check whether the body of the finally branch is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }


This checker is failed(false positive) on this positive test case:
```
// #432 empty try-with-resource - ok with unused var name
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'X')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'method')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTResourceList
            ——ASTResource
              ——ASTLocalVariableDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTVariableDeclarator
                  ——ASTVariableDeclaratorId (declared variable name = 'ignored')
                  ——ASTMethodCall (called method name = 'execute')
                    ——ASTArgumentList (size = 3)
                      ——ASTLambdaExpression
                        ——ASTLambdaParameterList
                        ——ASTMethodCall (called method name = 'delete')
                          ——ASTMethodCall (called method name = 'request')
                            ——ASTAmbiguousName (this is a primitive type)
                            ——ASTArgumentList (size = 1)
                              ——ASTVariableAccess (referenced variable name = 'mediaTypes')
                          ——ASTArgumentList (size = 0)
                      ——ASTVariableAccess (referenced variable name = 'DELETE')
                      ——ASTConstructorCall
                        ——ASTClassOrInterfaceType (this is a class type)
                        ——ASTArgumentList (size = 2)
                          ——ASTVariableAccess (referenced variable name = 'status')
                          ——ASTVariableAccess (referenced variable name = 'required')
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.types.JMethodSig getMethodType()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()
4. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isCallOnThisInstance(net.sourceforge.pmd.lang.java.ast.ASTMethodCall)
5. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTResourceList getResources(), //Returns the node for the resource list. This is null if this is not a try-with-resources.
6. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean isTryWithResources(), //Returns true if this node is a try-with-resources, in which case it has a ResourceSpecification child node.
7. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the finally branch of try statement.
2. Check whether the finally branch is empty.
If the finally branch of the try statement is empty, then this test case violates the rule.
['Get the finally branch of try statement.', 'Check whether the finally branch is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'ASTTryStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTFinallyClause', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the finally branch of try statement.* 匹配到的元操作或API：
logic: Get the finally branch of try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9912986755371094
*Check whether the finally branch is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty finally block
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                        int x = 0;
                    } finally { // warn
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock2')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'x')
                ——ASTNumericLiteral
          ——ASTFinallyClause
            ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the name of the class.
2. Get the method declaration of `foo`.
3. Get the try statement inside the `foo` method.
4. Get the finally branch of the try statement.
5. Check whether the finally branch is empty.

The checks lead to the conclusion that the finally branch of the try statement is empty, which violates the rule. Therefore, the number of violating the rule in this test case is 1.
['Get the name of the class.', 'Get the method declaration of `foo`.', 'Get the try statement inside the `foo` method.', 'Get the finally branch of the try statement.', 'Check whether the finally branch is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'ASTTryStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTFinallyClause', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of the class.* 匹配到的元操作或API：
logic: Get the name of the class.
most similar meta operation: Get the name of class
cosine Similarity: 0.968898594379425
*Get the method declaration of `foo`.* 匹配到的元操作或API：
logic: Get the method declaration of `foo`.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.8812096118927002
*Get the try statement inside the `foo` method.* 匹配到的元操作或API：
query: Get the try statement inside the `foo` method.
most similar API: get text of try statement
cosine Similarity: 0.853478193283081
*Get the finally branch of the try statement.* 匹配到的元操作或API：
logic: Get the finally branch of the try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9862933158874512
*Check whether the finally branch is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty finally block
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                        int x = 0;
                    } finally { // warn
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock2')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'x')
                ——ASTNumericLiteral
          ——ASTFinallyClause
            ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.document.Chars getText()
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTFinallyClause) {
            addViolation(data, node.getParent());
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <3>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <3>不通过
=========================error_testcase_logics=========================
1. Check whether the class is an interface.
2. Check whether the class has declared annotations.
3. Get the name of the package where the class is located.
4. Get the name of class.
5. Check whether the class is public.
6. Get the number of methods declared in class.
7. Get the name of method.
8. Check whether the method is public.
9. Get the signature of method.
10. Check whether the method signature throws any Exception.
11. Check whether the method has declared annotations.
12. Get the body of method.
13. Get all statements in method body.
14. Check whether the statement is a try statement.
15. Get the finally branch of try statement.
16. Check whether the finally branch is empty.

In this test case, the finally block of the try statement is empty, so it violates the rule. The number of violating the rule in this test case is: 1.
['Check whether the class is an interface.', 'Check whether the class has declared annotations.', 'Get the name of the package where the class is located.', 'Get the name of class.', 'Check whether the class is public.', 'Get the number of methods declared in class.', 'Get the name of method.', 'Check whether the method is public.', 'Get the signature of method.', 'Check whether the method signature throws any Exception.', 'Check whether the method has declared annotations.', 'Get the body of method.', 'Get all statements in method body.', 'Check whether the statement is a try statement.', 'Get the finally branch of try statement.', 'Check whether the finally branch is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'ASTTryStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTFinallyClause', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Check whether the class is an interface.* 匹配到的元操作或API：
logic: Check whether the class is an interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9778784513473511
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get the number of methods declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is public.* 匹配到的元操作或API：
logic: Check whether the method is public.
most similar meta operation: Check whether the method is public
cosine Similarity: 0.982057511806488
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Check whether the method signature throws any Exception.* 匹配到的元操作或API：
logic: Check whether the method signature throws any Exception.
most similar meta operation: Check whether the method signature throws x Exception
cosine Similarity: 0.9251599907875061
*Check whether the method has declared annotations.* 匹配到的元操作或API：
logic: Check whether the method has declared annotations.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9820230007171631
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752806425094604
*Get all statements in method body.* 匹配到的元操作或API：
query: Get all statements in method body.
most similar API: get body of method
cosine Similarity: 0.809191107749939
*Check whether the statement is a try statement.* 匹配到的元操作或API：
query: Check whether the statement is a try statement.
most similar API: Check whether the try statement equals
cosine Similarity: 0.9079428911209106
*Get the finally branch of try statement.* 匹配到的元操作或API：
logic: Get the finally branch of try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9912986755371094
*Check whether the finally branch is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty finally block
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                        int x = 0;
                    } finally { // warn
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock2')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'x')
                ——ASTNumericLiteral
          ——ASTFinallyClause
            ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPublic()
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
8. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
9. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean equals(java.lang.Object)
10. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether the method signature throws x Exception
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean throwsSpecificException(ASTMethodDeclaration node){
    ASTThrowsList list = node.getThrowsList();
    if(list == null){
        return false;
    }else{
        for(ASTClassOrInterfaceType classOrInterfaceType : list){
            if(TypeTestUtil.isA(x.class, classOrInterfaceType)){
                return true;
            }
        }
    }
    return false;
}
```
3.  //Check whether method has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTMethodDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTTryStatement) {
            ASTFinallyClause finallyClause = ((ASTTryStatement) node.getParent()).getFinallyClause();
            if (finallyClause != null && finallyClause.getBody() == node) {
                addViolation(data, finallyClause);
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Check whether the class is an interface.
2. Check whether the class has declared annotations.
3. Get the name of class.
4. Get the name of the method.
5. Check whether the method has declared annotations.
6. Get the signature of method.
7. Get the javadoc comment of method.
8. Check whether the method is abstract.
9. Check whether the method is private.
10. Check whether the method is public.
11. Check whether the method is default package-private.
12. Check whether the method is protected.
13. Check whether the method is main method.
14. Get the number of formal parameters of method.
15. Check whether the method has a try block.
16. Get the finally block of the try statement.
17. Check whether the finally block is empty.

If the finally block is empty, then this test case violates the rule. The number of violations in this test case is: 1.
['Check whether the class is an interface.', 'Check whether the class has declared annotations.', 'Get the name of class.', 'Get the name of the method.', 'Check whether the method has declared annotations.', 'Get the signature of method.', 'Get the javadoc comment of method.', 'Check whether the method is abstract.', 'Check whether the method is private.', 'Check whether the method is public.', 'Check whether the method is default package-private.', 'Check whether the method is protected.', 'Check whether the method is main method.', 'Get the number of formal parameters of method.', 'Check whether the method has a try block.', 'Get the finally block of the try statement.', 'Check whether the finally block is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'ASTTryStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTFinallyClause', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Check whether the class is an interface.* 匹配到的元操作或API：
logic: Check whether the class is an interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9778784513473511
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of the method.* 匹配到的元操作或API：
logic: Get the name of the method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9713990092277527
*Check whether the method has declared annotations.* 匹配到的元操作或API：
logic: Check whether the method has declared annotations.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9820230007171631
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Get the javadoc comment of method.* 匹配到的元操作或API：
logic: Get the javadoc comment of method.
most similar meta operation: Get the javadoc comment of method
cosine Similarity: 0.9902204871177673
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Check whether the method is private.* 匹配到的元操作或API：
logic: Check whether the method is private.
most similar meta operation: Check whether the method is private
cosine Similarity: 0.9821236729621887
*Check whether the method is public.* 匹配到的元操作或API：
logic: Check whether the method is public.
most similar meta operation: Check whether the method is public
cosine Similarity: 0.982057511806488
*Check whether the method is default package-private.* 匹配到的元操作或API：
logic: Check whether the method is default package-private.
most similar meta operation: Check whether the method is default package-private
cosine Similarity: 0.972201406955719
*Check whether the method is protected.* 匹配到的元操作或API：
logic: Check whether the method is protected.
most similar meta operation: Check whether the method is protected
cosine Similarity: 0.9815421104431152
*Check whether the method is main method.* 匹配到的元操作或API：
logic: Check whether the method is main method.
most similar meta operation: Check whether the method is main method
cosine Similarity: 0.9875174760818481
*Get the number of formal parameters of method.* 匹配到的元操作或API：
logic: Get the number of formal parameters of method.
most similar meta operation: Get the number of formal parameters of method
cosine Similarity: 0.9860840439796448
*Check whether the method has a try block.* 匹配到的元操作或API：
query: Check whether the method has a try block.
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.8399059176445007
*Get the finally block of the try statement.* 匹配到的元操作或API：
logic: Get the finally block of the try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.913399338722229
*Check whether the finally block is empty.* 匹配到的元操作或API：
query: Check whether the finally block is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8699493408203125
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty finally block
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                        int x = 0;
                    } finally { // warn
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock2')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'x')
                ——ASTNumericLiteral
          ——ASTFinallyClause
            ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPrivate()
8. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPublic()
9. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPackagePrivate()
10. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isProtected()
11. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isMainMethod()
12. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean isTryWithResources(), //Returns true if this node is a try-with-resources, in which case it has a ResourceSpecification child node.
13. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()
14. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether method has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTMethodDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```
3.  //Get the number of formal parameters of method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTMethodDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the method declaration from method call.
2. Get the name of method.
3. Check whether the method name is foo.
4. Get the body of method foo.
5. Check whether the method body contains a try statement.
6. Get the finally branch of the try statement.
7. Check whether the finally branch is empty.

If the finally branch of the try statement is empty, then this test case violates the rule.
['Get the method declaration from method call.', 'Get the name of method.', 'Check whether the method name is foo.', 'Get the body of method foo.', 'Check whether the method body contains a try statement.', 'Get the finally branch of the try statement.', 'Check whether the finally branch is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'ASTTryStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTFinallyClause', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the method declaration from method call.* 匹配到的元操作或API：
logic: Get the method declaration from method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9787436127662659
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name is foo.* 匹配到的元操作或API：
query: Check whether the method name is foo.
most similar API: Check whether the method equals
cosine Similarity: 0.8480663895606995
*Get the body of method foo.* 匹配到的元操作或API：
query: Get the body of method foo.
most similar API: get body of method
cosine Similarity: 0.9337466955184937
*Check whether the method body contains a try statement.* 匹配到的元操作或API：
query: Check whether the method body contains a try statement.
most similar API: get body of try statement
cosine Similarity: 0.8470122218132019
*Get the finally branch of the try statement.* 匹配到的元操作或API：
logic: Get the finally branch of the try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9862933158874512
*Check whether the finally branch is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty finally block
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                        int x = 0;
                    } finally { // warn
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock2')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'x')
                ——ASTNumericLiteral
          ——ASTFinallyClause
            ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
5. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 3
[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <2> but was: <3>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get the method declaration from class.
3. Check whether the method is foo.
4. Get the body of method.
5. Get all statements in the method body.
6. Get the first statement of the method body.
7. Check whether the statement is a try statement.
8. Get the try block of the try statement.
9. Check whether the try block is empty.
10. Get the finally branch of the try statement.
11. Check whether the finally branch is empty.
If the try block and the finally branch are both empty, then the number of violating the rule in this test case is 2.
['Get the name of class.', 'Get the method declaration from class.', 'Check whether the method is foo.', 'Get the body of method.', 'Get all statements in the method body.', 'Get the first statement of the method body.', 'Check whether the statement is a try statement.', 'Get the try block of the try statement.', 'Check whether the try block is empty.', 'Get the finally branch of the try statement.', 'Check whether the finally branch is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTTryStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTFinallyClause', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the method declaration from class.* 匹配到的元操作或API：
logic: Get the method declaration from class.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9198675155639648
*Check whether the method is foo.* 匹配到的元操作或API：
query: Check whether the method is foo.
most similar API: Check whether the method equals
cosine Similarity: 0.8826917409896851
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752806425094604
*Get all statements in the method body.* 匹配到的元操作或API：
query: Get all statements in the method body.
most similar API: get body of method
cosine Similarity: 0.802484393119812
*Get the first statement of the method body.* 匹配到的元操作或API：
query: Get the first statement of the method body.
most similar API: get body of method
cosine Similarity: 0.8377581238746643
*Check whether the statement is a try statement.* 匹配到的元操作或API：
query: Check whether the statement is a try statement.
most similar API: Check whether the try statement equals
cosine Similarity: 0.9079428911209106
*Get the try block of the try statement.* 匹配到的元操作或API：
query: Get the try block of the try statement.
most similar API: get body of try statement
cosine Similarity: 0.8504363894462585
*Check whether the try block is empty.* 匹配到的元操作或API：
query: Check whether the try block is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8674911260604858
*Get the finally branch of the try statement.* 匹配到的元操作或API：
logic: Get the finally branch of the try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9862933158874512
*Check whether the finally branch is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty try and finally block
public class EmptyTryBlock3 {
                public void foo() {
                    try {
                    } finally {
                    }
                }
            }
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock3')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTFinallyClause
            ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean equals(java.lang.Object)
5. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
6. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()
7. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTFinallyClause) {
            addViolation(data, node.getParent());
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <2> but was: <4>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <2> but was: <4>不通过
=========================error_testcase_logics=========================
1. Get the method declaration from method call.
        2. Get the body of the method.
        3. Get the try statement from the method body.
        4. Check whether the try statement has an empty body.
        5. Get the finally clause from the try statement.
        6. Check whether the finally clause has an empty body.

The number of violating the rule in this test case is: 2

Explanation of granular checks:
1. Get the method declaration from method call: This will get the declaration of `foo()` method.
2. Get the body of the method: This will retrieve the code block inside `foo()` method.
3. Get the try statement from the method body: This will identify the try statement inside the `foo()` method.
4. Check whether the try statement has an empty body: This will check if the body of the try statement is empty.
5. Get the finally clause from the try statement: This will retrieve the finally clause associated with the try statement.
6. Check whether the finally clause has an empty body: This will verify if the finally clause has an empty body.
If both the try statement body and the finally clause body are empty, the test case violates the rule twice.
['Get the method declaration from method call.', 'Get the body of the method.', 'Get the try statement from the method body.', 'Check whether the try statement has an empty body.', 'Get the finally clause from the try statement.', 'Check whether the finally clause has an empty body.', 'Get the method declaration from method call: This will get the declaration of `foo()` method.', 'Get the body of the method: This will retrieve the code block inside `foo()` method.', 'Get the try statement from the method body: This will identify the try statement inside the `foo()` method.', 'Check whether the try statement has an empty body: This will check if the body of the try statement is empty.', 'Get the finally clause from the try statement: This will retrieve the finally clause associated with the try statement.', 'Check whether the finally clause has an empty body: This will verify if the finally clause has an empty body.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTTryStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTFinallyClause', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the method declaration from method call.* 匹配到的元操作或API：
logic: Get the method declaration from method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9787436127662659
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Get the try statement from the method body.* 匹配到的元操作或API：
query: Get the try statement from the method body.
most similar API: get body of try statement
cosine Similarity: 0.9219610691070557
*Check whether the try statement has an empty body.* 匹配到的元操作或API：
query: Check whether the try statement has an empty body.
most similar API: get body of try statement
cosine Similarity: 0.837001383304596
*Get the finally clause from the try statement.* 匹配到的元操作或API：
logic: Get the finally clause from the try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.8984776139259338
*Check whether the finally clause has an empty body.* 匹配到的元操作或API：
query: Check whether the finally clause has an empty body.
most similar API: get body of finally clause
cosine Similarity: 0.8634058833122253
*Get the method declaration from method call: This will get the declaration of `foo()` method.* 匹配到的元操作或API：
logic: Get the method declaration from method call: This will get the declaration of `foo()` method.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9232783913612366
*Get the body of the method: This will retrieve the code block inside `foo()` method.* 匹配到的元操作或API：
query: Get the body of the method: This will retrieve the code block inside `foo()` method.
most similar API: get body of method
cosine Similarity: 0.8863427639007568
*Get the try statement from the method body: This will identify the try statement inside the `foo()` method.* 匹配到的元操作或API：
query: Get the try statement from the method body: This will identify the try statement inside the `foo()` method.
most similar API: get body of try statement: Returns the body of this try statement.
cosine Similarity: 0.8995976448059082
*Check whether the try statement has an empty body: This will check if the body of the try statement is empty.* 匹配到的元操作或API：
query: Check whether the try statement has an empty body: This will check if the body of the try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8400214910507202
*Get the finally clause from the try statement: This will retrieve the finally clause associated with the try statement.* 匹配到的元操作或API：
logic: Get the finally clause from the try statement: This will retrieve the finally clause associated with the try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.8539103865623474
*Check whether the finally clause has an empty body: This will verify if the finally clause has an empty body.* 匹配到的元操作或API：
query: Check whether the finally clause has an empty body: This will verify if the finally clause has an empty body.
most similar API: get body of finally clause
cosine Similarity: 0.8577454686164856
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty try and finally block
public class EmptyTryBlock3 {
                public void foo() {
                    try {
                    } finally {
                    }
                }
            }
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock3')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTFinallyClause
            ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()
4. net.sourceforge.pmd.lang.java.ast.ASTFinallyClause: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this finally clause.

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTFinallyClause) {
            addViolation(data, node.getParent());
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <2> but was: <4>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <2> but was: <4>不通过
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method is main method.
3. Get all statements in method body.
4. Check whether statement is a try statement.
5. Get the try block of try statement.
6. Check whether the try block is empty.
7. Get the finally block of try statement.
8. Check whether the finally block is empty.

Based on these checks, the test case violates the rule twice:
- The try block is empty.
- The finally block is empty.
['Get the name of method.', 'Check whether the method is main method.', 'Get all statements in method body.', 'Check whether statement is a try statement.', 'Get the try block of try statement.', 'Check whether the try block is empty.', 'Get the finally block of try statement.', 'Check whether the finally block is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTTryStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTFinallyClause', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is main method.* 匹配到的元操作或API：
logic: Check whether the method is main method.
most similar meta operation: Check whether the method is main method
cosine Similarity: 0.9875174760818481
*Get all statements in method body.* 匹配到的元操作或API：
query: Get all statements in method body.
most similar API: get body of method
cosine Similarity: 0.809191107749939
*Check whether statement is a try statement.* 匹配到的元操作或API：
query: Check whether statement is a try statement.
most similar API: Check whether the try statement equals
cosine Similarity: 0.91844642162323
*Get the try block of try statement.* 匹配到的元操作或API：
logic: Get the try block of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.856391966342926
*Check whether the try block is empty.* 匹配到的元操作或API：
query: Check whether the try block is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8674911260604858
*Get the finally block of try statement.* 匹配到的元操作或API：
logic: Get the finally block of try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9193657040596008
*Check whether the finally block is empty.* 匹配到的元操作或API：
query: Check whether the finally block is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8699493408203125
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty try and finally block
public class EmptyTryBlock3 {
                public void foo() {
                    try {
                    } finally {
                    }
                }
            }
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock3')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTFinallyClause
            ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isMainMethod()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean equals(java.lang.Object)
5. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
6. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()
7. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTFinallyClause) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <2> but was: <4>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <2> but was: <4>不通过
=========================error_testcase_logics=========================
1. Get the method declaration from method call.
        2. Get the method body of the method.
        3. Get all try statements in the method body.
        4. Get the try block body of the first try statement.
        5. Check whether the try block body is empty.
        6. Get the finally block body of the first try statement.
        7. Check whether the finally block body is empty.

The checks will identify the empty try and finally blocks in the `foo` method of the `EmptyTryBlock3` class, confirming that the number of violations is 2.
['Get the method declaration from method call.', 'Get the method body of the method.', 'Get all try statements in the method body.', 'Get the try block body of the first try statement.', 'Check whether the try block body is empty.', 'Get the finally block body of the first try statement.', 'Check whether the finally block body is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTTryStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTFinallyClause', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the method declaration from method call.* 匹配到的元操作或API：
logic: Get the method declaration from method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9787436127662659
*Get the method body of the method.* 匹配到的元操作或API：
query: Get the method body of the method.
most similar API: get body of method
cosine Similarity: 0.9668439030647278
*Get all try statements in the method body.* 匹配到的元操作或API：
query: Get all try statements in the method body.
most similar API: get body of try statement
cosine Similarity: 0.8588416576385498
*Get the try block body of the first try statement.* 匹配到的元操作或API：
query: Get the try block body of the first try statement.
most similar API: get body of try statement
cosine Similarity: 0.9029141068458557
*Check whether the try block body is empty.* 匹配到的元操作或API：
query: Check whether the try block body is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8459877967834473
*Get the finally block body of the first try statement.* 匹配到的元操作或API：
query: Get the finally block body of the first try statement.
most similar API: get body of try statement
cosine Similarity: 0.8508356809616089
*Check whether the finally block body is empty.* 匹配到的元操作或API：
query: Check whether the finally block body is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8513398170471191
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty try and finally block
public class EmptyTryBlock3 {
                public void foo() {
                    try {
                    } finally {
                    }
                }
            }
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock3')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTFinallyClause
            ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
3. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTTryStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTFinallyClause) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 2" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}, {'error_rules_info': '[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <2> but was: <5>'}, {'error_rules_info': '[ERROR]   "ok 2" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 2" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the body of the try statement.
2. Check whether the try statement body is empty.
3. Get the finally branch of the try statement.
4. Check whether the finally branch body is empty.
5. Check whether the method has any switch statements.
6. Check whether the method has any synchronized statements.
7. Check whether the method has any if statements.
8. Check whether the method has any while loop statements.
9. Check whether the method has any for loop statements.
10. Check whether the method has any do-while loop statements.
11. Check whether the method has any initializer blocks.

In this test case:
- The try statement body is empty (Check whether the try statement body is empty).
- The finally branch body is empty (Check whether the finally branch body is empty).

Therefore, the number of violations is 2.
['Get the body of the try statement.', 'Check whether the try statement body is empty.', 'Get the finally branch of the try statement.', 'Check whether the finally branch body is empty.', 'Check whether the method has any switch statements.', 'Check whether the method has any synchronized statements.', 'Check whether the method has any if statements.', 'Check whether the method has any while loop statements.', 'Check whether the method has any for loop statements.', 'Check whether the method has any do-while loop statements.', 'Check whether the method has any initializer blocks.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTTryStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTFinallyClause', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the body of the try statement.* 匹配到的元操作或API：
query: Get the body of the try statement.
most similar API: get body of try statement
cosine Similarity: 0.9787788391113281
*Check whether the try statement body is empty.* 匹配到的元操作或API：
query: Check whether the try statement body is empty.
most similar API: get body of try statement
cosine Similarity: 0.8382277488708496
*Get the finally branch of the try statement.* 匹配到的元操作或API：
logic: Get the finally branch of the try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9862933158874512
*Check whether the finally branch body is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method has any switch statements.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method has any synchronized statements.* 匹配到的元操作或API：
logic: Check whether the method has any synchronized statements.
most similar meta operation: Check whether the method is synchronized
cosine Similarity: 0.921629786491394
*Check whether the method has any if statements.* 匹配到的元操作或API：
query: Check whether the method has any if statements.
most similar API: Check whether the method equals
cosine Similarity: 0.8626116514205933
*Check whether the method has any while loop statements.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method has any for loop statements.* 匹配到的元操作或API：
query: Check whether the method has any for loop statements.
most similar API: Check whether the method equals
cosine Similarity: 0.8058323264122009
*Check whether the method has any do-while loop statements.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method has any initializer blocks.* 匹配到的元操作或API：
query: Check whether the method has any initializer blocks.
most similar API: Check whether is array initializer
cosine Similarity: 0.8194122314453125
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty try and finally block
public class EmptyTryBlock3 {
                public void foo() {
                    try {
                    } finally {
                    }
                }
            }
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'EmptyTryBlock3')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTFinallyClause
            ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isSynchronized()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean equals(java.lang.Object)
5. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isArrayInitializer(net.sourceforge.pmd.lang.java.ast.ASTExpression)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTFinallyClause) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <2> but was: <4>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <2> but was: <4>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 4
[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
96
80
109
93
82
68
106
91
94
78
106
91
=========================error_testcase_logics=========================
1. Get the body of try statement.
2. Check whether the body of try statement is empty.
3. Check whether the try statement is a try-with-resources statement.
4. Get the resources declared in try-with-resources statement.
5. Get the name of resource in try-with-resources statement.
6. Check whether the name of resource is "ignored".
If the body of the try statement is empty and the try statement is a try-with-resources statement and the resource name is not "ignored", then this test case violates the rule.

In this specific test case:

1. Get the body of try statement.
2. Check whether the body of try statement is empty. (Result: False, because there is a comment inside the body)
3. Check whether the try statement is a try-with-resources statement. (Result: True, as it includes a resource declaration)
4. Get the resources declared in try-with-resources statement. (Result: "ClientResponse response")
5. Get the name of resource in try-with-resources statement. (Result: "response")
6. Check whether the name of resource is "ignored". (Result: False, as the resource name is "response")

Since the body of the try statement is not empty due to the presence of a comment, it does not violate the rule. If there were no comments or any other code in the body, it would violate the rule.
['Get the body of try statement.', 'Check whether the body of try statement is empty.', 'Check whether the try statement is a try-with-resources statement.', 'Get the resources declared in try-with-resources statement.', 'Get the name of resource in try-with-resources statement.', 'Check whether the name of resource is "ignored".', 'Get the body of try statement.', 'Check whether the body of try statement is empty. (Result: False, because there is a comment inside the body)', 'Check whether the try statement is a try-with-resources statement. (Result: True, as it includes a resource declaration)', 'Get the resources declared in try-with-resources statement. (Result: "ClientResponse response")', 'Get the name of resource in try-with-resources statement. (Result: "response")', 'Check whether the name of resource is "ignored". (Result: False, as the resource name is "response")']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTResourceList', 'ASTAmbiguousName', 'ASTVariableAccess', 'ASTResource', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTLambdaExpression', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTTryStatement', 'TokenUtils', 'ASTLambdaParameterList', 'ASTClassOrInterfaceDeclaration', 'ASTConstructorCall', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the body of try statement.* 匹配到的元操作或API：
query: Get the body of try statement.
most similar API: get body of try statement
cosine Similarity: 0.9849936962127686
*Check whether the body of try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8571391105651855
*Check whether the try statement is a try-with-resources statement.* 匹配到的元操作或API：
query: Check whether the try statement is a try-with-resources statement.
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.9599140286445618
*Get the resources declared in try-with-resources statement.* 匹配到的元操作或API：
query: Get the resources declared in try-with-resources statement.
most similar API: get resources of try statement
cosine Similarity: 0.8955842852592468
*Get the name of resource in try-with-resources statement.* 匹配到的元操作或API：
query: Get the name of resource in try-with-resources statement.
most similar API: get resources of try statement
cosine Similarity: 0.8508659601211548
*Check whether the name of resource is "ignored".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of try statement.* 匹配到的元操作或API：
query: Get the body of try statement.
most similar API: get body of try statement
cosine Similarity: 0.9849936962127686
*Check whether the body of try statement is empty. (Result: False, because there is a comment inside the body)* 匹配到的元操作或API：
query: Check whether the body of try statement is empty. (Result: False, because there is a comment inside the body)
most similar API: get body of try statement
cosine Similarity: 0.8238735198974609
*Check whether the try statement is a try-with-resources statement. (Result: True, as it includes a resource declaration)* 匹配到的元操作或API：
query: Check whether the try statement is a try-with-resources statement. (Result: True, as it includes a resource declaration)
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.9343986511230469
*Get the resources declared in try-with-resources statement. (Result: "ClientResponse response")* 匹配到的元操作或API：
query: Get the resources declared in try-with-resources statement. (Result: "ClientResponse response")
most similar API: get resources of try statement
cosine Similarity: 0.872988224029541
*Get the name of resource in try-with-resources statement. (Result: "response")* 匹配到的元操作或API：
query: Get the name of resource in try-with-resources statement. (Result: "response")
most similar API: get resources of try statement
cosine Similarity: 0.849091649055481
*Check whether the name of resource is "ignored". (Result: False, as the resource name is "response")* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'X')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'method')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTResourceList
            ——ASTResource
              ——ASTLocalVariableDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTVariableDeclarator
                  ——ASTVariableDeclaratorId (declared variable name = 'response')
                  ——ASTMethodCall (called method name = 'execute')
                    ——ASTArgumentList (size = 3)
                      ——ASTLambdaExpression
                        ——ASTLambdaParameterList
                        ——ASTMethodCall (called method name = 'delete')
                          ——ASTMethodCall (called method name = 'request')
                            ——ASTAmbiguousName (this is a primitive type)
                            ——ASTArgumentList (size = 1)
                              ——ASTVariableAccess (referenced variable name = 'mediaTypes')
                          ——ASTArgumentList (size = 0)
                      ——ASTVariableAccess (referenced variable name = 'DELETE')
                      ——ASTConstructorCall
                        ——ASTClassOrInterfaceType (this is a class type)
                        ——ASTArgumentList (size = 2)
                          ——ASTVariableAccess (referenced variable name = 'status')
                          ——ASTVariableAccess (referenced variable name = 'required')
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean isTryWithResources(), //Returns true if this node is a try-with-resources, in which case it has a ResourceSpecification child node.
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTResourceList getResources(), //Returns the node for the resource list. This is null if this is not a try-with-resources.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources() && tryBody.isEmpty() && !isIgnoredResource(node.getResources())) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    private boolean isIgnoredResource(ASTResourceList resources) {
        if (resources != null) {
            for (ASTResource resource : resources) {
                ASTVariableDeclaratorId variableDeclaratorId = resource.getFirstChildOfType(ASTVariableDeclaratorId.class);
                if (variableDeclaratorId != null && !"ignored".equals(variableDeclaratorId.getImage())) {
                    return false;
                }
            }
        }
        return true;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the body of try statement.
2. Check whether the body of try statement is empty.
3. Get the finally branch of try statement.
4. Check whether the finally branch of try statement is empty.
5. Get the switch statement.
6. Check whether the switch statement is empty.
7. Get the synchronized statement.
8. Check whether the synchronized statement is empty.
9. Get the if statement.
10. Check whether the if statement has an empty body.
11. Get the else branch of if statement.
12. Check whether the else branch of if statement is empty.
13. Get the while statement.
14. Check whether the while statement has an empty body.
15. Get the for statement.
16. Check whether the for statement has an empty body.
17. Get the do-while statement.
18. Check whether the do-while statement has an empty body.
19. Get the initializer block.
20. Check whether the initializer block is empty.

In this specific test case:
21. Get the body of try statement.
22. Check whether the body of try statement is empty. (Expected result: False, as there is a comment inside the try block)
23. Get the finally branch of try statement.
24. Check whether the finally branch of try statement is empty. (Expected result: True, as the finally block is not present)
25. Check whether the try statement has a try-with-resources clause.
26. Get the resources of try-with-resources clause.
27. Check whether the resource name is "ignored". (Expected result: False, as the resource is named "response")

Based on the provided rule description and test case, the number of violating the rule in this test case is 1 because the try statement has an empty body (ignoring comments).

However, the provided description of the test case states that the rule should ignore empty try-with-resources blocks if the resource name is not "ignored". Since the resource name in this case is "response" and not "ignored", the try statement indeed violates the rule. If the resource name was "ignored", then the rule would ignore the empty try-with-resources block.
28. Check whether the try statement is an empty try-with-resources block and the resource name is not "ignored". (Expected result: True, as the try statement is an empty try-with-resources block and the resource name is "response")
29. Check whether the try statement is an empty try-with-resources block and the resource name is "ignored". (Expected result: False, as the resource name is "response")
30. Since the try statement is an empty try-with-resources block and the resource name is not "ignored", the test case violates the rule. (Expected result: True)

Given the checks, the test case indeed violates the rule as per the provided description and the rule specific ignores.
['Get the body of try statement.', 'Check whether the body of try statement is empty.', 'Get the finally branch of try statement.', 'Check whether the finally branch of try statement is empty.', 'Get the switch statement.', 'Check whether the switch statement is empty.', 'Get the synchronized statement.', 'Check whether the synchronized statement is empty.', 'Get the if statement.', 'Check whether the if statement has an empty body.', 'Get the else branch of if statement.', 'Check whether the else branch of if statement is empty.', 'Get the while statement.', 'Check whether the while statement has an empty body.', 'Get the for statement.', 'Check whether the for statement has an empty body.', 'Get the do-while statement.', 'Check whether the do-while statement has an empty body.', 'Get the initializer block.', 'Check whether the initializer block is empty.', 'Get the body of try statement.', 'Check whether the body of try statement is empty. (Expected result: False, as there is a comment inside the try block)', 'Get the finally branch of try statement.', 'Check whether the finally branch of try statement is empty. (Expected result: True, as the finally block is not present)', 'Check whether the try statement has a try-with-resources clause.', 'Get the resources of try-with-resources clause.', 'Check whether the resource name is "ignored". (Expected result: False, as the resource is named "response")', 'Check whether the try statement is an empty try-with-resources block and the resource name is not "ignored". (Expected result: True, as the try statement is an empty try-with-resources block and the resource name is "response")', 'Check whether the try statement is an empty try-with-resources block and the resource name is "ignored". (Expected result: False, as the resource name is "response")', 'Since the try statement is an empty try-with-resources block and the resource name is not "ignored", the test case violates the rule. (Expected result: True)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTResourceList', 'ASTAmbiguousName', 'ASTVariableAccess', 'ASTResource', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTLambdaExpression', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTTryStatement', 'TokenUtils', 'ASTLambdaParameterList', 'ASTClassOrInterfaceDeclaration', 'ASTConstructorCall', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the body of try statement.* 匹配到的元操作或API：
query: Get the body of try statement.
most similar API: get body of try statement
cosine Similarity: 0.9849936962127686
*Check whether the body of try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of try statement is empty.
most similar API: get body of try statement
cosine Similarity: 0.8571391105651855
*Get the finally branch of try statement.* 匹配到的元操作或API：
logic: Get the finally branch of try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9912986755371094
*Check whether the finally branch of try statement is empty.* 匹配到的元操作或API：
logic: Check whether the finally branch of try statement is empty.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.879764199256897
*Get the switch statement.* 匹配到的元操作或API：
logic: Get the switch statement.
most similar meta operation: Get a branch of switch statement
cosine Similarity: 0.8900695443153381
*Check whether the switch statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the synchronized statement.* 匹配到的元操作或API：
logic: Get the synchronized statement.
most similar meta operation: Get the lock of synchronized statement
cosine Similarity: 0.8976348042488098
*Check whether the synchronized statement is empty.* 匹配到的元操作或API：
query: Check whether the synchronized statement is empty.
most similar API: Check whether the method is synchronized
cosine Similarity: 0.8055706024169922
*Get the if statement.* 匹配到的元操作或API：
logic: Get the if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.886244535446167
*Check whether the if statement has an empty body.* 匹配到的元操作或API：
query: Check whether the if statement has an empty body.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8336375951766968
*Get the else branch of if statement.* 匹配到的元操作或API：
logic: Get the else branch of if statement.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.989610493183136
*Check whether the else branch of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the else branch of if statement is empty.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9108617305755615
*Get the while statement.* 匹配到的元操作或API：
logic: Get the while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.9067860841751099
*Check whether the while statement has an empty body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the for statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the for statement has an empty body.* 匹配到的元操作或API：
query: Check whether the for statement has an empty body.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8180275559425354
*Get the do-while statement.* 匹配到的元操作或API：
logic: Get the do-while statement.
most similar meta operation: Get the condition of do-while statement
cosine Similarity: 0.8836787939071655
*Check whether the do-while statement has an empty body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the initializer block.* 匹配到的元操作或API：
query: Get the initializer block.
most similar API: get initializer of resource
cosine Similarity: 0.8241337537765503
*Check whether the initializer block is empty.* 匹配到的元操作或API：
query: Check whether the initializer block is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.862004280090332
*Get the body of try statement.* 匹配到的元操作或API：
query: Get the body of try statement.
most similar API: get body of try statement
cosine Similarity: 0.9849936962127686
*Check whether the body of try statement is empty. (Expected result: False, as there is a comment inside the try block)* 匹配到的元操作或API：
query: Check whether the body of try statement is empty. (Expected result: False, as there is a comment inside the try block)
most similar API: get body of try statement
cosine Similarity: 0.8200055360794067
*Get the finally branch of try statement.* 匹配到的元操作或API：
logic: Get the finally branch of try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9912986755371094
*Check whether the finally branch of try statement is empty. (Expected result: True, as the finally block is not present)* 匹配到的元操作或API：
logic: Check whether the finally branch of try statement is empty. (Expected result: True, as the finally block is not present)
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.8648773431777954
*Check whether the try statement has a try-with-resources clause.* 匹配到的元操作或API：
query: Check whether the try statement has a try-with-resources clause.
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.9303063154220581
*Get the resources of try-with-resources clause.* 匹配到的元操作或API：
query: Get the resources of try-with-resources clause.
most similar API: get resources of try statement
cosine Similarity: 0.8798079490661621
*Check whether the resource name is "ignored". (Expected result: False, as the resource is named "response")* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the try statement is an empty try-with-resources block and the resource name is not "ignored". (Expected result: True, as the try statement is an empty try-with-resources block and the resource name is "response")* 匹配到的元操作或API：
query: Check whether the try statement is an empty try-with-resources block and the resource name is not "ignored". (Expected result: True, as the try statement is an empty try-with-resources block and the resource name is "response")
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.8615384101867676
*Check whether the try statement is an empty try-with-resources block and the resource name is "ignored". (Expected result: False, as the resource name is "response")* 匹配到的元操作或API：
query: Check whether the try statement is an empty try-with-resources block and the resource name is "ignored". (Expected result: False, as the resource name is "response")
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.866142988204956
*Since the try statement is an empty try-with-resources block and the resource name is not "ignored", the test case violates the rule. (Expected result: True)* 匹配到的元操作或API：
query: Since the try statement is an empty try-with-resources block and the resource name is not "ignored", the test case violates the rule. (Expected result: True)
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.8012701272964478
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'X')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'method')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTTryStatement
          ——ASTResourceList
            ——ASTResource
              ——ASTLocalVariableDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceType (this is a class type)
                ——ASTVariableDeclarator
                  ——ASTVariableDeclaratorId (declared variable name = 'response')
                  ——ASTMethodCall (called method name = 'execute')
                    ——ASTArgumentList (size = 3)
                      ——ASTLambdaExpression
                        ——ASTLambdaParameterList
                        ——ASTMethodCall (called method name = 'delete')
                          ——ASTMethodCall (called method name = 'request')
                            ——ASTAmbiguousName (this is a primitive type)
                            ——ASTArgumentList (size = 1)
                              ——ASTVariableAccess (referenced variable name = 'mediaTypes')
                          ——ASTArgumentList (size = 0)
                      ——ASTVariableAccess (referenced variable name = 'DELETE')
                      ——ASTConstructorCall
                        ——ASTClassOrInterfaceType (this is a class type)
                        ——ASTArgumentList (size = 2)
                          ——ASTVariableAccess (referenced variable name = 'status')
                          ——ASTVariableAccess (referenced variable name = 'required')
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()
3. net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTSwitchBranch> getBranches()
4. net.sourceforge.pmd.lang.java.ast.ASTSynchronizedStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLockExpression()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isSynchronized()
6. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()
8. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch()
9. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
10. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
11. net.sourceforge.pmd.lang.java.ast.ASTDoStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody()
12. net.sourceforge.pmd.lang.java.ast.ASTResource: public net.sourceforge.pmd.lang.java.ast.ASTExpression getInitializer(), //Returns the initializer of the expression. If this is a concise resource, then returns that expression. If this is a local variable declaration, returns the initializer of the variable.
13. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()
14. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean isTryWithResources(), //Returns true if this node is a try-with-resources, in which case it has a ResourceSpecification child node.
15. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTResourceList getResources(), //Returns the node for the resource list. This is null if this is not a try-with-resources.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null) {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
96
80
82
68
119
103
84
70
=========================error_testcase_logics=========================
1. Get the method name.
2. Check whether the method name is method.
3. Get the method body.
4. Get all try statements in the method body.
5. Check whether the try statement has a resource.
6. Check whether the try statement has an empty body.
7. Get the finally block of the try statement.
8. Check whether the finally block is empty.
9. Check whether the try statement is a concise try-with-resource.
10. Check whether the concise try-with-resource has an empty body.

In this test case, the concise try-with-resource has an empty body. Therefore, this test case violates the rule.
['Get the method name.', 'Check whether the method name is method.', 'Get the method body.', 'Get all try statements in the method body.', 'Check whether the try statement has a resource.', 'Check whether the try statement has an empty body.', 'Get the finally block of the try statement.', 'Check whether the finally block is empty.', 'Check whether the try statement is a concise try-with-resource.', 'Check whether the concise try-with-resource has an empty body.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTResourceList', 'ASTVariableAccess', 'ASTResource', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTImportDeclaration', 'ASTFormalParameters', 'ASTTryStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the method name.* 匹配到的元操作或API：
logic: Get the method name.
most similar meta operation: Get the name of method
cosine Similarity: 0.9567613005638123
*Check whether the method name is method.* 匹配到的元操作或API：
query: Check whether the method name is method.
most similar API: Check whether is test method
cosine Similarity: 0.8664756417274475
*Get the method body.* 匹配到的元操作或API：
query: Get the method body.
most similar API: get body of method
cosine Similarity: 0.952139139175415
*Get all try statements in the method body.* 匹配到的元操作或API：
query: Get all try statements in the method body.
most similar API: get body of try statement
cosine Similarity: 0.8588416576385498
*Check whether the try statement has a resource.* 匹配到的元操作或API：
query: Check whether the try statement has a resource.
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.9570353627204895
*Check whether the try statement has an empty body.* 匹配到的元操作或API：
query: Check whether the try statement has an empty body.
most similar API: get body of try statement
cosine Similarity: 0.837001383304596
*Get the finally block of the try statement.* 匹配到的元操作或API：
logic: Get the finally block of the try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.913399338722229
*Check whether the finally block is empty.* 匹配到的元操作或API：
query: Check whether the finally block is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8699493408203125
*Check whether the try statement is a concise try-with-resource.* 匹配到的元操作或API：
query: Check whether the try statement is a concise try-with-resource.
most similar API: Check whether the try statement is try with resources
cosine Similarity: 0.9197684526443481
*Check whether the concise try-with-resource has an empty body.* 匹配到的元操作或API：
query: Check whether the concise try-with-resource has an empty body.
most similar API: Check whether the resource list is empty
cosine Similarity: 0.8260365724563599
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null) {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty concise try-with-resource - not ok
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'X')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'method')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'in')
      ——ASTBlock
        ——ASTTryStatement
          ——ASTResourceList
            ——ASTResource
              ——ASTVariableAccess (referenced variable name = 'in')
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this try statement.
5. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean isTryWithResources(), //Returns true if this node is a try-with-resources, in which case it has a ResourceSpecification child node.
6. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()
7. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()
8. net.sourceforge.pmd.lang.java.ast.ASTResourceList: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
79
65
89
74
=========================error_testcase_logics=========================
1. Check whether the class has a method named `foo`.
2. Get the body of the method `foo`.
3. Check whether the method body contains a synchronized statement.
4. Get the body of the synchronized statement.
5. Check whether the body of the synchronized statement is empty.

The number of violations of the rule in this test case is indeed 1, as the synchronized statement has an empty body.
['Check whether the class has a method named `foo`.', 'Get the body of the method `foo`.', 'Check whether the method body contains a synchronized statement.', 'Get the body of the synchronized statement.', 'Check whether the body of the synchronized statement is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'ASTSynchronizedStatement', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTThisExpression', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Check whether the class has a method named `foo`.* 匹配到的元操作或API：
query: Check whether the class has a method named `foo`.
most similar API: Check whether is test method
cosine Similarity: 0.8198273181915283
*Get the body of the method `foo`.* 匹配到的元操作或API：
query: Get the body of the method `foo`.
most similar API: get body of method
cosine Similarity: 0.9110667705535889
*Check whether the method body contains a synchronized statement.* 匹配到的元操作或API：
logic: Check whether the method body contains a synchronized statement.
most similar meta operation: Check whether the method is synchronized
cosine Similarity: 0.8885619640350342
*Get the body of the synchronized statement.* 匹配到的元操作或API：
query: Get the body of the synchronized statement.
most similar API: get body of synchronized statement
cosine Similarity: 0.978999674320221
*Check whether the body of the synchronized statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the synchronized statement is empty.
most similar API: Check whether the synchronized statement equals
cosine Similarity: 0.8556152582168579
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty synchronized stmt
public class Foo {
                void foo() {
                    synchronized (this) {}
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTSynchronizedStatement
          ——ASTThisExpression
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isSynchronized()
4. net.sourceforge.pmd.lang.java.ast.ASTSynchronizedStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this statement.
5. net.sourceforge.pmd.lang.java.ast.ASTSynchronizedStatement: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the body of synchronized statement.
2. Check whether the body of synchronized statement is empty.
If the body of the synchronized statement is empty, then this test case violates the rule.
['Get the body of synchronized statement.', 'Check whether the body of synchronized statement is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'ASTSynchronizedStatement', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTThisExpression', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the body of synchronized statement.* 匹配到的元操作或API：
logic: Get the body of synchronized statement.
most similar meta operation: Get the lock of synchronized statement
cosine Similarity: 0.8570014238357544
*Check whether the body of synchronized statement is empty.* 匹配到的元操作或API：
query: Check whether the body of synchronized statement is empty.
most similar API: Check whether the synchronized statement equals
cosine Similarity: 0.8663209080696106
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty synchronized stmt
public class Foo {
                void foo() {
                    synchronized (this) {}
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTSynchronizedStatement
          ——ASTThisExpression
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTSynchronizedStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLockExpression()
2. net.sourceforge.pmd.lang.java.ast.ASTSynchronizedStatement: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Check whether the class is an interface.
2. Check whether the class is abstract.
3. Get the name of the method.
4. Get the body of the method.
5. Check whether the body of the method contains a synchronized statement.
6. Get the body of the synchronized statement.
7. Check whether the body of the synchronized statement is empty.

The number of violating the rule in this test case is: 1

Explanation:
- Step 1: The class `Foo` is not an interface.
- Step 2: The class `Foo` is not abstract.
- Step 3: The method name is `foo`.
- Step 4: The body of the method `foo` is `{ synchronized (this) {} }`.
- Step 5: The method body contains a synchronized statement.
- Step 6: The body of the synchronized statement is `{}`.
- Step 7: The body of the synchronized statement is empty, which violates the rule.
['Check whether the class is an interface.', 'Check whether the class is abstract.', 'Get the name of the method.', 'Get the body of the method.', 'Check whether the body of the method contains a synchronized statement.', 'Get the body of the synchronized statement.', 'Check whether the body of the synchronized statement is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'ASTSynchronizedStatement', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTThisExpression', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Check whether the class is an interface.* 匹配到的元操作或API：
logic: Check whether the class is an interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9778784513473511
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get the name of the method.* 匹配到的元操作或API：
logic: Get the name of the method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9713990092277527
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Check whether the body of the method contains a synchronized statement.* 匹配到的元操作或API：
logic: Check whether the body of the method contains a synchronized statement.
most similar meta operation: Check whether the method is synchronized
cosine Similarity: 0.8954302668571472
*Get the body of the synchronized statement.* 匹配到的元操作或API：
query: Get the body of the synchronized statement.
most similar API: get body of synchronized statement
cosine Similarity: 0.978999674320221
*Check whether the body of the synchronized statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the synchronized statement is empty.
most similar API: Check whether the synchronized statement equals
cosine Similarity: 0.8556152582168579
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty synchronized stmt
public class Foo {
                void foo() {
                    synchronized (this) {}
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTSynchronizedStatement
          ——ASTThisExpression
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isSynchronized()
6. net.sourceforge.pmd.lang.java.ast.ASTSynchronizedStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this statement.
7. net.sourceforge.pmd.lang.java.ast.ASTSynchronizedStatement: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the body of synchronized statement.
2. Check whether the body of synchronized statement is empty.
If the body of the synchronized statement is empty, then this test case violates the rule.
            
['Get the body of synchronized statement.', 'Check whether the body of synchronized statement is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'ASTSynchronizedStatement', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTThisExpression', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the body of synchronized statement.* 匹配到的元操作或API：
logic: Get the body of synchronized statement.
most similar meta operation: Get the lock of synchronized statement
cosine Similarity: 0.8570014238357544
*Check whether the body of synchronized statement is empty.* 匹配到的元操作或API：
query: Check whether the body of synchronized statement is empty.
most similar API: Check whether the synchronized statement equals
cosine Similarity: 0.8663209080696106
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty synchronized stmt
public class Foo {
                void foo() {
                    synchronized (this) {}
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTSynchronizedStatement
          ——ASTThisExpression
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTSynchronizedStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLockExpression()
2. net.sourceforge.pmd.lang.java.ast.ASTSynchronizedStatement: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the type of the control statement.
        2. Check whether the control statement is synchronized.
        3. Get the body of the synchronized statement.
        4. Check whether the body of the synchronized statement is empty.
        If the control statement is a synchronized statement and its body is empty, then this test case violates the rule.
['Get the type of the control statement.', 'Check whether the control statement is synchronized.', 'Get the body of the synchronized statement.', 'Check whether the body of the synchronized statement is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'ASTSynchronizedStatement', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTThisExpression', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the type of the control statement.* 匹配到的元操作或API：
query: Get the type of the control statement.
most similar API: get type of this expression
cosine Similarity: 0.8042596578598022
*Check whether the control statement is synchronized.* 匹配到的元操作或API：
query: Check whether the control statement is synchronized.
most similar API: Check whether the synchronized statement equals
cosine Similarity: 0.8959065675735474
*Get the body of the synchronized statement.* 匹配到的元操作或API：
query: Get the body of the synchronized statement.
most similar API: get body of synchronized statement
cosine Similarity: 0.978999674320221
*Check whether the body of the synchronized statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the synchronized statement is empty.
most similar API: Check whether the synchronized statement equals
cosine Similarity: 0.8556152582168579
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty synchronized stmt
public class Foo {
                void foo() {
                    synchronized (this) {}
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTSynchronizedStatement
          ——ASTThisExpression
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTThisExpression: public java.lang.Class<Class<?> getType()
2. net.sourceforge.pmd.lang.java.ast.ASTSynchronizedStatement: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTSynchronizedStatement: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this statement.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 7
[ERROR]   "bad 9" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the body of the method.
2. Check whether the body contains an empty initializer or block.
3. If an empty block is found, report it as a violation of the rule.

In this test case:
1. Get the body of the method `bar`.
2. Check whether the body contains an empty initializer or block.
3. The body of the method `bar` contains an empty block `{}`, which violates the rule.

Thus, the number of violations in this test case is: 1.
['Get the body of the method.', 'Check whether the body contains an empty initializer or block.', 'If an empty block is found, report it as a violation of the rule.', 'Get the body of the method `bar`.', 'Check whether the body contains an empty initializer or block.', 'The body of the method `bar` contains an empty block `{}`, which violates the rule.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Check whether the body contains an empty initializer or block.* 匹配到的元操作或API：
query: Check whether the body contains an empty initializer or block.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.838114857673645
*If an empty block is found, report it as a violation of the rule.* 匹配到的元操作或API：
query: If an empty block is found, report it as a violation of the rule.
most similar API: Check whether the block is empty
cosine Similarity: 0.8127841353416443
*Get the body of the method `bar`.* 匹配到的元操作或API：
query: Get the body of the method `bar`.
most similar API: get body of method
cosine Similarity: 0.8682438135147095
*Check whether the body contains an empty initializer or block.* 匹配到的元操作或API：
query: Check whether the body contains an empty initializer or block.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.838114857673645
*The body of the method `bar` contains an empty block `{}`, which violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty block
public class Foo {
                public void bar() {
                    {}
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()
3. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "bad 10" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
78
64
=========================error_testcase_logics=========================
1. Check whether the initializer is empty.
        If the initializer is empty, then this test case violates the rule.
        
In this specific test case, the initializer is indeed empty, so it violates the rule once.
['Check whether the initializer is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTInitializer', 'TypesFromReflection', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Check whether the initializer is empty.* 匹配到的元操作或API：
query: Check whether the initializer is empty.
most similar API: Check whether the initializer equals
cosine Similarity: 0.8651249408721924
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty initializer failure case (non static)
public class Foo {
                {}
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTInitializer: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "bad 13" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
100
82
94
78
96
79
77
63
95
78
94
79
77
63
82
68
=========================error_testcase_logics=========================
1. Get the number of loop statements in method.
2. Check whether the loop statement is a for loop.
3. Get the body of the for loop.
4. Check whether the body of the for loop is empty.
5. Repeat steps 2-4 for each loop statement in method.

In the provided test case:
1. The `bar` method contains two for loop statements.
2. Check whether the first for loop is a for loop. (It is a for loop)
3. Get the body of the first for loop. (The body is `{}` which is empty)
4. Check whether the body of the first for loop is empty. (It is empty)
5. Check whether the second for loop is a for loop. (It is a for loop)
6. Get the body of the second for loop. (The body contains `System.out.println(i);`)
7. Check whether the body of the second for loop is empty. (It is not empty)

Therefore, the first for loop violates the rule, and the number of violations in this test case is 1.
['Get the number of loop statements in method.', 'Check whether the loop statement is a for loop.', 'Get the body of the for loop.', 'Check whether the body of the for loop is empty.', 'Repeat steps 2-4 for each loop statement in method.', 'The `bar` method contains two for loop statements.', 'Check whether the first for loop is a for loop. (It is a for loop)', 'Get the body of the first for loop. (The body is `{}` which is empty)', 'Check whether the body of the first for loop is empty. (It is empty)', 'Check whether the second for loop is a for loop. (It is a for loop)', 'Get the body of the second for loop. (The body contains `System.out.println(i);`)', 'Check whether the body of the second for loop is empty. (It is not empty)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTVariableDeclaratorId', 'ASTStatementExpressionList', 'ASTBlock', 'ASTTypeExpression', 'ASTArgumentList', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'ASTForUpdate', 'JavaAstUtils', 'ASTFieldAccess', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTForInit', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTForStatement']
*Get the number of loop statements in method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the loop statement is a for loop.* 匹配到的元操作或API：
query: Check whether the loop statement is a for loop.
most similar API: Check whether the for statement equals
cosine Similarity: 0.8447393178939819
*Get the body of the for loop.* 匹配到的元操作或API：
query: Get the body of the for loop.
most similar API: get body of for statement
cosine Similarity: 0.9058630466461182
*Check whether the body of the for loop is empty.* 匹配到的元操作或API：
query: Check whether the body of the for loop is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8098464608192444
*Repeat steps 2-4 for each loop statement in method.* 匹配到的元操作或API：
未匹配成功元操作或API
*The `bar` method contains two for loop statements.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the first for loop is a for loop. (It is a for loop)* 匹配到的元操作或API：
query: Check whether the first for loop is a for loop. (It is a for loop)
most similar API: Check whether the for statement equals
cosine Similarity: 0.8034120202064514
*Get the body of the first for loop. (The body is `{}` which is empty)* 匹配到的元操作或API：
query: Get the body of the first for loop. (The body is `{}` which is empty)
most similar API: get body of for statement
cosine Similarity: 0.8522006273269653
*Check whether the body of the first for loop is empty. (It is empty)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the second for loop is a for loop. (It is a for loop)* 匹配到的元操作或API：
query: Check whether the second for loop is a for loop. (It is a for loop)
most similar API: Check whether the for statement equals
cosine Similarity: 0.8080329895019531
*Get the body of the second for loop. (The body contains `System.out.println(i);`)* 匹配到的元操作或API：
query: Get the body of the second for loop. (The body contains `System.out.println(i);`)
most similar API: get body of for statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8459082245826721
*Check whether the body of the second for loop is empty. (It is not empty)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty for
public class Foo {
                public void bar() {
                    for (int i = 0; i < 2; i++) {
                    }
                    for (int i = 0; i < 2; i++) { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public boolean equals(java.lang.Object)
2. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the number of loop statements in the method.
2. Get the first loop statement in the method.
3. Check whether the loop statement is a for loop.
4. Get the body of the first for loop.
5. Check whether the body of the first for loop is empty.
6. If the body of the first for loop is empty, then it violates the rule.
7. Get the second loop statement in the method.
8. Check whether the second loop statement is a for loop.
9. Get the body of the second for loop.
10. Check whether the body of the second for loop is empty.
11. If the body of the second for loop is not empty, then it does not violate the rule.

In this test case, the first for loop violates the rule, as its body is empty, while the second for loop does not violate the rule, as its body is not empty.
['Get the number of loop statements in the method.', 'Get the first loop statement in the method.', 'Check whether the loop statement is a for loop.', 'Get the body of the first for loop.', 'Check whether the body of the first for loop is empty.', 'If the body of the first for loop is empty, then it violates the rule.', 'Get the second loop statement in the method.', 'Check whether the second loop statement is a for loop.', 'Get the body of the second for loop.', 'Check whether the body of the second for loop is empty.', 'If the body of the second for loop is not empty, then it does not violate the rule.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTVariableDeclaratorId', 'ASTStatementExpressionList', 'ASTBlock', 'ASTTypeExpression', 'ASTArgumentList', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'ASTForUpdate', 'JavaAstUtils', 'ASTFieldAccess', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTForInit', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTForStatement']
*Get the number of loop statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first loop statement in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the loop statement is a for loop.* 匹配到的元操作或API：
query: Check whether the loop statement is a for loop.
most similar API: Check whether the for statement equals
cosine Similarity: 0.8447393178939819
*Get the body of the first for loop.* 匹配到的元操作或API：
query: Get the body of the first for loop.
most similar API: get body of for statement
cosine Similarity: 0.872355043888092
*Check whether the body of the first for loop is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the body of the first for loop is empty, then it violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the second loop statement in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the second loop statement is a for loop.* 匹配到的元操作或API：
query: Check whether the second loop statement is a for loop.
most similar API: Check whether the for statement equals
cosine Similarity: 0.8371503353118896
*Get the body of the second for loop.* 匹配到的元操作或API：
query: Get the body of the second for loop.
most similar API: get body of for statement
cosine Similarity: 0.8675823211669922
*Check whether the body of the second for loop is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the body of the second for loop is not empty, then it does not violate the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty for
public class Foo {
                public void bar() {
                    for (int i = 0; i < 2; i++) {
                    }
                    for (int i = 0; i < 2; i++) { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public boolean equals(java.lang.Object)
2. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the body of the for loop.
2. Check whether the body of the for loop is empty.

In this test case, there are two for loops. We will perform the granular checks on each loop to determine if they violate the rule.

1. Get the body of the first for loop.
2. Check whether the body of the first for loop is empty. // This should return true as the body is empty.
3. Get the body of the second for loop.
4. Check whether the body of the second for loop is empty. // This should return false as the body contains a method call.
['Get the body of the for loop.', 'Check whether the body of the for loop is empty.', 'Get the body of the first for loop.', 'Check whether the body of the first for loop is empty. // This should return true as the body is empty.', 'Get the body of the second for loop.', 'Check whether the body of the second for loop is empty. // This should return false as the body contains a method call.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTVariableDeclaratorId', 'ASTStatementExpressionList', 'ASTBlock', 'ASTTypeExpression', 'ASTArgumentList', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'ASTForUpdate', 'JavaAstUtils', 'ASTFieldAccess', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTForInit', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTForStatement']
*Get the body of the for loop.* 匹配到的元操作或API：
query: Get the body of the for loop.
most similar API: get body of for statement
cosine Similarity: 0.9058630466461182
*Check whether the body of the for loop is empty.* 匹配到的元操作或API：
query: Check whether the body of the for loop is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8098464608192444
*Get the body of the first for loop.* 匹配到的元操作或API：
query: Get the body of the first for loop.
most similar API: get body of for statement
cosine Similarity: 0.872355043888092
*Check whether the body of the first for loop is empty. // This should return true as the body is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the second for loop.* 匹配到的元操作或API：
query: Get the body of the second for loop.
most similar API: get body of for statement
cosine Similarity: 0.8675823211669922
*Check whether the body of the second for loop is empty. // This should return false as the body contains a method call.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty for
public class Foo {
                public void bar() {
                    for (int i = 0; i < 2; i++) {
                    }
                    for (int i = 0; i < 2; i++) { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the type of loop statement.
2. Check whether the loop statement is a for loop.
3. Get the condition of for loop.
4. Get the body of the for loop.
5. Check whether the body of the for loop is empty.
6. Repeat steps 2-5 for each for loop in the code.

In this test case, the first for loop has an empty body, while the second for loop does not. Therefore, the number of violating the rule is 1.
['Get the type of loop statement.', 'Check whether the loop statement is a for loop.', 'Get the condition of for loop.', 'Get the body of the for loop.', 'Check whether the body of the for loop is empty.', 'Repeat steps 2-5 for each for loop in the code.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTVariableDeclaratorId', 'ASTStatementExpressionList', 'ASTBlock', 'ASTTypeExpression', 'ASTArgumentList', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'ASTForUpdate', 'JavaAstUtils', 'ASTFieldAccess', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTForInit', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTForStatement']
*Get the type of loop statement.* 匹配到的元操作或API：
query: Get the type of loop statement.
most similar API: get enclosing type of for statement
cosine Similarity: 0.8097243905067444
*Check whether the loop statement is a for loop.* 匹配到的元操作或API：
query: Check whether the loop statement is a for loop.
most similar API: Check whether the for statement equals
cosine Similarity: 0.8447393178939819
*Get the condition of for loop.* 匹配到的元操作或API：
logic: Get the condition of for loop.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.8640909790992737
*Get the body of the for loop.* 匹配到的元操作或API：
query: Get the body of the for loop.
most similar API: get body of for statement
cosine Similarity: 0.9058630466461182
*Check whether the body of the for loop is empty.* 匹配到的元操作或API：
query: Check whether the body of the for loop is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8098464608192444
*Repeat steps 2-5 for each for loop in the code.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty for
public class Foo {
                public void bar() {
                    for (int i = 0; i < 2; i++) {
                    }
                    for (int i = 0; i < 2; i++) { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType(), //Returns the node representing the type declaration this node is found in. The type of that node is the type of the {@code this} expression. <p>This returns null for nodes that aren't enclosed in a type declaration. This includes {@linkplain ASTPackageDeclaration PackageDeclaration}, This includes {@linkplain ASTImportDeclaration ImportDeclaration}, {@linkplain ASTModuleDeclaration ModuleDeclaration}, {@linkplain ASTCompilationUnit CompilationUnit}, and top-level {@linkplain ASTAnyTypeDeclaration AnyTypeDeclaration}s.
2. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
4. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the number of loop statements in the method.
2. Get a loop statement from the method.
3. Check whether the loop statement is a for loop.
4. Get the body of the for loop.
5. Check whether the body of the for loop is empty.
6. Repeat steps 2-5 for each loop statement in the method.

The specific checks for the provided test case:

1. Get the number of loop statements in the method bar.
2. Get a loop statement from the method bar.
3. Check whether the loop statement is a for loop. // True
4. Get the body of the for loop. 
5. Check whether the body of the for loop is empty. // True, this is the first for loop and it violates the rule.
6. Get another loop statement from the method bar.
7. Check whether the loop statement is a for loop. // True
8. Get the body of the for loop.
9. Check whether the body of the for loop is empty. // False, this is the second for loop and it does not violate the rule.

The number of violating the rule in this test case is: 1
['Get the number of loop statements in the method.', 'Get a loop statement from the method.', 'Check whether the loop statement is a for loop.', 'Get the body of the for loop.', 'Check whether the body of the for loop is empty.', 'Repeat steps 2-5 for each loop statement in the method.', 'Get the number of loop statements in the method bar.', 'Get a loop statement from the method bar.', 'Check whether the loop statement is a for loop. // True', 'Get the body of the for loop.', 'Check whether the body of the for loop is empty. // True, this is the first for loop and it violates the rule.', 'Get another loop statement from the method bar.', 'Check whether the loop statement is a for loop. // True', 'Get the body of the for loop.', 'Check whether the body of the for loop is empty. // False, this is the second for loop and it does not violate the rule.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'JavaSemanticErrors', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTVariableDeclaratorId', 'ASTStatementExpressionList', 'ASTBlock', 'ASTTypeExpression', 'ASTArgumentList', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'ASTForUpdate', 'JavaAstUtils', 'ASTFieldAccess', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTUnaryExpression', 'JavadocTag', 'AstImplUtil', 'ASTForInit', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTForStatement']
*Get the number of loop statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get a loop statement from the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the loop statement is a for loop.* 匹配到的元操作或API：
query: Check whether the loop statement is a for loop.
most similar API: Check whether the for statement equals
cosine Similarity: 0.8447393178939819
*Get the body of the for loop.* 匹配到的元操作或API：
query: Get the body of the for loop.
most similar API: get body of for statement
cosine Similarity: 0.9058630466461182
*Check whether the body of the for loop is empty.* 匹配到的元操作或API：
query: Check whether the body of the for loop is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8098464608192444
*Repeat steps 2-5 for each loop statement in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of loop statements in the method bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get a loop statement from the method bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the loop statement is a for loop. // True* 匹配到的元操作或API：
query: Check whether the loop statement is a for loop. // True
most similar API: Check whether the for statement equals
cosine Similarity: 0.8205075263977051
*Get the body of the for loop.* 匹配到的元操作或API：
query: Get the body of the for loop.
most similar API: get body of for statement
cosine Similarity: 0.9058630466461182
*Check whether the body of the for loop is empty. // True, this is the first for loop and it violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get another loop statement from the method bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the loop statement is a for loop. // True* 匹配到的元操作或API：
query: Check whether the loop statement is a for loop. // True
most similar API: Check whether the for statement equals
cosine Similarity: 0.8205075263977051
*Get the body of the for loop.* 匹配到的元操作或API：
query: Get the body of the for loop.
most similar API: get body of for statement
cosine Similarity: 0.9058630466461182
*Check whether the body of the for loop is empty. // False, this is the second for loop and it does not violate the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty for
public class Foo {
                public void bar() {
                    for (int i = 0; i < 2; i++) {
                    }
                    for (int i = 0; i < 2; i++) { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
        ——ASTForStatement
          ——ASTForInit
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'i')
                ——ASTNumericLiteral
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
          ——ASTForUpdate
            ——ASTStatementExpressionList
              ——ASTUnaryExpression
                ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public boolean equals(java.lang.Object)
2. net.sourceforge.pmd.lang.java.ast.ASTForStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 13
[ERROR]   "bad 14" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
100
82
96
79
95
78
80
65
=========================error_testcase_logics=========================
1. Get the loop statement of the method.
2. Check whether the loop statement is a do-while statement.
3. Get the condition of the do-while statement.
4. Check whether the body of the do-while statement is empty.
5. Repeat steps 1-4 for each do-while statement in the method.

In the provided test case:
1. Get the loop statement of the method `bar`.
2. Check whether the loop statement is a do-while statement. (True for both do-while loops)
3. Get the condition of the first do-while statement. (i < 3)
4. Check whether the body of the first do-while statement is empty. (True)
5. Repeat steps 1-4 for the second do-while statement:
   2. Check whether the loop statement is a do-while statement. (True)
   3. Get the condition of the second do-while statement. (i < 3)
   4. Check whether the body of the second do-while statement is empty. (False, contains System.out.println(i))

The number of violating the rule in this test case is: 1
['Get the loop statement of the method.', 'Check whether the loop statement is a do-while statement.', 'Get the condition of the do-while statement.', 'Check whether the body of the do-while statement is empty.', 'Repeat steps 1-4 for each do-while statement in the method.', 'Get the loop statement of the method `bar`.', 'Check whether the loop statement is a do-while statement. (True for both do-while loops)', 'Get the condition of the first do-while statement. (i < 3)', 'Check whether the body of the first do-while statement is empty. (True)', 'Repeat steps 1-4 for the second do-while statement:', 'Check whether the loop statement is a do-while statement. (True)', 'Get the condition of the second do-while statement. (i < 3)', 'Check whether the body of the second do-while statement is empty. (False, contains System.out.println(i))']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'ASTTypeExpression', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTFieldAccess', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTDoStatement', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the loop statement of the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the loop statement is a do-while statement.* 匹配到的元操作或API：
query: Check whether the loop statement is a do-while statement.
most similar API: Check whether the do statement equals
cosine Similarity: 0.842008650302887
*Get the condition of the do-while statement.* 匹配到的元操作或API：
logic: Get the condition of the do-while statement.
most similar meta operation: Get the condition of do-while statement
cosine Similarity: 0.9807344079017639
*Check whether the body of the do-while statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 1-4 for each do-while statement in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop statement of the method `bar`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the loop statement is a do-while statement. (True for both do-while loops)* 匹配到的元操作或API：
query: Check whether the loop statement is a do-while statement. (True for both do-while loops)
most similar API: Check whether the do statement equals
cosine Similarity: 0.8277816772460938
*Get the condition of the first do-while statement. (i < 3)* 匹配到的元操作或API：
logic: Get the condition of the first do-while statement. (i < 3)
most similar meta operation: Get the condition of do-while statement
cosine Similarity: 0.8977248072624207
*Check whether the body of the first do-while statement is empty. (True)* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 1-4 for the second do-while statement:* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the loop statement is a do-while statement. (True)* 匹配到的元操作或API：
query: Check whether the loop statement is a do-while statement. (True)
most similar API: Check whether the do statement equals
cosine Similarity: 0.8436018228530884
*Get the condition of the second do-while statement. (i < 3)* 匹配到的元操作或API：
logic: Get the condition of the second do-while statement. (i < 3)
most similar meta operation: Get the condition of do-while statement
cosine Similarity: 0.8970052599906921
*Check whether the body of the second do-while statement is empty. (False, contains System.out.println(i))* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty do..while
public class Foo {
                public void bar() {
                    int i = 0;
                    do {
                    } while (i < 3);
                    do { // neg, nonempty
                        System.out.println(i);
                    } while (i < 3);
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'i')
            ——ASTNumericLiteral
        ——ASTDoStatement
          ——ASTBlock
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
        ——ASTDoStatement
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTDoStatement: public boolean equals(java.lang.Object)
2. net.sourceforge.pmd.lang.java.ast.ASTDoStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the loop statement of the method.
2. Check whether the loop statement is a do-while statement.
3. Get the body of the do-while statement.
4. Check whether the body of the do-while statement is empty.
5. Repeat steps 2-4 for each loop statement in the method.

Based on the provided test case, the steps would be applied as follows:

1. Get the loop statement of the method `bar`.
2. Check whether the loop statement `do {} while (i < 3);` is a do-while statement.
3. Get the body of the do-while statement.
4. Check whether the body of the do-while statement is empty. (In this case, it is.)
5. Repeat steps 2-4 for the next loop statement in the method `bar` which is `do { System.out.println(i); } while (i < 3);`.
6. Check whether the loop statement `do { System.out.println(i); } while (i < 3);` is a do-while statement.
7. Get the body of the do-while statement.
8. Check whether the body of the do-while statement is empty. (In this case, it is not.)

The number of violating the rule in this test case is: 1 (only the first do-while statement has an empty body).
['Get the loop statement of the method.', 'Check whether the loop statement is a do-while statement.', 'Get the body of the do-while statement.', 'Check whether the body of the do-while statement is empty.', 'Repeat steps 2-4 for each loop statement in the method.', 'Get the loop statement of the method `bar`.', 'Check whether the loop statement `do {} while (i < 3);` is a do-while statement.', 'Get the body of the do-while statement.', 'Check whether the body of the do-while statement is empty. (In this case, it is.)', 'Repeat steps 2-4 for the next loop statement in the method `bar` which is `do { System.out.println(i); } while (i < 3);`.', 'Check whether the loop statement `do { System.out.println(i); } while (i < 3);` is a do-while statement.', 'Get the body of the do-while statement.', 'Check whether the body of the do-while statement is empty. (In this case, it is not.)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'ASTTypeExpression', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTFieldAccess', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTDoStatement', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the loop statement of the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the loop statement is a do-while statement.* 匹配到的元操作或API：
query: Check whether the loop statement is a do-while statement.
most similar API: Check whether the do statement equals
cosine Similarity: 0.842008650302887
*Get the body of the do-while statement.* 匹配到的元操作或API：
query: Get the body of the do-while statement.
most similar API: get body of do statement
cosine Similarity: 0.9093490839004517
*Check whether the body of the do-while statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 2-4 for each loop statement in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop statement of the method `bar`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the loop statement `do {} while (i < 3);` is a do-while statement.* 匹配到的元操作或API：
query: Check whether the loop statement `do {} while (i < 3);` is a do-while statement.
most similar API: Check whether the do statement equals
cosine Similarity: 0.8011817336082458
*Get the body of the do-while statement.* 匹配到的元操作或API：
query: Get the body of the do-while statement.
most similar API: get body of do statement
cosine Similarity: 0.9093490839004517
*Check whether the body of the do-while statement is empty. (In this case, it is.)* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 2-4 for the next loop statement in the method `bar` which is `do { System.out.println(i); } while (i < 3);`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the loop statement `do { System.out.println(i); } while (i < 3);` is a do-while statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the do-while statement.* 匹配到的元操作或API：
query: Get the body of the do-while statement.
most similar API: get body of do statement
cosine Similarity: 0.9093490839004517
*Check whether the body of the do-while statement is empty. (In this case, it is not.)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty do..while
public class Foo {
                public void bar() {
                    int i = 0;
                    do {
                    } while (i < 3);
                    do { // neg, nonempty
                        System.out.println(i);
                    } while (i < 3);
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'i')
            ——ASTNumericLiteral
        ——ASTDoStatement
          ——ASTBlock
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
        ——ASTDoStatement
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTDoStatement: public boolean equals(java.lang.Object)
2. net.sourceforge.pmd.lang.java.ast.ASTDoStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that will be run while the guard evaluates to true.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the loop statement of the method.
2. Check whether the loop statement is a do-while loop.
3. Get the condition of do-while loop.
4. Get the body of do-while loop.
5. Check whether the body of do-while loop is empty.

In this test case:
- The first do-while loop has an empty body, which violates the rule.
- The second do-while loop has a non-empty body, which does not violate the rule.

Therefore, the number of violating the rule is 1.
['Get the loop statement of the method.', 'Check whether the loop statement is a do-while loop.', 'Get the condition of do-while loop.', 'Get the body of do-while loop.', 'Check whether the body of do-while loop is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'ASTTypeExpression', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTFieldAccess', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTDoStatement', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the loop statement of the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the loop statement is a do-while loop.* 匹配到的元操作或API：
query: Check whether the loop statement is a do-while loop.
most similar API: Check whether the do statement equals
cosine Similarity: 0.8265252113342285
*Get the condition of do-while loop.* 匹配到的元操作或API：
logic: Get the condition of do-while loop.
most similar meta operation: Get the condition of do-while statement
cosine Similarity: 0.9689745306968689
*Get the body of do-while loop.* 匹配到的元操作或API：
query: Get the body of do-while loop.
most similar API: get body of do statement
cosine Similarity: 0.8692190647125244
*Check whether the body of do-while loop is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty do..while
public class Foo {
                public void bar() {
                    int i = 0;
                    do {
                    } while (i < 3);
                    do { // neg, nonempty
                        System.out.println(i);
                    } while (i < 3);
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'i')
            ——ASTNumericLiteral
        ——ASTDoStatement
          ——ASTBlock
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
        ——ASTDoStatement
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTDoStatement: public boolean equals(java.lang.Object)
2. net.sourceforge.pmd.lang.java.ast.ASTDoStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody()
3. net.sourceforge.pmd.lang.java.ast.ASTDoStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that will be run while the guard evaluates to true.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = (ASTBlock) node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 14" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 14" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the loop statement of the method.
2. Check whether the loop statement is a do-while statement.
3. Get the body of the do-while statement.
4. Check whether the body of the do-while statement is empty.
5. Repeat steps 2-4 for the next do-while statement in the method.

In this test case:
1. The loop statement in the method `bar` is a do-while statement.
2. The first do-while statement has an empty body: `do { } while (i < 3);`.
3. The second do-while statement has a non-empty body: `do { System.out.println(i); } while (i < 3);`.

Therefore, there is one violating the rule in the test case.
['Get the loop statement of the method.', 'Check whether the loop statement is a do-while statement.', 'Get the body of the do-while statement.', 'Check whether the body of the do-while statement is empty.', 'Repeat steps 2-4 for the next do-while statement in the method.', 'The loop statement in the method `bar` is a do-while statement.', 'The first do-while statement has an empty body: `do { } while (i < 3);`.', 'The second do-while statement has a non-empty body: `do { System.out.println(i); } while (i < 3);`.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'ASTTypeExpression', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTFieldAccess', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTDoStatement', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the loop statement of the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the loop statement is a do-while statement.* 匹配到的元操作或API：
query: Check whether the loop statement is a do-while statement.
most similar API: Check whether the do statement equals
cosine Similarity: 0.842008650302887
*Get the body of the do-while statement.* 匹配到的元操作或API：
query: Get the body of the do-while statement.
most similar API: get body of do statement
cosine Similarity: 0.9093490839004517
*Check whether the body of the do-while statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 2-4 for the next do-while statement in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*The loop statement in the method `bar` is a do-while statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*The first do-while statement has an empty body: `do { } while (i < 3);`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The second do-while statement has a non-empty body: `do { System.out.println(i); } while (i < 3);`.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty do..while
public class Foo {
                public void bar() {
                    int i = 0;
                    do {
                    } while (i < 3);
                    do { // neg, nonempty
                        System.out.println(i);
                    } while (i < 3);
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'i')
            ——ASTNumericLiteral
        ——ASTDoStatement
          ——ASTBlock
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
        ——ASTDoStatement
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTDoStatement: public boolean equals(java.lang.Object)
2. net.sourceforge.pmd.lang.java.ast.ASTDoStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that will be run while the guard evaluates to true.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock && ((ASTBlock) body).isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 14" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 14" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the loop statements of the method.
2. Check whether the loop statement is a do-while loop.
3. Get the condition of the do-while loop.
4. Get the body of the do-while loop.
5. Check whether the body of the do-while loop is empty.
        If the loop statement is a do-while loop and its body is empty, then this test case violates the rule.
        
Based on the test case provided, the first do-while loop has an empty body, which violates the rule. The second do-while loop is non-empty and thus does not violate the rule. Therefore, the number of violations in this test case is 1, as correctly identified.
['Get the loop statements of the method.', 'Check whether the loop statement is a do-while loop.', 'Get the condition of the do-while loop.', 'Get the body of the do-while loop.', 'Check whether the body of the do-while loop is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVoidType', 'ASTVariableDeclarator', 'ASTInfixExpression', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'ASTTypeExpression', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTFieldAccess', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'ASTDoStatement', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the loop statements of the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the loop statement is a do-while loop.* 匹配到的元操作或API：
query: Check whether the loop statement is a do-while loop.
most similar API: Check whether the do statement equals
cosine Similarity: 0.8265252113342285
*Get the condition of the do-while loop.* 匹配到的元操作或API：
logic: Get the condition of the do-while loop.
most similar meta operation: Get the condition of do-while statement
cosine Similarity: 0.9633842706680298
*Get the body of the do-while loop.* 匹配到的元操作或API：
query: Get the body of the do-while loop.
most similar API: get body of do statement
cosine Similarity: 0.865790843963623
*Check whether the body of the do-while loop is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty do..while
public class Foo {
                public void bar() {
                    int i = 0;
                    do {
                    } while (i < 3);
                    do { // neg, nonempty
                        System.out.println(i);
                    } while (i < 3);
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'i')
            ——ASTNumericLiteral
        ——ASTDoStatement
          ——ASTBlock
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral
        ——ASTDoStatement
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'i')
            ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTDoStatement: public boolean equals(java.lang.Object)
2. net.sourceforge.pmd.lang.java.ast.ASTDoStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody()
3. net.sourceforge.pmd.lang.java.ast.ASTDoStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that will be run while the guard evaluates to true.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 14
[ERROR]   "bad 15" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
96
79
82
68
95
78
119
103
84
70
96
80
=========================error_testcase_logics=========================
1. Get the loop variable of for-each loop.
        2. Get the condition of for-each loop.
        3. Check whether the body of for-each loop is empty.
        If the body of the for-each loop is empty, then this test case violates the rule.
        
In this test case, the first for-each loop has an empty body, which is a violation of the rule. The second for-each loop has a non-empty body, so it does not violate the rule.
['Get the loop variable of for-each loop.', 'Get the condition of for-each loop.', 'Check whether the body of for-each loop is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'ASTTypeExpression', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTForeachStatement', 'ASTFieldAccess', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTImportDeclaration', 'ASTTypeArguments', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9849274754524231
*Get the condition of for-each loop.* 匹配到的元操作或API：
logic: Get the condition of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.8536347150802612
*Check whether the body of for-each loop is empty.* 匹配到的元操作或API：
query: Check whether the body of for-each loop is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8055719137191772
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty foreach
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
            ——ASTTypeArguments
              ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'list')
      ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'i')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'i')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForeachStatement: public net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId getVarId()
2. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "ok 8" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
96
79
82
68
95
78
119
103
84
70
96
80
75
61
=========================error_testcase_logics=========================
1. Get the loop variable of for-each loop.
        2. Check whether the body of for-each loop is empty.
        3. Get the loop variable of for-each loop.
        4. Check whether the body of for-each loop is an empty statement.
        5. Get the loop variable of for-each loop.
        6. Check whether the body of for-each loop is nonempty.

Performing the checks:

1. Get the loop variable of for-each loop. (first for-each loop)
   - Loop variable: ignored
2. Check whether the body of for-each loop is empty. (first for-each loop)
   - Body is empty: true
3. Get the loop variable of for-each loop. (second for-each loop)
   - Loop variable: ignored2
4. Check whether the body of for-each loop is an empty statement. (second for-each loop)
   - Body is an empty statement: true
5. Get the loop variable of for-each loop. (third for-each loop)
   - Loop variable: i
6. Check whether the body of for-each loop is nonempty. (third for-each loop)
   - Body is nonempty: true

In this test case, the first two for-each loops have empty bodies, which violates the rule. The third for-each loop is nonempty, so it does not violate the rule.

The number of violating the rule in this test case is: 2
['Get the loop variable of for-each loop.', 'Check whether the body of for-each loop is empty.', 'Get the loop variable of for-each loop.', 'Check whether the body of for-each loop is an empty statement.', 'Get the loop variable of for-each loop.', 'Check whether the body of for-each loop is nonempty.', 'Get the loop variable of for-each loop. (first for-each loop)', 'Check whether the body of for-each loop is empty. (first for-each loop)', 'Get the loop variable of for-each loop. (second for-each loop)', 'Check whether the body of for-each loop is an empty statement. (second for-each loop)', 'Get the loop variable of for-each loop. (third for-each loop)', 'Check whether the body of for-each loop is nonempty. (third for-each loop)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'ASTTypeExpression', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTForeachStatement', 'ASTFieldAccess', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTImportDeclaration', 'ASTTypeArguments', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTEmptyStatement', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9849274754524231
*Check whether the body of for-each loop is empty.* 匹配到的元操作或API：
query: Check whether the body of for-each loop is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.8055719137191772
*Get the loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9849274754524231
*Check whether the body of for-each loop is an empty statement.* 匹配到的元操作或API：
query: Check whether the body of for-each loop is an empty statement.
most similar API: Check whether the empty statement equals
cosine Similarity: 0.8451460599899292
*Get the loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9849274754524231
*Check whether the body of for-each loop is nonempty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop variable of for-each loop. (first for-each loop)* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop. (first for-each loop)
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9659166932106018
*Check whether the body of for-each loop is empty. (first for-each loop)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop variable of for-each loop. (second for-each loop)* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop. (second for-each loop)
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.952373743057251
*Check whether the body of for-each loop is an empty statement. (second for-each loop)* 匹配到的元操作或API：
query: Check whether the body of for-each loop is an empty statement. (second for-each loop)
most similar API: Check whether the empty statement equals
cosine Similarity: 0.8203574419021606
*Get the loop variable of for-each loop. (third for-each loop)* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop. (third for-each loop)
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9372854828834534
*Check whether the body of for-each loop is nonempty. (third for-each loop)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }


This checker is failed(false positive) on this positive test case:
```
// neg, empty foreach with unused var name
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int ignored : list) {
                    }
                    for (int ignored2 : list) ;
                    for (int i : list) { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
            ——ASTTypeArguments
              ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'list')
      ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'ignored')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'ignored2')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTEmptyStatement
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'i')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForeachStatement: public net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId getVarId()
2. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()
3. net.sourceforge.pmd.lang.java.ast.ASTEmptyStatement: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTEmptyStatement emptyStmt = node.getFirstChildOfType(ASTEmptyStatement.class);
        if ((body != null && body.isEmpty()) || (emptyStmt != null && !node.getVarId().getImage().equals("ignored"))) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 8" resulted in wrong number of failures, ==> expected: <0> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 8" resulted in wrong number of failures, ==> expected: <0> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get a loop variable of for-each loop.
        2. Get the body of the for-each loop.
        3. Check whether the body of the for-each loop is empty.
        4. Check whether the for-each loop is followed by a semicolon, indicating an empty body.
        5. Repeat steps 1-4 for each for-each loop in the test case.

Performing these checks:

1. Get a loop variable of for-each loop.
   - Loop variable is `ignored`.
2. Get the body of the for-each loop.
   - Body is `{}`.
3. Check whether the body of the for-each loop is empty.
   - The body is empty.
4. Check whether the for-each loop is followed by a semicolon, indicating an empty body.
   - The for-each loop is not followed by a semicolon, but it has empty braces `{}`, which indicates an empty body.

1. Get a loop variable of for-each loop.
   - Loop variable is `ignored2`.
2. Get the body of the for-each loop.
   - Body is `;`.
3. Check whether the body of the for-each loop is empty.
   - The body is empty.
4. Check whether the for-each loop is followed by a semicolon, indicating an empty body.
   - The for-each loop is followed by a semicolon, indicating an empty body.

1. Get a loop variable of for-each loop.
   - Loop variable is `i`.
2. Get the body of the for-each loop.
   - Body is `{ System.out.println(i); }`.
3. Check whether the body of the for-each loop is empty.
   - The body is not empty.

Based on these checks, there are 2 instances in the test case where the for-each loop body is empty, violating the rule. The third for-each loop does not violate the rule because its body is not empty.
['Get a loop variable of for-each loop.', 'Get the body of the for-each loop.', 'Check whether the body of the for-each loop is empty.', 'Check whether the for-each loop is followed by a semicolon, indicating an empty body.', 'Repeat steps 1-4 for each for-each loop in the test case.', 'Get a loop variable of for-each loop.', 'Get the body of the for-each loop.', 'Check whether the body of the for-each loop is empty.', 'Check whether the for-each loop is followed by a semicolon, indicating an empty body.', 'Get a loop variable of for-each loop.', 'Get the body of the for-each loop.', 'Check whether the body of the for-each loop is empty.', 'Check whether the for-each loop is followed by a semicolon, indicating an empty body.', 'Get a loop variable of for-each loop.', 'Get the body of the for-each loop.', 'Check whether the body of the for-each loop is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'ASTTypeExpression', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTForeachStatement', 'ASTFieldAccess', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTImportDeclaration', 'ASTTypeArguments', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTEmptyStatement', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get a loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get a loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9762570858001709
*Get the body of the for-each loop.* 匹配到的元操作或API：
query: Get the body of the for-each loop.
most similar API: get body of foreach statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8478140830993652
*Check whether the body of the for-each loop is empty.* 匹配到的元操作或API：
query: Check whether the body of the for-each loop is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8085559606552124
*Check whether the for-each loop is followed by a semicolon, indicating an empty body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 1-4 for each for-each loop in the test case.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get a loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get a loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9762570858001709
*Get the body of the for-each loop.* 匹配到的元操作或API：
query: Get the body of the for-each loop.
most similar API: get body of foreach statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8478140830993652
*Check whether the body of the for-each loop is empty.* 匹配到的元操作或API：
query: Check whether the body of the for-each loop is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8085559606552124
*Check whether the for-each loop is followed by a semicolon, indicating an empty body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get a loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get a loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9762570858001709
*Get the body of the for-each loop.* 匹配到的元操作或API：
query: Get the body of the for-each loop.
most similar API: get body of foreach statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8478140830993652
*Check whether the body of the for-each loop is empty.* 匹配到的元操作或API：
query: Check whether the body of the for-each loop is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8085559606552124
*Check whether the for-each loop is followed by a semicolon, indicating an empty body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get a loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get a loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9762570858001709
*Get the body of the for-each loop.* 匹配到的元操作或API：
query: Get the body of the for-each loop.
most similar API: get body of foreach statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8478140830993652
*Check whether the body of the for-each loop is empty.* 匹配到的元操作或API：
query: Check whether the body of the for-each loop is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8085559606552124
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }


This checker is failed(false positive) on this positive test case:
```
// neg, empty foreach with unused var name
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int ignored : list) {
                    }
                    for (int ignored2 : list) ;
                    for (int i : list) { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
            ——ASTTypeArguments
              ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'list')
      ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'ignored')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'ignored2')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTEmptyStatement
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'i')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForeachStatement: public net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId getVarId()
2. net.sourceforge.pmd.lang.java.ast.ASTForeachStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (node.getBody() instanceof ASTEmptyStatement) {
            ASTVariableDeclaratorId id = node.getVarId();
            if (id != null && !"ignored".equals(id.getImage())) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 8" resulted in wrong number of failures, ==> expected: <0> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 8" resulted in wrong number of failures, ==> expected: <0> but was: <2>不通过
=========================error_testcase_logics=========================
To check the adherence of the provided test case to the rule, we will perform the following granular checks:

1. Get the loop variable of for-each loop.
2. Check whether the body of the for-each loop is empty.
3. Get the loop variable of for-each loop.
4. Check whether the body of the for-each loop (semicolon) is empty.
5. Get the loop variable of for-each loop.
6. Check whether the body of the for-each loop is empty.

Let's perform these checks on the provided test case:

1. Get the loop variable of for-each loop.
   - The loop variable is `ignored`.
2. Check whether the body of the for-each loop is empty.
   - The body is `{}`, which is considered empty according to the rule.
3. Get the loop variable of for-each loop.
   - The loop variable is `ignored2`.
4. Check whether the body of the for-each loop (semicolon) is empty.
   - The body is `;`, which is considered empty according to the rule.
5. Get the loop variable of for-each loop.
   - The loop variable is `i`.
6. Check whether the body of the for-each loop is empty.
   - The body is `{ System.out.println(i); }`, which is not empty.

Based on these checks, we can see that the first two for-each loops have empty bodies, which violates the rule. The third for-each loop is not empty, so it does not violate the rule.

Therefore, the number of violations in the test case is: 2
['Get the loop variable of for-each loop.', 'Check whether the body of the for-each loop is empty.', 'Get the loop variable of for-each loop.', 'Check whether the body of the for-each loop (semicolon) is empty.', 'Get the loop variable of for-each loop.', 'Check whether the body of the for-each loop is empty.', 'Get the loop variable of for-each loop.', 'Check whether the body of the for-each loop is empty.', 'Get the loop variable of for-each loop.', 'Check whether the body of the for-each loop (semicolon) is empty.', 'Get the loop variable of for-each loop.', 'Check whether the body of the for-each loop is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'ASTTypeExpression', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTForeachStatement', 'ASTFieldAccess', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTImportDeclaration', 'ASTTypeArguments', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTEmptyStatement', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9849274754524231
*Check whether the body of the for-each loop is empty.* 匹配到的元操作或API：
query: Check whether the body of the for-each loop is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8085559606552124
*Get the loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9849274754524231
*Check whether the body of the for-each loop (semicolon) is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9849274754524231
*Check whether the body of the for-each loop is empty.* 匹配到的元操作或API：
query: Check whether the body of the for-each loop is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8085559606552124
*Get the loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9849274754524231
*Check whether the body of the for-each loop is empty.* 匹配到的元操作或API：
query: Check whether the body of the for-each loop is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8085559606552124
*Get the loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9849274754524231
*Check whether the body of the for-each loop (semicolon) is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop variable of for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9849274754524231
*Check whether the body of the for-each loop is empty.* 匹配到的元操作或API：
query: Check whether the body of the for-each loop is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8085559606552124
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }


This checker is failed(false positive) on this positive test case:
```
// neg, empty foreach with unused var name
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int ignored : list) {
                    }
                    for (int ignored2 : list) ;
                    for (int i : list) { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
            ——ASTTypeArguments
              ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'list')
      ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'ignored')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'ignored2')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTEmptyStatement
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'i')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForeachStatement: public net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId getVarId()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTEmptyStatement emptyStmt = node.getFirstChildOfType(ASTEmptyStatement.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (emptyStmt != null) {
            ASTVariableDeclaratorId varId = node.getVarId();
            if (varId != null && !"ignored".equals(varId.getImage())) {
                addViolation(data, emptyStmt);
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 8" resulted in wrong number of failures, ==> expected: <0> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 8" resulted in wrong number of failures, ==> expected: <0> but was: <2>不通过
=========================error_testcase_logics=========================
Let's break down the code and verify each loop statement for an empty body:

1. Get all loop statements in the method `bar`.
2. Identify the first for-each loop: `for (int ignored : list) { }`.
    3. Get the body of the for-each loop.
    4. Check whether the body of the for-each loop is empty.
3. Identify the second for-each loop: `for (int ignored2 : list) ;`.
    5. Get the body of the for-each loop.
    6. Check whether the body of the for-each loop is empty.
4. Identify the third for-each loop: `for (int i : list) { System.out.println(i); }`.
    7. Get the body of the for-each loop.
    8. Check whether the body of the for-each loop is empty.

Based on the checks:
- The first loop `for (int ignored : list) { }` has an empty block `{}` as its body.
- The second loop `for (int ignored2 : list) ;` uses a semicolon `;` which is considered as an empty statement.
- The third loop `for (int i : list) { System.out.println(i); }` is not empty as it contains a `System.out.println(i);` statement.

So, there are 2 violations of the rule in this test case.
['Get all loop statements in the method `bar`.', 'Identify the first for-each loop: `for (int ignored : list) { }`.', 'Get the body of the for-each loop.', 'Check whether the body of the for-each loop is empty.', 'Identify the second for-each loop: `for (int ignored2 : list) ;`.', 'Get the body of the for-each loop.', 'Check whether the body of the for-each loop is empty.', 'Identify the third for-each loop: `for (int i : list) { System.out.println(i); }`.', 'Get the body of the for-each loop.', 'Check whether the body of the for-each loop is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'ASTTypeExpression', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTForeachStatement', 'ASTFieldAccess', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTImportDeclaration', 'ASTTypeArguments', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTEmptyStatement', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get all loop statements in the method `bar`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Identify the first for-each loop: `for (int ignored : list) { }`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the for-each loop.* 匹配到的元操作或API：
query: Get the body of the for-each loop.
most similar API: get body of foreach statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8478140830993652
*Check whether the body of the for-each loop is empty.* 匹配到的元操作或API：
query: Check whether the body of the for-each loop is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8085559606552124
*Identify the second for-each loop: `for (int ignored2 : list) ;`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the for-each loop.* 匹配到的元操作或API：
query: Get the body of the for-each loop.
most similar API: get body of foreach statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8478140830993652
*Check whether the body of the for-each loop is empty.* 匹配到的元操作或API：
query: Check whether the body of the for-each loop is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8085559606552124
*Identify the third for-each loop: `for (int i : list) { System.out.println(i); }`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the for-each loop.* 匹配到的元操作或API：
query: Get the body of the for-each loop.
most similar API: get body of foreach statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8478140830993652
*Check whether the body of the for-each loop is empty.* 匹配到的元操作或API：
query: Check whether the body of the for-each loop is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8085559606552124
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }


This checker is failed(false positive) on this positive test case:
```
// neg, empty foreach with unused var name
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int ignored : list) {
                    }
                    for (int ignored2 : list) ;
                    for (int i : list) { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
            ——ASTTypeArguments
              ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'list')
      ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'ignored')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'ignored2')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTEmptyStatement
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'i')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForeachStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock && ((ASTBlock) body).isEmpty()) {
            addViolation(data, node);
        } else if (body instanceof ASTEmptyStatement) {
            ASTLocalVariableDeclaration decl = node.getFirstChildOfType(ASTLocalVariableDeclaration.class);
            if (decl != null) {
                ASTVariableDeclaratorId id = decl.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                if (id != null && !"ignored".equals(id.getImage())) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 8" resulted in wrong number of failures, ==> expected: <0> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 8" resulted in wrong number of failures, ==> expected: <0> but was: <2>不通过
=========================error_testcase_logics=========================
To verify the adherence of the provided test case to the rule, we need to perform the following granular checks:

1. Get all for-each loop statements in the method `bar`.
2. Get the loop variable of the first for-each loop.
3. Check whether the loop variable is named `ignored`.
4. Get the body of the first for-each loop.
5. Check whether the body of the first for-each loop is empty.
6. Get the body of the second for-each loop.
7. Check whether the body of the second for-each loop is empty.
8. Get the loop variable of the third for-each loop.
9. Check whether the loop variable is named `ignored2`.
10. Get the body of the third for-each loop.
11. Check whether the body of the third for-each loop is empty.
12. Get the loop variable of the fourth for-each loop.
13. Check whether the loop variable is named `i`.
14. Get the body of the fourth for-each loop.
15. Check whether the body of the fourth for-each loop is empty.

Performing these checks:

1. Get all for-each loop statements in the method `bar`.
   - There are three for-each loops in the method `bar`.

2. Get the loop variable of the first for-each loop.
   - The loop variable of the first for-each loop is `ignored`.

3. Check whether the loop variable is named `ignored`.
   - The loop variable is named `ignored`.

4. Get the body of the first for-each loop.
   - The body of the first for-each loop is `{}`.

5. Check whether the body of the first for-each loop is empty.
   - The body of the first for-each loop is empty.

6. Get the body of the second for-each loop.
   - The body of the second for-each loop is `;`.

7. Check whether the body of the second for-each loop is empty.
   - The body of the second for-each loop is considered empty as it only consists of a semicolon.

8. Get the loop variable of the third for-each loop.
   - The loop variable of the third for-each loop is `ignored2`.

9. Check whether the loop variable is named `ignored2`.
   - The loop variable is named `ignored2`.

10. Get the body of the third for-each loop.
    - The body of the third for-each loop is `;`.

11. Check whether the body of the third for-each loop is empty.
    - The body of the third for-each loop is considered empty as it only consists of a semicolon.

12. Get the loop variable of the fourth for-each loop.
    - The loop variable of the fourth for-each loop is `i`.

13. Check whether the loop variable is named `i`.
    - The loop variable is named `i`.

14. Get the body of the fourth for-each loop.
    - The body of the fourth for-each loop is `{ System.out.println(i); }`.

15. Check whether the body of the fourth for-each loop is empty.
    - The body of the fourth for-each loop is not empty as it contains `System.out.println(i);`.

Based on these checks, the first two for-each loops have empty bodies, and the third for-each loop also has an empty body (denoted by a semicolon). The fourth for-each loop has a non-empty body. Therefore, the number of violating the rule in this test case is: 3.

However, the comment states that the number of violations is 0, which seems incorrect based on the provided code. The correct number of violations should be 3.
['Get all for-each loop statements in the method `bar`.', 'Get the loop variable of the first for-each loop.', 'Check whether the loop variable is named `ignored`.', 'Get the body of the first for-each loop.', 'Check whether the body of the first for-each loop is empty.', 'Get the body of the second for-each loop.', 'Check whether the body of the second for-each loop is empty.', 'Get the loop variable of the third for-each loop.', 'Check whether the loop variable is named `ignored2`.', 'Get the body of the third for-each loop.', 'Check whether the body of the third for-each loop is empty.', 'Get the loop variable of the fourth for-each loop.', 'Check whether the loop variable is named `i`.', 'Get the body of the fourth for-each loop.', 'Check whether the body of the fourth for-each loop is empty.', 'Get all for-each loop statements in the method `bar`.', 'Get the loop variable of the first for-each loop.', 'Check whether the loop variable is named `ignored`.', 'Get the body of the first for-each loop.', 'Check whether the body of the first for-each loop is empty.', 'Get the body of the second for-each loop.', 'Check whether the body of the second for-each loop is empty.', 'Get the loop variable of the third for-each loop.', 'Check whether the loop variable is named `ignored2`.', 'Get the body of the third for-each loop.', 'Check whether the body of the third for-each loop is empty.', 'Get the loop variable of the fourth for-each loop.', 'Check whether the loop variable is named `i`.', 'Get the body of the fourth for-each loop.', 'Check whether the body of the fourth for-each loop is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'ASTTypeExpression', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTForeachStatement', 'ASTFieldAccess', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTImportDeclaration', 'ASTTypeArguments', 'ASTFormalParameters', 'ASTPrimitiveType', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTEmptyStatement', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get all for-each loop statements in the method `bar`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop variable of the first for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of the first for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.947660505771637
*Check whether the loop variable is named `ignored`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the first for-each loop.* 匹配到的元操作或API：
query: Get the body of the first for-each loop.
most similar API: get body of foreach statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8237611651420593
*Check whether the body of the first for-each loop is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the second for-each loop.* 匹配到的元操作或API：
query: Get the body of the second for-each loop.
most similar API: get body of foreach statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.817691445350647
*Check whether the body of the second for-each loop is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop variable of the third for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of the third for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9136438369750977
*Check whether the loop variable is named `ignored2`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the third for-each loop.* 匹配到的元操作或API：
query: Get the body of the third for-each loop.
most similar API: get body of foreach statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8050040006637573
*Check whether the body of the third for-each loop is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop variable of the fourth for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of the fourth for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9125688076019287
*Check whether the loop variable is named `i`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the fourth for-each loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the fourth for-each loop is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all for-each loop statements in the method `bar`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop variable of the first for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of the first for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.947660505771637
*Check whether the loop variable is named `ignored`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the first for-each loop.* 匹配到的元操作或API：
query: Get the body of the first for-each loop.
most similar API: get body of foreach statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8237611651420593
*Check whether the body of the first for-each loop is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the second for-each loop.* 匹配到的元操作或API：
query: Get the body of the second for-each loop.
most similar API: get body of foreach statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.817691445350647
*Check whether the body of the second for-each loop is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop variable of the third for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of the third for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9136438369750977
*Check whether the loop variable is named `ignored2`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the third for-each loop.* 匹配到的元操作或API：
query: Get the body of the third for-each loop.
most similar API: get body of foreach statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8050040006637573
*Check whether the body of the third for-each loop is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop variable of the fourth for-each loop.* 匹配到的元操作或API：
logic: Get the loop variable of the fourth for-each loop.
most similar meta operation: Get the loop variable of for-each loop
cosine Similarity: 0.9125688076019287
*Check whether the loop variable is named `i`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of the fourth for-each loop.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of the fourth for-each loop is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }


This checker is failed(false positive) on this positive test case:
```
// neg, empty foreach with unused var name
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int ignored : list) {
                    }
                    for (int ignored2 : list) ;
                    for (int i : list) { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
            ——ASTTypeArguments
              ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'list')
      ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'ignored')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'ignored2')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTEmptyStatement
        ——ASTForeachStatement
          ——ASTLocalVariableDeclaration
            ——ASTModifierList
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTVariableDeclarator
              ——ASTVariableDeclaratorId (declared variable name = 'i')
          ——ASTVariableAccess (referenced variable name = 'list')
          ——ASTBlock
            ——ASTExpressionStatement
              ——ASTMethodCall (called method name = 'println')
                ——ASTFieldAccess
                  ——ASTTypeExpression
                    ——ASTClassOrInterfaceType (this is a class type)
                ——ASTArgumentList (size = 1)
                  ——ASTVariableAccess (referenced variable name = 'i')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTForeachStatement: public net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId getVarId()
2. net.sourceforge.pmd.lang.java.ast.ASTForeachStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (node.getBody() instanceof ASTEmptyStatement) {
            ASTVariableDeclaratorId id = node.getVarId();
            if (id != null && !"ignored".equals(id.getImage())) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 8" resulted in wrong number of failures, ==> expected: <0> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 8" resulted in wrong number of failures, ==> expected: <0> but was: <2>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 8
[ERROR]   "bad 16" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
100
82
79
65
114
98
107
91
=========================error_testcase_logics=========================
1. Get the loop variable of for loop.
        2. Get the condition of while statement.
        3. Get the body of while statement.
        4. Check whether the body of while statement is empty.
        5. Get the condition of do-while statement.
        6. Get the body of do-while statement.
        7. Check whether the body of do-while statement is empty.
        8. Get the body of synchronized statement.
        9. Check whether the body of synchronized statement is empty.
        10. Get the body of if statement.
        11. Check whether the body of if statement is empty.
        12. Get the else branch of if statement.
        13. Check whether the else branch of if statement is empty.
        14. Get the body of switch statement.
        15. Check whether the body of switch statement is empty.
        16. Get the body of try statement.
        17. Check whether the body of try statement is empty.
        18. Get the body of finally clause of try statement.
        19. Check whether the body of finally clause of try statement is empty.
        20. Get the body of initializer.
        21. Check whether the body of initializer is empty.
        22. Get the body of block used as statement.
        23. Check whether the body of block used as statement is empty.

In this specific test case:
2. Get the condition of while statement.
3. Get the body of while statement.
4. Check whether the body of while statement is empty.

The first while loop's body is empty, which violates the rule. The second while loop's body is not empty, so it does not violate the rule. Therefore, there is one violation in this test case.
['Get the loop variable of for loop.', 'Get the condition of while statement.', 'Get the body of while statement.', 'Check whether the body of while statement is empty.', 'Get the condition of do-while statement.', 'Get the body of do-while statement.', 'Check whether the body of do-while statement is empty.', 'Get the body of synchronized statement.', 'Check whether the body of synchronized statement is empty.', 'Get the body of if statement.', 'Check whether the body of if statement is empty.', 'Get the else branch of if statement.', 'Check whether the else branch of if statement is empty.', 'Get the body of switch statement.', 'Check whether the body of switch statement is empty.', 'Get the body of try statement.', 'Check whether the body of try statement is empty.', 'Get the body of finally clause of try statement.', 'Check whether the body of finally clause of try statement is empty.', 'Get the body of initializer.', 'Check whether the body of initializer is empty.', 'Get the body of block used as statement.', 'Check whether the body of block used as statement is empty.', 'Get the condition of while statement.', 'Get the body of while statement.', 'Check whether the body of while statement is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ASTWhileStatement', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTBooleanLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the loop variable of for loop.* 匹配到的元操作或API：
logic: Get the loop variable of for loop.
most similar meta operation: Get a loop variable of for loop
cosine Similarity: 0.975679874420166
*Get the condition of while statement.* 匹配到的元操作或API：
logic: Get the condition of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.9850377440452576
*Get the body of while statement.* 匹配到的元操作或API：
logic: Get the body of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.8570233583450317
*Check whether the body of while statement is empty.* 匹配到的元操作或API：
query: Check whether the body of while statement is empty.
most similar API: get body of while statement
cosine Similarity: 0.8571988940238953
*Get the condition of do-while statement.* 匹配到的元操作或API：
logic: Get the condition of do-while statement.
most similar meta operation: Get the condition of do-while statement
cosine Similarity: 0.9866269826889038
*Get the body of do-while statement.* 匹配到的元操作或API：
query: Get the body of do-while statement.
most similar API: get body of while statement
cosine Similarity: 0.9322226047515869
*Check whether the body of do-while statement is empty.* 匹配到的元操作或API：
query: Check whether the body of do-while statement is empty.
most similar API: get body of while statement
cosine Similarity: 0.8107189536094666
*Get the body of synchronized statement.* 匹配到的元操作或API：
logic: Get the body of synchronized statement.
most similar meta operation: Get the lock of synchronized statement
cosine Similarity: 0.8570014238357544
*Check whether the body of synchronized statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of if statement.* 匹配到的元操作或API：
query: Get the body of if statement.
most similar API: get body of while statement
cosine Similarity: 0.8392339944839478
*Check whether the body of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8571328520774841
*Get the else branch of if statement.* 匹配到的元操作或API：
logic: Get the else branch of if statement.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.989610493183136
*Check whether the else branch of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the else branch of if statement is empty.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9108617305755615
*Get the body of switch statement.* 匹配到的元操作或API：
logic: Get the body of switch statement.
most similar meta operation: Get a branch of switch statement
cosine Similarity: 0.8521517515182495
*Check whether the body of switch statement is empty.* 匹配到的元操作或API：
query: Check whether the body of switch statement is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8093868494033813
*Get the body of try statement.* 匹配到的元操作或API：
query: Get the body of try statement.
most similar API: get body of while statement
cosine Similarity: 0.8471757769584656
*Check whether the body of try statement is empty.* 匹配到的元操作或API：
query: Check whether the body of try statement is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8019887208938599
*Get the body of finally clause of try statement.* 匹配到的元操作或API：
logic: Get the body of finally clause of try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.8654302954673767
*Check whether the body of finally clause of try statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of initializer.* 匹配到的元操作或API：
query: Get the body of initializer.
most similar API: get body of class or interface
cosine Similarity: 0.8195229768753052
*Check whether the body of initializer is empty.* 匹配到的元操作或API：
query: Check whether the body of initializer is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8729528784751892
*Get the body of block used as statement.* 匹配到的元操作或API：
query: Get the body of block used as statement.
most similar API: get ast info of block
cosine Similarity: 0.8184911608695984
*Check whether the body of block used as statement is empty.* 匹配到的元操作或API：
query: Check whether the body of block used as statement is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.9012241363525391
*Get the condition of while statement.* 匹配到的元操作或API：
logic: Get the condition of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.9850377440452576
*Get the body of while statement.* 匹配到的元操作或API：
logic: Get the body of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.8570233583450317
*Check whether the body of while statement is empty.* 匹配到的元操作或API：
query: Check whether the body of while statement is empty.
most similar API: get body of while statement
cosine Similarity: 0.8571988940238953
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty while
public class Foo {
                public void bar() {
                    while (true == true) {
                    }
                    while (true == true) {
                        String x = "";
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTWhileStatement
          ——ASTInfixExpression
            ——ASTBooleanLiteral
            ——ASTBooleanLiteral
          ——ASTBlock
        ——ASTWhileStatement
          ——ASTInfixExpression
            ——ASTBooleanLiteral
            ——ASTBooleanLiteral
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'x')
                ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public net.sourceforge.pmd.lang.ast.NodeStream<ASTVariableDeclaratorId> getLoopVariables(net.sourceforge.pmd.lang.java.ast.ASTForStatement)
2. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
3. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
4. net.sourceforge.pmd.lang.java.ast.ASTDoStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody()
5. net.sourceforge.pmd.lang.java.ast.ASTSynchronizedStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLockExpression()
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
7. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch()
8. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
9. net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTSwitchBranch> getBranches()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()
11. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()
12. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTTypeBody getBody(), //Returns the body of this type declaration.
13. net.sourceforge.pmd.lang.java.ast.ASTBlock: public net.sourceforge.pmd.lang.ast.AstInfo<RootNode> getAstInfo()
14. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 16" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 16" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the name of the class.
2. Get all methods declared in class.
3. Get the name of method.
4. Check whether the method is bar.
5. Get all statements in method.
6. Get a loop statement of for loop/while loop/do-while loop.
7. Check whether the loop statement is a while statement.
8. Get the condition of while statement.
9. Check whether the condition is true == true.
10. Get the body of while statement.
11. Check whether the body of while statement is empty.

The above checks will determine if the while loop with the condition `true == true` has an empty body. If it does, then this test case violates the rule.

1. Repeat steps 6 to 11 for the next while loop to ensure it does not have an empty body.

In this test case, the first while loop will be identified as having an empty body, thus violating the rule. The second while loop, which initializes a local variable, does not violate the rule.
['Get the name of the class.', 'Get all methods declared in class.', 'Get the name of method.', 'Check whether the method is bar.', 'Get all statements in method.', 'Get a loop statement of for loop/while loop/do-while loop.', 'Check whether the loop statement is a while statement.', 'Get the condition of while statement.', 'Check whether the condition is true == true.', 'Get the body of while statement.', 'Check whether the body of while statement is empty.', 'Repeat steps 6 to 11 for the next while loop to ensure it does not have an empty body.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ASTWhileStatement', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTBooleanLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of the class.* 匹配到的元操作或API：
logic: Get the name of the class.
most similar meta operation: Get the name of class
cosine Similarity: 0.968898594379425
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is bar.* 匹配到的元操作或API：
query: Check whether the method is bar.
most similar API: Check whether is test method
cosine Similarity: 0.832916259765625
*Get all statements in method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get a loop statement of for loop/while loop/do-while loop.* 匹配到的元操作或API：
query: Get a loop statement of for loop/while loop/do-while loop.
most similar API: get body of while statement: Returns the statement that represents the body of this loop.
cosine Similarity: 0.8206522464752197
*Check whether the loop statement is a while statement.* 匹配到的元操作或API：
query: Check whether the loop statement is a while statement.
most similar API: Check whether the while statement equals
cosine Similarity: 0.8921941518783569
*Get the condition of while statement.* 匹配到的元操作或API：
logic: Get the condition of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.9850377440452576
*Check whether the condition is true == true.* 匹配到的元操作或API：
query: Check whether the condition is true == true.
most similar API: Check whether the boolean literal equals
cosine Similarity: 0.8127687573432922
*Get the body of while statement.* 匹配到的元操作或API：
logic: Get the body of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.8570233583450317
*Check whether the body of while statement is empty.* 匹配到的元操作或API：
query: Check whether the body of while statement is empty.
most similar API: get body of while statement
cosine Similarity: 0.8571988940238953
*Repeat steps 6 to 11 for the next while loop to ensure it does not have an empty body.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty while
public class Foo {
                public void bar() {
                    while (true == true) {
                    }
                    while (true == true) {
                        String x = "";
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTWhileStatement
          ——ASTInfixExpression
            ——ASTBooleanLiteral
            ——ASTBooleanLiteral
          ——ASTBlock
        ——ASTWhileStatement
          ——ASTInfixExpression
            ——ASTBooleanLiteral
            ——ASTBooleanLiteral
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'x')
                ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
5. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
6. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public boolean equals(java.lang.Object)
7. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
8. net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTStatement body = node.getBody();
        if (body instanceof ASTBlock && ((ASTBlock) body).isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 16" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 16" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the condition of while statement.
2. Check whether the body of while statement is empty.
3. Get the condition of while statement.
4. Check whether the body of while statement is empty.

The test case contains two while statements. We need to check each one:

1. Get the condition of while statement. (First while statement)
   - Condition is `true == true`.
2. Check whether the body of while statement is empty. (First while statement)
   - The body is empty, so this violates the rule.
3. Get the condition of while statement. (Second while statement)
   - Condition is `true == true`.
4. Check whether the body of while statement is empty. (Second while statement)
   - The body is not empty as it contains `String x = "";`, so this does not violate the rule.

Therefore, the number of violating the rule in this test case is: 1
['Get the condition of while statement.', 'Check whether the body of while statement is empty.', 'Get the condition of while statement.', 'Check whether the body of while statement is empty.', 'Get the condition of while statement. (First while statement)', 'Check whether the body of while statement is empty. (First while statement)', 'Get the condition of while statement. (Second while statement)', 'Check whether the body of while statement is empty. (Second while statement)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ASTWhileStatement', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTBooleanLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of while statement.* 匹配到的元操作或API：
logic: Get the condition of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.9850377440452576
*Check whether the body of while statement is empty.* 匹配到的元操作或API：
query: Check whether the body of while statement is empty.
most similar API: get body of while statement
cosine Similarity: 0.8571988940238953
*Get the condition of while statement.* 匹配到的元操作或API：
logic: Get the condition of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.9850377440452576
*Check whether the body of while statement is empty.* 匹配到的元操作或API：
query: Check whether the body of while statement is empty.
most similar API: get body of while statement
cosine Similarity: 0.8571988940238953
*Get the condition of while statement. (First while statement)* 匹配到的元操作或API：
logic: Get the condition of while statement. (First while statement)
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.9471314549446106
*Check whether the body of while statement is empty. (First while statement)* 匹配到的元操作或API：
query: Check whether the body of while statement is empty. (First while statement)
most similar API: get body of while statement
cosine Similarity: 0.8553191423416138
*Get the condition of while statement. (Second while statement)* 匹配到的元操作或API：
logic: Get the condition of while statement. (Second while statement)
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.9401178956031799
*Check whether the body of while statement is empty. (Second while statement)* 匹配到的元操作或API：
query: Check whether the body of while statement is empty. (Second while statement)
most similar API: get body of while statement
cosine Similarity: 0.8460816144943237
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty while
public class Foo {
                public void bar() {
                    while (true == true) {
                    }
                    while (true == true) {
                        String x = "";
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTWhileStatement
          ——ASTInfixExpression
            ——ASTBooleanLiteral
            ——ASTBooleanLiteral
          ——ASTBlock
        ——ASTWhileStatement
          ——ASTInfixExpression
            ——ASTBooleanLiteral
            ——ASTBooleanLiteral
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'x')
                ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 16" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 16" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the loop variable of for loop.
        2. Get the condition of while statement.
        3. Get the condition of do-while statement.
        4. Get the body of while statement.
        5. Check whether the body of while statement is empty.
        6. Get the body of do-while statement.
        7. Check whether the body of do-while statement is empty.
        8. Get the body of for statement.
        9. Check whether the body of for statement is empty.
        10. Get the catch branch of try statement.
        11. Check whether the catch branch of try statement is empty.
        12. Get the finally branch of try statement.
        13. Check whether the finally branch of try statement is empty.
        14. Get the body of switch statement.
        15. Check whether the body of switch statement is empty.
        16. Get the body of synchronized statement.
        17. Check whether the body of synchronized statement is empty.
        18. Get the body of if statement.
        19. Check whether the body of if statement is empty.
        20. Get the else branch of if statement.
        21. Check whether the else branch of if statement is empty.
        22. Get the body of initializer block.
        23. Check whether the body of initializer block is empty.

In this test case:
1. Get the condition of while statement. (Condition is `true == true`)
2. Get the body of while statement. (Body is `{}`)
3. Check whether the body of while statement is empty. (This checks the first while loop and finds that the body is indeed empty, thus violating the rule.)
4. Get the body of while statement. (Body is `{ String x = ""; }`)
5. Check whether the body of while statement is empty. (This checks the second while loop and finds that the body is not empty, thus not violating the rule.)

The number of violations in this test case is 1, as indicated.
['Get the loop variable of for loop.', 'Get the condition of while statement.', 'Get the condition of do-while statement.', 'Get the body of while statement.', 'Check whether the body of while statement is empty.', 'Get the body of do-while statement.', 'Check whether the body of do-while statement is empty.', 'Get the body of for statement.', 'Check whether the body of for statement is empty.', 'Get the catch branch of try statement.', 'Check whether the catch branch of try statement is empty.', 'Get the finally branch of try statement.', 'Check whether the finally branch of try statement is empty.', 'Get the body of switch statement.', 'Check whether the body of switch statement is empty.', 'Get the body of synchronized statement.', 'Check whether the body of synchronized statement is empty.', 'Get the body of if statement.', 'Check whether the body of if statement is empty.', 'Get the else branch of if statement.', 'Check whether the else branch of if statement is empty.', 'Get the body of initializer block.', 'Check whether the body of initializer block is empty.', 'Get the condition of while statement. (Condition is `true == true`)', 'Get the body of while statement. (Body is `{}`)', 'Check whether the body of while statement is empty. (This checks the first while loop and finds that the body is indeed empty, thus violating the rule.)', 'Get the body of while statement. (Body is `{ String x = ""; }`)', 'Check whether the body of while statement is empty. (This checks the second while loop and finds that the body is not empty, thus not violating the rule.)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ASTWhileStatement', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTBooleanLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the loop variable of for loop.* 匹配到的元操作或API：
logic: Get the loop variable of for loop.
most similar meta operation: Get a loop variable of for loop
cosine Similarity: 0.975679874420166
*Get the condition of while statement.* 匹配到的元操作或API：
logic: Get the condition of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.9850377440452576
*Get the condition of do-while statement.* 匹配到的元操作或API：
logic: Get the condition of do-while statement.
most similar meta operation: Get the condition of do-while statement
cosine Similarity: 0.9866269826889038
*Get the body of while statement.* 匹配到的元操作或API：
logic: Get the body of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.8570233583450317
*Check whether the body of while statement is empty.* 匹配到的元操作或API：
query: Check whether the body of while statement is empty.
most similar API: get body of while statement
cosine Similarity: 0.8571988940238953
*Get the body of do-while statement.* 匹配到的元操作或API：
query: Get the body of do-while statement.
most similar API: get body of while statement
cosine Similarity: 0.9322226047515869
*Check whether the body of do-while statement is empty.* 匹配到的元操作或API：
query: Check whether the body of do-while statement is empty.
most similar API: get body of while statement
cosine Similarity: 0.8107189536094666
*Get the body of for statement.* 匹配到的元操作或API：
query: Get the body of for statement.
most similar API: get body of while statement
cosine Similarity: 0.8151957988739014
*Check whether the body of for statement is empty.* 匹配到的元操作或API：
query: Check whether the body of for statement is empty.
most similar API: Check whether the string literal is empty
cosine Similarity: 0.8216725587844849
*Get the catch branch of try statement.* 匹配到的元操作或API：
logic: Get the catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9813414812088013
*Check whether the catch branch of try statement is empty.* 匹配到的元操作或API：
logic: Check whether the catch branch of try statement is empty.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8558295965194702
*Get the finally branch of try statement.* 匹配到的元操作或API：
logic: Get the finally branch of try statement.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.9912986755371094
*Check whether the finally branch of try statement is empty.* 匹配到的元操作或API：
logic: Check whether the finally branch of try statement is empty.
most similar meta operation: Get the finally branch of try statement
cosine Similarity: 0.879764199256897
*Get the body of switch statement.* 匹配到的元操作或API：
logic: Get the body of switch statement.
most similar meta operation: Get a branch of switch statement
cosine Similarity: 0.8521517515182495
*Check whether the body of switch statement is empty.* 匹配到的元操作或API：
query: Check whether the body of switch statement is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8093868494033813
*Get the body of synchronized statement.* 匹配到的元操作或API：
logic: Get the body of synchronized statement.
most similar meta operation: Get the lock of synchronized statement
cosine Similarity: 0.8570014238357544
*Check whether the body of synchronized statement is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of if statement.* 匹配到的元操作或API：
query: Get the body of if statement.
most similar API: get body of while statement
cosine Similarity: 0.8392339944839478
*Check whether the body of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8571328520774841
*Get the else branch of if statement.* 匹配到的元操作或API：
logic: Get the else branch of if statement.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.989610493183136
*Check whether the else branch of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the else branch of if statement is empty.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9108617305755615
*Get the body of initializer block.* 匹配到的元操作或API：
query: Get the body of initializer block.
most similar API: get body of class or interface
cosine Similarity: 0.8036789894104004
*Check whether the body of initializer block is empty.* 匹配到的元操作或API：
query: Check whether the body of initializer block is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8572171926498413
*Get the condition of while statement. (Condition is `true == true`)* 匹配到的元操作或API：
logic: Get the condition of while statement. (Condition is `true == true`)
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.9129581451416016
*Get the body of while statement. (Body is `{}`)* 匹配到的元操作或API：
query: Get the body of while statement. (Body is `{}`)
most similar API: get body of while statement
cosine Similarity: 0.9481326341629028
*Check whether the body of while statement is empty. (This checks the first while loop and finds that the body is indeed empty, thus violating the rule.)* 匹配到的元操作或API：
query: Check whether the body of while statement is empty. (This checks the first while loop and finds that the body is indeed empty, thus violating the rule.)
most similar API: get body of while statement
cosine Similarity: 0.8082395792007446
*Get the body of while statement. (Body is `{ String x = ""; }`)* 匹配到的元操作或API：
query: Get the body of while statement. (Body is `{ String x = ""; }`)
most similar API: get body of while statement
cosine Similarity: 0.9371758699417114
*Check whether the body of while statement is empty. (This checks the second while loop and finds that the body is not empty, thus not violating the rule.)* 匹配到的元操作或API：
query: Check whether the body of while statement is empty. (This checks the second while loop and finds that the body is not empty, thus not violating the rule.)
most similar API: get body of while statement
cosine Similarity: 0.8132957220077515
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty while
public class Foo {
                public void bar() {
                    while (true == true) {
                    }
                    while (true == true) {
                        String x = "";
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTWhileStatement
          ——ASTInfixExpression
            ——ASTBooleanLiteral
            ——ASTBooleanLiteral
          ——ASTBlock
        ——ASTWhileStatement
          ——ASTInfixExpression
            ——ASTBooleanLiteral
            ——ASTBooleanLiteral
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'x')
                ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public net.sourceforge.pmd.lang.ast.NodeStream<ASTVariableDeclaratorId> getLoopVariables(net.sourceforge.pmd.lang.java.ast.ASTForStatement)
2. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
3. net.sourceforge.pmd.lang.java.ast.ASTDoStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody()
4. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty(), //True if the constant value is empty. Does not necessarily compute the constant value.
6. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
7. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.java.ast.ASTFinallyClause getFinallyClause()
8. net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTSwitchBranch> getBranches()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()
10. net.sourceforge.pmd.lang.java.ast.ASTSynchronizedStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getLockExpression()
11. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
12. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch()
13. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
14. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTTypeBody getBody(), //Returns the body of this type declaration.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 16" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 16" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the condition of while statement.
2. Get the body of while statement.
3. Check whether the body of while statement is empty.
4. Get the condition of while statement.
5. Get the body of while statement.
6. Check whether the body of while statement is empty.

Based on the provided test case, the first `while` loop has an empty body, so it violates the rule. The second `while` loop has a non-empty body, so it does not violate the rule. Therefore, the number of violations is 1.
['Get the condition of while statement.', 'Get the body of while statement.', 'Check whether the body of while statement is empty.', 'Get the condition of while statement.', 'Get the body of while statement.', 'Check whether the body of while statement is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ASTWhileStatement', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTBooleanLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of while statement.* 匹配到的元操作或API：
logic: Get the condition of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.9850377440452576
*Get the body of while statement.* 匹配到的元操作或API：
logic: Get the body of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.8570233583450317
*Check whether the body of while statement is empty.* 匹配到的元操作或API：
query: Check whether the body of while statement is empty.
most similar API: get body of while statement
cosine Similarity: 0.8571988940238953
*Get the condition of while statement.* 匹配到的元操作或API：
logic: Get the condition of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.9850377440452576
*Get the body of while statement.* 匹配到的元操作或API：
logic: Get the body of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.8570233583450317
*Check whether the body of while statement is empty.* 匹配到的元操作或API：
query: Check whether the body of while statement is empty.
most similar API: get body of while statement
cosine Similarity: 0.8571988940238953
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// pos, empty while
public class Foo {
                public void bar() {
                    while (true == true) {
                    }
                    while (true == true) {
                        String x = "";
                    }
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTWhileStatement
          ——ASTInfixExpression
            ——ASTBooleanLiteral
            ——ASTBooleanLiteral
          ——ASTBlock
        ——ASTWhileStatement
          ——ASTInfixExpression
            ——ASTBooleanLiteral
            ——ASTBooleanLiteral
          ——ASTBlock
            ——ASTLocalVariableDeclaration
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclarator
                ——ASTVariableDeclaratorId (declared variable name = 'x')
                ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 16" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 16" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 16
[ERROR]   "bad 17" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
79
65
107
91
75
61
=========================error_testcase_logics=========================
1. Get the loop variable of for loop.
        2. Get the condition of while statement.
        3. Check whether the condition of while statement is true.
        4. Get the body of while statement.
        5. Check whether the body of while statement is empty.

Given the test case, the steps to ascertain adherence to the rule are as follows:

1. Get the name of method.
2. Check whether the method name is bar.
3. Get the loop variable of for loop.
   - Not applicable, as there is no for loop in the provided test case.
4. Get the condition of while statement.
5. Check whether the condition of while statement is true.
6. Get the body of while statement.
7. Check whether the body of while statement is empty.
   - The body of the while statement is indeed an empty statement (`;`), so this test case violates the rule.
   
Therefore, the number of violations in this test case is 1.
['Get the loop variable of for loop.', 'Get the condition of while statement.', 'Check whether the condition of while statement is true.', 'Get the body of while statement.', 'Check whether the body of while statement is empty.', 'Get the name of method.', 'Check whether the method name is bar.', 'Get the loop variable of for loop.', 'Get the condition of while statement.', 'Check whether the condition of while statement is true.', 'Get the body of while statement.', 'Check whether the body of while statement is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ASTWhileStatement', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTBooleanLiteral', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTEmptyStatement', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the loop variable of for loop.* 匹配到的元操作或API：
logic: Get the loop variable of for loop.
most similar meta operation: Get a loop variable of for loop
cosine Similarity: 0.975679874420166
*Get the condition of while statement.* 匹配到的元操作或API：
logic: Get the condition of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.9850377440452576
*Check whether the condition of while statement is true.* 匹配到的元操作或API：
logic: Check whether the condition of while statement is true.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.8978612422943115
*Get the body of while statement.* 匹配到的元操作或API：
logic: Get the body of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.8570233583450317
*Check whether the body of while statement is empty.* 匹配到的元操作或API：
query: Check whether the body of while statement is empty.
most similar API: get body of while statement
cosine Similarity: 0.8571988940238953
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name is bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the loop variable of for loop.* 匹配到的元操作或API：
logic: Get the loop variable of for loop.
most similar meta operation: Get a loop variable of for loop
cosine Similarity: 0.975679874420166
*Get the condition of while statement.* 匹配到的元操作或API：
logic: Get the condition of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.9850377440452576
*Check whether the condition of while statement is true.* 匹配到的元操作或API：
logic: Check whether the condition of while statement is true.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.8978612422943115
*Get the body of while statement.* 匹配到的元操作或API：
logic: Get the body of while statement.
most similar meta operation: Get the condition of while statement
cosine Similarity: 0.8570233583450317
*Check whether the body of while statement is empty.* 匹配到的元操作或API：
query: Check whether the body of while statement is empty.
most similar API: get body of while statement
cosine Similarity: 0.8571988940238953
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }


This checker is failed(false negative) on this negative test case:
```
// while(true);
public class Foo {
                public void bar() {
                    while (true);
                }
            }
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTWhileStatement
          ——ASTBooleanLiteral
          ——ASTEmptyStatement


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public net.sourceforge.pmd.lang.ast.NodeStream<ASTVariableDeclaratorId> getLoopVariables(net.sourceforge.pmd.lang.java.ast.ASTForStatement)
2. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
3. net.sourceforge.pmd.lang.java.ast.ASTWhileStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getBody(), //Returns the statement that represents the body of this loop.
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "bad 18" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
100
82
84
69
119
103
=========================error_testcase_logics=========================
1. Get the name of method.
        2. Get the body of method.
        3. Get a control statement in method body.
        4. Check whether the control statement is an if statement.
        5. Get the condition of if statement.
        6. Get the body of if statement.
        7. Check whether the body of if statement is empty.
        If the body of the if statement is empty, then this test case violates the rule.
        8. Count the number of empty control statements.
        The number of violating the rule in this test case is: 1
['Get the name of method.', 'Get the body of method.', 'Get a control statement in method body.', 'Check whether the control statement is an if statement.', 'Get the condition of if statement.', 'Get the body of if statement.', 'Check whether the body of if statement is empty.', 'Count the number of empty control statements.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752806425094604
*Get a control statement in method body.* 匹配到的元操作或API：
query: Get a control statement in method body.
most similar API: get body of method
cosine Similarity: 0.8030452132225037
*Check whether the control statement is an if statement.* 匹配到的元操作或API：
query: Check whether the control statement is an if statement.
most similar API: Check whether the if statement equals
cosine Similarity: 0.8228201866149902
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Get the body of if statement.* 匹配到的元操作或API：
query: Get the body of if statement.
most similar API: get text of if statement
cosine Similarity: 0.8786208033561707
*Check whether the body of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8571328520774841
*Count the number of empty control statements.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }


This checker is failed(false negative) on this negative test case:
```
// one empty if statement
public class Foo {
    void bar(int x) {
        if (x > 2) {
        }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
3. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
5. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.document.Chars getText()
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 18" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 18" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Check whether the if statement has else branch.
2. Get the condition of if statement.
3. Check whether the body of if statement is empty.
4. Get the else branch of if statement.
5. Check whether the else branch of if statement is empty.
6. Get the body of the else branch of if statement.
7. Check whether the body of the else branch is empty.
8. Check whether the if statement is in a method.
9. Get the method that contains the if statement.
10. Check whether the method has initializers.
11. Check whether any initializer is empty.
12. Get the class that contains the if statement.
13. Check whether the class has initializers.
14. Check whether any initializer is empty.
15. Check whether the class has static blocks.
16. Check whether any static block is empty.

In this specific test case:
1. Check whether the if statement has else branch. (No else branch)
2. Get the condition of if statement. (Condition is `x > 2`)
3. Check whether the body of if statement is empty. (Yes, the body is empty)

Thus, the number of violating the rule in this test case is indeed 1.
['Check whether the if statement has else branch.', 'Get the condition of if statement.', 'Check whether the body of if statement is empty.', 'Get the else branch of if statement.', 'Check whether the else branch of if statement is empty.', 'Get the body of the else branch of if statement.', 'Check whether the body of the else branch is empty.', 'Check whether the if statement is in a method.', 'Get the method that contains the if statement.', 'Check whether the method has initializers.', 'Check whether any initializer is empty.', 'Get the class that contains the if statement.', 'Check whether the class has initializers.', 'Check whether any initializer is empty.', 'Check whether the class has static blocks.', 'Check whether any static block is empty.', 'Check whether the if statement has else branch. (No else branch)', 'Get the condition of if statement. (Condition is `x > 2`)', 'Check whether the body of if statement is empty. (Yes, the body is empty)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Check whether the if statement has else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9873020648956299
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Check whether the body of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8571328520774841
*Get the else branch of if statement.* 匹配到的元操作或API：
logic: Get the else branch of if statement.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.989610493183136
*Check whether the else branch of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the else branch of if statement is empty.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9108617305755615
*Get the body of the else branch of if statement.* 匹配到的元操作或API：
logic: Get the body of the else branch of if statement.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.9402499198913574
*Check whether the body of the else branch is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the if statement is in a method.* 匹配到的元操作或API：
query: Check whether the if statement is in a method.
most similar API: Check whether the method equals
cosine Similarity: 0.8821923136711121
*Get the method that contains the if statement.* 匹配到的元操作或API：
query: Get the method that contains the if statement.
most similar API: Check whether the method equals
cosine Similarity: 0.8071913123130798
*Check whether the method has initializers.* 匹配到的元操作或API：
query: Check whether the method has initializers.
most similar API: Check whether is array initializer
cosine Similarity: 0.8452569842338562
*Check whether any initializer is empty.* 匹配到的元操作或API：
query: Check whether any initializer is empty.
most similar API: Check whether is array initializer
cosine Similarity: 0.813037097454071
*Get the class that contains the if statement.* 匹配到的元操作或API：
query: Get the class that contains the if statement.
most similar API: get class of if statement
cosine Similarity: 0.9300882816314697
*Check whether the class has initializers.* 匹配到的元操作或API：
query: Check whether the class has initializers.
most similar API: Check whether is array initializer
cosine Similarity: 0.8557380437850952
*Check whether any initializer is empty.* 匹配到的元操作或API：
query: Check whether any initializer is empty.
most similar API: Check whether is array initializer
cosine Similarity: 0.813037097454071
*Check whether the class has static blocks.* 匹配到的元操作或API：
logic: Check whether the class has static blocks.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.875225305557251
*Check whether any static block is empty.* 匹配到的元操作或API：
query: Check whether any static block is empty.
most similar API: Check whether the block is empty
cosine Similarity: 0.9047138690948486
*Check whether the if statement has else branch. (No else branch)* 匹配到的元操作或API：
logic: Check whether the if statement has else branch. (No else branch)
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9769582748413086
*Get the condition of if statement. (Condition is `x > 2`)* 匹配到的元操作或API：
logic: Get the condition of if statement. (Condition is `x > 2`)
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.8765612840652466
*Check whether the body of if statement is empty. (Yes, the body is empty)* 匹配到的元操作或API：
query: Check whether the body of if statement is empty. (Yes, the body is empty)
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8252861499786377
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }


This checker is failed(false negative) on this negative test case:
```
// one empty if statement
public class Foo {
    void bar(int x) {
        if (x > 2) {
        }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
4. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean equals(java.lang.Object)
6. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isArrayInitializer(net.sourceforge.pmd.lang.java.ast.ASTExpression)
7. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public java.lang.Class<Class<?> getClass()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
9. net.sourceforge.pmd.lang.java.ast.ASTBlock: public boolean isEmpty()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        ASTStatement elseBranch = node.getElseBranch();
        if (elseBranch instanceof ASTBlock && ((ASTBlock) elseBranch).isEmpty()) {
            addViolation(data, elseBranch);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 18" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 18" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the method declaration from method call.
        2. Get the body of the method.
        3. Get all control statements in the method body.
        4. Check whether the control statement is an if statement.
        5. Check whether the if statement has an empty body.

This sequence of checks will identify whether there is an if statement with an empty body in the provided test case. In this case, the if statement `if (x > 2) {}` is indeed empty, thus violating the rule.

The number of violating the rule in this test case is: 1
            
['Get the method declaration from method call.', 'Get the body of the method.', 'Get all control statements in the method body.', 'Check whether the control statement is an if statement.', 'Check whether the if statement has an empty body.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the method declaration from method call.* 匹配到的元操作或API：
logic: Get the method declaration from method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9787436127662659
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Get all control statements in the method body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is an if statement.* 匹配到的元操作或API：
query: Check whether the control statement is an if statement.
most similar API: Check whether the if statement equals
cosine Similarity: 0.8228201866149902
*Check whether the if statement has an empty body.* 匹配到的元操作或API：
query: Check whether the if statement has an empty body.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8336375951766968
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }


This checker is failed(false negative) on this negative test case:
```
// one empty if statement
public class Foo {
    void bar(int x) {
        if (x > 2) {
        }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement ifStmt = node.getFirstStmt();
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        } else if (ifStmt instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get all control statements in method.
2. Check whether the control statement is an if statement.
3. Get the condition of if statement.
4. Check whether the if statement has an else branch.
5. Get the body of if statement.
6. Check whether the body of if statement is empty.
7. Repeat steps 1-6 for each control statement in the method.

Based on the provided test case:
1. Get all control statements in method `bar`.
2. Check whether the control statement is an if statement. (True)
3. Get the condition of if statement. (x > 2)
4. Check whether the if statement has an else branch. (False)
5. Get the body of if statement.
6. Check whether the body of if statement is empty. (True)

The number of violating the rule in this test case is: 1
['Get all control statements in method.', 'Check whether the control statement is an if statement.', 'Get the condition of if statement.', 'Check whether the if statement has an else branch.', 'Get the body of if statement.', 'Check whether the body of if statement is empty.', 'Repeat steps 1-6 for each control statement in the method.', 'Get all control statements in method `bar`.', 'Check whether the control statement is an if statement. (True)', 'Get the condition of if statement. (x > 2)', 'Check whether the if statement has an else branch. (False)', 'Get the body of if statement.', 'Check whether the body of if statement is empty. (True)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get all control statements in method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is an if statement.* 匹配到的元操作或API：
query: Check whether the control statement is an if statement.
most similar API: Check whether the if statement equals
cosine Similarity: 0.8228201866149902
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Check whether the if statement has an else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9772751331329346
*Get the body of if statement.* 匹配到的元操作或API：
query: Get the body of if statement.
most similar API: get text of if statement
cosine Similarity: 0.8786208033561707
*Check whether the body of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8571328520774841
*Repeat steps 1-6 for each control statement in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all control statements in method `bar`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is an if statement. (True)* 匹配到的元操作或API：
query: Check whether the control statement is an if statement. (True)
most similar API: Check whether the if statement equals
cosine Similarity: 0.8163113594055176
*Get the condition of if statement. (x > 2)* 匹配到的元操作或API：
logic: Get the condition of if statement. (x > 2)
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.8769012093544006
*Check whether the if statement has an else branch. (False)* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch. (False)
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9652798175811768
*Get the body of if statement.* 匹配到的元操作或API：
query: Get the body of if statement.
most similar API: get text of if statement
cosine Similarity: 0.8786208033561707
*Check whether the body of if statement is empty. (True)* 匹配到的元操作或API：
query: Check whether the body of if statement is empty. (True)
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8282914161682129
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }


This checker is failed(false negative) on this negative test case:
```
// one empty if statement
public class Foo {
    void bar(int x) {
        if (x > 2) {
        }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean equals(java.lang.Object)
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
3. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
4. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.document.Chars getText()
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 18" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 18" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the method declaration from the method call.
        2. Get the statements in the method body.
        3. Get the control statement from the method body.
        4. Check whether the control statement is an if statement.
        5. Get the condition of if statement.
        6. Get the body of the if statement.
        7. Check whether the body of the if statement is empty.
        If the body of the if statement is empty, then this test case violates the rule.

Given the test case, the sequence of checks would be:

1. Get the method declaration from the method call. (This is `void bar(int x)`)
2. Get the statements in the method body. (This includes `if (x > 2) { }`)
3. Get the control statement from the method body. (This is `if (x > 2) { }`)
4. Check whether the control statement is an if statement. (Yes, it is an if statement)
5. Get the condition of if statement. (This is `x > 2`)
6. Get the body of the if statement. (This is `{ }`)
7. Check whether the body of the if statement is empty. (Yes, the body is empty)

Thus, the test case violates the rule with one empty if statement.
['Get the method declaration from the method call.', 'Get the statements in the method body.', 'Get the control statement from the method body.', 'Check whether the control statement is an if statement.', 'Get the condition of if statement.', 'Get the body of the if statement.', 'Check whether the body of the if statement is empty.', 'Get the method declaration from the method call. (This is `void bar(int x)`)', 'Get the statements in the method body. (This includes `if (x > 2) { }`)', 'Get the control statement from the method body. (This is `if (x > 2) { }`)', 'Check whether the control statement is an if statement. (Yes, it is an if statement)', 'Get the condition of if statement. (This is `x > 2`)', 'Get the body of the if statement. (This is `{ }`)', 'Check whether the body of the if statement is empty. (Yes, the body is empty)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the method declaration from the method call.* 匹配到的元操作或API：
logic: Get the method declaration from the method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9715675115585327
*Get the statements in the method body.* 匹配到的元操作或API：
query: Get the statements in the method body.
most similar API: get body of method
cosine Similarity: 0.8396947383880615
*Get the control statement from the method body.* 匹配到的元操作或API：
query: Get the control statement from the method body.
most similar API: get body of method
cosine Similarity: 0.820036768913269
*Check whether the control statement is an if statement.* 匹配到的元操作或API：
query: Check whether the control statement is an if statement.
most similar API: Check whether the if statement equals
cosine Similarity: 0.8228201866149902
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Get the body of the if statement.* 匹配到的元操作或API：
query: Get the body of the if statement.
most similar API: get text of if statement
cosine Similarity: 0.8748294115066528
*Check whether the body of the if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of the if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8603639006614685
*Get the method declaration from the method call. (This is `void bar(int x)`)* 匹配到的元操作或API：
logic: Get the method declaration from the method call. (This is `void bar(int x)`)
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9000828266143799
*Get the statements in the method body. (This includes `if (x > 2) { }`)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the control statement from the method body. (This is `if (x > 2) { }`)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is an if statement. (Yes, it is an if statement)* 匹配到的元操作或API：
query: Check whether the control statement is an if statement. (Yes, it is an if statement)
most similar API: Check whether the if statement equals
cosine Similarity: 0.8210322856903076
*Get the condition of if statement. (This is `x > 2`)* 匹配到的元操作或API：
logic: Get the condition of if statement. (This is `x > 2`)
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.8794639706611633
*Get the body of the if statement. (This is `{ }`)* 匹配到的元操作或API：
query: Get the body of the if statement. (This is `{ }`)
most similar API: get text of if statement
cosine Similarity: 0.8147521018981934
*Check whether the body of the if statement is empty. (Yes, the body is empty)* 匹配到的元操作或API：
query: Check whether the body of the if statement is empty. (Yes, the body is empty)
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8228371739387512
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }


This checker is failed(false negative) on this negative test case:
```
// one empty if statement
public class Foo {
    void bar(int x) {
        if (x > 2) {
        }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
4. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.document.Chars getText()
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 18" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 18" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 18
[ERROR]   "bad 19" resulted in wrong number of failures, ==> expected: <2> but was: <3>不通过
100
82
84
69
119
103
=========================error_testcase_logics=========================
1. Get the number of control statements in the method.
2. Get the first control statement in the method.
3. Check whether the control statement is an if statement.
4. Check whether the if statement has an else branch.
5. Get the body of the if statement.
6. Check whether the body of the if statement is empty.
7. Get the body of the else branch.
8. Check whether the body of the else branch is empty.
9. Count the number of empty control statement bodies.
10. If the if statement body is empty, increment the count.
11. If the else branch body is empty, increment the count.
12. Check whether the number of empty control statement bodies equals 2.
If the if statement body and the else branch body are both empty, then the number of violating the rule in this test case is indeed 2.
['Get the number of control statements in the method.', 'Get the first control statement in the method.', 'Check whether the control statement is an if statement.', 'Check whether the if statement has an else branch.', 'Get the body of the if statement.', 'Check whether the body of the if statement is empty.', 'Get the body of the else branch.', 'Check whether the body of the else branch is empty.', 'Count the number of empty control statement bodies.', 'If the if statement body is empty, increment the count.', 'If the else branch body is empty, increment the count.', 'Check whether the number of empty control statement bodies equals 2.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the number of control statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first control statement in the method.* 匹配到的元操作或API：
query: Get the first control statement in the method.
most similar API: get first child of method
cosine Similarity: 0.8109579086303711
*Check whether the control statement is an if statement.* 匹配到的元操作或API：
query: Check whether the control statement is an if statement.
most similar API: Check whether the if statement equals
cosine Similarity: 0.8228201866149902
*Check whether the if statement has an else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9772751331329346
*Get the body of the if statement.* 匹配到的元操作或API：
query: Get the body of the if statement.
most similar API: get text of if statement
cosine Similarity: 0.8748294115066528
*Check whether the body of the if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of the if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8603639006614685
*Get the body of the else branch.* 匹配到的元操作或API：
logic: Get the body of the else branch.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.856397271156311
*Check whether the body of the else branch is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Count the number of empty control statement bodies.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the if statement body is empty, increment the count.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the else branch body is empty, increment the count.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the number of empty control statement bodies equals 2.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty if with else statement
public class Foo {
    void bar(int x) {
        if (x > 2) {
        } else {
        }
    }
}
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.Node getFirstChild()
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
4. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.document.Chars getText()
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
6. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        if (node.hasElse()) {
            ASTStatement elseBranch = node.getElseBranch();
            if (elseBranch instanceof ASTBlock && ((ASTBlock) elseBranch).isEmpty()) {
                addViolation(data, elseBranch);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 19" resulted in wrong number of failures, ==> expected: <2> but was: <4>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 19" resulted in wrong number of failures, ==> expected: <2> but was: <4>不通过
=========================error_testcase_logics=========================
1. Get the condition of if statement.
2. Get the else branch of if statement.
3. Check whether the if statement has else branch.
4. Check whether the body of if statement is empty.
5. Check whether the body of else branch is empty.

Let's break down the test case:

1. Get the condition of if statement.
   - Condition is `x > 2`.

2. Get the else branch of if statement.
   - Else branch is `{}`.

3. Check whether the if statement has else branch.
   - The if statement does have an else branch.

4. Check whether the body of if statement is empty.
   - The body of the if statement is `{}`, which is empty.

5. Check whether the body of else branch is empty.
   - The body of the else branch is `{}`, which is empty.

This test case violates the rule twice: once for the empty body of the if statement and once for the empty body of the else statement.
['Get the condition of if statement.', 'Get the else branch of if statement.', 'Check whether the if statement has else branch.', 'Check whether the body of if statement is empty.', 'Check whether the body of else branch is empty.', 'Get the condition of if statement.', 'Get the else branch of if statement.', 'Check whether the if statement has else branch.', 'Check whether the body of if statement is empty.', 'Check whether the body of else branch is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Get the else branch of if statement.* 匹配到的元操作或API：
logic: Get the else branch of if statement.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.989610493183136
*Check whether the if statement has else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9873020648956299
*Check whether the body of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8571328520774841
*Check whether the body of else branch is empty.* 匹配到的元操作或API：
logic: Check whether the body of else branch is empty.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.856262743473053
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Get the else branch of if statement.* 匹配到的元操作或API：
logic: Get the else branch of if statement.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.989610493183136
*Check whether the if statement has else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9873020648956299
*Check whether the body of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8571328520774841
*Check whether the body of else branch is empty.* 匹配到的元操作或API：
logic: Check whether the body of else branch is empty.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.856262743473053
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty if with else statement
public class Foo {
    void bar(int x) {
        if (x > 2) {
        } else {
        }
    }
}
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch()
3. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        if (node.hasElse()) {
            ASTBlock elseBody = (ASTBlock) node.getElseBranch();
            if (elseBody.isEmpty()) {
                addViolation(data, node.getElseBranch());
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 19" resulted in wrong number of failures, ==> expected: <2> but was: <4>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 19" resulted in wrong number of failures, ==> expected: <2> but was: <4>不通过
=========================error_testcase_logics=========================
1. Get the condition of if statement.
        2. Get the body of the if statement.
        3. Check whether the body of the if statement is empty.
        4. Get the else branch of if statement.
        5. Check whether the else branch of the if statement is empty.
        If the body of the if statement is empty, then this is a violation of the rule.
        If the else branch of the if statement is empty, then this is a violation of the rule.
        
Based on the provided test case, the number of violations in this test case is indeed 2:
- The body of the if statement is empty.
- The else branch of the if statement is empty.
['Get the condition of if statement.', 'Get the body of the if statement.', 'Check whether the body of the if statement is empty.', 'Get the else branch of if statement.', 'Check whether the else branch of the if statement is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Get the body of the if statement.* 匹配到的元操作或API：
query: Get the body of the if statement.
most similar API: get text of if statement
cosine Similarity: 0.8748294115066528
*Check whether the body of the if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of the if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8603639006614685
*Get the else branch of if statement.* 匹配到的元操作或API：
logic: Get the else branch of if statement.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.989610493183136
*Check whether the else branch of the if statement is empty.* 匹配到的元操作或API：
logic: Check whether the else branch of the if statement is empty.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9060104489326477
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty if with else statement
public class Foo {
    void bar(int x) {
        if (x > 2) {
        } else {
        }
    }
}
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.document.Chars getText()
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
4. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch()
5. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        if (node.hasElse()) {
            ASTStatement elseBranch = node.getElseBranch();
            if (elseBranch instanceof ASTBlock && ((ASTBlock) elseBranch).isEmpty()) {
                addViolation(data, elseBranch);
            } else if (elseBranch instanceof ASTEmptyStatement) {
                addViolation(data, elseBranch);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 19" resulted in wrong number of failures, ==> expected: <2> but was: <4>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 19" resulted in wrong number of failures, ==> expected: <2> but was: <4>不通过
=========================error_testcase_logics=========================
1. Get the name of the method.
2. Get the control statements in the method.
3. Check whether the control statement is an if statement.
4. Get the then branch of the if statement.
5. Check whether the then branch is empty.
6. Check whether the if statement has an else branch.
7. Get the else branch of the if statement.
8. Check whether the else branch is empty.

Based on the provided test case, the checks will proceed as follows:

1. Get the name of the method.
        - The method name is `bar`.

2. Get the control statements in the method.
        - The control statement is an `if` statement.

3. Check whether the control statement is an if statement.
        - The control statement is indeed an `if` statement.

4. Get the then branch of the if statement.
        - The then branch is `{}`.

5. Check whether the then branch is empty.
        - The then branch is empty.

6. Check whether the if statement has an else branch.
        - The `if` statement does have an `else` branch.

7. Get the else branch of the if statement.
        - The `else` branch is `{}`.

8. Check whether the else branch is empty.
        - The `else` branch is empty.

The checks confirm that there are two empty branches in the `if` statement, thus the number of violations in this test case is indeed 2.
['Get the name of the method.', 'Get the control statements in the method.', 'Check whether the control statement is an if statement.', 'Get the then branch of the if statement.', 'Check whether the then branch is empty.', 'Check whether the if statement has an else branch.', 'Get the else branch of the if statement.', 'Check whether the else branch is empty.', 'Get the name of the method.', 'Get the control statements in the method.', 'Check whether the control statement is an if statement.', 'Get the then branch of the if statement.', 'Check whether the then branch is empty.', 'Check whether the if statement has an else branch.', 'Get the else branch of the if statement.', 'Check whether the else branch is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of the method.* 匹配到的元操作或API：
logic: Get the name of the method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9713990092277527
*Get the control statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is an if statement.* 匹配到的元操作或API：
query: Check whether the control statement is an if statement.
most similar API: Check whether the if statement equals
cosine Similarity: 0.8228201866149902
*Get the then branch of the if statement.* 匹配到的元操作或API：
logic: Get the then branch of the if statement.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.8635511994361877
*Check whether the then branch is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the if statement has an else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9772751331329346
*Get the else branch of the if statement.* 匹配到的元操作或API：
logic: Get the else branch of the if statement.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.9849298000335693
*Check whether the else branch is empty.* 匹配到的元操作或API：
logic: Check whether the else branch is empty.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.8779306411743164
*Get the name of the method.* 匹配到的元操作或API：
logic: Get the name of the method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9713990092277527
*Get the control statements in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is an if statement.* 匹配到的元操作或API：
query: Check whether the control statement is an if statement.
most similar API: Check whether the if statement equals
cosine Similarity: 0.8228201866149902
*Get the then branch of the if statement.* 匹配到的元操作或API：
logic: Get the then branch of the if statement.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.8635511994361877
*Check whether the then branch is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the if statement has an else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9772751331329346
*Get the else branch of the if statement.* 匹配到的元操作或API：
logic: Get the else branch of the if statement.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.9849298000335693
*Check whether the else branch is empty.* 匹配到的元操作或API：
logic: Check whether the else branch is empty.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.8779306411743164
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty if with else statement
public class Foo {
    void bar(int x) {
        if (x > 2) {
        } else {
        }
    }
}
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch()
4. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        if (node.hasElse()) {
            ASTBlock elseBody = (ASTBlock) node.getElseBranch();
            if (elseBody != null && elseBody.isEmpty()) {
                addViolation(data, elseBody);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 19" resulted in wrong number of failures, ==> expected: <2> but was: <4>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 19" resulted in wrong number of failures, ==> expected: <2> but was: <4>不通过
=========================error_testcase_logics=========================
1. Get the control statement of the method.
        2. Check whether the control statement is an if statement.
        3. Check whether the if statement has an else branch.
        4. Get the body of the if statement.
        5. Check whether the body of the if statement is empty.
        6. Get the body of the else branch.
        7. Check whether the body of the else branch is empty.
        If the if statement or its else branch has an empty body, then it violates the rule.
        
For this specific test case:
1. Get the control statement of the method `bar`.
        2. Check whether the control statement is an if statement. (True)
        3. Check whether the if statement has an else branch. (True)
        4. Get the body of the if statement.
        5. Check whether the body of the if statement is empty. (True)
        6. Get the body of the else branch.
        7. Check whether the body of the else branch is empty. (True)

Both the if statement's body and the else branch's body are empty, so this test case violates the rule twice.
['Get the control statement of the method.', 'Check whether the control statement is an if statement.', 'Check whether the if statement has an else branch.', 'Get the body of the if statement.', 'Check whether the body of the if statement is empty.', 'Get the body of the else branch.', 'Check whether the body of the else branch is empty.', 'Get the control statement of the method `bar`.', 'Check whether the control statement is an if statement. (True)', 'Check whether the if statement has an else branch. (True)', 'Get the body of the if statement.', 'Check whether the body of the if statement is empty. (True)', 'Get the body of the else branch.', 'Check whether the body of the else branch is empty. (True)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the control statement of the method.* 匹配到的元操作或API：
query: Get the control statement of the method.
most similar API: get text of method
cosine Similarity: 0.814026951789856
*Check whether the control statement is an if statement.* 匹配到的元操作或API：
query: Check whether the control statement is an if statement.
most similar API: Check whether the if statement equals
cosine Similarity: 0.8228201866149902
*Check whether the if statement has an else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9772751331329346
*Get the body of the if statement.* 匹配到的元操作或API：
query: Get the body of the if statement.
most similar API: get text of if statement
cosine Similarity: 0.8748294115066528
*Check whether the body of the if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of the if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8603639006614685
*Get the body of the else branch.* 匹配到的元操作或API：
logic: Get the body of the else branch.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.856397271156311
*Check whether the body of the else branch is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the control statement of the method `bar`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is an if statement. (True)* 匹配到的元操作或API：
query: Check whether the control statement is an if statement. (True)
most similar API: Check whether the if statement equals
cosine Similarity: 0.8163113594055176
*Check whether the if statement has an else branch. (True)* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch. (True)
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.971953272819519
*Get the body of the if statement.* 匹配到的元操作或API：
query: Get the body of the if statement.
most similar API: get text of if statement
cosine Similarity: 0.8748294115066528
*Check whether the body of the if statement is empty. (True)* 匹配到的元操作或API：
query: Check whether the body of the if statement is empty. (True)
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8231198787689209
*Get the body of the else branch.* 匹配到的元操作或API：
logic: Get the body of the else branch.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.856397271156311
*Check whether the body of the else branch is empty. (True)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty if with else statement
public class Foo {
    void bar(int x) {
        if (x > 2) {
        } else {
        }
    }
}
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.document.Chars getText()
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
4. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.document.Chars getText()
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
6. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        if (node.hasElse()) {
            ASTStatement elseBranch = node.getElseBranch();
            if (elseBranch instanceof ASTBlock && ((ASTBlock) elseBranch).isEmpty()) {
                addViolation(data, node);
            } else if (elseBranch instanceof ASTEmptyStatement) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 19" resulted in wrong number of failures, ==> expected: <2> but was: <4>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 19" resulted in wrong number of failures, ==> expected: <2> but was: <4>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 19
[ERROR]   "bad 20" resulted in wrong number of failures, ==> expected: <3> but was: <5>不通过
100
82
84
69
119
103
=========================error_testcase_logics=========================
1. Get the method named bar in class Foo.
2. Get the control statements in method bar.
3. Check whether the control statement is an if statement.
4. Check whether the if statement has an empty body.
5. If the if statement has an empty body, report a violation.
6. Check whether the if statement has an else if branch.
7. If the if statement has an else if branch, get the else if branch.
8. Check whether the else if branch has an empty body.
9. If the else if branch has an empty body, report a violation.
10. Check whether the if statement has an else branch.
11. If the if statement has an else branch, get the else branch.
12. Check whether the else branch has an empty body.
13. If the else branch has an empty body, report a violation.

Based on the provided test case, the following checks will be performed and result in violations:

1. Get the method named bar in class Foo.
2. Get the control statements in method bar.
3. Check whether the control statement is an if statement. (True)
4. Check whether the if statement has an empty body. (True)
5. Report a violation for the empty if statement body.
6. Check whether the if statement has an else if branch. (True)
7. Get the else if branch.
8. Check whether the else if branch has an empty body. (True)
9. Report a violation for the empty else if statement body.
10. Check whether the if statement has an else branch. (True)
11. Get the else branch.
12. Check whether the else branch has an empty body. (True)
13. Report a violation for the empty else statement body.

The number of violations reported in this test case is: 3
['Get the method named bar in class Foo.', 'Get the control statements in method bar.', 'Check whether the control statement is an if statement.', 'Check whether the if statement has an empty body.', 'If the if statement has an empty body, report a violation.', 'Check whether the if statement has an else if branch.', 'If the if statement has an else if branch, get the else if branch.', 'Check whether the else if branch has an empty body.', 'If the else if branch has an empty body, report a violation.', 'Check whether the if statement has an else branch.', 'If the if statement has an else branch, get the else branch.', 'Check whether the else branch has an empty body.', 'If the else branch has an empty body, report a violation.', 'Get the method named bar in class Foo.', 'Get the control statements in method bar.', 'Check whether the control statement is an if statement. (True)', 'Check whether the if statement has an empty body. (True)', 'Report a violation for the empty if statement body.', 'Check whether the if statement has an else if branch. (True)', 'Get the else if branch.', 'Check whether the else if branch has an empty body. (True)', 'Report a violation for the empty else if statement body.', 'Check whether the if statement has an else branch. (True)', 'Get the else branch.', 'Check whether the else branch has an empty body. (True)', 'Report a violation for the empty else statement body.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the method named bar in class Foo.* 匹配到的元操作或API：
query: Get the method named bar in class Foo.
most similar API: get name of method
cosine Similarity: 0.8016407489776611
*Get the control statements in method bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is an if statement.* 匹配到的元操作或API：
query: Check whether the control statement is an if statement.
most similar API: Check whether the if statement equals
cosine Similarity: 0.8228201866149902
*Check whether the if statement has an empty body.* 匹配到的元操作或API：
query: Check whether the if statement has an empty body.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8336375951766968
*If the if statement has an empty body, report a violation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the if statement has an else if branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else if branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9757484197616577
*If the if statement has an else if branch, get the else if branch.* 匹配到的元操作或API：
logic: If the if statement has an else if branch, get the else if branch.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.9363903403282166
*Check whether the else if branch has an empty body.* 匹配到的元操作或API：
logic: Check whether the else if branch has an empty body.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.8546527624130249
*If the else if branch has an empty body, report a violation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the if statement has an else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9772751331329346
*If the if statement has an else branch, get the else branch.* 匹配到的元操作或API：
logic: If the if statement has an else branch, get the else branch.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.9467620849609375
*Check whether the else branch has an empty body.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the else branch has an empty body, report a violation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the method named bar in class Foo.* 匹配到的元操作或API：
query: Get the method named bar in class Foo.
most similar API: get name of method
cosine Similarity: 0.8016407489776611
*Get the control statements in method bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is an if statement. (True)* 匹配到的元操作或API：
query: Check whether the control statement is an if statement. (True)
most similar API: Check whether the if statement equals
cosine Similarity: 0.8163113594055176
*Check whether the if statement has an empty body. (True)* 匹配到的元操作或API：
query: Check whether the if statement has an empty body. (True)
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8348976373672485
*Report a violation for the empty if statement body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the if statement has an else if branch. (True)* 匹配到的元操作或API：
logic: Check whether the if statement has an else if branch. (True)
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9700324535369873
*Get the else if branch.* 匹配到的元操作或API：
logic: Get the else if branch.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.9474235773086548
*Check whether the else if branch has an empty body. (True)* 匹配到的元操作或API：
未匹配成功元操作或API
*Report a violation for the empty else if statement body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the if statement has an else branch. (True)* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch. (True)
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.971953272819519
*Get the else branch.* 匹配到的元操作或API：
logic: Get the else branch.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.9180188179016113
*Check whether the else branch has an empty body. (True)* 匹配到的元操作或API：
未匹配成功元操作或API
*Report a violation for the empty else statement body.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty if with else and else if statement
public class Foo {
    void bar(int x) {
        if (x > 2) {
        } else if (x > 3) {
        } else {
        }
    }
}
The number of violating the rule in this test case is: 3

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock
          ——ASTIfStatement
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'x')
              ——ASTNumericLiteral
            ——ASTBlock
            ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName(), //Returns the simple name of the method.
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()
4. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
5. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        if (node.hasElse()) {
            ASTStatement elseBranch = node.getElseBranch();
            if (elseBranch instanceof ASTBlock && ((ASTBlock) elseBranch).isEmpty()) {
                addViolation(data, elseBranch);
            } else if (elseBranch instanceof ASTIfStatement) {
                visit((ASTIfStatement) elseBranch, data);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 20" resulted in wrong number of failures, ==> expected: <3> but was: <8>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 20" resulted in wrong number of failures, ==> expected: <3> but was: <8>不通过
=========================error_testcase_logics=========================
1. Get the condition of if statement.
        2. Get the body of if statement.
        3. Check whether the body of if statement is empty.
        4. Check whether the if statement has an else branch.
        5. Get the body of else branch.
        6. Check whether the body of else branch is empty.
        7. Get the condition of else if statement.
        8. Get the body of else if statement.
        9. Check whether the body of else if statement is empty.

The checks confirm that the body of the if statement, the body of the else branch, and the body of the else if statement are all empty, thus violating the rule in three places.
['Get the condition of if statement.', 'Get the body of if statement.', 'Check whether the body of if statement is empty.', 'Check whether the if statement has an else branch.', 'Get the body of else branch.', 'Check whether the body of else branch is empty.', 'Get the condition of else if statement.', 'Get the body of else if statement.', 'Check whether the body of else if statement is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Get the body of if statement.* 匹配到的元操作或API：
query: Get the body of if statement.
most similar API: get text of if statement
cosine Similarity: 0.8786208033561707
*Check whether the body of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8571328520774841
*Check whether the if statement has an else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9772751331329346
*Get the body of else branch.* 匹配到的元操作或API：
query: Get the body of else branch.
most similar API: get else branch of if statement
cosine Similarity: 0.8357541561126709
*Check whether the body of else branch is empty.* 匹配到的元操作或API：
logic: Check whether the body of else branch is empty.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.856262743473053
*Get the condition of else if statement.* 匹配到的元操作或API：
logic: Get the condition of else if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9141820669174194
*Get the body of else if statement.* 匹配到的元操作或API：
logic: Get the body of else if statement.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.8730061054229736
*Check whether the body of else if statement is empty.* 匹配到的元操作或API：
query: Check whether the body of else if statement is empty.
most similar API: Check whether the if statement has else
cosine Similarity: 0.8600708842277527
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty if with else and else if statement
public class Foo {
    void bar(int x) {
        if (x > 2) {
        } else if (x > 3) {
        } else {
        }
    }
}
The number of violating the rule in this test case is: 3

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock
          ——ASTIfStatement
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'x')
              ——ASTNumericLiteral
            ——ASTBlock
            ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.document.Chars getText()
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
4. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
5. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch(), //Returns the statement of the {@code else} clause, if any.
6. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch()
7. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse(), //Returns true if this statement has an {@code else} clause.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }

        if (node.hasElse()) {
            ASTStatement elseBranch = node.getElseBranch();
            if (elseBranch instanceof ASTBlock && ((ASTBlock) elseBranch).isEmpty()) {
                addViolation(data, elseBranch);
            } else if (elseBranch instanceof ASTIfStatement) {
                visit((ASTIfStatement) elseBranch, data);
            } else if (elseBranch instanceof ASTEmptyStatement) {
                addViolation(data, elseBranch);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 20" resulted in wrong number of failures, ==> expected: <3> but was: <8>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 20" resulted in wrong number of failures, ==> expected: <3> but was: <8>不通过
=========================error_testcase_logics=========================
1. Get the method declaration from method call.
        2. Get the control statements from method body.
        3. Check whether the control statement is an if statement.
        4. Check whether the if statement has an else branch.
        5. Check whether the body of the if statement is empty.
        6. Check whether the if statement has an else if branch.
        7. Check whether the body of the else if statement is empty.
        8. Check whether the body of the else statement is empty.
        9. Count the number of empty bodies in the if, else if, and else statements.
        
In this test case:
- The if statement has an empty body.
- The else if statement has an empty body.
- The else statement has an empty body.

Thus, the number of violating the rule in this test case is: 3.
['Get the method declaration from method call.', 'Get the control statements from method body.', 'Check whether the control statement is an if statement.', 'Check whether the if statement has an else branch.', 'Check whether the body of the if statement is empty.', 'Check whether the if statement has an else if branch.', 'Check whether the body of the else if statement is empty.', 'Check whether the body of the else statement is empty.', 'Count the number of empty bodies in the if, else if, and else statements.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the method declaration from method call.* 匹配到的元操作或API：
logic: Get the method declaration from method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9787436127662659
*Get the control statements from method body.* 匹配到的元操作或API：
query: Get the control statements from method body.
most similar API: get body of method
cosine Similarity: 0.8088934421539307
*Check whether the control statement is an if statement.* 匹配到的元操作或API：
query: Check whether the control statement is an if statement.
most similar API: Check whether the if statement equals
cosine Similarity: 0.8228201866149902
*Check whether the if statement has an else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9772751331329346
*Check whether the body of the if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of the if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8603639006614685
*Check whether the if statement has an else if branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else if branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9757484197616577
*Check whether the body of the else if statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the else if statement is empty.
most similar API: Check whether the if statement has else
cosine Similarity: 0.8557353019714355
*Check whether the body of the else statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the else statement is empty.
most similar API: Check whether the if statement has else
cosine Similarity: 0.8450315594673157
*Count the number of empty bodies in the if, else if, and else statements.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty if with else and else if statement
public class Foo {
    void bar(int x) {
        if (x > 2) {
        } else if (x > 3) {
        } else {
        }
    }
}
The number of violating the rule in this test case is: 3

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock
          ——ASTIfStatement
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'x')
              ——ASTNumericLiteral
            ——ASTBlock
            ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
5. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse(), //Returns true if this statement has an {@code else} clause.

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        if (node.hasElse()) {
            ASTBlock elseBody = node.getElseBlock();
            if (elseBody != null && elseBody.isEmpty()) {
                addViolation(data, node);
            } else if (elseBody instanceof ASTIfStatement) {
                visit((ASTIfStatement) elseBody, data);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the condition of if statement.
        2. Get the body of if statement.
        3. Check whether the body of if statement is empty.
        4. Check whether the if statement has else branch.
        5. Get the body of else branch.
        6. Check whether the body of else branch is empty.
        7. Check whether the else branch is an if statement (else if).
        8. Get the condition of the nested if statement (else if).
        9. Get the body of the nested if statement (else if).
        10. Check whether the body of the nested if statement is empty.
        11. If the else branch is an if statement, repeat 7-10.

These checks will reveal that there are indeed three empty bodies in the provided test case: one for the `if` statement, one for the `else if` statement, and one for the `else` statement.
['Get the condition of if statement.', 'Get the body of if statement.', 'Check whether the body of if statement is empty.', 'Check whether the if statement has else branch.', 'Get the body of else branch.', 'Check whether the body of else branch is empty.', 'Check whether the else branch is an if statement (else if).', 'Get the condition of the nested if statement (else if).', 'Get the body of the nested if statement (else if).', 'Check whether the body of the nested if statement is empty.', 'If the else branch is an if statement, repeat 7-10.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Get the body of if statement.* 匹配到的元操作或API：
query: Get the body of if statement.
most similar API: get text of if statement
cosine Similarity: 0.8786208033561707
*Check whether the body of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8571328520774841
*Check whether the if statement has else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9873020648956299
*Get the body of else branch.* 匹配到的元操作或API：
query: Get the body of else branch.
most similar API: get else branch of if statement
cosine Similarity: 0.8357541561126709
*Check whether the body of else branch is empty.* 匹配到的元操作或API：
logic: Check whether the body of else branch is empty.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.856262743473053
*Check whether the else branch is an if statement (else if).* 匹配到的元操作或API：
logic: Check whether the else branch is an if statement (else if).
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9551436901092529
*Get the condition of the nested if statement (else if).* 匹配到的元操作或API：
logic: Get the condition of the nested if statement (else if).
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.8799403309822083
*Get the body of the nested if statement (else if).* 匹配到的元操作或API：
query: Get the body of the nested if statement (else if).
most similar API: get else branch of if statement
cosine Similarity: 0.8250082731246948
*Check whether the body of the nested if statement is empty.* 匹配到的元操作或API：
query: Check whether the body of the nested if statement is empty.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8129525184631348
*If the else branch is an if statement, repeat 7-10.* 匹配到的元操作或API：
query: If the else branch is an if statement, repeat 7-10.
most similar API: get else branch of if statement
cosine Similarity: 0.8392394781112671
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty if with else and else if statement
public class Foo {
    void bar(int x) {
        if (x > 2) {
        } else if (x > 3) {
        } else {
        }
    }
}
The number of violating the rule in this test case is: 3

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock
          ——ASTIfStatement
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'x')
              ——ASTNumericLiteral
            ——ASTBlock
            ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.document.Chars getText()
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
4. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
5. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch(), //Returns the statement of the {@code else} clause, if any.
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        if (node.hasElse()) {
            ASTStatement elseBranch = node.getElseBranch();
            if (elseBranch instanceof ASTBlock && ((ASTBlock) elseBranch).isEmpty()) {
                addViolation(data, elseBranch);
            } else if (elseBranch instanceof ASTIfStatement) {
                visit((ASTIfStatement) elseBranch, data);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 20" resulted in wrong number of failures, ==> expected: <3> but was: <8>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 20" resulted in wrong number of failures, ==> expected: <3> but was: <8>不通过
=========================error_testcase_logics=========================
1. Get the condition of if statement.
        2. Get the body of if statement.
        3. Check whether the body of if statement is empty.
        4. Check whether the if statement has an else branch.
        5. Get the body of the else branch.
        6. Check whether the else branch body is empty.
        7. Check whether the if statement has an else if branch.
        8. Get the body of the else if branch.
        9. Check whether the else if branch body is empty.

For the given test case:
1. Get the condition of if statement. (Condition is x > 2)
2. Get the body of if statement. (Body is {})
3. Check whether the body of if statement is empty. (True, body is empty)
4. Check whether the if statement has an else branch. (True, else branch exists)
5. Get the body of the else branch. (Body is {})
6. Check whether the else branch body is empty. (True, else branch body is empty)
7. Check whether the if statement has an else if branch. (True, else if branch exists)
8. Get the body of the else if branch. (Body is {})
9. Check whether the else if branch body is empty. (True, else if branch body is empty)

Since each of the if, else if, and else statements has an empty body, this test case violates the rule three times.
['Get the condition of if statement.', 'Get the body of if statement.', 'Check whether the body of if statement is empty.', 'Check whether the if statement has an else branch.', 'Get the body of the else branch.', 'Check whether the else branch body is empty.', 'Check whether the if statement has an else if branch.', 'Get the body of the else if branch.', 'Check whether the else if branch body is empty.', 'Get the condition of if statement. (Condition is x > 2)', 'Get the body of if statement. (Body is {})', 'Check whether the body of if statement is empty. (True, body is empty)', 'Check whether the if statement has an else branch. (True, else branch exists)', 'Get the body of the else branch. (Body is {})', 'Check whether the else branch body is empty. (True, else branch body is empty)', 'Check whether the if statement has an else if branch. (True, else if branch exists)', 'Get the body of the else if branch. (Body is {})', 'Check whether the else if branch body is empty. (True, else if branch body is empty)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Get the body of if statement.* 匹配到的元操作或API：
query: Get the body of if statement.
most similar API: get text of if statement
cosine Similarity: 0.8786208033561707
*Check whether the body of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8571328520774841
*Check whether the if statement has an else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9772751331329346
*Get the body of the else branch.* 匹配到的元操作或API：
logic: Get the body of the else branch.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.856397271156311
*Check whether the else branch body is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the if statement has an else if branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else if branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9757484197616577
*Get the body of the else if branch.* 匹配到的元操作或API：
logic: Get the body of the else if branch.
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.8879250288009644
*Check whether the else if branch body is empty.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the condition of if statement. (Condition is x > 2)* 匹配到的元操作或API：
logic: Get the condition of if statement. (Condition is x > 2)
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.8801204562187195
*Get the body of if statement. (Body is {})* 匹配到的元操作或API：
query: Get the body of if statement. (Body is {})
most similar API: get text of if statement
cosine Similarity: 0.8299852609634399
*Check whether the body of if statement is empty. (True, body is empty)* 匹配到的元操作或API：
query: Check whether the body of if statement is empty. (True, body is empty)
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.823948860168457
*Check whether the if statement has an else branch. (True, else branch exists)* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch. (True, else branch exists)
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.953109622001648
*Get the body of the else branch. (Body is {})* 匹配到的元操作或API：
query: Get the body of the else branch. (Body is {})
most similar API: get else branch of if statement
cosine Similarity: 0.8094145655632019
*Check whether the else branch body is empty. (True, else branch body is empty)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the if statement has an else if branch. (True, else if branch exists)* 匹配到的元操作或API：
logic: Check whether the if statement has an else if branch. (True, else if branch exists)
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9342654943466187
*Get the body of the else if branch. (Body is {})* 匹配到的元操作或API：
logic: Get the body of the else if branch. (Body is {})
most similar meta operation: Get the else branch of if statement
cosine Similarity: 0.8586427569389343
*Check whether the else if branch body is empty. (True, else if branch body is empty)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty if with else and else if statement
public class Foo {
    void bar(int x) {
        if (x > 2) {
        } else if (x > 3) {
        } else {
        }
    }
}
The number of violating the rule in this test case is: 3

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock
          ——ASTIfStatement
            ——ASTInfixExpression
              ——ASTVariableAccess (referenced variable name = 'x')
              ——ASTNumericLiteral
            ——ASTBlock
            ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.document.Chars getText()
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
4. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
5. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()
7. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTStatement getElseBranch(), //Returns the statement of the {@code else} clause, if any.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        if (node.hasElse()) {
            ASTStatement elseBranch = node.getElseBranch();
            if (elseBranch instanceof ASTIfStatement) {
                visit((ASTIfStatement) elseBranch, data);
            } else if (elseBranch instanceof ASTBlock && ((ASTBlock) elseBranch).isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 20" resulted in wrong number of failures, ==> expected: <3> but was: <8>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 20" resulted in wrong number of failures, ==> expected: <3> but was: <8>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 20
[ERROR]   "bad 21" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
100
82
84
69
119
103
75
61
=========================error_testcase_logics=========================
1. Get the name of method.
2. Get the method body of method.
3. Get control statements in method body.
4. Check whether the control statement is an if statement.
5. Get the condition of if statement.
6. Check whether the if statement has an else branch.
7. Get the body of if statement.
8. Check whether the body of if statement is empty.

This sequence of checks will ascertain that the if statement in the provided test case is indeed empty, thereby violating the rule. In this case, the condition `x > 2` is followed by a semicolon, which signifies an empty body for the if statement.
            
['Get the name of method.', 'Get the method body of method.', 'Get control statements in method body.', 'Check whether the control statement is an if statement.', 'Get the condition of if statement.', 'Check whether the if statement has an else branch.', 'Get the body of if statement.', 'Check whether the body of if statement is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTEmptyStatement', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the method body of method.* 匹配到的元操作或API：
query: Get the method body of method.
most similar API: get body of method
cosine Similarity: 0.970495343208313
*Get control statements in method body.* 匹配到的元操作或API：
query: Get control statements in method body.
most similar API: get body of method
cosine Similarity: 0.8039075136184692
*Check whether the control statement is an if statement.* 匹配到的元操作或API：
query: Check whether the control statement is an if statement.
most similar API: Check whether the if statement equals
cosine Similarity: 0.8228201866149902
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Check whether the if statement has an else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9772751331329346
*Get the body of if statement.* 匹配到的元操作或API：
query: Get the body of if statement.
most similar API: get text of if statement
cosine Similarity: 0.8786208033561707
*Check whether the body of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8571328520774841
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty if statement
public class Foo {
    void bar(int x) {
        if (x > 2);
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTEmptyStatement


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
3. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
5. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
6. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.document.Chars getText()
7. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        } else if (node.getBody() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the condition of if statement.
        2. Check whether the if statement has an else branch.
        3. Get the body of if statement.
        4. Check whether the body of if statement is empty.
        If the body of the if statement is empty, then this test case violates the rule.
        
In this specific test case:
5. Check whether the body of if statement is a single semicolon.
        This granular check is to ascertain if the empty body is represented by a single semicolon, which is indeed the case here. Thus, the test case violates the rule.
['Get the condition of if statement.', 'Check whether the if statement has an else branch.', 'Get the body of if statement.', 'Check whether the body of if statement is empty.', 'Check whether the body of if statement is a single semicolon.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTEmptyStatement', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the condition of if statement.* 匹配到的元操作或API：
logic: Get the condition of if statement.
most similar meta operation: Get the condition of if statement
cosine Similarity: 0.9797651767730713
*Check whether the if statement has an else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9772751331329346
*Get the body of if statement.* 匹配到的元操作或API：
query: Get the body of if statement.
most similar API: get text of if statement
cosine Similarity: 0.8786208033561707
*Check whether the body of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8571328520774841
*Check whether the body of if statement is a single semicolon.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }


This checker is failed(false negative) on this negative test case:
```
// empty if statement
public class Foo {
    void bar(int x) {
        if (x > 2);
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTEmptyStatement


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getCondition()
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
3. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.document.Chars getText()
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        } else if (node.getElseBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        } else if (node.getElseBranch() == null && node.getThenBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "bad 22" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
100
82
84
69
119
103
=========================error_testcase_logics=========================
1. Get the name of method.
2. Get the body of method.
3. Find all if statements in the method body.
4. Check whether the if statement has an else branch.
5. Get the body of if statement.
6. Check whether the body of if statement is empty.

In this test case:

1. Get the name of method: bar
2. Get the body of method: { if (x == 0) { // empty! } }
3. Find all if statements in the method body: if (x == 0) { // empty! }
4. Check whether the if statement has an else branch: No else branch.
5. Get the body of if statement: { // empty! }
6. Check whether the body of if statement is empty: The body is empty, but contains a comment.

Since the body of the if statement is considered empty in terms of code execution, this test case violates the rule. The presence of a comment does not count as executable code.

The number of constructs violating the rule in this test case is: 1
['Get the name of method.', 'Get the body of method.', 'Find all if statements in the method body.', 'Check whether the if statement has an else branch.', 'Get the body of if statement.', 'Check whether the body of if statement is empty.', 'Get the name of method: bar', 'Get the body of method: { if (x == 0) { // empty! } }', 'Find all if statements in the method body: if (x == 0) { // empty! }', 'Check whether the if statement has an else branch: No else branch.', 'Get the body of if statement: { // empty! }', 'Check whether the body of if statement is empty: The body is empty, but contains a comment.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752806425094604
*Find all if statements in the method body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the if statement has an else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9772751331329346
*Get the body of if statement.* 匹配到的元操作或API：
query: Get the body of if statement.
most similar API: get text of if statement
cosine Similarity: 0.8786208033561707
*Check whether the body of if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8571328520774841
*Get the name of method: bar* 匹配到的元操作或API：
logic: Get the name of method: bar
most similar meta operation: Get the name of method
cosine Similarity: 0.8775444030761719
*Get the body of method: { if (x == 0) { // empty! } }* 匹配到的元操作或API：
query: Get the body of method: { if (x == 0) { // empty! } }
most similar API: get body of method
cosine Similarity: 0.8245773911476135
*Find all if statements in the method body: if (x == 0) { // empty! }* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the if statement has an else branch: No else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch: No else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9531092643737793
*Get the body of if statement: { // empty! }* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the body of if statement is empty: The body is empty, but contains a comment.* 匹配到的元操作或API：
query: Check whether the body of if statement is empty: The body is empty, but contains a comment.
most similar API: Check whether is comment
cosine Similarity: 0.800646960735321
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        } else if (node.getElseBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        } else if (node.getElseBranch() == null && node.getThenBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }
This checker has passed this negative testcase:
public class Foo {
    void bar(int x) {
        if (x > 2);
    }
}


This checker is failed(false negative) on this negative test case:
```
// empty if statement with comment
public class Foo {
    void bar(int x) {
        if (x == 0) {
            // empty!
        }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
3. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
4. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.document.Chars getText()
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()
6. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isComment(net.sourceforge.pmd.lang.ast.impl.javacc.JavaccToken), //Returns true if the given token is a Java comment.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources() && !containsOnlyComments(tryBody)) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty() && !containsOnlyComments(finallyClause.getBody())) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty() && !containsOnlyComments(tryBody)) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty() && !containsOnlyComments(tryBody)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty() && !containsOnlyComments(body)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty() && !containsOnlyComments(body)) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty() && !containsOnlyComments(body)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty() && !containsOnlyComments(ifBody)) {
            addViolation(data, node);
        } else if (node.getElseBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        } else if (node.getElseBranch() == null && node.getThenBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty() && !containsOnlyComments(body)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty() && !containsOnlyComments(body)) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty() && !containsOnlyComments(body)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement && !containsOnlyComments(node)) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement && !containsOnlyComments(node)) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement && !containsOnlyComments(node)) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement && !containsOnlyComments(node)) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement && !containsOnlyComments(node)) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement && !containsOnlyComments(node)) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody && !containsOnlyComments(node)) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && !containsOnlyComments(node)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty() && !containsOnlyComments(body)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty() && !containsOnlyComments(body)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    private boolean containsOnlyComments(ASTBlock block) {
        return block.stream()
                   .filter(token -> token instanceof JavaccToken)
                   .map(token -> (JavaccToken) token)
                   .allMatch(JavaAstUtils::isComment);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the control statement.
2. Check whether the control statement is an if statement.
3. Check whether the if statement has an else branch.
4. Get the body of the if statement.
5. Check whether the body of the if statement is empty.

In this test case, the if statement's body is considered empty because it only contains a comment, and no executable code. Thus, the number of violations is indeed 1.
['Get the control statement.', 'Check whether the control statement is an if statement.', 'Check whether the if statement has an else branch.', 'Get the body of the if statement.', 'Check whether the body of the if statement is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the control statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is an if statement.* 匹配到的元操作或API：
query: Check whether the control statement is an if statement.
most similar API: Check whether the if statement equals
cosine Similarity: 0.8228201866149902
*Check whether the if statement has an else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9772751331329346
*Get the body of the if statement.* 匹配到的元操作或API：
query: Get the body of the if statement.
most similar API: get text of if statement
cosine Similarity: 0.8748294115066528
*Check whether the body of the if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of the if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8603639006614685
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        } else if (node.getElseBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        } else if (node.getElseBranch() == null && node.getThenBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }
This checker has passed this negative testcase:
public class Foo {
    void bar(int x) {
        if (x > 2);
    }
}


This checker is failed(false negative) on this negative test case:
```
// empty if statement with comment
public class Foo {
    void bar(int x) {
        if (x == 0) {
            // empty!
        }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean equals(java.lang.Object)
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
3. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.document.Chars getText()
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty() && !hasComment(ifBody)) {
            addViolation(data, node);
        } else if (node.getElseBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        } else if (node.getElseBranch() == null && node.getThenBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    private boolean hasComment(ASTBlock block) {
        Chars text = block.getText();
        return text != null && text.toString().contains("//");
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty() && !hasComment(body)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty() && !hasComment(body)) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty() && !hasComment(body)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement && !hasComment(node)) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement && !hasComment(node)) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement && !hasComment(node)) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement && !hasComment(node)) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement && !hasComment(node)) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement && !hasComment(node)) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody && !hasComment(node)) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && !hasComment(node)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty() && !hasComment(body)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty() && !hasComment(body)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the control statement.
2. Check whether the control statement is an if statement.
3. Check whether the if statement has an empty body.
4. Check whether the if statement has a comment in the empty body.
5. Check whether the if statement has a non-comment token in the body.

The test case involves an if statement with an empty body containing only a comment. According to the rule, an empty body is reported, regardless of the comment.

Based on the checks:
- The control statement is an if statement.
- The if statement has an empty body.
- The if statement has a comment in the empty body.
- The if statement does not have a non-comment token in the body.

Since the if statement has an empty body, it violates the rule. Therefore, the number of violations is 1.
['Get the control statement.', 'Check whether the control statement is an if statement.', 'Check whether the if statement has an empty body.', 'Check whether the if statement has a comment in the empty body.', 'Check whether the if statement has a non-comment token in the body.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the control statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is an if statement.* 匹配到的元操作或API：
query: Check whether the control statement is an if statement.
most similar API: Check whether the if statement equals
cosine Similarity: 0.8228201866149902
*Check whether the if statement has an empty body.* 匹配到的元操作或API：
query: Check whether the if statement has an empty body.
most similar API: Check whether the class or interface body is empty
cosine Similarity: 0.8336375951766968
*Check whether the if statement has a comment in the empty body.* 匹配到的元操作或API：
query: Check whether the if statement has a comment in the empty body.
most similar API: Check whether is comment
cosine Similarity: 0.8555049300193787
*Check whether the if statement has a non-comment token in the body.* 匹配到的元操作或API：
query: Check whether the if statement has a non-comment token in the body.
most similar API: Check whether is comment: Returns true if the given token is a Java comment.
cosine Similarity: 0.8003389835357666
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        } else if (node.getElseBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        } else if (node.getElseBranch() == null && node.getThenBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }
This checker has passed this negative testcase:
public class Foo {
    void bar(int x) {
        if (x > 2);
    }
}


This checker is failed(false negative) on this negative test case:
```
// empty if statement with comment
public class Foo {
    void bar(int x) {
        if (x == 0) {
            // empty!
        }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean equals(java.lang.Object)
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: public boolean isEmpty()
3. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isComment(net.sourceforge.pmd.lang.ast.impl.javacc.JavaccToken), //Returns true if the given token is a Java comment.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty() && !hasComment(ifBody)) {
            addViolation(data, node);
        } else if (node.getElseBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        } else if (node.getElseBranch() == null && node.getThenBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty() && !hasComment(body)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty() && !hasComment(body)) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty() && !hasComment(body)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement && !hasComment(node)) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty() && !hasComment(body)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty() && !hasComment(body)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    private boolean hasComment(ASTBlock block) {
        for (Node child : block) {
            if (child instanceof net.sourceforge.pmd.lang.ast.impl.javacc.JavaccToken) {
                if (JavaAstUtils.isComment((net.sourceforge.pmd.lang.ast.impl.javacc.JavaccToken) child)) {
                    return true;
                }
            }
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get the method declaration from class.
3. Get the signature of method.
4. Get the name of method.
5. Get the control statements in method body.
6. Check whether the control statement is an if statement.
7. Get the if statement body.
8. Check whether the if statement body is empty (ignoring comments).
9. If the if statement body is empty (ignoring comments), then this test case violates the rule.

In the provided test case:
- The class name is Foo.
- The method signature is `void bar(int x)`.
- The method contains an if statement.
- The if statement body contains only a comment.
- Therefore, the if statement body is considered empty when ignoring comments, violating the rule.
['Get the name of class.', 'Get the method declaration from class.', 'Get the signature of method.', 'Get the name of method.', 'Get the control statements in method body.', 'Check whether the control statement is an if statement.', 'Get the if statement body.', 'Check whether the if statement body is empty (ignoring comments).', 'If the if statement body is empty (ignoring comments), then this test case violates the rule.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the method declaration from class.* 匹配到的元操作或API：
logic: Get the method declaration from class.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9198675155639648
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the control statements in method body.* 匹配到的元操作或API：
query: Get the control statements in method body.
most similar API: get body of method
cosine Similarity: 0.8021714687347412
*Check whether the control statement is an if statement.* 匹配到的元操作或API：
query: Check whether the control statement is an if statement.
most similar API: Check whether the if statement equals
cosine Similarity: 0.8228201866149902
*Get the if statement body.* 匹配到的元操作或API：
query: Get the if statement body.
most similar API: get text of if statement
cosine Similarity: 0.8767099380493164
*Check whether the if statement body is empty (ignoring comments).* 匹配到的元操作或API：
未匹配成功元操作或API
*If the if statement body is empty (ignoring comments), then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        } else if (node.getElseBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        } else if (node.getElseBranch() == null && node.getThenBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }
This checker has passed this negative testcase:
public class Foo {
    void bar(int x) {
        if (x > 2);
    }
}


This checker is failed(false negative) on this negative test case:
```
// empty if statement with comment
public class Foo {
    void bar(int x) {
        if (x == 0) {
            // empty!
        }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
5. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean equals(java.lang.Object)
6. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.document.Chars getText()

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;



import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && isEffectivelyEmpty(ifBody)) {
            addViolation(data, node);
        } else if (node.getElseBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        } else if (node.getElseBranch() == null && node.getThenBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && isEffectivelyEmpty(body)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && isEffectivelyEmpty(body)) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && isEffectivelyEmpty(body)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && isEffectivelyEmpty(body)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    private boolean isEffectivelyEmpty(ASTBlock block) {
        return block.isEmpty() || block.children().allMatch(node -> node instanceof ASTComment);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the control statement.
2. Check whether the control statement is an if statement.
3. Check whether the if statement has an else branch.
4. Get the body of the if statement.
5. Check whether the body of the if statement is empty.

If the control statement is an if statement and its body is empty, then this test case violates the rule. In this specific test case, the if statement's body is considered empty because it only contains a comment, not executable code. Therefore, the number of violations is indeed 1.
['Get the control statement.', 'Check whether the control statement is an if statement.', 'Check whether the if statement has an else branch.', 'Get the body of the if statement.', 'Check whether the body of the if statement is empty.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVoidType', 'ASTVariableDeclaratorId', 'ASTInfixExpression', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTIfStatement', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the control statement.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the control statement is an if statement.* 匹配到的元操作或API：
query: Check whether the control statement is an if statement.
most similar API: Check whether the if statement equals
cosine Similarity: 0.8228201866149902
*Check whether the if statement has an else branch.* 匹配到的元操作或API：
logic: Check whether the if statement has an else branch.
most similar meta operation: Check whether the if statement has else branch
cosine Similarity: 0.9772751331329346
*Get the body of the if statement.* 匹配到的元操作或API：
query: Get the body of the if statement.
most similar API: get text of if statement
cosine Similarity: 0.8748294115066528
*Check whether the body of the if statement is empty.* 匹配到的元操作或API：
logic: Check whether the body of the if statement is empty.
most similar meta operation: Check whether the string is empty
cosine Similarity: 0.8603639006614685
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports control statements whose body is empty, as well as empty initializers. The checked code constructs are the following: bodies of try statements、 finally clauses of try statements、 switch statements、 synchronized statements、 if statements、 loop statements: while, for, do .. while、initializers and blocks used as statements (for scoping).;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        } else if (node.getElseBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        } else if (node.getElseBranch() == null && node.getThenBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class EmptyTryBlock2 {
                public void foo() {
                    try {
                    } finally {
                        int x = 5;
                    }
                }
            }
This checker has passed this negative testcase:
class X {
                void method() {
                    try (ClientResponse response = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                        // was false positive
                        // EmptyTryBlock was fixed to ignore empty try-with-resources.
                        // This new rule will by default report also empty try-with-resource blocks,
                        // if the resource name is not "ignored", see next test case.
                    }
                }
            }
This checker has passed this negative testcase:
import java.io.InputStream;
            class X {
                void method(InputStream in) {
                    try (in) {
                    }
                }
            }
This checker has passed this positive testcase:
class X {
                void method() {
                    try (ClientResponse ignored = execute(() -> target.request(mediaTypes).delete(), DELETE, new ExpectedResponse(status, required))) {
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    {}
                }
            }
This checker has passed this negative testcase:
public class Foo {
                {}
            }
This checker has passed this negative testcase:
import java.util.List;

            public class Foo {

                public void bar(List<Integer> list) {
                    for (int i : list) {
                    }
                    for (int i : list)  { // neg, nonempty
                        System.out.println(i);
                    }
                }
            }
This checker has passed this negative testcase:
public class Foo {
                public void bar() {
                    while (true);
                }
            }
This checker has passed this negative testcase:
public class Foo {
    void bar(int x) {
        if (x > 2);
    }
}


This checker is failed(false negative) on this negative test case:
```
// empty if statement with comment
public class Foo {
    void bar(int x) {
        if (x == 0) {
            // empty!
        }
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock
        ——ASTIfStatement
          ——ASTInfixExpression
            ——ASTVariableAccess (referenced variable name = 'x')
            ——ASTNumericLiteral
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean equals(java.lang.Object)
2. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public boolean hasElse()
3. net.sourceforge.pmd.lang.java.ast.ASTIfStatement: public net.sourceforge.pmd.lang.document.Chars getText()
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isEmpty()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class EmptyControlStatementRule extends AbstractJavaRulechainRule {

    public EmptyControlStatementRule() {
        super(ASTTryStatement.class, ASTFinallyClause.class, ASTSwitchStatement.class, ASTSynchronizedStatement.class, ASTIfStatement.class, ASTForStatement.class, ASTWhileStatement.class, ASTDoStatement.class, ASTBlock.class, ASTInitializer.class, ASTForeachStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        ASTBlock tryBody = node.getBody();
        if (tryBody.isEmpty() && !node.isTryWithResources()) {
            addViolation(data, node);
        }
        ASTFinallyClause finallyClause = node.getFinallyClause();
        if (finallyClause != null && finallyClause.getBody().isEmpty()) {
            addViolation(data, finallyClause);
        }
        if (node.isTryWithResources()) {
            ASTResourceList resources = node.getResources();
            if (resources != null && resources.isEmpty()) {
                addViolation(data, node);
            } else {
                for (ASTResource resource : resources) {
                    if (resource.getFirstChildOfType(ASTLocalVariableDeclaration.class) != null) {
                        ASTVariableDeclaratorId id = resource.getFirstDescendantOfType(ASTVariableDeclaratorId.class);
                        if (id != null && !"ignored".equals(id.getImage()) && tryBody.isEmpty()) {
                            addViolation(data, node);
                        }
                    } else if (resource.getFirstChildOfType(ASTVariableAccess.class) != null && tryBody.isEmpty()) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyClause node, Object data) {
        ASTBlock body = node.getBody();
        if (body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSwitchStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        NodeStream<ASTSwitchBranch> branches = node.getBranches();
        if (branches.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTSynchronizedStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBlock ifBody = node.getFirstChildOfType(ASTBlock.class);
        if (ifBody != null && ifBody.isEmpty()) {
            addViolation(data, node);
        } else if (node.getElseBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        } else if (node.getElseBranch() == null && node.getThenBranch() instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWhileStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        ASTStatement statementBody = node.getBody();
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        } else if (statementBody instanceof ASTEmptyStatement) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTDoStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlock node, Object data) {
        if (node.isEmpty() && node.getParent() instanceof ASTIfStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTForStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTWhileStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTDoStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSwitchStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTSynchronizedStatement) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock && node.getParent().getParent() instanceof ASTClassOrInterfaceBody) {
            addViolation(data, node);
        } else if (node.isEmpty() && node.getParent() instanceof ASTBlock) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTInitializer node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForeachStatement node, Object data) {
        ASTBlock body = node.getFirstChildOfType(ASTBlock.class);
        if (body != null && body.isEmpty()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 22" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 22" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 22
测试用例全部通过
最终通过 19 个测试用例
正例 8 个
反例 11 个
输入token：972733
输出token：679962
结束

规则执行完毕，时间总花销： 12094.18540930748 秒
