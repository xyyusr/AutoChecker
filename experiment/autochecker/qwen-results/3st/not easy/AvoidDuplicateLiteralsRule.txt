开始

========================================== Rule AvoidDuplicateLiteralsRule ===========================================
一共 11 个测试用例
正例 3 个
反例 8 个
1989
1586
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of the class.
        2. Get all method declarations in class.
        3. Get method by name bar.
        4. Get all method calls in method bar.
        5. Get the called method name for each method call.
        6. Get the argument of each method call if the called method name is buz.
        7. Check whether the argument is a string literal.
        8. Get the length of each string literal.
        9. Check whether the length of the string literal is greater than or equal to 3.
        10. Create a map to count occurrences of each string literal.
        11. For each string literal, increment its count in the map.
        12. Check whether any string literal count is greater than or equal to 4.
        13. If a string literal count is greater than or equal to 4, get the name of the field that should be declared as a constant.
        14. Check whether the class contains a final static field with the same value as the duplicate string literal.
        15. If the class does not contain a final static field with the same value as the duplicate string literal, report the violation.

Based on these checks, the test case violates the rule as the string literal "Howdy" is passed to the `buz` method four times and its length is greater than or equal to 3. There is no final static field declared in the class with the value "Howdy".
['Get the name of the class.', 'Get all method declarations in class.', 'Get method by name bar.', 'Get all method calls in method bar.', 'Get the called method name for each method call.', 'Get the argument of each method call if the called method name is buz.', 'Check whether the argument is a string literal.', 'Get the length of each string literal.', 'Check whether the length of the string literal is greater than or equal to 3.', 'Create a map to count occurrences of each string literal.', 'For each string literal, increment its count in the map.', 'Check whether any string literal count is greater than or equal to 4.', 'If a string literal count is greater than or equal to 4, get the name of the field that should be declared as a constant.', 'Check whether the class contains a final static field with the same value as the duplicate string literal.', 'If the class does not contain a final static field with the same value as the duplicate string literal, report the violation.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of the class.* 匹配到的元操作或API：
logic: Get the name of the class.
most similar meta operation: Get the name of class
cosine Similarity: 0.968898594379425
*Get all method declarations in class.* 匹配到的元操作或API：
logic: Get all method declarations in class.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.8512488603591919
*Get method by name bar.* 匹配到的元操作或API：
query: Get method by name bar.
most similar API: get name of method
cosine Similarity: 0.8466580510139465
*Get all method calls in method bar.* 匹配到的元操作或API：
query: Get all method calls in method bar.
most similar API: get method name of method call
cosine Similarity: 0.8112229704856873
*Get the called method name for each method call.* 匹配到的元操作或API：
logic: Get the called method name for each method call.
most similar meta operation: Get the name of called method
cosine Similarity: 0.924312174320221
*Get the argument of each method call if the called method name is buz.* 匹配到的元操作或API：
logic: Get the argument of each method call if the called method name is buz.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.878119707107544
*Check whether the argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9077170491218567
*Get the length of each string literal.* 匹配到的元操作或API：
logic: Get the length of each string literal.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.9603046178817749
*Check whether the length of the string literal is greater than or equal to 3.* 匹配到的元操作或API：
query: Check whether the length of the string literal is greater than or equal to 3.
most similar API: length of string literal
cosine Similarity: 0.8233399987220764
*Create a map to count occurrences of each string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each string literal, increment its count in the map.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal count is greater than or equal to 4.* 匹配到的元操作或API：
query: Check whether any string literal count is greater than or equal to 4.
most similar API: Check whether the string literal equals
cosine Similarity: 0.8146824240684509
*If a string literal count is greater than or equal to 4, get the name of the field that should be declared as a constant.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class contains a final static field with the same value as the duplicate string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the class does not contain a final static field with the same value as the duplicate string literal, report the violation.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
The test case corresponding to the rule:
```
// duplicate literals in argument list
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'buz')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName(), //Returns the simple name of the method.
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length()
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length(), //Length of the constant value in characters.
7. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean equals(java.lang.Object)

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```
2.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        if (isMethodCallArgumentStringType(node)) {
            ASTArgumentList arguments = node.getArguments();
            ASTExpression expression = arguments.get(0);
            if (expression instanceof ASTStringLiteral) {
                ASTStringLiteral literal = (ASTStringLiteral) expression;
                if (literal.length() >= 3) {
                    Map<String, List<ASTStringLiteral>> literalMap = (Map<String, List<ASTStringLiteral>>) data;
                    literalMap.computeIfAbsent(literal.getValue().toString(), k -> new ArrayList<>()).add(literal);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        if (astArgumentList.getNumChildren() > 0) {
            ASTExpression expression = astArgumentList.getFirstChild();
            return TypeTestUtil.isA(String.class, expression.getTypeMirror());
        }
        return false;
    }

    @Override
    public void end(ASTCompilationUnit node, Object data) {
        Map<String, List<ASTStringLiteral>> literalMap = (Map<String, List<ASTStringLiteral>>) data;
        for (List<ASTStringLiteral> literals : literalMap.values()) {
            if (literals.size() >= 4) {
                for (int i = 3; i < literals.size(); i++) {
                    addViolation(data, literals.get(i));
                }
            }
        }
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        return super.visit(node, new HashMap<String, List<ASTStringLiteral>>());
    }

    // Get method declaration from method call
    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method) {
        JMethodSymbol symbol = (JMethodSymbol) method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Check whether the class is an interface.
2. Check whether the class is abstract.
3. Get all string literals in the class.
4. Check the length of each string literal.
5. Filter out string literals with length less than 3.
6. Count occurrences of each remaining string literal.
7. Identify string literals that appear 4 or more times.
8. Check whether each of these string literals are assigned to a constant field.
9. Get the left operand of the assignment expression.
10. Check whether the left operand is a field.
11. Check whether the field is static.
12. Check whether the field is final.
13. Check whether the field is of type String.

For the given test case:
1. The class `Foo` is not an interface.
2. The class `Foo` is not abstract.
3. The string literals in the class are "Howdy".
4. The length of "Howdy" is 5, which is greater than 3.
5. "Howdy" is not filtered out.
6. "Howdy" appears 4 times.
7. "Howdy" is one of the string literals that appear 4 or more times.
8. There is no assignment of "Howdy" to a constant field.
9. The left operand of the assignment expression is not applicable here as there is no assignment in the test case.
10. The left operand being a field is not applicable.
11. The left operand being static is not applicable.
12. The left operand being final is not applicable.
13. The left operand being of type String is not applicable.

Since "Howdy" is repeated 4 times and there is no assignment to a constant field, this test case violates the rule once. The description of this test case is "bad 1" and the number of violations is 1.
['Check whether the class is an interface.', 'Check whether the class is abstract.', 'Get all string literals in the class.', 'Check the length of each string literal.', 'Filter out string literals with length less than 3.', 'Count occurrences of each remaining string literal.', 'Identify string literals that appear 4 or more times.', 'Check whether each of these string literals are assigned to a constant field.', 'Get the left operand of the assignment expression.', 'Check whether the left operand is a field.', 'Check whether the field is static.', 'Check whether the field is final.', 'Check whether the field is of type String.', 'The class `Foo` is not an interface.', 'The class `Foo` is not abstract.', 'The string literals in the class are "Howdy".', 'The length of "Howdy" is 5, which is greater than 3.', '"Howdy" is not filtered out.', '"Howdy" appears 4 times.', '"Howdy" is one of the string literals that appear 4 or more times.', 'There is no assignment of "Howdy" to a constant field.', 'The left operand of the assignment expression is not applicable here as there is no assignment in the test case.', 'The left operand being a field is not applicable.', 'The left operand being static is not applicable.', 'The left operand being final is not applicable.', 'The left operand being of type String is not applicable.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Check whether the class is an interface.* 匹配到的元操作或API：
logic: Check whether the class is an interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9778784513473511
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all string literals in the class.* 匹配到的元操作或API：
query: Get all string literals in the class.
most similar API: get class of string literal
cosine Similarity: 0.8472422957420349
*Check the length of each string literal.* 匹配到的元操作或API：
logic: Check the length of each string literal.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.9169606566429138
*Filter out string literals with length less than 3.* 匹配到的元操作或API：
未匹配成功元操作或API
*Count occurrences of each remaining string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Identify string literals that appear 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each of these string literals are assigned to a constant field.* 匹配到的元操作或API：
query: Check whether each of these string literals are assigned to a constant field.
most similar API: Check whether the string literal is compile time constant
cosine Similarity: 0.8610177636146545
*Get the left operand of the assignment expression.* 匹配到的元操作或API：
logic: Get the left operand of the assignment expression.
most similar meta operation: Get the left operand of assignment expression
cosine Similarity: 0.9864992499351501
*Check whether the left operand is a field.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the field is static.* 匹配到的元操作或API：
logic: Check whether the field is static.
most similar meta operation: Check whether the field is static
cosine Similarity: 0.9852341413497925
*Check whether the field is final.* 匹配到的元操作或API：
logic: Check whether the field is final.
most similar meta operation: Check whether the field is final
cosine Similarity: 0.9875956177711487
*Check whether the field is of type String.* 匹配到的元操作或API：
logic: Check whether the field is of type String.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.9757717847824097
*The class `Foo` is not an interface.* 匹配到的元操作或API：
未匹配成功元操作或API
*The class `Foo` is not abstract.* 匹配到的元操作或API：
未匹配成功元操作或API
*The string literals in the class are "Howdy".* 匹配到的元操作或API：
未匹配成功元操作或API
*The length of "Howdy" is 5, which is greater than 3.* 匹配到的元操作或API：
未匹配成功元操作或API
*"Howdy" is not filtered out.* 匹配到的元操作或API：
未匹配成功元操作或API
*"Howdy" appears 4 times.* 匹配到的元操作或API：
未匹配成功元操作或API
*"Howdy" is one of the string literals that appear 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
*There is no assignment of "Howdy" to a constant field.* 匹配到的元操作或API：
未匹配成功元操作或API
*The left operand of the assignment expression is not applicable here as there is no assignment in the test case.* 匹配到的元操作或API：
未匹配成功元操作或API
*The left operand being a field is not applicable.* 匹配到的元操作或API：
未匹配成功元操作或API
*The left operand being static is not applicable.* 匹配到的元操作或API：
未匹配成功元操作或API
*The left operand being final is not applicable.* 匹配到的元操作或API：
未匹配成功元操作或API
*The left operand being of type String is not applicable.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
The test case corresponding to the rule:
```
// duplicate literals in argument list
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'buz')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.Class<Class<?> getClass()
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length()
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isCompileTimeConstant()
6. net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression: public net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr getLeftOperand()
7. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isStatic()
8. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isFinal()

1.  //Check whether the field is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFieldStringType(ASTFieldDeclaration node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


出现语法错误，这一轮舍弃，直接重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
        2. Get the signature of method.
        3. Get the number of formal parameters of method.
        4. Get a formal parameter of method.
        5. Get the type of formal parameter.
        6. Check whether the formal parameter is string type.
        7. Get all method calls inside method.
        8. Get the name of called method.
        9. Get the number of arguments of called method.
        10. Get an argument of called method.
        11. Check whether the argument is a string literal.
        12. Get the length of string literal.
        13. Check whether the length of string literal is greater than or equal to 3.
        14. Get the value of string literal.
        15. Count occurrences of each string literal value in the method.
        16. Check whether the count of any string literal value is greater than or equal to 4.
        If the count of any string literal value is greater than or equal to 4 and the length of the string literal is greater than or equal to 3, then the test case violates the rule.
['Get the name of method.', 'Get the signature of method.', 'Get the number of formal parameters of method.', 'Get a formal parameter of method.', 'Get the type of formal parameter.', 'Check whether the formal parameter is string type.', 'Get all method calls inside method.', 'Get the name of called method.', 'Get the number of arguments of called method.', 'Get an argument of called method.', 'Check whether the argument is a string literal.', 'Get the length of string literal.', 'Check whether the length of string literal is greater than or equal to 3.', 'Get the value of string literal.', 'Count occurrences of each string literal value in the method.', 'Check whether the count of any string literal value is greater than or equal to 4.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Get the number of formal parameters of method.* 匹配到的元操作或API：
logic: Get the number of formal parameters of method.
most similar meta operation: Get the number of formal parameters of method
cosine Similarity: 0.9860840439796448
*Get a formal parameter of method.* 匹配到的元操作或API：
logic: Get a formal parameter of method.
most similar meta operation: Get a formal parameter of method
cosine Similarity: 0.9826655983924866
*Get the type of formal parameter.* 匹配到的元操作或API：
logic: Get the type of formal parameter.
most similar meta operation: Get the type of formal parameter
cosine Similarity: 0.9854808449745178
*Check whether the formal parameter is string type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is string type.
most similar meta operation: Check whether the formal parameter is string type
cosine Similarity: 0.9882045984268188
*Get all method calls inside method.* 匹配到的元操作或API：
query: Get all method calls inside method.
most similar API: get method name of method call
cosine Similarity: 0.8236050605773926
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846129417419434
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9077170491218567
*Get the length of string literal.* 匹配到的元操作或API：
logic: Get the length of string literal.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.9875898361206055
*Check whether the length of string literal is greater than or equal to 3.* 匹配到的元操作或API：
query: Check whether the length of string literal is greater than or equal to 3.
most similar API: Check whether the string literal is long literal
cosine Similarity: 0.8297566771507263
*Get the value of string literal.* 匹配到的元操作或API：
logic: Get the value of string literal.
most similar meta operation: Get the value of string literal
cosine Similarity: 0.983224630355835
*Count occurrences of each string literal value in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of any string literal value is greater than or equal to 4.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
The test case corresponding to the rule:
```
// duplicate literals in argument list
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'buz')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTFormalParameters getFormalParameters()
4. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
7. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length()
8. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isLongLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral long integer literal}.
9. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.String getConstValue()

1.  //Get the number of formal parameters of method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTMethodDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```
2.  //Check whether the formal parameter is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFormalParameterStringType(ASTFormalParameter node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```
3.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
4.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        ASTArgumentList arguments = node.getArguments();
        for (ASTExpression expression : arguments) {
            if (expression instanceof ASTStringLiteral) {
                ASTStringLiteral literal = (ASTStringLiteral) expression;
                if (literal.length() >= 3) {
                    String value = literal.getConstValue();
                    int count = 0;
                    ASTClassOrInterfaceDeclaration classNode = (ASTClassOrInterfaceDeclaration) node.getNthParent(2);
                    for (ASTMethodCall methodCall : classNode.descendants(ASTMethodCall.class)) {
                        ASTArgumentList methodCallArguments = methodCall.getArguments();
                        for (ASTExpression methodCallExpression : methodCallArguments) {
                            if (methodCallExpression instanceof ASTStringLiteral) {
                                ASTStringLiteral methodCallLiteral = (ASTStringLiteral) methodCallExpression;
                                if (methodCallLiteral.getConstValue().equals(value) && methodCallLiteral.length() >= 3) {
                                    count++;
                                }
                            }
                        }
                    }
                    if (count >= 4) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    // Get the number of formal parameters of method
    public int getFormalParametersNumber(ASTMethodDeclaration node) {
        ASTFormalParameters formalParameters = node.getFormalParameters();
        return formalParameters.size();
    }

    // Check whether the formal parameter is string type
    public boolean isFormalParameterStringType(ASTFormalParameter node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // Select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Get the signature of method.
3. Get the body of method.
4. Get all method calls in the method body.
5. Get the argument list of each method call.
6. Check whether the argument is a string literal.
7. Get the length of string literal.
8. Check whether the length of string literal is greater than or equal to 3.
9. Collect all string literals in the method body that have a length greater than or equal to 3.
10. Count the occurrences of each unique string literal.
11. Check whether any string literal occurs 4 or more times.
12. If a string literal occurs 4 or more times, check whether it is assigned to a final field.

In this specific test case:
1. Get the name of method: bar
2. Get the signature of method: private void bar()
3. Get the body of method: Contains four method calls to `buz` with the string literal "Howdy".
4. Get all method calls in the method body: buz("Howdy"), buz("Howdy"), buz("Howdy"), buz("Howdy")
5. Get the argument list of each method call: "Howdy", "Howdy", "Howdy", "Howdy"
6. Check whether the argument is a string literal: True for all
7. Get the length of string literal: Length of "Howdy" is 5
8. Check whether the length of string literal is greater than or equal to 3: True for all
9. Collect all string literals in the method body that have a length greater than or equal to 3: "Howdy" (4 occurrences)
10. Count the occurrences of each unique string literal: "Howdy" occurs 4 times
11. Check whether any string literal occurs 4 or more times: True for "Howdy"
12. If a string literal occurs 4 or more times, check whether it is assigned to a final field: Not applicable, as the string literal is not assigned to any final field.

Since the string literal "Howdy" is used 4 times in the method `bar` and is not assigned to a final field, this test case violates the rule. The number of violating the rule in this test case is: 1.
['Get the name of method.', 'Get the signature of method.', 'Get the body of method.', 'Get all method calls in the method body.', 'Get the argument list of each method call.', 'Check whether the argument is a string literal.', 'Get the length of string literal.', 'Check whether the length of string literal is greater than or equal to 3.', 'Collect all string literals in the method body that have a length greater than or equal to 3.', 'Count the occurrences of each unique string literal.', 'Check whether any string literal occurs 4 or more times.', 'If a string literal occurs 4 or more times, check whether it is assigned to a final field.', 'Get the name of method: bar', 'Get the signature of method: private void bar()', 'Get the body of method: Contains four method calls to `buz` with the string literal "Howdy".', 'Get all method calls in the method body: buz("Howdy"), buz("Howdy"), buz("Howdy"), buz("Howdy")', 'Get the argument list of each method call: "Howdy", "Howdy", "Howdy", "Howdy"', 'Check whether the argument is a string literal: True for all', 'Get the length of string literal: Length of "Howdy" is 5', 'Check whether the length of string literal is greater than or equal to 3: True for all', 'Collect all string literals in the method body that have a length greater than or equal to 3: "Howdy" (4 occurrences)', 'Count the occurrences of each unique string literal: "Howdy" occurs 4 times', 'Check whether any string literal occurs 4 or more times: True for "Howdy"', 'If a string literal occurs 4 or more times, check whether it is assigned to a final field: Not applicable, as the string literal is not assigned to any final field.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752806425094604
*Get all method calls in the method body.* 匹配到的元操作或API：
query: Get all method calls in the method body.
most similar API: get body of method
cosine Similarity: 0.8307023644447327
*Get the argument list of each method call.* 匹配到的元操作或API：
logic: Get the argument list of each method call.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.85608971118927
*Check whether the argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9077170491218567
*Get the length of string literal.* 匹配到的元操作或API：
logic: Get the length of string literal.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.9875898361206055
*Check whether the length of string literal is greater than or equal to 3.* 匹配到的元操作或API：
query: Check whether the length of string literal is greater than or equal to 3.
most similar API: Check whether the string literal is long literal
cosine Similarity: 0.8297566771507263
*Collect all string literals in the method body that have a length greater than or equal to 3.* 匹配到的元操作或API：
未匹配成功元操作或API
*Count the occurrences of each unique string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
*If a string literal occurs 4 or more times, check whether it is assigned to a final field.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: bar* 匹配到的元操作或API：
logic: Get the name of method: bar
most similar meta operation: Get the name of method
cosine Similarity: 0.8775444030761719
*Get the signature of method: private void bar()* 匹配到的元操作或API：
logic: Get the signature of method: private void bar()
most similar meta operation: Get the signature of method
cosine Similarity: 0.9073016047477722
*Get the body of method: Contains four method calls to `buz` with the string literal "Howdy".* 匹配到的元操作或API：
query: Get the body of method: Contains four method calls to `buz` with the string literal "Howdy".
most similar API: get body of method
cosine Similarity: 0.8357859253883362
*Get all method calls in the method body: buz("Howdy"), buz("Howdy"), buz("Howdy"), buz("Howdy")* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the argument list of each method call: "Howdy", "Howdy", "Howdy", "Howdy"* 匹配到的元操作或API：
query: Get the argument list of each method call: "Howdy", "Howdy", "Howdy", "Howdy"
most similar API: get arguments of method call
cosine Similarity: 0.8496021628379822
*Check whether the argument is a string literal: True for all* 匹配到的元操作或API：
logic: Check whether the argument is a string literal: True for all
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8698047995567322
*Get the length of string literal: Length of "Howdy" is 5* 匹配到的元操作或API：
logic: Get the length of string literal: Length of "Howdy" is 5
most similar meta operation: Get the length of string literal
cosine Similarity: 0.8807318210601807
*Check whether the length of string literal is greater than or equal to 3: True for all* 匹配到的元操作或API：
query: Check whether the length of string literal is greater than or equal to 3: True for all
most similar API: length of string literal
cosine Similarity: 0.8334826231002808
*Collect all string literals in the method body that have a length greater than or equal to 3: "Howdy" (4 occurrences)* 匹配到的元操作或API：
未匹配成功元操作或API
*Count the occurrences of each unique string literal: "Howdy" occurs 4 times* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs 4 or more times: True for "Howdy"* 匹配到的元操作或API：
未匹配成功元操作或API
*If a string literal occurs 4 or more times, check whether it is assigned to a final field: Not applicable, as the string literal is not assigned to any final field.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
The test case corresponding to the rule:
```
// duplicate literals in argument list
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'buz')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length()
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isLongLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral long integer literal}.
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
7. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length(), //Length of the constant value in characters.

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
2.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;


import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.descendants(ASTStringLiteral.class).forEach(literal -> {
            String value = literal.getImage();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
True
此测试用例生成了first checker: bad 1


======================接下来开始迭代=====================
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
96
80
99
82
81
67
=========================error_testcase_logics=========================
To perform granular checks on the provided test case, we need to examine the annotations and count the occurrences of the string literals. Here are the steps:

1. Get the name of class.
2. Check whether class has declared annotations.
3. Get a declared annotation of class.
4. Check whether the annotation is SuppressWarnings.
5. Get the parameter list of SuppressWarnings annotation.
6. Check whether the parameter list contains string literals.
7. Get the string literal from the SuppressWarnings annotation.
8. Check whether the length of the string literal is greater than or equal to 3.
9. Count the occurrences of the string literal.
10. Check whether the count of the string literal is greater than or equal to 4.

Let's perform these steps:

1. Get the name of class.
   - The name of the class is `Foo`.

2. Check whether class has declared annotations.
   - The class has declared annotations.

3. Get a declared annotation of class.
   - The declared annotation is `@SuppressWarnings("foo")`.

4. Check whether the annotation is SuppressWarnings.
   - The annotation is `SuppressWarnings`.

5. Get the parameter list of SuppressWarnings annotation.
   - The parameter list contains one string literal `"foo"`.

6. Check whether the parameter list contains string literals.
   - The parameter list contains string literals.

7. Get the string literal from the SuppressWarnings annotation.
   - The string literal is `"foo"`.

8. Check whether the length of the string literal is greater than or equal to 3.
   - The length of the string literal `"foo"` is 3, which is greater than or equal to 3.

9. Count the occurrences of the string literal.
   - The string literal `"foo"` is used 8 times as a parameter to the `@SuppressWarnings` annotation.

10. Check whether the count of the string literal is greater than or equal to 4.
    - The count of the string literal `"foo"` is 8, which is greater than or equal to 4.

The test case violates the rule because the string literal `"foo"` is used as a parameter to the `@SuppressWarnings` annotation more than 4 times.
['Get the name of class.', 'Check whether class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the annotation is SuppressWarnings.', 'Get the parameter list of SuppressWarnings annotation.', 'Check whether the parameter list contains string literals.', 'Get the string literal from the SuppressWarnings annotation.', 'Check whether the length of the string literal is greater than or equal to 3.', 'Count the occurrences of the string literal.', 'Check whether the count of the string literal is greater than or equal to 4.', 'Get the name of class.', 'Check whether class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the annotation is SuppressWarnings.', 'Get the parameter list of SuppressWarnings annotation.', 'Check whether the parameter list contains string literals.', 'Get the string literal from the SuppressWarnings annotation.', 'Check whether the length of the string literal is greater than or equal to 3.', 'Count the occurrences of the string literal.', 'Check whether the count of the string literal is greater than or equal to 4.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTAnnotationMemberList', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTAnnotation', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'TokenUtils', 'ASTMemberValuePair', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether class has declared annotations.* 匹配到的元操作或API：
logic: Check whether class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9901518821716309
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.987838864326477
*Check whether the annotation is SuppressWarnings.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the parameter list of SuppressWarnings annotation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the parameter list contains string literals.* 匹配到的元操作或API：
query: Check whether the parameter list contains string literals.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8509273529052734
*Get the string literal from the SuppressWarnings annotation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the length of the string literal is greater than or equal to 3.* 匹配到的元操作或API：
query: Check whether the length of the string literal is greater than or equal to 3.
most similar API: length of string literal
cosine Similarity: 0.8233399987220764
*Count the occurrences of the string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of the string literal is greater than or equal to 4.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether class has declared annotations.* 匹配到的元操作或API：
logic: Check whether class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9901518821716309
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.987838864326477
*Check whether the annotation is SuppressWarnings.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the parameter list of SuppressWarnings annotation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the parameter list contains string literals.* 匹配到的元操作或API：
query: Check whether the parameter list contains string literals.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8509273529052734
*Get the string literal from the SuppressWarnings annotation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the length of the string literal is greater than or equal to 3.* 匹配到的元操作或API：
query: Check whether the length of the string literal is greater than or equal to 3.
most similar API: length of string literal
cosine Similarity: 0.8233399987220764
*Count the occurrences of the string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of the string literal is greater than or equal to 4.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.descendants(ASTStringLiteral.class).forEach(literal -> {
            String value = literal.getImage();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}


This checker is failed(false negative) on this negative test case:
```
// duplicate literals in annotations, default case
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
  ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length(), //Length of the constant value in characters.

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.descendants(ASTStringLiteral.class).forEach(literal -> {
            String value = literal.getImage();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        node.ancestor(ASTClassOrInterfaceDeclaration.class).ifPresent(classNode -> {
            classNode.getDeclaredAnnotations().forEach(annotation -> {
                annotation.getFirstChildOfType(ASTAnnotationMemberList.class).ifPresent(memberList -> {
                    memberList.descendants(ASTMemberValuePair.class).forEach(pair -> {
                        pair.getFirstChildOfType(ASTStringLiteral.class).ifPresent(literal -> {
                            String value = literal.getImage();
                            if (value.length() >= 3) {
                                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                                if (!firstOccurrenceMap.containsKey(value)) {
                                    firstOccurrenceMap.put(value, literal);
                                }
                            }
                        });
                    });
                });
            });

            stringLiteralCount.forEach((value, count) -> {
                if (count >= 4) {
                    ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                    addViolation(data, firstOccurrence);
                }
            });
        });

        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To analyze the adherence of the test case to the rule, we need to perform the following granular checks:

1. Get the name of class.
2. Check whether the class has declared annotations.
3. If the class has declared annotations, get the list of declared annotations.
4. For each annotation in the list, get the argument list of the annotation.
5. For each argument in the annotation, check whether the argument is a string literal.
6. If the argument is a string literal, get the value of the string literal.
7. Check whether the string literal has a length of 3 or more.
8. Count the occurrences of each string literal in the annotation arguments.
9. Check whether any string literal occurs 4 or more times.
10. If any string literal occurs 4 or more times, it violates the rule.

Let's apply these checks to the provided test case.

1. Get the name of class.
   - The name of the class is `Foo`.

2. Check whether the class has declared annotations.
   - The class `Foo` has declared annotations.

3. If the class has declared annotations, get the list of declared annotations.
   - The annotations declared on the class are `@SuppressWarnings("foo")` repeated multiple times.

4. For each annotation in the list, get the argument list of the annotation.
   - The argument list for each `@SuppressWarnings` annotation is `("foo")`.

5. For each argument in the annotation, check whether the argument is a string literal.
   - The argument `"foo"` is a string literal.

6. If the argument is a string literal, get the value of the string literal.
   - The value of the string literal is `"foo"`.

7. Check whether the string literal has a length of 3 or more.
   - The length of the string literal `"foo"` is 3, which meets the threshold of 3 or more.

8. Count the occurrences of each string literal in the annotation arguments.
   - The string literal `"foo"` occurs 8 times in the annotation arguments.

9. Check whether any string literal occurs 4 or more times.
   - The string literal `"foo"` occurs 8 times, which is more than 4.

10. If any string literal occurs 4 or more times, it violates the rule.
    - Since the string literal `"foo"` occurs 8 times, it violates the rule.

The number of violating the rule in this test case is indeed 1, as the string literal `"foo"` is used as an argument in more than 4 `@SuppressWarnings` annotations.
['Get the name of class.', 'Check whether the class has declared annotations.', 'If the class has declared annotations, get the list of declared annotations.', 'For each annotation in the list, get the argument list of the annotation.', 'For each argument in the annotation, check whether the argument is a string literal.', 'If the argument is a string literal, get the value of the string literal.', 'Check whether the string literal has a length of 3 or more.', 'Count the occurrences of each string literal in the annotation arguments.', 'Check whether any string literal occurs 4 or more times.', 'If any string literal occurs 4 or more times, it violates the rule.', 'Get the name of class.', 'Check whether the class has declared annotations.', 'If the class has declared annotations, get the list of declared annotations.', 'For each annotation in the list, get the argument list of the annotation.', 'For each argument in the annotation, check whether the argument is a string literal.', 'If the argument is a string literal, get the value of the string literal.', 'Check whether the string literal has a length of 3 or more.', 'Count the occurrences of each string literal in the annotation arguments.', 'Check whether any string literal occurs 4 or more times.', 'If any string literal occurs 4 or more times, it violates the rule.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTAnnotationMemberList', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTAnnotation', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'TokenUtils', 'ASTMemberValuePair', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*If the class has declared annotations, get the list of declared annotations.* 匹配到的元操作或API：
logic: If the class has declared annotations, get the list of declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.8948651552200317
*For each annotation in the list, get the argument list of the annotation.* 匹配到的元操作或API：
query: For each annotation in the list, get the argument list of the annotation.
most similar API: for each of annotation member list
cosine Similarity: 0.829756498336792
*For each argument in the annotation, check whether the argument is a string literal.* 匹配到的元操作或API：
query: For each argument in the annotation, check whether the argument is a string literal.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8474366664886475
*If the argument is a string literal, get the value of the string literal.* 匹配到的元操作或API：
logic: If the argument is a string literal, get the value of the string literal.
most similar meta operation: Get the value of string literal
cosine Similarity: 0.9168165326118469
*Check whether the string literal has a length of 3 or more.* 匹配到的元操作或API：
query: Check whether the string literal has a length of 3 or more.
most similar API: Check whether the string literal is long literal
cosine Similarity: 0.8505315184593201
*Count the occurrences of each string literal in the annotation arguments.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
*If any string literal occurs 4 or more times, it violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*If the class has declared annotations, get the list of declared annotations.* 匹配到的元操作或API：
logic: If the class has declared annotations, get the list of declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.8948651552200317
*For each annotation in the list, get the argument list of the annotation.* 匹配到的元操作或API：
query: For each annotation in the list, get the argument list of the annotation.
most similar API: for each of annotation member list
cosine Similarity: 0.829756498336792
*For each argument in the annotation, check whether the argument is a string literal.* 匹配到的元操作或API：
query: For each argument in the annotation, check whether the argument is a string literal.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.8474366664886475
*If the argument is a string literal, get the value of the string literal.* 匹配到的元操作或API：
logic: If the argument is a string literal, get the value of the string literal.
most similar meta operation: Get the value of string literal
cosine Similarity: 0.9168165326118469
*Check whether the string literal has a length of 3 or more.* 匹配到的元操作或API：
query: Check whether the string literal has a length of 3 or more.
most similar API: Check whether the string literal is long literal
cosine Similarity: 0.8505315184593201
*Count the occurrences of each string literal in the annotation arguments.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
*If any string literal occurs 4 or more times, it violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.descendants(ASTStringLiteral.class).forEach(literal -> {
            String value = literal.getImage();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}


This checker is failed(false negative) on this negative test case:
```
// duplicate literals in annotations, default case
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
  ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTAnnotationMemberList: public void forEach(java.util.function.Consumer)
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.String getConstValue()
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isLongLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral long integer literal}.

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.descendants(ASTStringLiteral.class).forEach(literal -> {
            String value = literal.getImage();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.getDeclaredAnnotations().stream().flatMap(annotation -> 
            annotation.getAnnotationMemberList().getDescendants(ASTStringLiteral.class).stream()
        ).forEach(literal -> {
            String value = literal.getImage();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all annotations declared in class.
3. Get the value of each annotation if it is SuppressWarnings.
4. Check whether the value is a string literal.
5. Check whether the length of the string literal is greater than or equal to 3.
6. Count occurrences of each string literal that meets the above criteria.
7. Check whether any string literal occurs 4 or more times.

For the provided test case:

1. The name of the class is Foo.
2. The class has multiple annotations declared.
3. The annotation value is "foo" for each SuppressWarnings annotation.
4. The value "foo" is a string literal.
5. The length of "foo" is greater than or equal to 3.
6. The string literal "foo" occurs 8 times.
7. Since "foo" occurs more than 4 times, the rule is violated.

The number of string literals that violate the rule in this test case is 1.
['Get the name of class.', 'Get all annotations declared in class.', 'Get the value of each annotation if it is SuppressWarnings.', 'Check whether the value is a string literal.', 'Check whether the length of the string literal is greater than or equal to 3.', 'Count occurrences of each string literal that meets the above criteria.', 'Check whether any string literal occurs 4 or more times.', 'The name of the class is Foo.', 'The class has multiple annotations declared.', 'The annotation value is "foo" for each SuppressWarnings annotation.', 'The value "foo" is a string literal.', 'The length of "foo" is greater than or equal to 3.', 'The string literal "foo" occurs 8 times.', 'Since "foo" occurs more than 4 times, the rule is violated.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTAnnotationMemberList', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTAnnotation', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'TokenUtils', 'ASTMemberValuePair', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all annotations declared in class.* 匹配到的元操作或API：
logic: Get all annotations declared in class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.8872413635253906
*Get the value of each annotation if it is SuppressWarnings.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the value is a string literal.* 匹配到的元操作或API：
query: Check whether the value is a string literal.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.9385813474655151
*Check whether the length of the string literal is greater than or equal to 3.* 匹配到的元操作或API：
query: Check whether the length of the string literal is greater than or equal to 3.
most similar API: length of string literal
cosine Similarity: 0.8233399987220764
*Count occurrences of each string literal that meets the above criteria.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
*The name of the class is Foo.* 匹配到的元操作或API：
未匹配成功元操作或API
*The class has multiple annotations declared.* 匹配到的元操作或API：
未匹配成功元操作或API
*The annotation value is "foo" for each SuppressWarnings annotation.* 匹配到的元操作或API：
未匹配成功元操作或API
*The value "foo" is a string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*The length of "foo" is greater than or equal to 3.* 匹配到的元操作或API：
未匹配成功元操作或API
*The string literal "foo" occurs 8 times.* 匹配到的元操作或API：
未匹配成功元操作或API
*Since "foo" occurs more than 4 times, the rule is violated.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.descendants(ASTStringLiteral.class).forEach(literal -> {
            String value = literal.getImage();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}


This checker is failed(false negative) on this negative test case:
```
// duplicate literals in annotations, default case
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
  ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length(), //Length of the constant value in characters.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.descendants(ASTStringLiteral.class).forEach(literal -> {
            String value = literal.getImage();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        Map<String, Integer> annotationLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.getDeclaredAnnotations().forEach(annotation -> {
            annotation.getFirstChildOfType(ASTAnnotationMemberList.class).getDescendants(ASTMemberValuePair.class).forEach(pair -> {
                ASTExpression expression = pair.getFirstChildOfType(ASTExpression.class);
                if (expression instanceof ASTStringLiteral) {
                    ASTStringLiteral literal = (ASTStringLiteral) expression;
                    String value = literal.getImage();
                    if (value.length() >= 3) {
                        annotationLiteralCount.put(value, annotationLiteralCount.getOrDefault(value, 0) + 1);
                        if (!firstOccurrenceMap.containsKey(value)) {
                            firstOccurrenceMap.put(value, literal);
                        }
                    }
                }
            });
        });

        annotationLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all annotations declared in the class.
3. Get the name of the annotation.
4. Check whether the annotation name is SuppressWarnings.
5. Get the value of the SuppressWarnings annotation.
6. Check whether the value is a string literal.
7. Get the length of string literal.
8. Check whether the length of string literal is greater than or equal to 3.
9. Count occurrences of each string literal value in the SuppressWarnings annotations.
10. Check whether the count of any string literal value is greater than or equal to 4.

In this test case, the `SuppressWarnings` annotation is used multiple times with the same string literal "foo". The length of "foo" is greater than 3, and it is used 8 times, which is more than the threshold of 4. Therefore, the number of violations of the rule in this test case is 1.
['Get the name of class.', 'Get all annotations declared in the class.', 'Get the name of the annotation.', 'Check whether the annotation name is SuppressWarnings.', 'Get the value of the SuppressWarnings annotation.', 'Check whether the value is a string literal.', 'Get the length of string literal.', 'Check whether the length of string literal is greater than or equal to 3.', 'Count occurrences of each string literal value in the SuppressWarnings annotations.', 'Check whether the count of any string literal value is greater than or equal to 4.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTAnnotationMemberList', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTAnnotation', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'TokenUtils', 'ASTMemberValuePair', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all annotations declared in the class.* 匹配到的元操作或API：
logic: Get all annotations declared in the class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.8816115856170654
*Get the name of the annotation.* 匹配到的元操作或API：
logic: Get the name of the annotation.
most similar meta operation: Get the name of annotation declaration
cosine Similarity: 0.9262325763702393
*Check whether the annotation name is SuppressWarnings.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the value of the SuppressWarnings annotation.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the value is a string literal.* 匹配到的元操作或API：
query: Check whether the value is a string literal.
most similar API: Check whether the string literal is string literal
cosine Similarity: 0.9385813474655151
*Get the length of string literal.* 匹配到的元操作或API：
logic: Get the length of string literal.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.9875898361206055
*Check whether the length of string literal is greater than or equal to 3.* 匹配到的元操作或API：
query: Check whether the length of string literal is greater than or equal to 3.
most similar API: Check whether the string literal is long literal
cosine Similarity: 0.8297566771507263
*Count occurrences of each string literal value in the SuppressWarnings annotations.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of any string literal value is greater than or equal to 4.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.descendants(ASTStringLiteral.class).forEach(literal -> {
            String value = literal.getImage();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}


This checker is failed(false negative) on this negative test case:
```
// duplicate literals in annotations, default case
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
  ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration: public java.lang.String getSimpleName()
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isStringLiteral(), //Returns true if this is a {@linkplain ASTStringLiteral string literal}.
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length()
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isLongLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral long integer literal}.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.descendants(ASTStringLiteral.class).forEach(literal -> {
            String value = literal.getImage();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.getDeclaredAnnotations().forEach(annotation -> {
            annotation.descendants(ASTStringLiteral.class).forEach(literal -> {
                String value = literal.getImage();
                if (value.length() >= 3) {
                    stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                    if (!firstOccurrenceMap.containsKey(value)) {
                        firstOccurrenceMap.put(value, literal);
                    }
                }
            });
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
To analyze the provided test case for adherence to the rule, we need to perform granular checks on the string literals used in the annotations. Here are the steps:

1. Get the declared annotations of class.
2. Iterate through each declared annotation.
3. For each annotation, get the value of the string literal(s) in the annotation.
4. Check whether the length of the string literal is 3 or more.
5. If the length is 3 or more, track the occurrences of each string literal.
6. Check whether any string literal occurs 4 or more times.
7. If a string literal occurs 4 or more times, check whether it is declared as a constant field.

Let's apply these steps to the test case:

1. Get the declared annotations of class.
    - The declared annotations are `@SuppressWarnings("foo")` (repeated 8 times).

2. Iterate through each declared annotation.
    - Iterate through the 8 `@SuppressWarnings("foo")` annotations.

3. For each annotation, get the value of the string literal(s) in the annotation.
    - For each `@SuppressWarnings("foo")`, the string literal is `"foo"`.

4. Check whether the length of the string literal is 3 or more.
    - The length of `"foo"` is 3, which meets the threshold.

5. If the length is 3 or more, track the occurrences of each string literal.
    - Track the occurrence of `"foo"`.

6. Check whether any string literal occurs 4 or more times.
    - `"foo"` occurs 8 times, which is more than the threshold of 4.

7. If a string literal occurs 4 or more times, check whether it is declared as a constant field.
    - `"foo"` is not declared as a constant field in the class.

Based on these checks, the test case violates the rule because the string literal `"foo"` appears 8 times in the annotations, which exceeds the threshold of 4, and it is not declared as a constant field. The number of violations in this test case is indeed: 1.
['Get the declared annotations of class.', 'Iterate through each declared annotation.', 'For each annotation, get the value of the string literal(s) in the annotation.', 'Check whether the length of the string literal is 3 or more.', 'If the length is 3 or more, track the occurrences of each string literal.', 'Check whether any string literal occurs 4 or more times.', 'If a string literal occurs 4 or more times, check whether it is declared as a constant field.', 'Get the declared annotations of class.', 'Iterate through each declared annotation.', 'For each annotation, get the value of the string literal(s) in the annotation.', 'Check whether the length of the string literal is 3 or more.', 'If the length is 3 or more, track the occurrences of each string literal.', 'Check whether any string literal occurs 4 or more times.', 'If a string literal occurs 4 or more times, check whether it is declared as a constant field.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTAnnotationMemberList', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTAnnotation', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'TokenUtils', 'ASTMemberValuePair', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the declared annotations of class.* 匹配到的元操作或API：
logic: Get the declared annotations of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9313310384750366
*Iterate through each declared annotation.* 匹配到的元操作或API：
query: Iterate through each declared annotation.
most similar API: iterator of annotation
cosine Similarity: 0.8646450638771057
*For each annotation, get the value of the string literal(s) in the annotation.* 匹配到的元操作或API：
query: For each annotation, get the value of the string literal(s) in the annotation.
most similar API: get text of annotation
cosine Similarity: 0.8194466829299927
*Check whether the length of the string literal is 3 or more.* 匹配到的元操作或API：
query: Check whether the length of the string literal is 3 or more.
most similar API: length of string literal
cosine Similarity: 0.8429111838340759
*If the length is 3 or more, track the occurrences of each string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
*If a string literal occurs 4 or more times, check whether it is declared as a constant field.* 匹配到的元操作或API：
query: If a string literal occurs 4 or more times, check whether it is declared as a constant field.
most similar API: Check whether the string literal is compile time constant
cosine Similarity: 0.8316318392753601
*Get the declared annotations of class.* 匹配到的元操作或API：
logic: Get the declared annotations of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9313310384750366
*Iterate through each declared annotation.* 匹配到的元操作或API：
query: Iterate through each declared annotation.
most similar API: iterator of annotation
cosine Similarity: 0.8646450638771057
*For each annotation, get the value of the string literal(s) in the annotation.* 匹配到的元操作或API：
query: For each annotation, get the value of the string literal(s) in the annotation.
most similar API: get text of annotation
cosine Similarity: 0.8194466829299927
*Check whether the length of the string literal is 3 or more.* 匹配到的元操作或API：
query: Check whether the length of the string literal is 3 or more.
most similar API: length of string literal
cosine Similarity: 0.8429111838340759
*If the length is 3 or more, track the occurrences of each string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal occurs 4 or more times.* 匹配到的元操作或API：
未匹配成功元操作或API
*If a string literal occurs 4 or more times, check whether it is declared as a constant field.* 匹配到的元操作或API：
query: If a string literal occurs 4 or more times, check whether it is declared as a constant field.
most similar API: Check whether the string literal is compile time constant
cosine Similarity: 0.8316318392753601
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.descendants(ASTStringLiteral.class).forEach(literal -> {
            String value = literal.getImage();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}


This checker is failed(false negative) on this negative test case:
```
// duplicate literals in annotations, default case
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTAnnotationMemberList
        ——ASTMemberValuePair
          ——ASTStringLiteral
  ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
2. net.sourceforge.pmd.lang.java.ast.ASTAnnotation: public java.util.Iterator<ASTMemberValuePair> iterator()
3. net.sourceforge.pmd.lang.java.ast.ASTAnnotation: public net.sourceforge.pmd.lang.document.Chars getText()
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length(), //Length of the constant value in characters.
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isCompileTimeConstant()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.descendants(ASTStringLiteral.class).forEach(literal -> {
            String value = literal.getImage();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        node.getParent().as(ASTClassOrInterfaceDeclaration.class).ifPresent(classOrInterfaceDeclaration -> {
            classOrInterfaceDeclaration.getDeclaredAnnotations().forEach(annotation -> {
                annotation.iterator().forEachRemaining(memberValuePair -> {
                    ASTStringLiteral literal = memberValuePair.getValue().as(ASTStringLiteral.class).orElse(null);
                    if (literal != null && literal.getImage().length() >= 3) {
                        String value = literal.getImage();
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (!firstOccurrenceMap.containsKey(value)) {
                            firstOccurrenceMap.put(value, literal);
                        }
                    }
                });
            });
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 3
[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get all string literals in class.
2. Check whether the length of string literal is less than 3.
3. Get the count of each unique string literal with length >= 3.
4. Check whether any string literal count is 4 or more.

For the provided test case:

1. Get all string literals in class: "foo", "foo", "foo", "foo", "fo", "fo", "fo", "fo".
2. Check whether the length of string literal "foo" is less than 3: False.
3. Get the count of the string literal "foo": 4.
4. Check whether the count of the string literal "foo" is 4 or more: True (violates the rule).

5. Check whether the length of string literal "fo" is less than 3: True (ignored).
6. Get the count of the string literal "fo": 4.
7. Check whether the count of the string literal "fo" is 4 or more: True (but ignored due to length < 3).

Thus, the number of violating the rule in this test case is 1, specifically with the string literal "foo".
['Get all string literals in class.', 'Check whether the length of string literal is less than 3.', 'Get the count of each unique string literal with length >= 3.', 'Check whether any string literal count is 4 or more.', 'Get all string literals in class: "foo", "foo", "foo", "foo", "fo", "fo", "fo", "fo".', 'Check whether the length of string literal "foo" is less than 3: False.', 'Get the count of the string literal "foo": 4.', 'Check whether the count of the string literal "foo" is 4 or more: True (violates the rule).', 'Check whether the length of string literal "fo" is less than 3: True (ignored).', 'Get the count of the string literal "fo": 4.', 'Check whether the count of the string literal "fo" is 4 or more: True (but ignored due to length < 3).']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get all string literals in class.* 匹配到的元操作或API：
query: Get all string literals in class.
most similar API: get class of string literal
cosine Similarity: 0.855272114276886
*Check whether the length of string literal is less than 3.* 匹配到的元操作或API：
query: Check whether the length of string literal is less than 3.
most similar API: length of string literal
cosine Similarity: 0.8233144879341125
*Get the count of each unique string literal with length >= 3.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any string literal count is 4 or more.* 匹配到的元操作或API：
query: Check whether any string literal count is 4 or more.
most similar API: Check whether the string literal is double literal
cosine Similarity: 0.8192036747932434
*Get all string literals in class: "foo", "foo", "foo", "foo", "fo", "fo", "fo", "fo".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the length of string literal "foo" is less than 3: False.* 匹配到的元操作或API：
query: Check whether the length of string literal "foo" is less than 3: False.
most similar API: length of string literal
cosine Similarity: 0.8163949251174927
*Get the count of the string literal "foo": 4.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of the string literal "foo" is 4 or more: True (violates the rule).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the length of string literal "fo" is less than 3: True (ignored).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the count of the string literal "fo": 4.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of the string literal "fo" is 4 or more: True (but ignored due to length < 3).* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.descendants(ASTStringLiteral.class).forEach(literal -> {
            String value = literal.getImage();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}


This checker is failed(false negative) on this negative test case:
```
// minimum length property, default value
public class Foo {
    private void bar() {
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
        buz("fo"); buz("fo"); buz("fo"); buz("fo");
    }
    private void buz(String x) {}
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'buz')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.Class<Class<?> getClass()
2. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length(), //Length of the constant value in characters.
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isDoubleLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral double literal}.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.descendants(ASTStringLiteral.class).forEach(literal -> {
            String value = literal.getImage();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all methods declared in class.
3. Get the body of method.
4. Get all string literals in the method body.
5. Check whether the length of the string literal is less than 3.
6. Get the count of each string literal that has a length of 3 or more.
7. Check whether the count of any string literal is 4 or more.
8. If the count is 4 or more, check whether the string literal is assigned to a final field.

For the provided test case:
1. Get the name of class: Foo.
2. Get all methods declared in class: bar.
3. Get the body of method bar.
4. Get all string literals in the method body: "foo", "foo", "foo", "foo", "fo", "fo", "fo", "fo".
5. Check whether the length of the string literal is less than 3: "fo" has a length of 2, so it is ignored.
6. Get the count of each string literal that has a length of 3 or more: "foo" appears 4 times.
7. Check whether the count of any string literal is 4 or more: "foo" appears 4 times.
8. If the count is 4 or more, check whether the string literal is assigned to a final field: "foo" is not assigned to a final field.

Since "foo" appears 4 times and is not assigned to a final field, this test case violates the rule. The number of violating the rule in this test case is: 1.
['Get the name of class.', 'Get all methods declared in class.', 'Get the body of method.', 'Get all string literals in the method body.', 'Check whether the length of the string literal is less than 3.', 'Get the count of each string literal that has a length of 3 or more.', 'Check whether the count of any string literal is 4 or more.', 'If the count is 4 or more, check whether the string literal is assigned to a final field.', 'Get the name of class: Foo.', 'Get all methods declared in class: bar.', 'Get the body of method bar.', 'Get all string literals in the method body: "foo", "foo", "foo", "foo", "fo", "fo", "fo", "fo".', 'Check whether the length of the string literal is less than 3: "fo" has a length of 2, so it is ignored.', 'Get the count of each string literal that has a length of 3 or more: "foo" appears 4 times.', 'Check whether the count of any string literal is 4 or more: "foo" appears 4 times.', 'If the count is 4 or more, check whether the string literal is assigned to a final field: "foo" is not assigned to a final field.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752806425094604
*Get all string literals in the method body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the length of the string literal is less than 3.* 匹配到的元操作或API：
query: Check whether the length of the string literal is less than 3.
most similar API: length of string literal
cosine Similarity: 0.8179241418838501
*Get the count of each string literal that has a length of 3 or more.* 匹配到的元操作或API：
query: Get the count of each string literal that has a length of 3 or more.
most similar API: get num children of string literal
cosine Similarity: 0.8220588564872742
*Check whether the count of any string literal is 4 or more.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the count is 4 or more, check whether the string literal is assigned to a final field.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: Foo.* 匹配到的元操作或API：
logic: Get the name of class: Foo.
most similar meta operation: Get the name of class
cosine Similarity: 0.9150534272193909
*Get all methods declared in class: bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the body of method bar.* 匹配到的元操作或API：
query: Get the body of method bar.
most similar API: get body of method
cosine Similarity: 0.8829172849655151
*Get all string literals in the method body: "foo", "foo", "foo", "foo", "fo", "fo", "fo", "fo".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the length of the string literal is less than 3: "fo" has a length of 2, so it is ignored.* 匹配到的元操作或API：
query: Check whether the length of the string literal is less than 3: "fo" has a length of 2, so it is ignored.
most similar API: length of string literal
cosine Similarity: 0.8074280023574829
*Get the count of each string literal that has a length of 3 or more: "foo" appears 4 times.* 匹配到的元操作或API：
query: Get the count of each string literal that has a length of 3 or more: "foo" appears 4 times.
most similar API: get num children of string literal
cosine Similarity: 0.8008230924606323
*Check whether the count of any string literal is 4 or more: "foo" appears 4 times.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the count is 4 or more, check whether the string literal is assigned to a final field: "foo" is not assigned to a final field.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.descendants(ASTStringLiteral.class).forEach(literal -> {
            String value = literal.getImage();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}


This checker is failed(false negative) on this negative test case:
```
// minimum length property, default value
public class Foo {
    private void bar() {
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
        buz("fo"); buz("fo"); buz("fo"); buz("fo");
    }
    private void buz(String x) {}
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'buz')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length(), //Length of the constant value in characters.
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int getNumChildren()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.descendants(ASTStringLiteral.class).forEach(literal -> {
            String value = literal.getImage();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        node.descendants(ASTMethodCall.class).forEach(methodCall -> {
            ASTArgumentList arguments = methodCall.getArguments();
            arguments.forEach(arg -> {
                if (arg instanceof ASTStringLiteral) {
                    ASTStringLiteral literal = (ASTStringLiteral) arg;
                    String value = literal.getImage();
                    if (value.length() >= 3) {
                        stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                        if (!firstOccurrenceMap.containsKey(value)) {
                            firstOccurrenceMap.put(value, literal);
                        }
                    }
                }
            });
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 1" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}, {'error_rules_info': '[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <4>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 1" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get all string literals in class.
2. Check whether the string literal length is less than 3.
3. Ignore string literals with length less than 3.
4. Count occurrences of each non-ignored string literal.
5. Check whether the count of any non-ignored string literal is 4 or more.
6. If the count of any non-ignored string literal is 4 or more, identify the string literal.
7. Check whether the identified string literal is assigned to a constant field.
8. If the string literal is not assigned to a constant field, note it as a violation.

In the provided test case:

1. The string literals "foo" and "fo" are identified in the class.
2. "fo" has a length less than 3, so it is ignored.
3. "foo" has a length of 3 or more, so it is not ignored.
4. "foo" appears 4 times in the method `bar`.
5. Since "foo" appears 4 times, it is checked for assignment to a constant field.
6. "foo" is not assigned to any constant field.
7. Therefore, the test case violates the rule once.
['Get all string literals in class.', 'Check whether the string literal length is less than 3.', 'Ignore string literals with length less than 3.', 'Count occurrences of each non-ignored string literal.', 'Check whether the count of any non-ignored string literal is 4 or more.', 'If the count of any non-ignored string literal is 4 or more, identify the string literal.', 'Check whether the identified string literal is assigned to a constant field.', 'If the string literal is not assigned to a constant field, note it as a violation.', 'The string literals "foo" and "fo" are identified in the class.', '"fo" has a length less than 3, so it is ignored.', '"foo" has a length of 3 or more, so it is not ignored.', '"foo" appears 4 times in the method `bar`.', 'Since "foo" appears 4 times, it is checked for assignment to a constant field.', '"foo" is not assigned to any constant field.', 'Therefore, the test case violates the rule once.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get all string literals in class.* 匹配到的元操作或API：
query: Get all string literals in class.
most similar API: get class of string literal
cosine Similarity: 0.855272114276886
*Check whether the string literal length is less than 3.* 匹配到的元操作或API：
query: Check whether the string literal length is less than 3.
most similar API: Check whether the string literal is long literal
cosine Similarity: 0.8144642114639282
*Ignore string literals with length less than 3.* 匹配到的元操作或API：
未匹配成功元操作或API
*Count occurrences of each non-ignored string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of any non-ignored string literal is 4 or more.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the count of any non-ignored string literal is 4 or more, identify the string literal.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the identified string literal is assigned to a constant field.* 匹配到的元操作或API：
query: Check whether the identified string literal is assigned to a constant field.
most similar API: Check whether the string literal is compile time constant
cosine Similarity: 0.8658952713012695
*If the string literal is not assigned to a constant field, note it as a violation.* 匹配到的元操作或API：
未匹配成功元操作或API
*The string literals "foo" and "fo" are identified in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*"fo" has a length less than 3, so it is ignored.* 匹配到的元操作或API：
未匹配成功元操作或API
*"foo" has a length of 3 or more, so it is not ignored.* 匹配到的元操作或API：
未匹配成功元操作或API
*"foo" appears 4 times in the method `bar`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Since "foo" appears 4 times, it is checked for assignment to a constant field.* 匹配到的元操作或API：
未匹配成功元操作或API
*"foo" is not assigned to any constant field.* 匹配到的元操作或API：
未匹配成功元操作或API
*Therefore, the test case violates the rule once.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.descendants(ASTStringLiteral.class).forEach(literal -> {
            String value = literal.getImage();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}


This checker is failed(false negative) on this negative test case:
```
// minimum length property, default value
public class Foo {
    private void bar() {
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
        buz("fo"); buz("fo"); buz("fo"); buz("fo");
    }
    private void buz(String x) {}
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'buz')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.Class<Class<?> getClass()
2. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isLongLiteral(), //Returns true if this is a {@linkplain ASTNumericLiteral long integer literal}.
3. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isCompileTimeConstant()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.descendants(ASTStringLiteral.class).forEach(literal -> {
            String value = literal.getImage();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all methods declared in class.
3. Get the signature of method.
4. Get the body of method.
5. Get all string literals used in method.
6. Check whether the length of string literal is less than 3.
7. Get the count of each string literal used in method.
8. Check whether the count of any string literal is 4 or more.
9. If the string literal length is not less than 3 and the count of the string literal is 4 or more, check whether it is declared as a constant field.

For the provided test case:

1. Get the name of class: Foo
2. Get all methods declared in class: bar, buz
3. Get the signature of method: private void bar()
4. Get the body of method: 
    - buz("foo"); buz("foo"); buz("foo"); buz("foo");
    - buz("fo"); buz("fo"); buz("fo"); buz("fo");
5. Get all string literals used in method: "foo", "fo"
6. Check whether the length of string literal is less than 3:
    - "foo" length is 3 -> not ignored
    - "fo" length is 2 -> ignored
7. Get the count of each string literal used in method:
    - "foo" count is 4
    - "fo" count is 4 but ignored due to length
8. Check whether the count of any string literal is 4 or more:
    - "foo" count is 4 -> violating the rule
9. If the string literal length is not less than 3 and the count of the string literal is 4 or more, check whether it is declared as a constant field:
    - "foo" is not declared as a constant field -> violating the rule

The number of violating the rule in this test case is indeed: 1
['Get the name of class.', 'Get all methods declared in class.', 'Get the signature of method.', 'Get the body of method.', 'Get all string literals used in method.', 'Check whether the length of string literal is less than 3.', 'Get the count of each string literal used in method.', 'Check whether the count of any string literal is 4 or more.', 'If the string literal length is not less than 3 and the count of the string literal is 4 or more, check whether it is declared as a constant field.', 'Get the name of class: Foo', 'Get all methods declared in class: bar, buz', 'Get the signature of method: private void bar()', 'Get the body of method:', 'Get all string literals used in method: "foo", "fo"', 'Check whether the length of string literal is less than 3:', 'Get the count of each string literal used in method:', 'Check whether the count of any string literal is 4 or more:', 'If the string literal length is not less than 3 and the count of the string literal is 4 or more, check whether it is declared as a constant field:']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752806425094604
*Get all string literals used in method.* 匹配到的元操作或API：
query: Get all string literals used in method.
most similar API: get symbol table of string literal
cosine Similarity: 0.8143868446350098
*Check whether the length of string literal is less than 3.* 匹配到的元操作或API：
query: Check whether the length of string literal is less than 3.
most similar API: length of string literal
cosine Similarity: 0.8233144879341125
*Get the count of each string literal used in method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of any string literal is 4 or more.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the string literal length is not less than 3 and the count of the string literal is 4 or more, check whether it is declared as a constant field.* 匹配到的元操作或API：
query: If the string literal length is not less than 3 and the count of the string literal is 4 or more, check whether it is declared as a constant field.
most similar API: Check whether the string literal is compile time constant
cosine Similarity: 0.8108195662498474
*Get the name of class: Foo* 匹配到的元操作或API：
logic: Get the name of class: Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9263077974319458
*Get all methods declared in class: bar, buz* 匹配到的元操作或API：
query: Get all methods declared in class: bar, buz
most similar API: get declared annotations of method
cosine Similarity: 0.803353488445282
*Get the signature of method: private void bar()* 匹配到的元操作或API：
logic: Get the signature of method: private void bar()
most similar meta operation: Get the signature of method
cosine Similarity: 0.9073016047477722
*Get the body of method:* 匹配到的元操作或API：
query: Get the body of method:
most similar API: get body of method
cosine Similarity: 0.9746073484420776
*Get all string literals used in method: "foo", "fo"* 匹配到的元操作或API：
query: Get all string literals used in method: "foo", "fo"
most similar API: get symbol table of string literal
cosine Similarity: 0.8040931224822998
*Check whether the length of string literal is less than 3:* 匹配到的元操作或API：
query: Check whether the length of string literal is less than 3:
most similar API: length of string literal
cosine Similarity: 0.8320521116256714
*Get the count of each string literal used in method:* 匹配到的元操作或API：
query: Get the count of each string literal used in method:
most similar API: get num children of string literal
cosine Similarity: 0.8131014108657837
*Check whether the count of any string literal is 4 or more:* 匹配到的元操作或API：
未匹配成功元操作或API
*If the string literal length is not less than 3 and the count of the string literal is 4 or more, check whether it is declared as a constant field:* 匹配到的元操作或API：
query: If the string literal length is not less than 3 and the count of the string literal is 4 or more, check whether it is declared as a constant field:
most similar API: Check whether the string literal is compile time constant
cosine Similarity: 0.8176851868629456
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.descendants(ASTStringLiteral.class).forEach(literal -> {
            String value = literal.getImage();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}


This checker is failed(false negative) on this negative test case:
```
// minimum length property, default value
public class Foo {
    private void bar() {
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
        buz("fo"); buz("fo"); buz("fo"); buz("fo");
    }
    private void buz(String x) {}
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'buz')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public net.sourceforge.pmd.lang.java.symbols.table.JSymbolTable getSymbolTable()
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length(), //Length of the constant value in characters.
7. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isCompileTimeConstant()
8. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int getNumChildren()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.descendants(ASTStringLiteral.class).forEach(literal -> {
            String value = literal.getImage();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Get all methods declared in class.
        3. Get the body of method.
        4. Get all assignment expressions in method body.
        5. Get all string literals in method body.
        6. Get the value of string literal.
        7. Get the length of string literal.
        8. Check whether the length of string literal is less than 3.
        9. If not less than 3, count the occurrences of the string literal in method body.
        10. Check whether the count of the string literal is 4 or more.
        11. If the count is 4 or more, check whether the string literal is assigned to a final field.
        12. If not assigned to a final field, check whether the string literal is declared as a constant field.

Perform these checks for each string literal in the method body:

- For the string literal "foo":
  1. Get the value of string literal.
  2. Get the length of string literal.
  3. Check whether the length of string literal is less than 3.
  4. Since the length is not less than 3, count the occurrences of the string literal in method body.
  5. Check whether the count of the string literal is 4 or more.
  6. Since the count is 4, check whether the string literal is assigned to a final field.
  7. Since the string literal is not assigned to a final field, check whether the string literal is declared as a constant field.
  8. If the string literal is not declared as a constant field, this test case violates the rule.

- For the string literal "fo":
  1. Get the value of string literal.
  2. Get the length of string literal.
  3. Check whether the length of string literal is less than 3.
  4. Since the length is less than 3, this string literal is ignored.

Based on these granular checks, the test case violates the rule once with the string literal "foo".
['Get the name of class.', 'Get all methods declared in class.', 'Get the body of method.', 'Get all assignment expressions in method body.', 'Get all string literals in method body.', 'Get the value of string literal.', 'Get the length of string literal.', 'Check whether the length of string literal is less than 3.', 'If not less than 3, count the occurrences of the string literal in method body.', 'Check whether the count of the string literal is 4 or more.', 'If the count is 4 or more, check whether the string literal is assigned to a final field.', 'If not assigned to a final field, check whether the string literal is declared as a constant field.', 'Get the value of string literal.', 'Get the length of string literal.', 'Check whether the length of string literal is less than 3.', 'Since the length is not less than 3, count the occurrences of the string literal in method body.', 'Check whether the count of the string literal is 4 or more.', 'Since the count is 4, check whether the string literal is assigned to a final field.', 'Since the string literal is not assigned to a final field, check whether the string literal is declared as a constant field.', 'If the string literal is not declared as a constant field, this test case violates the rule.', 'Get the value of string literal.', 'Get the length of string literal.', 'Check whether the length of string literal is less than 3.', 'Since the length is less than 3, this string literal is ignored.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'ASTMethodCall', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'ASTExpressionStatement', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752806425094604
*Get all assignment expressions in method body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all string literals in method body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the value of string literal.* 匹配到的元操作或API：
logic: Get the value of string literal.
most similar meta operation: Get the value of string literal
cosine Similarity: 0.983224630355835
*Get the length of string literal.* 匹配到的元操作或API：
logic: Get the length of string literal.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.9875898361206055
*Check whether the length of string literal is less than 3.* 匹配到的元操作或API：
query: Check whether the length of string literal is less than 3.
most similar API: length of string literal
cosine Similarity: 0.8233144879341125
*If not less than 3, count the occurrences of the string literal in method body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of the string literal is 4 or more.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the count is 4 or more, check whether the string literal is assigned to a final field.* 匹配到的元操作或API：
未匹配成功元操作或API
*If not assigned to a final field, check whether the string literal is declared as a constant field.* 匹配到的元操作或API：
query: If not assigned to a final field, check whether the string literal is declared as a constant field.
most similar API: Check whether the string literal is compile time constant
cosine Similarity: 0.8568408489227295
*Get the value of string literal.* 匹配到的元操作或API：
logic: Get the value of string literal.
most similar meta operation: Get the value of string literal
cosine Similarity: 0.983224630355835
*Get the length of string literal.* 匹配到的元操作或API：
logic: Get the length of string literal.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.9875898361206055
*Check whether the length of string literal is less than 3.* 匹配到的元操作或API：
query: Check whether the length of string literal is less than 3.
most similar API: length of string literal
cosine Similarity: 0.8233144879341125
*Since the length is not less than 3, count the occurrences of the string literal in method body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the count of the string literal is 4 or more.* 匹配到的元操作或API：
未匹配成功元操作或API
*Since the count is 4, check whether the string literal is assigned to a final field.* 匹配到的元操作或API：
未匹配成功元操作或API
*Since the string literal is not assigned to a final field, check whether the string literal is declared as a constant field.* 匹配到的元操作或API：
query: Since the string literal is not assigned to a final field, check whether the string literal is declared as a constant field.
most similar API: Check whether the string literal is compile time constant
cosine Similarity: 0.8551843166351318
*If the string literal is not declared as a constant field, this test case violates the rule.* 匹配到的元操作或API：
query: If the string literal is not declared as a constant field, this test case violates the rule.
most similar API: Check whether the string literal is compile time constant
cosine Similarity: 0.8022654056549072
*Get the value of string literal.* 匹配到的元操作或API：
logic: Get the value of string literal.
most similar meta operation: Get the value of string literal
cosine Similarity: 0.983224630355835
*Get the length of string literal.* 匹配到的元操作或API：
logic: Get the length of string literal.
most similar meta operation: Get the length of string literal
cosine Similarity: 0.9875898361206055
*Check whether the length of string literal is less than 3.* 匹配到的元操作或API：
query: Check whether the length of string literal is less than 3.
most similar API: length of string literal
cosine Similarity: 0.8233144879341125
*Since the length is less than 3, this string literal is ignored.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.errorprone;


import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.descendants(ASTStringLiteral.class).forEach(literal -> {
            String value = literal.getImage();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}


This checker is failed(false negative) on this negative test case:
```
// minimum length property, default value
public class Foo {
    private void bar() {
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
        buz("fo"); buz("fo"); buz("fo"); buz("fo");
    }
    private void buz(String x) {}
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'buz')
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral
    ——ASTMethodDeclaration (method name = 'buz')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'x')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
4. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public java.lang.String getConstValue()
5. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length()
6. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public int length(), //Length of the constant value in characters.
7. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isCompileTimeConstant()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashMap;
import java.util.Map;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Map<String, Integer> stringLiteralCount = new HashMap<>();
        Map<String, ASTStringLiteral> firstOccurrenceMap = new HashMap<>();

        node.descendants(ASTStringLiteral.class).forEach(literal -> {
            String value = literal.getConstValue();
            if (value.length() >= 3) {
                stringLiteralCount.put(value, stringLiteralCount.getOrDefault(value, 0) + 1);
                if (!firstOccurrenceMap.containsKey(value)) {
                    firstOccurrenceMap.put(value, literal);
                }
            }
        });

        stringLiteralCount.forEach((value, count) -> {
            if (count >= 4) {
                ASTStringLiteral firstOccurrence = firstOccurrenceMap.get(value);
                addViolation(data, firstOccurrence);
            }
        });

        return super.visit(node, data);
    }

    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }

    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
编译是否通过？
True
测试是否通过
True
测试用例全部通过
最终通过 10 个测试用例
正例 3 个
反例 7 个
输入token：786792
输出token：553188
结束

规则执行完毕，时间总花销： 2019.664316892624 秒
