开始

========================================== Rule IdenticalCatchBranchesRule ===========================================
一共 7 个测试用例
正例 5 个
反例 2 个
1684
1319
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the number of catch clauses in the try statement.
2. Check whether the number of catch clauses is greater than 1.
3. Get the catch branch of the first catch clause.
4. Get the catch branch of the second catch clause.
5. Check whether the catch branches are identical.
6. Get the exception type of the first catch clause.
7. Get the exception type of the second catch clause.
8. Check whether the exception types are different.
If the number of catch clauses is greater than 1, and the catch branches are identical but the exception types are different, then this test case violates the rule.
['Get the number of catch clauses in the try statement.', 'Check whether the number of catch clauses is greater than 1.', 'Get the catch branch of the first catch clause.', 'Get the catch branch of the second catch clause.', 'Check whether the catch branches are identical.', 'Get the exception type of the first catch clause.', 'Get the exception type of the second catch clause.', 'Check whether the exception types are different.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTInitializer', 'TypesFromReflection', 'ASTTryStatement', 'TokenUtils', 'ASTCatchClause', 'ASTThrowStatement', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTCatchParameter', 'JavaSemanticErrors']
*Get the number of catch clauses in the try statement.* 匹配到的元操作或API：
query: Get the number of catch clauses in the try statement.
most similar API: get catch clauses of try statement
cosine Similarity: 0.8890749216079712
*Check whether the number of catch clauses is greater than 1.* 匹配到的元操作或API：
query: Check whether the number of catch clauses is greater than 1.
most similar API: Check whether the catch clause equals
cosine Similarity: 0.8589111566543579
*Get the catch branch of the first catch clause.* 匹配到的元操作或API：
logic: Get the catch branch of the first catch clause.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8598181009292603
*Get the catch branch of the second catch clause.* 匹配到的元操作或API：
logic: Get the catch branch of the second catch clause.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8568049073219299
*Check whether the catch branches are identical.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the exception type of the first catch clause.* 匹配到的元操作或API：
logic: Get the exception type of the first catch clause.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.8797888159751892
*Get the exception type of the second catch clause.* 匹配到的元操作或API：
logic: Get the exception type of the second catch clause.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.8797162175178528
*Check whether the exception types are different.* 匹配到的元操作或API：
query: Check whether the exception types are different.
most similar API: Check whether has exception list
cosine Similarity: 0.812656581401825
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Identical catch branches use up vertical space and increase the complexity of code without adding functionality. It’s better style to collapse identical branches into a single multi-catch branch.;
The test case corresponding to the rule:
```
// Collapsible statement
class Foo {
    {
        try {
            // do something
        } catch (IllegalArgumentException e) {
            throw e;
        } catch (IllegalStateException e) { // Can be collapsed into the previous block
            throw e;
        }
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTVariableAccess (referenced variable name = 'e')
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTVariableAccess (referenced variable name = 'e')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses(), //Returns the catch statement nodes of this try statement. If there are none, returns an empty list.
2. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
4. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes()
5. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean hasExceptionList(net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration, [Ljava.lang.Class;)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public IdenticalCatchBranchesRule() {
        super(ASTTryStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        Set<String> seen = new HashSet<>();
        ASTCatchClause previousClause = null;

        for (ASTCatchClause clause : node.getCatchClauses()) {
            ASTCatchParameter parameter = clause.getFirstChildOfType(ASTCatchParameter.class);
            ASTBlock block = clause.getFirstChildOfType(ASTBlock.class);
            ASTThrowStatement throwStatement = block.getFirstChildOfType(ASTThrowStatement.class);
            ASTVariableAccess variableAccess = throwStatement != null ? throwStatement.getFirstChildOfType(ASTVariableAccess.class) : null;

            if (variableAccess != null && "e".equals(variableAccess.getName())) {
                String exceptionType = parameter.getAllExceptionTypes().map(ASTClassOrInterfaceType::getImage).collect(java.util.stream.Collectors.joining("|"));
                if (previousClause != null) {
                    ASTBlock previousBlock = previousClause.getFirstChildOfType(ASTBlock.class);
                    if (seen.contains(exceptionType) && previousBlock != null && previousBlock.equals(block)) {
                        addViolation(data, clause);
                    }
                }
                seen.add(exceptionType);
                previousClause = clause;
            }
        }

        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the catch branch of try statement.
2. Get the exception type of catch parameter.
3. Get the catch branch of try statement.
4. Get the exception type of catch parameter.
5. Get the catch branch of try statement.
6. Get the catch branch of try statement.
7. Check whether the catch branches have the same body.
8. If the catch branches have the same body, get the exception types of each catch parameter.
9. Check whether the exception types can be combined into a multi-catch block.

In this test case:
1. Get the catch branch of try statement. (First catch block)
2. Get the exception type of catch parameter. (IllegalArgumentException)
3. Get the catch branch of try statement. (Second catch block)
4. Get the exception type of catch parameter. (IllegalStateException)
5. Get the catch branch of try statement. (First catch block)
6. Get the catch branch of try statement. (Second catch block)
7. Check whether the catch branches have the same body. (Both are throwing the exception)
8. If the catch branches have the same body, get the exception types of each catch parameter. (IllegalArgumentException, IllegalStateException)
9. Check whether the exception types can be combined into a multi-catch block. (Yes, they can be combined into a single catch block: `catch (IllegalArgumentException | IllegalStateException e)`)

This test case violates the rule once by having identical catch branches that can be collapsed into a multi-catch branch.
['Get the catch branch of try statement.', 'Get the exception type of catch parameter.', 'Get the catch branch of try statement.', 'Get the exception type of catch parameter.', 'Get the catch branch of try statement.', 'Get the catch branch of try statement.', 'Check whether the catch branches have the same body.', 'If the catch branches have the same body, get the exception types of each catch parameter.', 'Check whether the exception types can be combined into a multi-catch block.', 'Get the catch branch of try statement. (First catch block)', 'Get the exception type of catch parameter. (IllegalArgumentException)', 'Get the catch branch of try statement. (Second catch block)', 'Get the exception type of catch parameter. (IllegalStateException)', 'Get the catch branch of try statement. (First catch block)', 'Get the catch branch of try statement. (Second catch block)', 'Check whether the catch branches have the same body. (Both are throwing the exception)', 'If the catch branches have the same body, get the exception types of each catch parameter. (IllegalArgumentException, IllegalStateException)', 'Check whether the exception types can be combined into a multi-catch block. (Yes, they can be combined into a single catch block: `catch (IllegalArgumentException | IllegalStateException e)`)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTInitializer', 'TypesFromReflection', 'ASTTryStatement', 'TokenUtils', 'ASTCatchClause', 'ASTThrowStatement', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTCatchParameter', 'JavaSemanticErrors']
*Get the catch branch of try statement.* 匹配到的元操作或API：
logic: Get the catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9813414812088013
*Get the exception type of catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9756684899330139
*Get the catch branch of try statement.* 匹配到的元操作或API：
logic: Get the catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9813414812088013
*Get the exception type of catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9756684899330139
*Get the catch branch of try statement.* 匹配到的元操作或API：
logic: Get the catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9813414812088013
*Get the catch branch of try statement.* 匹配到的元操作或API：
logic: Get the catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9813414812088013
*Check whether the catch branches have the same body.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the catch branches have the same body, get the exception types of each catch parameter.* 匹配到的元操作或API：
query: If the catch branches have the same body, get the exception types of each catch parameter.
most similar API: get all exception types of catch parameter
cosine Similarity: 0.87981778383255
*Check whether the exception types can be combined into a multi-catch block.* 匹配到的元操作或API：
query: Check whether the exception types can be combined into a multi-catch block.
most similar API: Check whether the catch parameter is multicatch
cosine Similarity: 0.8264646530151367
*Get the catch branch of try statement. (First catch block)* 匹配到的元操作或API：
logic: Get the catch branch of try statement. (First catch block)
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9521147608757019
*Get the exception type of catch parameter. (IllegalArgumentException)* 匹配到的元操作或API：
logic: Get the exception type of catch parameter. (IllegalArgumentException)
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9387785196304321
*Get the catch branch of try statement. (Second catch block)* 匹配到的元操作或API：
logic: Get the catch branch of try statement. (Second catch block)
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9491589069366455
*Get the exception type of catch parameter. (IllegalStateException)* 匹配到的元操作或API：
logic: Get the exception type of catch parameter. (IllegalStateException)
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9228209257125854
*Get the catch branch of try statement. (First catch block)* 匹配到的元操作或API：
logic: Get the catch branch of try statement. (First catch block)
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9521147608757019
*Get the catch branch of try statement. (Second catch block)* 匹配到的元操作或API：
logic: Get the catch branch of try statement. (Second catch block)
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9491589069366455
*Check whether the catch branches have the same body. (Both are throwing the exception)* 匹配到的元操作或API：
未匹配成功元操作或API
*If the catch branches have the same body, get the exception types of each catch parameter. (IllegalArgumentException, IllegalStateException)* 匹配到的元操作或API：
query: If the catch branches have the same body, get the exception types of each catch parameter. (IllegalArgumentException, IllegalStateException)
most similar API: get all exception types of catch parameter
cosine Similarity: 0.8825773000717163
*Check whether the exception types can be combined into a multi-catch block. (Yes, they can be combined into a single catch block: `catch (IllegalArgumentException | IllegalStateException e)`)* 匹配到的元操作或API：
query: Check whether the exception types can be combined into a multi-catch block. (Yes, they can be combined into a single catch block: `catch (IllegalArgumentException | IllegalStateException e)`)
most similar API: Check whether the catch parameter is multicatch: Returns true if this is a multi-catch parameter, that is, it catches several unrelated exception types at the same time. For example: <pre>catch (IllegalStateException | IllegalArgumentException e) {}</pre>
cosine Similarity: 0.8436551690101624
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Identical catch branches use up vertical space and increase the complexity of code without adding functionality. It’s better style to collapse identical branches into a single multi-catch branch.;
The test case corresponding to the rule:
```
// Collapsible statement
class Foo {
    {
        try {
            // do something
        } catch (IllegalArgumentException e) {
            throw e;
        } catch (IllegalStateException e) { // Can be collapsed into the previous block
            throw e;
        }
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTVariableAccess (referenced variable name = 'e')
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTVariableAccess (referenced variable name = 'e')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
2. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes()
3. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes(), //Returns a stream of all declared exception types (expanding a union type if present). <p>Note that this is the only reliable way to inspect multi-catch clauses, as the type mirror of a {@link ASTUnionType} is not itself a {@link JIntersectionType}, but the {@link TypeSystem#lub(Collection) LUB} of the components. Since exception types cannot be interfaces, the LUB always erases to a single class supertype (eg {@link RuntimeException}).
4. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public boolean isMulticatch(), //Returns true if this is a multi-catch parameter, that is, it catches several unrelated exception types at the same time. For example: <pre>catch (IllegalStateException | IllegalArgumentException e) {}</pre>



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public IdenticalCatchBranchesRule() {
        super(ASTCatchClause.class);
    }

    @Override
    public Object visit(ASTCatchClause node, Object data) {
        ASTCatchClause previousCatch = node.getPreviousSibling();
        if (previousCatch != null) {
            ASTThrowStatement currentThrow = node.getFirstChildOfType(ASTThrowStatement.class);
            ASTThrowStatement previousThrow = previousCatch.getFirstChildOfType(ASTThrowStatement.class);
            if (currentThrow != null && previousThrow != null) {
                ASTVariableAccess currentVarAccess = currentThrow.getFirstChildOfType(ASTVariableAccess.class);
                ASTVariableAccess previousVarAccess = previousThrow.getFirstChildOfType(ASTVariableAccess.class);
                if (currentVarAccess != null && previousVarAccess != null) {
                    if (currentVarAccess.getName().equals(previousVarAccess.getName()) && 
                        areCatchParametersIdentical(node.getCatchParameter(), previousCatch.getCatchParameter())) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean areCatchParametersIdentical(ASTCatchParameter current, ASTCatchParameter previous) {
        if (current.isMulticatch() || previous.isMulticatch()) {
            return false;
        }
        NodeStream<ASTClassOrInterfaceType> currentTypes = current.getAllExceptionTypes();
        NodeStream<ASTClassOrInterfaceType> previousTypes = previous.getAllExceptionTypes();
        return currentTypes.size() == 1 && previousTypes.size() == 1 &&
               currentTypes.first().getImage().equals(previousTypes.first().getImage());
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the number of catch clauses in try statement.
2. Get the catch branch of try statement.
3. Get the parameter of catch clause.
4. Get the name of catch parameter.
5. Get the exception type of catch parameter.
6. Get the catch branch body of try statement.
7. Get the next catch branch in the try statement.
8. Get the parameter of the next catch clause.
9. Get the exception type of the next catch parameter.
10. Get the catch branch body of the next catch clause.
11. Compare the catch branch body of the first catch clause with the next catch branch body.
12. Check whether the exception types in the first and the next catch clauses can be combined into a multi-catch branch.

In this test case:
- There are two catch clauses.
- The exception types in both catch clauses are different (`IllegalArgumentException` and `IllegalStateException`).
- The catch branch bodies in both catch clauses are identical (`throw e;`).
- Therefore, the identical catch branches can be collapsed into a single multi-catch branch.

This test case violates the rule once.
['Get the number of catch clauses in try statement.', 'Get the catch branch of try statement.', 'Get the parameter of catch clause.', 'Get the name of catch parameter.', 'Get the exception type of catch parameter.', 'Get the catch branch body of try statement.', 'Get the next catch branch in the try statement.', 'Get the parameter of the next catch clause.', 'Get the exception type of the next catch parameter.', 'Get the catch branch body of the next catch clause.', 'Compare the catch branch body of the first catch clause with the next catch branch body.', 'Check whether the exception types in the first and the next catch clauses can be combined into a multi-catch branch.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTInitializer', 'TypesFromReflection', 'ASTTryStatement', 'TokenUtils', 'ASTCatchClause', 'ASTThrowStatement', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTCatchParameter', 'JavaSemanticErrors']
*Get the number of catch clauses in try statement.* 匹配到的元操作或API：
query: Get the number of catch clauses in try statement.
most similar API: get catch clauses of try statement
cosine Similarity: 0.9002132415771484
*Get the catch branch of try statement.* 匹配到的元操作或API：
logic: Get the catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9813414812088013
*Get the parameter of catch clause.* 匹配到的元操作或API：
logic: Get the parameter of catch clause.
most similar meta operation: Get a parameter of catch clause
cosine Similarity: 0.9828796982765198
*Get the name of catch parameter.* 匹配到的元操作或API：
logic: Get the name of catch parameter.
most similar meta operation: Get the name of catch parameter
cosine Similarity: 0.9860472679138184
*Get the exception type of catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9756684899330139
*Get the catch branch body of try statement.* 匹配到的元操作或API：
logic: Get the catch branch body of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9364120364189148
*Get the next catch branch in the try statement.* 匹配到的元操作或API：
logic: Get the next catch branch in the try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9228959083557129
*Get the parameter of the next catch clause.* 匹配到的元操作或API：
logic: Get the parameter of the next catch clause.
most similar meta operation: Get a parameter of catch clause
cosine Similarity: 0.9314497113227844
*Get the exception type of the next catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of the next catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9264075756072998
*Get the catch branch body of the next catch clause.* 匹配到的元操作或API：
query: Get the catch branch body of the next catch clause.
most similar API: get body of catch clause: Returns the body of this catch branch.
cosine Similarity: 0.9191560745239258
*Compare the catch branch body of the first catch clause with the next catch branch body.* 匹配到的元操作或API：
query: Compare the catch branch body of the first catch clause with the next catch branch body.
most similar API: compare location of catch clause
cosine Similarity: 0.8050363063812256
*Check whether the exception types in the first and the next catch clauses can be combined into a multi-catch branch.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Identical catch branches use up vertical space and increase the complexity of code without adding functionality. It’s better style to collapse identical branches into a single multi-catch branch.;
The test case corresponding to the rule:
```
// Collapsible statement
class Foo {
    {
        try {
            // do something
        } catch (IllegalArgumentException e) {
            throw e;
        } catch (IllegalStateException e) { // Can be collapsed into the previous block
            throw e;
        }
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTVariableAccess (referenced variable name = 'e')
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTVariableAccess (referenced variable name = 'e')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses(), //Returns the catch statement nodes of this try statement. If there are none, returns an empty list.
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
3. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTCatchParameter getParameter()
4. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public java.lang.String getName()
5. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes()
6. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this catch branch.
7. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public int compareLocation(net.sourceforge.pmd.lang.ast.Node)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import java.util.List;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public IdenticalCatchBranchesRule() {
        super(ASTTryStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        List<ASTCatchClause> catchClauses = node.getCatchClauses();
        for (int i = 0; i < catchClauses.size() - 1; i++) {
            ASTCatchClause currentClause = catchClauses.get(i);
            ASTCatchClause nextClause = catchClauses.get(i + 1);

            if (isIdenticalCatchBody(currentClause.getBody(), nextClause.getBody())) {
                List<String> currentTypes = currentClause.getParameter().getTypeImage().split("\\|");
                List<String> nextTypes = nextClause.getParameter().getTypeImage().split("\\|");

                if (!hasCommonExceptionType(currentTypes, nextTypes)) {
                    continue;
                }

                addViolation(data, currentClause);
            }
        }
        return super.visit(node, data);
    }

    private boolean isIdenticalCatchBody(ASTBlock block1, ASTBlock block2) {
        if (block1.getNumChildren() != block2.getNumChildren()) {
            return false;
        }

        for (int i = 0; i < block1.getNumChildren(); i++) {
            JavaNode child1 = block1.getChild(i);
            JavaNode child2 = block2.getChild(i);

            if (child1 instanceof ASTThrowStatement && child2 instanceof ASTThrowStatement) {
                ASTThrowStatement throw1 = (ASTThrowStatement) child1;
                ASTThrowStatement throw2 = (ASTThrowStatement) child2;

                ASTVariableAccess varAccess1 = throw1.getFirstChildOfType(ASTVariableAccess.class);
                ASTVariableAccess varAccess2 = throw2.getFirstChildOfType(ASTVariableAccess.class);

                if (varAccess1 != null && varAccess2 != null && varAccess1.getName().equals(varAccess2.getName())) {
                    continue;
                }
            }
            if (!child1.equals(child2)) {
                return false;
            }
        }
        return true;
    }

    private boolean hasCommonExceptionType(List<String> types1, List<String> types2) {
        for (String type1 : types1) {
            for (String type2 : types2) {
                if (type1.trim().equals(type2.trim())) {
                    return true;
                }
            }
        }
        return false;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
        2. Get the try statement within the class.
        3. Get the catch branches of the try statement.
        4. Get the first catch branch.
        5. Get the catch parameter of the first catch branch.
        6. Get the name of catch parameter of the first catch branch.
        7. Get the catch branch body of the first catch branch.
        8. Get the second catch branch.
        9. Get the catch parameter of the second catch branch.
        10. Get the name of catch parameter of the second catch branch.
        11. Get the catch branch body of the second catch branch.
        12. Check whether the catch branch body of the first and second catch branches are identical.
        13. Get the exception type of the first catch parameter.
        14. Get the exception type of the second catch parameter.
        15. Check whether the exception types of the first and second catch parameters are different.
        If the catch branch bodies of the first and second catch branches are identical and the exception types of the first and second catch parameters are different, then this test case violates the rule.
        In this specific test case:
        12. Check whether the catch branch body of the first and second catch branches are identical. (They are both "throw e;")
        15. Check whether the exception types of the first and second catch parameters are different. (IllegalArgumentException and IllegalStateException are different)
        Since the catch branch bodies are identical and the exception types are different, the test case violates the rule.
['Get the name of class.', 'Get the try statement within the class.', 'Get the catch branches of the try statement.', 'Get the first catch branch.', 'Get the catch parameter of the first catch branch.', 'Get the name of catch parameter of the first catch branch.', 'Get the catch branch body of the first catch branch.', 'Get the second catch branch.', 'Get the catch parameter of the second catch branch.', 'Get the name of catch parameter of the second catch branch.', 'Get the catch branch body of the second catch branch.', 'Check whether the catch branch body of the first and second catch branches are identical.', 'Get the exception type of the first catch parameter.', 'Get the exception type of the second catch parameter.', 'Check whether the exception types of the first and second catch parameters are different.', 'Check whether the catch branch body of the first and second catch branches are identical. (They are both "throw e;")', 'Check whether the exception types of the first and second catch parameters are different. (IllegalArgumentException and IllegalStateException are different)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTInitializer', 'TypesFromReflection', 'ASTTryStatement', 'TokenUtils', 'ASTCatchClause', 'ASTThrowStatement', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTCatchParameter', 'JavaSemanticErrors']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the try statement within the class.* 匹配到的元操作或API：
logic: Get the try statement within the class.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8500578999519348
*Get the catch branches of the try statement.* 匹配到的元操作或API：
logic: Get the catch branches of the try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9282875061035156
*Get the first catch branch.* 匹配到的元操作或API：
query: Get the first catch branch.
most similar API: get first descendant of type of catch clause
cosine Similarity: 0.8019823431968689
*Get the catch parameter of the first catch branch.* 匹配到的元操作或API：
query: Get the catch parameter of the first catch branch.
most similar API: get parameter of catch clause: Returns the catch parameter.
cosine Similarity: 0.8492509126663208
*Get the name of catch parameter of the first catch branch.* 匹配到的元操作或API：
logic: Get the name of catch parameter of the first catch branch.
most similar meta operation: Get the name of catch parameter
cosine Similarity: 0.8841040730476379
*Get the catch branch body of the first catch branch.* 匹配到的元操作或API：
query: Get the catch branch body of the first catch branch.
most similar API: get body of catch clause: Returns the body of this catch branch.
cosine Similarity: 0.8672946691513062
*Get the second catch branch.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the catch parameter of the second catch branch.* 匹配到的元操作或API：
query: Get the catch parameter of the second catch branch.
most similar API: get parameter of catch clause: Returns the catch parameter.
cosine Similarity: 0.8446161150932312
*Get the name of catch parameter of the second catch branch.* 匹配到的元操作或API：
logic: Get the name of catch parameter of the second catch branch.
most similar meta operation: Get the name of catch parameter
cosine Similarity: 0.8705593347549438
*Get the catch branch body of the second catch branch.* 匹配到的元操作或API：
query: Get the catch branch body of the second catch branch.
most similar API: get body of catch clause: Returns the body of this catch branch.
cosine Similarity: 0.8488980531692505
*Check whether the catch branch body of the first and second catch branches are identical.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the exception type of the first catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of the first catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.922197163105011
*Get the exception type of the second catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of the second catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9218042492866516
*Check whether the exception types of the first and second catch parameters are different.* 匹配到的元操作或API：
query: Check whether the exception types of the first and second catch parameters are different.
most similar API: get all exception types of catch parameter
cosine Similarity: 0.8225350379943848
*Check whether the catch branch body of the first and second catch branches are identical. (They are both "throw e;")* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the exception types of the first and second catch parameters are different. (IllegalArgumentException and IllegalStateException are different)* 匹配到的元操作或API：
query: Check whether the exception types of the first and second catch parameters are different. (IllegalArgumentException and IllegalStateException are different)
most similar API: get all exception types of catch parameter
cosine Similarity: 0.807688295841217
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Identical catch branches use up vertical space and increase the complexity of code without adding functionality. It’s better style to collapse identical branches into a single multi-catch branch.;
The test case corresponding to the rule:
```
// Collapsible statement
class Foo {
    {
        try {
            // do something
        } catch (IllegalArgumentException e) {
            throw e;
        } catch (IllegalStateException e) { // Can be collapsed into the previous block
            throw e;
        }
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTVariableAccess (referenced variable name = 'e')
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTVariableAccess (referenced variable name = 'e')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
3. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public T getFirstDescendantOfType(java.lang.Class)
4. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTCatchParameter getParameter(), //Returns the catch parameter.
5. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public java.lang.String getName()
6. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this catch branch.
7. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes()
8. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes(), //Returns a stream of all declared exception types (expanding a union type if present). <p>Note that this is the only reliable way to inspect multi-catch clauses, as the type mirror of a {@link ASTUnionType} is not itself a {@link JIntersectionType}, but the {@link TypeSystem#lub(Collection) LUB} of the components. Since exception types cannot be interfaces, the LUB always erases to a single class supertype (eg {@link RuntimeException}).



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public IdenticalCatchBranchesRule() {
        super(ASTCatchClause.class);
    }

    @Override
    public Object visit(ASTCatchClause node, Object data) {
        ASTCatchClause previousCatchClause = (ASTCatchClause) node.getPreviousSibling();
        if (previousCatchClause != null) {
            ASTBlock currentBody = node.getBody();
            ASTBlock previousBody = previousCatchClause.getBody();

            if (currentBody.getNumChildren() == 1 && previousBody.getNumChildren() == 1) {
                ASTThrowStatement currentThrow = currentBody.getFirstDescendantOfType(ASTThrowStatement.class);
                ASTThrowStatement previousThrow = previousBody.getFirstDescendantOfType(ASTThrowStatement.class);

                if (currentThrow != null && previousThrow != null) {
                    ASTVariableAccess currentVarAccess = currentThrow.getFirstDescendantOfType(ASTVariableAccess.class);
                    ASTVariableAccess previousVarAccess = previousThrow.getFirstDescendantOfType(ASTVariableAccess.class);

                    if (currentVarAccess != null && previousVarAccess != null && currentVarAccess.getName().equals(previousVarAccess.getName())) {
                        ASTCatchParameter currentParam = node.getParameter();
                        ASTCatchParameter previousParam = previousCatchClause.getParameter();

                        if (!currentParam.getName().equals(previousParam.getName())) {
                            addViolation(data, node);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the catch clauses of the try statement.
2. Get the number of catch clauses.
3. Get the signature of the first catch clause.
4. Get the type of the first catch parameter.
5. Get the catch branch of the first catch clause.
6. Get the signature of the second catch clause.
7. Get the type of the second catch parameter.
8. Get the catch branch of the second catch clause.
9. Compare the catch branches of the first and second catch clauses.
10. Check whether the catch branches are identical.
11. Check whether the catch branch throws the same exception as the catch parameter.
12. Check whether the catch branch throws the same exception as the catch parameter in the other catch clause.
13. Check whether the catch parameter types are different.
14. Check whether the number of catch clauses is greater than 1.
15. Check whether the class has a try block with multiple catch clauses.
16. Check whether the try block has identical catch branches.

If the catch branches are identical and the catch parameter types are different, then this test case violates the rule. In this specific case:
- The first catch clause catches `IllegalArgumentException` and throws `e`.
- The second catch clause catches `IllegalStateException` and throws `e`.
- The catch branches are identical.
- The catch parameter types are different (`IllegalArgumentException` and `IllegalStateException`).

Therefore, the test case violates the rule.
['Get the catch clauses of the try statement.', 'Get the number of catch clauses.', 'Get the signature of the first catch clause.', 'Get the type of the first catch parameter.', 'Get the catch branch of the first catch clause.', 'Get the signature of the second catch clause.', 'Get the type of the second catch parameter.', 'Get the catch branch of the second catch clause.', 'Compare the catch branches of the first and second catch clauses.', 'Check whether the catch branches are identical.', 'Check whether the catch branch throws the same exception as the catch parameter.', 'Check whether the catch branch throws the same exception as the catch parameter in the other catch clause.', 'Check whether the catch parameter types are different.', 'Check whether the number of catch clauses is greater than 1.', 'Check whether the class has a try block with multiple catch clauses.', 'Check whether the try block has identical catch branches.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTInitializer', 'TypesFromReflection', 'ASTTryStatement', 'TokenUtils', 'ASTCatchClause', 'ASTThrowStatement', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTCatchParameter', 'JavaSemanticErrors']
*Get the catch clauses of the try statement.* 匹配到的元操作或API：
query: Get the catch clauses of the try statement.
most similar API: get catch clauses of try statement
cosine Similarity: 0.9775608777999878
*Get the number of catch clauses.* 匹配到的元操作或API：
query: Get the number of catch clauses.
most similar API: get num children of catch clause
cosine Similarity: 0.8711758852005005
*Get the signature of the first catch clause.* 匹配到的元操作或API：
query: Get the signature of the first catch clause.
most similar API: get first token of catch clause
cosine Similarity: 0.8664122819900513
*Get the type of the first catch parameter.* 匹配到的元操作或API：
logic: Get the type of the first catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.8765738010406494
*Get the catch branch of the first catch clause.* 匹配到的元操作或API：
logic: Get the catch branch of the first catch clause.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8598181009292603
*Get the signature of the second catch clause.* 匹配到的元操作或API：
query: Get the signature of the second catch clause.
most similar API: get body of catch clause
cosine Similarity: 0.8204609155654907
*Get the type of the second catch parameter.* 匹配到的元操作或API：
logic: Get the type of the second catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.8779891133308411
*Get the catch branch of the second catch clause.* 匹配到的元操作或API：
logic: Get the catch branch of the second catch clause.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8568049073219299
*Compare the catch branches of the first and second catch clauses.* 匹配到的元操作或API：
query: Compare the catch branches of the first and second catch clauses.
most similar API: compare location of catch clause
cosine Similarity: 0.8446922898292542
*Check whether the catch branches are identical.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the catch branch throws the same exception as the catch parameter.* 匹配到的元操作或API：
query: Check whether the catch branch throws the same exception as the catch parameter.
most similar API: Check whether the catch parameter equals
cosine Similarity: 0.8659041523933411
*Check whether the catch branch throws the same exception as the catch parameter in the other catch clause.* 匹配到的元操作或API：
query: Check whether the catch branch throws the same exception as the catch parameter in the other catch clause.
most similar API: Check whether the catch clause equals
cosine Similarity: 0.8632692694664001
*Check whether the catch parameter types are different.* 匹配到的元操作或API：
logic: Check whether the catch parameter types are different.
most similar meta operation: Check whether the catch parameter is x type
cosine Similarity: 0.893730640411377
*Check whether the number of catch clauses is greater than 1.* 匹配到的元操作或API：
query: Check whether the number of catch clauses is greater than 1.
most similar API: Check whether the catch clause equals
cosine Similarity: 0.8589111566543579
*Check whether the class has a try block with multiple catch clauses.* 匹配到的元操作或API：
query: Check whether the class has a try block with multiple catch clauses.
most similar API: Check whether the catch clause equals
cosine Similarity: 0.8480735421180725
*Check whether the try block has identical catch branches.* 匹配到的元操作或API：
query: Check whether the try block has identical catch branches.
most similar API: Check whether the try statement equals
cosine Similarity: 0.8294334411621094
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Identical catch branches use up vertical space and increase the complexity of code without adding functionality. It’s better style to collapse identical branches into a single multi-catch branch.;
The test case corresponding to the rule:
```
// Collapsible statement
class Foo {
    {
        try {
            // do something
        } catch (IllegalArgumentException e) {
            throw e;
        } catch (IllegalStateException e) { // Can be collapsed into the previous block
            throw e;
        }
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTVariableAccess (referenced variable name = 'e')
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTVariableAccess (referenced variable name = 'e')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses(), //Returns the catch statement nodes of this try statement. If there are none, returns an empty list.
2. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public int getNumChildren()
3. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.ast.impl.javacc.JavaccToken getFirstToken()
4. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes()
5. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
6. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this catch branch.
7. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public int compareLocation(net.sourceforge.pmd.lang.ast.Node)
8. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public boolean equals(java.lang.Object)
9. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public boolean equals(java.lang.Object)
10. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean equals(java.lang.Object)

1.  //Check whether the catch parameter is x type
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isSpecificType(ASTCatchParameter node){
    NodeStream<ASTClassOrInterfaceType> allExceptionTypes = node.getAllExceptionTypes();
    for(ASTClassOrInterfaceType type : allExceptionTypes){
        if(TypeTestUtil.isA(x.class, type)){
            return true;
        }
    }
    return false;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {

    public IdenticalCatchBranchesRule() {
        super(ASTTryStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        NodeStream<ASTCatchClause> catchClauses = node.getCatchClauses();
        Map<String, List<ASTCatchClause>> catchBodyMap = new HashMap<>();

        for (ASTCatchClause catchClause : catchClauses) {
            ASTBlock body = catchClause.getBody();
            String bodyImage = body.getImage();

            if (!catchBodyMap.containsKey(bodyImage)) {
                catchBodyMap.put(bodyImage, new ArrayList<>());
            }
            catchBodyMap.get(bodyImage).add(catchClause);
        }

        for (List<ASTCatchClause> clauses : catchBodyMap.values()) {
            if (clauses.size() > 1) {
                ASTCatchClause firstClause = clauses.get(0);
                for (int i = 1; i < clauses.size(); i++) {
                    ASTCatchClause currentClause = clauses.get(i);
                    if (firstClause.getBody().equals(currentClause.getBody())) {
                        if (canBeCollapsed(firstClause, currentClause)) {
                            addViolation(data, currentClause);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean canBeCollapsed(ASTCatchClause firstClause, ASTCatchClause currentClause) {
        ASTBlock firstBody = firstClause.getBody();
        ASTBlock currentBody = currentClause.getBody();

        if (!firstBody.hasDescendant(ASTThrowStatement.class) || !currentBody.hasDescendant(ASTThrowStatement.class)) {
            return false;
        }

        ASTThrowStatement firstThrow = firstBody.getFirstDescendant(ASTThrowStatement.class);
        ASTThrowStatement currentThrow = currentBody.getFirstDescendant(ASTThrowStatement.class);

        if (!firstThrow.getExpression().equals(currentThrow.getExpression())) {
            return false;
        }

        ASTCatchParameter firstParam = firstClause.getParameter();
        ASTCatchParameter currentParam = currentClause.getParameter();

        // Check if both catch parameters are of the same specific type, e.g., Exception.class
        if (isSpecificType(firstParam, Exception.class) && isSpecificType(currentParam, Exception.class)) {
            return true;
        }

        return false;
    }

    // Check whether the catch parameter is of a specific type
    public boolean isSpecificType(ASTCatchParameter node, Class<?> type) {
        NodeStream<ASTClassOrInterfaceType> allExceptionTypes = node.getAllExceptionTypes();
        for (ASTClassOrInterfaceType exceptionType : allExceptionTypes) {
            if (TypeTestUtil.isA(type, exceptionType)) {
                return true;
            }
        }
        return false;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 1
1884
1488
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of catch clause.
        2. Get the exception type of catch parameter.
        3. Get the catch branch of try statement.
        4. Check whether the catch branch is identical to another catch branch in the same try statement.
        5. If identical catch branches are found, get the exception types of all identical catch branches.
        6. Check whether there are more than one exception types in the identical catch branches.
        7. Check whether the exception types are not the same.

If the catch branches have identical statements and there are more than one exception types in the catch clauses, then this test case violates the rule.
            
['Get the name of catch clause.', 'Get the exception type of catch parameter.', 'Get the catch branch of try statement.', 'Check whether the catch branch is identical to another catch branch in the same try statement.', 'If identical catch branches are found, get the exception types of all identical catch branches.', 'Check whether there are more than one exception types in the identical catch branches.', 'Check whether the exception types are not the same.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTInitializer', 'TypesFromReflection', 'ASTTryStatement', 'TokenUtils', 'ASTCatchClause', 'ASTThrowStatement', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTCatchParameter', 'JavaSemanticErrors']
*Get the name of catch clause.* 匹配到的元操作或API：
logic: Get the name of catch clause.
most similar meta operation: Get the name of catch parameter
cosine Similarity: 0.8923118710517883
*Get the exception type of catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9756684899330139
*Get the catch branch of try statement.* 匹配到的元操作或API：
logic: Get the catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9813414812088013
*Check whether the catch branch is identical to another catch branch in the same try statement.* 匹配到的元操作或API：
query: Check whether the catch branch is identical to another catch branch in the same try statement.
most similar API: Check whether the try statement equals
cosine Similarity: 0.8148948550224304
*If identical catch branches are found, get the exception types of all identical catch branches.* 匹配到的元操作或API：
query: If identical catch branches are found, get the exception types of all identical catch branches.
most similar API: get all exception types of catch parameter
cosine Similarity: 0.8105719685554504
*Check whether there are more than one exception types in the identical catch branches.* 匹配到的元操作或API：
query: Check whether there are more than one exception types in the identical catch branches.
most similar API: get all exception types of catch parameter
cosine Similarity: 0.8016138076782227
*Check whether the exception types are not the same.* 匹配到的元操作或API：
query: Check whether the exception types are not the same.
most similar API: Check whether has exception list
cosine Similarity: 0.804380476474762
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Identical catch branches use up vertical space and increase the complexity of code without adding functionality. It’s better style to collapse identical branches into a single multi-catch branch.;
The test case corresponding to the rule:
```
// Identical statements, with different exception names
class Foo {
    {
        try {
            // do something
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalStateException ise) {
            throw new RuntimeException(ise);
        }
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 1)
                    ——ASTVariableAccess (referenced variable name = 'e')
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'ise')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 1)
                    ——ASTVariableAccess (referenced variable name = 'ise')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes()
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
4. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public boolean equals(java.lang.Object)
5. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes(), //Returns a stream of all declared exception types (expanding a union type if present). <p>Note that this is the only reliable way to inspect multi-catch clauses, as the type mirror of a {@link ASTUnionType} is not itself a {@link JIntersectionType}, but the {@link TypeSystem#lub(Collection) LUB} of the components. Since exception types cannot be interfaces, the LUB always erases to a single class supertype (eg {@link RuntimeException}).
6. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean hasExceptionList(net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration, [Ljava.lang.Class;)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public IdenticalCatchBranchesRule() {
        super(ASTTryStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        List<ASTCatchClause> catchClauses = node.getCatchClauses().toList();
        Map<String, List<ASTCatchClause>> catchBlocksMap = new HashMap<>();

        for (ASTCatchClause catchClause : catchClauses) {
            ASTBlock catchBlock = catchClause.getFirstChildOfType(ASTBlock.class);
            if (catchBlock != null) {
                // Convert the catch block to a string representation for comparison
                String catchBlockString = catchBlock.getImage();
                String catchBlockHash = catchBlockString + "|" + catchClause.getAllExceptionTypes().map(type -> type.getImage()).toList().toString();
                catchBlocksMap.computeIfAbsent(catchBlockHash, k -> new ArrayList<>()).add(catchClause);
            }
        }

        for (List<ASTCatchClause> clauses : catchBlocksMap.values()) {
            if (clauses.size() > 1) {
                for (int i = 1; i < clauses.size(); i++) {
                    addViolation(data, clauses.get(i));
                }
            }
        }

        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the catch branches of the try statement.
2. Get the number of catch branches.
3. Get the catch branch 1.
4. Get the catch parameter of catch branch 1.
5. Get the method declaration from method call in catch branch 1.
6. Get the catch branch 2.
7. Get the catch parameter of catch branch 2.
8. Get the method declaration from method call in catch branch 2.
9. Compare the method declarations from catch branches 1 and 2.
10. Check whether the exception types in catch branches 1 and 2 are different.
11. Check whether the method bodies in catch branches 1 and 2 are identical.

If the catch branches have different exception types and identical method bodies, then this test case violates the rule.
['Get the catch branches of the try statement.', 'Get the number of catch branches.', 'Get the catch branch 1.', 'Get the catch parameter of catch branch 1.', 'Get the method declaration from method call in catch branch 1.', 'Get the catch branch 2.', 'Get the catch parameter of catch branch 2.', 'Get the method declaration from method call in catch branch 2.', 'Compare the method declarations from catch branches 1 and 2.', 'Check whether the exception types in catch branches 1 and 2 are different.', 'Check whether the method bodies in catch branches 1 and 2 are identical.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTInitializer', 'TypesFromReflection', 'ASTTryStatement', 'TokenUtils', 'ASTCatchClause', 'ASTThrowStatement', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTCatchParameter', 'JavaSemanticErrors']
*Get the catch branches of the try statement.* 匹配到的元操作或API：
logic: Get the catch branches of the try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9282875061035156
*Get the number of catch branches.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the catch branch 1.* 匹配到的元操作或API：
logic: Get the catch branch 1.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8639990091323853
*Get the catch parameter of catch branch 1.* 匹配到的元操作或API：
logic: Get the catch parameter of catch branch 1.
most similar meta operation: Get the name of catch parameter
cosine Similarity: 0.8573616147041321
*Get the method declaration from method call in catch branch 1.* 匹配到的元操作或API：
logic: Get the method declaration from method call in catch branch 1.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.8820713758468628
*Get the catch branch 2.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the catch parameter of catch branch 2.* 匹配到的元操作或API：
query: Get the catch parameter of catch branch 2.
most similar API: get parameter of catch clause: Returns the catch parameter.
cosine Similarity: 0.8612392544746399
*Get the method declaration from method call in catch branch 2.* 匹配到的元操作或API：
logic: Get the method declaration from method call in catch branch 2.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.8860683441162109
*Compare the method declarations from catch branches 1 and 2.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the exception types in catch branches 1 and 2 are different.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method bodies in catch branches 1 and 2 are identical.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Identical catch branches use up vertical space and increase the complexity of code without adding functionality. It’s better style to collapse identical branches into a single multi-catch branch.;
The test case corresponding to the rule:
```
// Identical statements, with different exception names
class Foo {
    {
        try {
            // do something
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalStateException ise) {
            throw new RuntimeException(ise);
        }
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 1)
                    ——ASTVariableAccess (referenced variable name = 'e')
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'ise')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 1)
                    ——ASTVariableAccess (referenced variable name = 'ise')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
2. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public java.lang.String getName()
3. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTCatchParameter getParameter(), //Returns the catch parameter.

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public IdenticalCatchBranchesRule() {
        super(ASTTryStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        List<ASTCatchClause> catchClauses = node.getCatchClauses().toList();
        Map<String, List<ASTCatchClause>> catchMap = new HashMap<>();

        for (ASTCatchClause clause : catchClauses) {
            ASTCatchParameter param = clause.getParameter();
            ASTThrowStatement throwStmt = clause.getFirstChildOfType(ASTThrowStatement.class);
            if (throwStmt != null) {
                ASTConstructorCall constructorCall = throwStmt.getFirstChildOfType(ASTConstructorCall.class);
                if (constructorCall != null) {
                    ASTVariableAccess varAccess = constructorCall.getFirstChildOfType(ASTVariableAccess.class);
                    if (varAccess != null) {
                        String key = generateKey(param, throwStmt);
                        catchMap.computeIfAbsent(key, k -> new ArrayList<>()).add(clause);
                    }
                }
            }
        }

        for (List<ASTCatchClause> clauses : catchMap.values()) {
            if (clauses.size() > 1) {
                for (int i = 1; i < clauses.size(); i++) {
                    addViolation(data, clauses.get(i));
                }
            }
        }

        return super.visit(node, data);
    }

    private String generateKey(ASTCatchParameter param, ASTThrowStatement throwStmt) {
        StringBuilder keyBuilder = new StringBuilder();
        keyBuilder.append(param.getName());
        keyBuilder.append(throwStmt);
        return keyBuilder.toString();
    }

    // Utility method to get method declaration from method call
    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method) {
        JMethodSymbol symbol = (JMethodSymbol) method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the catch branches of the try statement.
2. Check whether the number of catch branches is greater than 1.
3. Get the catch branch 1.
4. Get the exception type of catch branch 1.
5. Get the body of catch branch 1.
6. Get the catch branch 2.
7. Get the exception type of catch branch 2.
8. Get the body of catch branch 2.
9. Check whether the body of catch branch 1 is identical to the body of catch branch 2.
10. Get the number of arguments of called method in catch branch 1.
11. Check whether the number of arguments of called method in catch branch 1 is 1.
12. Get the argument of called method in catch branch 1.
13. Get the type of argument in catch branch 1.
14. Get the number of arguments of called method in catch branch 2.
15. Check whether the number of arguments of called method in catch branch 2 is 1.
16. Get the argument of called method in catch branch 2.
17. Get the type of argument in catch branch 2.
18. Check whether the type of argument in catch branch 1 is different from the type of argument in catch branch 2.

If steps 2, 9, 11, 15, and 18 are all true, then this test case violates the rule.
            
['Get the catch branches of the try statement.', 'Check whether the number of catch branches is greater than 1.', 'Get the catch branch 1.', 'Get the exception type of catch branch 1.', 'Get the body of catch branch 1.', 'Get the catch branch 2.', 'Get the exception type of catch branch 2.', 'Get the body of catch branch 2.', 'Check whether the body of catch branch 1 is identical to the body of catch branch 2.', 'Get the number of arguments of called method in catch branch 1.', 'Check whether the number of arguments of called method in catch branch 1 is 1.', 'Get the argument of called method in catch branch 1.', 'Get the type of argument in catch branch 1.', 'Get the number of arguments of called method in catch branch 2.', 'Check whether the number of arguments of called method in catch branch 2 is 1.', 'Get the argument of called method in catch branch 2.', 'Get the type of argument in catch branch 2.', 'Check whether the type of argument in catch branch 1 is different from the type of argument in catch branch 2.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTInitializer', 'TypesFromReflection', 'ASTTryStatement', 'TokenUtils', 'ASTCatchClause', 'ASTThrowStatement', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTCatchParameter', 'JavaSemanticErrors']
*Get the catch branches of the try statement.* 匹配到的元操作或API：
logic: Get the catch branches of the try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9282875061035156
*Check whether the number of catch branches is greater than 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the catch branch 1.* 匹配到的元操作或API：
logic: Get the catch branch 1.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8639990091323853
*Get the exception type of catch branch 1.* 匹配到的元操作或API：
logic: Get the exception type of catch branch 1.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.8537728786468506
*Get the body of catch branch 1.* 匹配到的元操作或API：
query: Get the body of catch branch 1.
most similar API: get body of catch clause: Returns the body of this catch branch.
cosine Similarity: 0.8922620415687561
*Get the catch branch 2.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the exception type of catch branch 2.* 匹配到的元操作或API：
query: Get the exception type of catch branch 2.
most similar API: get all exception types of catch parameter
cosine Similarity: 0.8122421503067017
*Get the body of catch branch 2.* 匹配到的元操作或API：
query: Get the body of catch branch 2.
most similar API: get body of catch clause: Returns the body of this catch branch.
cosine Similarity: 0.8931505084037781
*Check whether the body of catch branch 1 is identical to the body of catch branch 2.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of arguments of called method in catch branch 1.* 匹配到的元操作或API：
logic: Get the number of arguments of called method in catch branch 1.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.8977807760238647
*Check whether the number of arguments of called method in catch branch 1 is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the argument of called method in catch branch 1.* 匹配到的元操作或API：
logic: Get the argument of called method in catch branch 1.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8609472513198853
*Get the type of argument in catch branch 1.* 匹配到的元操作或API：
query: Get the type of argument in catch branch 1.
most similar API: get type node of catch parameter
cosine Similarity: 0.8145331144332886
*Get the number of arguments of called method in catch branch 2.* 匹配到的元操作或API：
logic: Get the number of arguments of called method in catch branch 2.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9011045694351196
*Check whether the number of arguments of called method in catch branch 2 is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the argument of called method in catch branch 2.* 匹配到的元操作或API：
logic: Get the argument of called method in catch branch 2.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8606562614440918
*Get the type of argument in catch branch 2.* 匹配到的元操作或API：
query: Get the type of argument in catch branch 2.
most similar API: get type node of catch parameter
cosine Similarity: 0.8131181001663208
*Check whether the type of argument in catch branch 1 is different from the type of argument in catch branch 2.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Identical catch branches use up vertical space and increase the complexity of code without adding functionality. It’s better style to collapse identical branches into a single multi-catch branch.;
The test case corresponding to the rule:
```
// Identical statements, with different exception names
class Foo {
    {
        try {
            // do something
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalStateException ise) {
            throw new RuntimeException(ise);
        }
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 1)
                    ——ASTVariableAccess (referenced variable name = 'e')
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'ise')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 1)
                    ——ASTVariableAccess (referenced variable name = 'ise')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
2. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes()
3. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this catch branch.
4. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes(), //Returns a stream of all declared exception types (expanding a union type if present). <p>Note that this is the only reliable way to inspect multi-catch clauses, as the type mirror of a {@link ASTUnionType} is not itself a {@link JIntersectionType}, but the {@link TypeSystem#lub(Collection) LUB} of the components. Since exception types cannot be interfaces, the LUB always erases to a single class supertype (eg {@link RuntimeException}).
5. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
6. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode(), //Returns the type node of this catch parameter. May be a {@link ASTUnionType UnionType}.

1.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public IdenticalCatchBranchesRule() {
        super(ASTTryStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        List<ASTCatchClause> catchClauses = node.getCatchClauses().toList();
        for (int i = 0; i < catchClauses.size() - 1; i++) {
            ASTCatchClause currentClause = catchClauses.get(i);
            ASTCatchClause nextClause = catchClauses.get(i + 1);
            if (isBodyIdentical(currentClause, nextClause) && isSameThrowStatement(currentClause, nextClause)) {
                addViolation(data, currentClause);
            }
        }
        return super.visit(node, data);
    }

    private boolean isBodyIdentical(ASTCatchClause clause1, ASTCatchClause clause2) {
        return clause1.getBody().equals(clause2.getBody());
    }

    private boolean isSameThrowStatement(ASTCatchClause clause1, ASTCatchClause clause2) {
        ASTBlock body1 = clause1.getBody();
        ASTBlock body2 = clause2.getBody();
        if (body1.getNumChildren() != body2.getNumChildren()) {
            return false;
        }
        ASTThrowStatement throw1 = body1.getFirstChildOfType(ASTThrowStatement.class);
        ASTThrowStatement throw2 = body2.getFirstChildOfType(ASTThrowStatement.class);
        if (throw1 == null || throw2 == null) {
            return false;
        }
        ASTConstructorCall constructorCall1 = throw1.getFirstChildOfType(ASTConstructorCall.class);
        ASTConstructorCall constructorCall2 = throw2.getFirstChildOfType(ASTConstructorCall.class);
        if (!constructorCall1.getTypeNode().getType().equals(constructorCall2.getTypeNode().getType())) {
            return false;
        }
        ASTArgumentList arguments1 = constructorCall1.getArguments();
        ASTArgumentList arguments2 = constructorCall2.getArguments();
        if (getArgumentNumber(constructorCall1) != getArgumentNumber(constructorCall2)) {
            return false;
        }
        ASTVariableAccess arg1 = arguments1.getFirstChildOfType(ASTVariableAccess.class);
        ASTVariableAccess arg2 = arguments2.getFirstChildOfType(ASTVariableAccess.class);
        return arg1 != null && arg2 != null && arg1.getName().equals(clause1.getCatchParameter().getFirstDescendantOfType(ASTVariableDeclaratorId.class).getName()) && arg2.getName().equals(clause2.getCatchParameter().getFirstDescendantOfType(ASTVariableDeclaratorId.class).getName());
    }

    //Get the number of arguments of called method
    public int getArgumentNumber(ASTConstructorCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the catch branch of try statement.
2. Get the exception type of catch parameter.
3. Get the catch branch of try statement (second catch block).
4. Get the exception type of catch parameter (second catch block).
5. Get the catch branch of try statement.
6. Get the catch branch of try statement (second catch block).
7. Check whether the catch branches are identical.

If the catch branches are identical and the exception types are different, then this test case violates the rule.
            
['Get the catch branch of try statement.', 'Get the exception type of catch parameter.', 'Get the catch branch of try statement (second catch block).', 'Get the exception type of catch parameter (second catch block).', 'Get the catch branch of try statement.', 'Get the catch branch of try statement (second catch block).', 'Check whether the catch branches are identical.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTInitializer', 'TypesFromReflection', 'ASTTryStatement', 'TokenUtils', 'ASTCatchClause', 'ASTThrowStatement', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTCatchParameter', 'JavaSemanticErrors']
*Get the catch branch of try statement.* 匹配到的元操作或API：
logic: Get the catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9813414812088013
*Get the exception type of catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9756684899330139
*Get the catch branch of try statement (second catch block).* 匹配到的元操作或API：
logic: Get the catch branch of try statement (second catch block).
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9446043372154236
*Get the exception type of catch parameter (second catch block).* 匹配到的元操作或API：
logic: Get the exception type of catch parameter (second catch block).
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9169362187385559
*Get the catch branch of try statement.* 匹配到的元操作或API：
logic: Get the catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9813414812088013
*Get the catch branch of try statement (second catch block).* 匹配到的元操作或API：
logic: Get the catch branch of try statement (second catch block).
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9446043372154236
*Check whether the catch branches are identical.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Identical catch branches use up vertical space and increase the complexity of code without adding functionality. It’s better style to collapse identical branches into a single multi-catch branch.;
The test case corresponding to the rule:
```
// Identical statements, with different exception names
class Foo {
    {
        try {
            // do something
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalStateException ise) {
            throw new RuntimeException(ise);
        }
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 1)
                    ——ASTVariableAccess (referenced variable name = 'e')
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'ise')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 1)
                    ——ASTVariableAccess (referenced variable name = 'ise')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
2. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public IdenticalCatchBranchesRule() {
        super(ASTTryStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        List<ASTCatchClause> catchClauses = node.getCatchClauses().toList();
        Map<String, ASTCatchClause> catchBranchesMap = new HashMap<>();

        for (int i = 0; i < catchClauses.size(); i++) {
            ASTCatchClause currentClause = catchClauses.get(i);
            ASTCatchParameter catchParam = currentClause.getFirstChildOfType(ASTCatchParameter.class);
            ASTThrowStatement throwStmt = currentClause.getFirstChildOfType(ASTThrowStatement.class);

            if (catchParam != null && throwStmt != null) {
                String throwStmtSignature = getThrowStatementSignature(throwStmt);
                if (catchBranchesMap.containsKey(throwStmtSignature)) {
                    ASTCatchClause previousClause = catchBranchesMap.get(throwStmtSignature);
                    if (areCatchClausesIdentical(previousClause, currentClause)) {
                        addViolation(data, currentClause);
                    }
                } else {
                    catchBranchesMap.put(throwStmtSignature, currentClause);
                }
            }
        }
        return super.visit(node, data);
    }

    private String getThrowStatementSignature(ASTThrowStatement throwStmt) {
        ASTConstructorCall constructorCall = throwStmt.getFirstChildOfType(ASTConstructorCall.class);
        ASTClassOrInterfaceType exceptionType = constructorCall.getFirstChildOfType(ASTClassOrInterfaceType.class);
        ASTArgumentList argumentList = constructorCall.getFirstChildOfType(ASTArgumentList.class);
        ASTVariableAccess variableAccess = argumentList.getFirstChildOfType(ASTVariableAccess.class);

        return exceptionType.getType() + ":" + variableAccess.getName();
    }

    private boolean areCatchClausesIdentical(ASTCatchClause clause1, ASTCatchClause clause2) {
        return clause1.getImage().equals(clause2.getImage());
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the catch branches of the try statement.
2. Get the number of catch branches.
3. Get the catch parameter of the first catch branch.
4. Get the exception type of the first catch parameter.
5. Get the catch parameter of the second catch branch.
6. Get the exception type of the second catch parameter.
7. Get the catch branch of the first catch branch.
8. Get the catch branch of the second catch branch.
9. Check whether the catch branches have the same statements.
10. If the catch branches have the same statements, check whether they have different exception types.
11. If the catch branches have different exception types and the same statements, suggest collapsing them into a single multi-catch branch.
12. Check whether the test case has multiple catch branches with the same statements and different exception types.
13. Count the number of such occurrences.
14. Verify the number of violating the rule in the test case is 1.

By performing these checks, we can determine whether the catch branches in the provided test case are identical and should be collapsed into a single multi-catch branch.
['Get the catch branches of the try statement.', 'Get the number of catch branches.', 'Get the catch parameter of the first catch branch.', 'Get the exception type of the first catch parameter.', 'Get the catch parameter of the second catch branch.', 'Get the exception type of the second catch parameter.', 'Get the catch branch of the first catch branch.', 'Get the catch branch of the second catch branch.', 'Check whether the catch branches have the same statements.', 'If the catch branches have the same statements, check whether they have different exception types.', 'If the catch branches have different exception types and the same statements, suggest collapsing them into a single multi-catch branch.', 'Check whether the test case has multiple catch branches with the same statements and different exception types.', 'Count the number of such occurrences.', 'Verify the number of violating the rule in the test case is 1.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTInitializer', 'TypesFromReflection', 'ASTTryStatement', 'TokenUtils', 'ASTCatchClause', 'ASTThrowStatement', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'ASTCatchParameter', 'JavaSemanticErrors']
*Get the catch branches of the try statement.* 匹配到的元操作或API：
logic: Get the catch branches of the try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9282875061035156
*Get the number of catch branches.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the catch parameter of the first catch branch.* 匹配到的元操作或API：
query: Get the catch parameter of the first catch branch.
most similar API: get parameter of catch clause: Returns the catch parameter.
cosine Similarity: 0.8492509126663208
*Get the exception type of the first catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of the first catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.922197163105011
*Get the catch parameter of the second catch branch.* 匹配到的元操作或API：
query: Get the catch parameter of the second catch branch.
most similar API: get parameter of catch clause: Returns the catch parameter.
cosine Similarity: 0.8446161150932312
*Get the exception type of the second catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of the second catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9218042492866516
*Get the catch branch of the first catch branch.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the catch branch of the second catch branch.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the catch branches have the same statements.* 匹配到的元操作或API：
query: Check whether the catch branches have the same statements.
most similar API: Check whether the catch clause equals
cosine Similarity: 0.8328673243522644
*If the catch branches have the same statements, check whether they have different exception types.* 匹配到的元操作或API：
query: If the catch branches have the same statements, check whether they have different exception types.
most similar API: Check whether the catch clause equals
cosine Similarity: 0.8114619851112366
*If the catch branches have different exception types and the same statements, suggest collapsing them into a single multi-catch branch.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the test case has multiple catch branches with the same statements and different exception types.* 匹配到的元操作或API：
未匹配成功元操作或API
*Count the number of such occurrences.* 匹配到的元操作或API：
未匹配成功元操作或API
*Verify the number of violating the rule in the test case is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Identical catch branches use up vertical space and increase the complexity of code without adding functionality. It’s better style to collapse identical branches into a single multi-catch branch.;
The test case corresponding to the rule:
```
// Identical statements, with different exception names
class Foo {
    {
        try {
            // do something
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalStateException ise) {
            throw new RuntimeException(ise);
        }
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 1)
                    ——ASTVariableAccess (referenced variable name = 'e')
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'ise')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 1)
                    ——ASTVariableAccess (referenced variable name = 'ise')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
2. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTCatchParameter getParameter(), //Returns the catch parameter.
3. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes()
4. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public boolean equals(java.lang.Object)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.HashMap;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public IdenticalCatchBranchesRule() {
        super(ASTTryStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        NodeStream<ASTCatchClause> catchClauses = node.getCatchClauses();
        Map<String, ASTCatchClause> catchBlockMap = new HashMap<>();

        for (ASTCatchClause catchClause : catchClauses) {
            ASTBlock catchBlock = catchClause.getFirstChildOfType(ASTBlock.class);
            String catchBlockSignature = catchBlock != null ? catchBlock.getImage() : "";

            if (!catchBlockMap.containsKey(catchBlockSignature)) {
                catchBlockMap.put(catchBlockSignature, catchClause);
            } else {
                ASTCatchClause previousClause = catchBlockMap.get(catchBlockSignature);
                if (catchClause.getParameter().getAllExceptionTypes().allMatch(type -> 
                    !previousClause.getParameter().getAllExceptionTypes().anyMatch(prevType -> prevType.getType().equals(type.getType()))
                )) {
                    addViolation(data, catchClause);
                }
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 2


======================接下来开始迭代=====================
为反例生成first checker失败
结束

规则执行完毕，时间总花销： 1724.9204223155975 秒
