开始

========================================== Rule StringInstantiationRule ===========================================
一共 10 个测试用例
正例 5 个
反例 5 个
1574
1236
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the field declaration of bar.
2. Check whether the field is initialized.
3. Check whether the field is initialized to a new String object.
4. Get the constructor call from the field initialization.
5. Get the name of constructor.
6. Check whether the constructor name is String.
7. Get the field declaration of baz.
8. Check whether the field is initialized.
9. Check whether the field is initialized to a new String object.
10. Get the constructor call from the field initialization.
11. Get the name of constructor.
12. Check whether the constructor name is String.

If the field `bar` is initialized to a new String object and the constructor name is `String`, then this violates the rule.
If the field `baz` is initialized to a new String object and the constructor name is `String`, then this violates the rule.
['Get the field declaration of bar.', 'Check whether the field is initialized.', 'Check whether the field is initialized to a new String object.', 'Get the constructor call from the field initialization.', 'Get the name of constructor.', 'Check whether the constructor name is String.', 'Get the field declaration of baz.', 'Check whether the field is initialized.', 'Check whether the field is initialized to a new String object.', 'Get the constructor call from the field initialization.', 'Get the name of constructor.', 'Check whether the constructor name is String.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTFieldDeclaration', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the field declaration of bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the field is initialized.* 匹配到的元操作或API：
logic: Check whether the field is initialized.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.9865798950195312
*Check whether the field is initialized to a new String object.* 匹配到的元操作或API：
logic: Check whether the field is initialized to a new String object.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.8908883929252625
*Get the constructor call from the field initialization.* 匹配到的元操作或API：
query: Get the constructor call from the field initialization.
most similar API: get parent of constructor call
cosine Similarity: 0.8214364647865295
*Get the name of constructor.* 匹配到的元操作或API：
logic: Get the name of constructor.
most similar meta operation: Get the name of constructor
cosine Similarity: 0.9789292812347412
*Check whether the constructor name is String.* 匹配到的元操作或API：
query: Check whether the constructor name is String.
most similar API: Check whether the constructor call is parenthesized
cosine Similarity: 0.8053991794586182
*Get the field declaration of baz.* 匹配到的元操作或API：
query: Get the field declaration of baz.
most similar API: get declared annotations of field
cosine Similarity: 0.8004313707351685
*Check whether the field is initialized.* 匹配到的元操作或API：
logic: Check whether the field is initialized.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.9865798950195312
*Check whether the field is initialized to a new String object.* 匹配到的元操作或API：
logic: Check whether the field is initialized to a new String object.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.8908883929252625
*Get the constructor call from the field initialization.* 匹配到的元操作或API：
query: Get the constructor call from the field initialization.
most similar API: get parent of constructor call
cosine Similarity: 0.8214364647865295
*Get the name of constructor.* 匹配到的元操作或API：
logic: Get the name of constructor.
most similar meta operation: Get the name of constructor
cosine Similarity: 0.9789292812347412
*Check whether the constructor name is String.* 匹配到的元操作或API：
query: Check whether the constructor name is String.
most similar API: Check whether the constructor call is parenthesized
cosine Similarity: 0.8053991794586182
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Avoid instantiating String objects.;
The test case corresponding to the rule:
```
// new 'new String's
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'bar')
        ——ASTConstructorCall
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTArgumentList (size = 1)
            ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'baz')
        ——ASTConstructorCall
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public N getParent()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.String getName()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isParenthesized(), //Returns true if this expression has at least one level of parentheses. The specific depth can be fetched with {@link #getParenthesisDepth()}.
4. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()

1.  //Check whether the field is initialized
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean isInitialized(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                return true;
            }
        }
    }
    return false;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        NodeStream<ASTFieldDeclaration> fields = node.children(ASTFieldDeclaration.class);
        for (ASTFieldDeclaration field : fields) {
            if (isInitialized(field)) {
                NodeStream<ASTVariableDeclaratorId> varIds = field.getVarIds();
                for (ASTVariableDeclaratorId varId : varIds) {
                    ASTExpression init = varId.getInitializer();
                    if (init instanceof ASTConstructorCall) {
                        ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                        ASTClassOrInterfaceType type = constructorCall.getType();
                        Type stringType = TypeSystem.STRING;
                        if (type.getType() != null && type.getType().equals(stringType)) {
                            addViolation(data, constructorCall);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTClassOrInterfaceType type = node.getType();
        Type stringType = TypeSystem.STRING;
        if (type.getType() != null && type.getType().equals(stringType)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    // Check whether the field is initialized
    public boolean isInitialized(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                return true;
            }
        }
        return false;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
To granularly check the adherence to the rule "Avoid instantiating String objects" for the provided test case, we can break down the operations as follows:

1. Get the type of field `bar`.
2. Check whether the type of field `bar` is String class type.
3. Check whether field `bar` is initialized using `new String()`.
4. Get the type of field `baz`.
5. Check whether the type of field `baz` is String class type.
6. Check whether field `baz` is initialized using `new String()`.

Let's perform these checks:

1. Get the type of field `bar`.
        Result: The type of field `bar` is String class type.

2. Check whether the type of field `bar` is String class type.
        Result: The field `bar` is indeed of type String.

3. Check whether field `bar` is initialized using `new String()`.
        Result: The field `bar` is initialized using `new String("bar")`.

4. Get the type of field `baz`.
        Result: The type of field `baz` is String class type.

5. Check whether the type of field `baz` is String class type.
        Result: The field `baz` is indeed of type String.

6. Check whether field `baz` is initialized using `new String()`.
        Result: The field `baz` is initialized using `new String()`.

Both fields `bar` and `baz` are initialized using `new String()`, which violates the rule. Therefore, the number of violations in this test case is 2.
['Get the type of field `bar`.', 'Check whether the type of field `bar` is String class type.', 'Check whether field `bar` is initialized using `new String()`.', 'Get the type of field `baz`.', 'Check whether the type of field `baz` is String class type.', 'Check whether field `baz` is initialized using `new String()`.', 'Get the type of field `bar`.', 'Check whether the type of field `bar` is String class type.', 'Check whether field `bar` is initialized using `new String()`.', 'Get the type of field `baz`.', 'Check whether the type of field `baz` is String class type.', 'Check whether field `baz` is initialized using `new String()`.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTFieldDeclaration', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the type of field `bar`.* 匹配到的元操作或API：
logic: Get the type of field `bar`.
most similar meta operation: Get the type of field
cosine Similarity: 0.8754798173904419
*Check whether the type of field `bar` is String class type.* 匹配到的元操作或API：
logic: Check whether the type of field `bar` is String class type.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.8950687050819397
*Check whether field `bar` is initialized using `new String()`.* 匹配到的元操作或API：
logic: Check whether field `bar` is initialized using `new String()`.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.8750156164169312
*Get the type of field `baz`.* 匹配到的元操作或API：
query: Get the type of field `baz`.
most similar API: get type system of field
cosine Similarity: 0.8005542755126953
*Check whether the type of field `baz` is String class type.* 匹配到的元操作或API：
logic: Check whether the type of field `baz` is String class type.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.8815824389457703
*Check whether field `baz` is initialized using `new String()`.* 匹配到的元操作或API：
logic: Check whether field `baz` is initialized using `new String()`.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.8759865760803223
*Get the type of field `bar`.* 匹配到的元操作或API：
logic: Get the type of field `bar`.
most similar meta operation: Get the type of field
cosine Similarity: 0.8754798173904419
*Check whether the type of field `bar` is String class type.* 匹配到的元操作或API：
logic: Check whether the type of field `bar` is String class type.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.8950687050819397
*Check whether field `bar` is initialized using `new String()`.* 匹配到的元操作或API：
logic: Check whether field `bar` is initialized using `new String()`.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.8750156164169312
*Get the type of field `baz`.* 匹配到的元操作或API：
query: Get the type of field `baz`.
most similar API: get type system of field
cosine Similarity: 0.8005542755126953
*Check whether the type of field `baz` is String class type.* 匹配到的元操作或API：
logic: Check whether the type of field `baz` is String class type.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.8815824389457703
*Check whether field `baz` is initialized using `new String()`.* 匹配到的元操作或API：
logic: Check whether field `baz` is initialized using `new String()`.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.8759865760803223
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Avoid instantiating String objects.;
The test case corresponding to the rule:
```
// new 'new String's
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'bar')
        ——ASTConstructorCall
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTArgumentList (size = 1)
            ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'baz')
        ——ASTConstructorCall
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.types.TypeSystem getTypeSystem()

1.  //Check whether the field is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFieldStringType(ASTFieldDeclaration node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```
2.  //Check whether the field is initialized
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean isInitialized(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                return true;
            }
        }
    }
    return false;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            NodeStream<ASTConstructorCall> constructorCalls = node.getVarIds().children(ASTConstructorCall.class);
            for (ASTConstructorCall constructorCall : constructorCalls) {
                if (constructorCall.getType() != null && constructorCall.getType().getQualifiedName().equals("java.lang.String")) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    // Check whether the field is string type
    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    // Check whether the field is initialized
    public boolean isInitialized(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    return true;
                }
            }
        }
        return false;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the type of object created by constructor call.
2. Check whether the type of object is String class type.
3. Check whether the constructor call has arguments.
4. Get the number of arguments of the constructor call.
5. Get the argument of the constructor call.
6. Check whether the argument is a string literal.
7. Get the type of object created by constructor call.
8. Check whether the type of object is String class type.
9. Check whether the constructor call has arguments.
10. Get the number of arguments of the constructor call.
11. Check whether the number of arguments is 0.

If the type of object created by the constructor call is String and the constructor call has arguments and the argument is a string literal, then this test case violates the rule. This check is performed for the first instantiation `new String("bar")`.

If the type of object created by the constructor call is String and the constructor call has no arguments, then this test case also violates the rule. This check is performed for the second instantiation `new String()`.

In this test case, both instantiations of String objects violate the rule.
            
['Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Check whether the constructor call has arguments.', 'Get the number of arguments of the constructor call.', 'Get the argument of the constructor call.', 'Check whether the argument is a string literal.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Check whether the constructor call has arguments.', 'Get the number of arguments of the constructor call.', 'Check whether the number of arguments is 0.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTFieldDeclaration', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Check whether the constructor call has arguments.* 匹配到的元操作或API：
query: Check whether the constructor call has arguments.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8736711740493774
*Get the number of arguments of the constructor call.* 匹配到的元操作或API：
logic: Get the number of arguments of the constructor call.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9067217707633972
*Get the argument of the constructor call.* 匹配到的元操作或API：
logic: Get the argument of the constructor call.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8546751737594604
*Check whether the argument is a string literal.* 匹配到的元操作或API：
logic: Check whether the argument is a string literal.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9077170491218567
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Check whether the constructor call has arguments.* 匹配到的元操作或API：
query: Check whether the constructor call has arguments.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8736711740493774
*Get the number of arguments of the constructor call.* 匹配到的元操作或API：
logic: Get the number of arguments of the constructor call.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9067217707633972
*Check whether the number of arguments is 0.* 匹配到的元操作或API：
query: Check whether the number of arguments is 0.
most similar API: size or zero of argument list
cosine Similarity: 0.8315972685813904
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Avoid instantiating String objects.;
The test case corresponding to the rule:
```
// new 'new String's
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'bar')
        ——ASTConstructorCall
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTArgumentList (size = 1)
            ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'baz')
        ——ASTConstructorCall
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
4. net.sourceforge.pmd.lang.java.ast.ASTArgumentList: static public int sizeOrZero(net.sourceforge.pmd.lang.java.ast.ASTList)

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
3.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        if ("String".equals(typeNode.getImage()) && isConstructorCallStringType(node)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    // Check whether the type of object is String class type
    public boolean isConstructorCallStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode.getTypeMirror());
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the type of object created by constructor call.
2. Check whether the type of object is String class type.
3. Get the number of arguments of called method.
4. Check whether the number of arguments is 1.
5. Check whether the method is a constructor.
6. Get the type of object created by constructor call.
7. Check whether the type of object is String class type.
8. Get the number of arguments of called method.
9. Check whether the number of arguments is 0.
10. Check whether the method is a constructor.

This test case violates the rule twice as indicated:
- First violation: When `new String("bar")` is used.
- Second violation: When `new String()` is used.
Both operations instantiate String objects directly using the constructor, which is against the rule.
['Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 1.', 'Check whether the method is a constructor.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 0.', 'Check whether the method is a constructor.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTFieldDeclaration', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846129417419434
*Check whether the number of arguments is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is a constructor.* 匹配到的元操作或API：
query: Check whether the method is a constructor.
most similar API: Check whether the constructor call is qualified instance creation
cosine Similarity: 0.8379802703857422
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846129417419434
*Check whether the number of arguments is 0.* 匹配到的元操作或API：
query: Check whether the number of arguments is 0.
most similar API: size or zero of argument list
cosine Similarity: 0.8315972685813904
*Check whether the method is a constructor.* 匹配到的元操作或API：
query: Check whether the method is a constructor.
most similar API: Check whether the constructor call is qualified instance creation
cosine Similarity: 0.8379802703857422
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Avoid instantiating String objects.;
The test case corresponding to the rule:
```
// new 'new String's
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'bar')
        ——ASTConstructorCall
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTArgumentList (size = 1)
            ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'baz')
        ——ASTConstructorCall
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isQualifiedInstanceCreation(), //Returns true if this expression begins with a primary expression. Such an expression creates an instance of inner member classes and their anonymous subclasses. For example, {@code new Outer().new Inner()} evaluates to an instance of the Inner class, which is nested inside the new instance of Outer.
3. net.sourceforge.pmd.lang.java.ast.ASTArgumentList: static public int sizeOrZero(net.sourceforge.pmd.lang.java.ast.ASTList)

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTFieldDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        NodeStream<ASTConstructorCall> constructorCalls = node.children(ASTConstructorCall.class);
        constructorCalls.forEach(constructorCall -> {
            JType type = constructorCall.getType();
            if (type != null && isVariableAccessStringType(constructorCall)) {
                addViolation(data, constructorCall);
            }
        });
        return super.visit(node, data);
    }

    // Check whether the type of object is String class type
    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        return TypeTestUtil.isA(String.class, node.getType());
    }

    // Get the number of arguments of called method
    public int getArgumentNumber(ASTMethodCall node) {
        ASTArgumentList arguments = node.getArguments();
        return arguments.size();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of field.
2. Check whether the field is private (for bar).
3. Check whether the field is private (for baz).
4. Get the type of field (for bar).
5. Check whether the field is String type (for bar).
6. Get the type of field (for baz).
7. Check whether the field is String type (for baz).
8. Get the initialization of field (for bar).
9. Check whether the initialization is a new String object (for bar).
10. Get the initialization of field (for baz).
11. Check whether the initialization is a new String object (for baz).

- 8. Check whether the initialization is a new String object (for bar).
- 11. Check whether the initialization is a new String object (for baz).

If the initialization of the field is a new String object, then this test case violates the rule. In this test case, both `bar` and `baz` are instantiated using new String objects, so there are 2 violations of the rule.
['Get the name of field.', 'Check whether the field is private (for bar).', 'Check whether the field is private (for baz).', 'Get the type of field (for bar).', 'Check whether the field is String type (for bar).', 'Get the type of field (for baz).', 'Check whether the field is String type (for baz).', 'Get the initialization of field (for bar).', 'Check whether the initialization is a new String object (for bar).', 'Get the initialization of field (for baz).', 'Check whether the initialization is a new String object (for baz).']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTFieldDeclaration', 'ASTClassOrInterfaceBody', 'TypesFromReflection', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of field.* 匹配到的元操作或API：
logic: Get the name of field.
most similar meta operation: Get the name of field
cosine Similarity: 0.978217363357544
*Check whether the field is private (for bar).* 匹配到的元操作或API：
logic: Check whether the field is private (for bar).
most similar meta operation: Check whether the field is private
cosine Similarity: 0.9322208166122437
*Check whether the field is private (for baz).* 匹配到的元操作或API：
logic: Check whether the field is private (for baz).
most similar meta operation: Check whether the field is private
cosine Similarity: 0.9369250535964966
*Get the type of field (for bar).* 匹配到的元操作或API：
logic: Get the type of field (for bar).
most similar meta operation: Get the type of field
cosine Similarity: 0.9087801575660706
*Check whether the field is String type (for bar).* 匹配到的元操作或API：
logic: Check whether the field is String type (for bar).
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.9330703616142273
*Get the type of field (for baz).* 匹配到的元操作或API：
logic: Get the type of field (for baz).
most similar meta operation: Get the type of field
cosine Similarity: 0.8965097665786743
*Check whether the field is String type (for baz).* 匹配到的元操作或API：
logic: Check whether the field is String type (for baz).
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.928146243095398
*Get the initialization of field (for bar).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the initialization is a new String object (for bar).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the initialization of field (for baz).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the initialization is a new String object (for baz).* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Avoid instantiating String objects.;
The test case corresponding to the rule:
```
// new 'new String's
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'bar')
        ——ASTConstructorCall
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTArgumentList (size = 1)
            ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'baz')
        ——ASTConstructorCall
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isPrivate()
2. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()

1.  //Get the name of field
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.ast.NodeStream;
public String getFieldName(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId variableDeclaratorId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(variableDeclaratorId.getName().equals("x")){
            String variableName = variableDeclaratorId.getName();
            return variableName;
        }
    }
    return null;
}
```
2.  //Check whether the field is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFieldStringType(ASTFieldDeclaration node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            NodeStream<ASTConstructorCall> constructorCalls = node.children(ASTConstructorCall.class);
            for (ASTConstructorCall constructorCall : constructorCalls) {
                if (TypeTestUtil.isA(String.class, constructorCall.getType())) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 1
1634
1279
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Get the return type of method.
3. Check whether the return type of method is string type.
4. Get the body of the method.
5. Check whether the method body contains a return statement.
6. Get the return expression in return statement.
7. Check whether the return expression is a constructor call.
8. Get the type of object created by constructor call.
9. Check whether the type of object is String class type.

If the method's return expression is a constructor call and the type of object created is the String class type, then this test case violates the rule.
['Get the name of method.', 'Get the return type of method.', 'Check whether the return type of method is string type.', 'Get the body of the method.', 'Check whether the method body contains a return statement.', 'Get the return expression in return statement.', 'Check whether the return expression is a constructor call.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTConstructorCall', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the return type of method.* 匹配到的元操作或API：
logic: Get the return type of method.
most similar meta operation: Get the return type of method
cosine Similarity: 0.983596682548523
*Check whether the return type of method is string type.* 匹配到的元操作或API：
logic: Check whether the return type of method is string type.
most similar meta operation: Check whether the return type of method is string type
cosine Similarity: 0.9892082214355469
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Check whether the method body contains a return statement.* 匹配到的元操作或API：
query: Check whether the method body contains a return statement.
most similar API: Check whether the return statement equals
cosine Similarity: 0.8523768782615662
*Get the return expression in return statement.* 匹配到的元操作或API：
logic: Get the return expression in return statement.
most similar meta operation: Get the return expression in return statement
cosine Similarity: 0.9881546497344971
*Check whether the return expression is a constructor call.* 匹配到的元操作或API：
query: Check whether the return expression is a constructor call.
most similar API: Check whether the constructor call is expression
cosine Similarity: 0.9070413112640381
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Avoid instantiating String objects.;
The test case corresponding to the rule:
```
// Method returning new String
public class Foo {
    String foo() {
        return new String("foo");
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTConstructorCall
            ——ASTClassOrInterfaceType (this is a class type)
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getResultTypeNode()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
4. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public boolean equals(java.lang.Object)
5. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getExpr()
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()

1.  //Check whether the return type of method is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnValueStringType(ASTMethodDeclaration method) {
    return TypeTestUtil.isA(String.class, method.getResultTypeNode());
}
```
2.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTReturnStatement.class);
    }

    @Override
    public Object visit(ASTReturnStatement node, Object data) {
        ASTExpression expr = node.getExpr();
        if (expr instanceof ASTConstructorCall) {
            ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
            JType type = constructorCall.getType();
            if (isVariableAccessStringType(constructorCall)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Check whether the type of object is String class type
    private boolean isVariableAccessStringType(ASTConstructorCall node) {
        JType type = node.getType();
        return TypeTestUtil.isA(String.class, type);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
        2. Get the return type of method.
        3. Check whether the return type of method is String type.
        4. Get the return expression in return statement.
        5. Check whether the return expression is a constructor call.
        6. Get the type of object created by constructor call.
        7. Check whether the type of object is String class type.

If the return expression is a constructor call and the type of object created is String, then this test case violates the rule.
['Get the name of method.', 'Get the return type of method.', 'Check whether the return type of method is String type.', 'Get the return expression in return statement.', 'Check whether the return expression is a constructor call.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTConstructorCall', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the return type of method.* 匹配到的元操作或API：
logic: Get the return type of method.
most similar meta operation: Get the return type of method
cosine Similarity: 0.983596682548523
*Check whether the return type of method is String type.* 匹配到的元操作或API：
logic: Check whether the return type of method is String type.
most similar meta operation: Check whether the return type of method is string type
cosine Similarity: 0.9892082214355469
*Get the return expression in return statement.* 匹配到的元操作或API：
logic: Get the return expression in return statement.
most similar meta operation: Get the return expression in return statement
cosine Similarity: 0.9881546497344971
*Check whether the return expression is a constructor call.* 匹配到的元操作或API：
query: Check whether the return expression is a constructor call.
most similar API: Check whether the constructor call is expression
cosine Similarity: 0.9070413112640381
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Avoid instantiating String objects.;
The test case corresponding to the rule:
```
// Method returning new String
public class Foo {
    String foo() {
        return new String("foo");
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTConstructorCall
            ——ASTClassOrInterfaceType (this is a class type)
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getResultTypeNode()
3. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getExpr()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()

1.  //Check whether the return type of method is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnValueStringType(ASTMethodDeclaration method) {
    return TypeTestUtil.isA(String.class, method.getResultTypeNode());
}
```
2.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        // Check whether the constructor call is for String and it's a literal instantiation
        if (node.isLiteralInstantiation() && "java.lang.String".equals(node.getTypeNode().getType().getQualifiedName())) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    // Check whether the return type of method is string type
    public boolean isReturnValueStringType(ASTMethodDeclaration method) {
        return TypeTestUtil.isA(String.class, method.getResultType().getType());
    }

    // Check whether the type of object is String class type
    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode().getType());
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the return type of method.
2. Check whether the return type of method is string type.
3. Get the body of method.
4. Check whether the body of method contains a return statement.
5. Get the return expression in return statement.
6. Check whether the return expression is a constructor call.
7. Get the type of object created by constructor call.
8. Check whether the type of object is String class type.

If the return type of the method is String, the body contains a return statement, the return expression is a constructor call, and the type of the object created by the constructor call is String, then this test case violates the rule.
['Get the return type of method.', 'Check whether the return type of method is string type.', 'Get the body of method.', 'Check whether the body of method contains a return statement.', 'Get the return expression in return statement.', 'Check whether the return expression is a constructor call.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTConstructorCall', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the return type of method.* 匹配到的元操作或API：
logic: Get the return type of method.
most similar meta operation: Get the return type of method
cosine Similarity: 0.983596682548523
*Check whether the return type of method is string type.* 匹配到的元操作或API：
logic: Check whether the return type of method is string type.
most similar meta operation: Check whether the return type of method is string type
cosine Similarity: 0.9892082214355469
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752806425094604
*Check whether the body of method contains a return statement.* 匹配到的元操作或API：
query: Check whether the body of method contains a return statement.
most similar API: Check whether the return statement equals
cosine Similarity: 0.8555349111557007
*Get the return expression in return statement.* 匹配到的元操作或API：
logic: Get the return expression in return statement.
most similar meta operation: Get the return expression in return statement
cosine Similarity: 0.9881546497344971
*Check whether the return expression is a constructor call.* 匹配到的元操作或API：
query: Check whether the return expression is a constructor call.
most similar API: Check whether the constructor call is expression
cosine Similarity: 0.9070413112640381
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Avoid instantiating String objects.;
The test case corresponding to the rule:
```
// Method returning new String
public class Foo {
    String foo() {
        return new String("foo");
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTConstructorCall
            ——ASTClassOrInterfaceType (this is a class type)
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getResultTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
3. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getExpr()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()

1.  //Check whether the return type of method is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnValueStringType(ASTMethodDeclaration method) {
    return TypeTestUtil.isA(String.class, method.getResultTypeNode());
}
```
2.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        if (TypeTestUtil.isA(String.class, typeNode.getType())) {
            // Check if the parent node is a return statement
            if (node.getParent() instanceof ASTReturnStatement) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Check whether the return type of method is String type
    public boolean isReturnValueStringType(ASTMethodDeclaration method) {
        return TypeTestUtil.isA(String.class, method.getResultTypeNode().getType());
    }

    // Check whether the type of object is String class type
    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode().getType());
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the return expression in return statement.
2. Check whether the return expression is a new String instantiation.
3. If the return expression is a new String instantiation, then this test case violates the rule.

In this specific test case:
- The return expression in the return statement is `new String("foo")`.
- Therefore, the test case violates the rule by instantiating a String object.
['Get the return expression in return statement.', 'Check whether the return expression is a new String instantiation.', 'If the return expression is a new String instantiation, then this test case violates the rule.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTConstructorCall', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the return expression in return statement.* 匹配到的元操作或API：
logic: Get the return expression in return statement.
most similar meta operation: Get the return expression in return statement
cosine Similarity: 0.9881546497344971
*Check whether the return expression is a new String instantiation.* 匹配到的元操作或API：
query: Check whether the return expression is a new String instantiation.
most similar API: Check whether the string literal is expression
cosine Similarity: 0.8237643241882324
*If the return expression is a new String instantiation, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Avoid instantiating String objects.;
The test case corresponding to the rule:
```
// Method returning new String
public class Foo {
    String foo() {
        return new String("foo");
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTConstructorCall
            ——ASTClassOrInterfaceType (this is a class type)
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getExpr()
2. net.sourceforge.pmd.lang.java.ast.ASTStringLiteral: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        if (TypeTestUtil.isA(node.getType(), String.class)) {
            Node parent = node.getParent();
            if (parent instanceof ASTReturnStatement) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Get the return type of method.
3. Check whether the return type of method is string type.
4. Get the body of method.
5. Find all object creations in the method body.
6. Check whether the type of object created by constructor call is String class type.

If the method returns a String and the return expression is an object creation of the String class type, then this test case violates the rule.
['Get the name of method.', 'Get the return type of method.', 'Check whether the return type of method is string type.', 'Get the body of method.', 'Find all object creations in the method body.', 'Check whether the type of object created by constructor call is String class type.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTStringLiteral', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTClassOrInterfaceDeclaration', 'ASTConstructorCall', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the return type of method.* 匹配到的元操作或API：
logic: Get the return type of method.
most similar meta operation: Get the return type of method
cosine Similarity: 0.983596682548523
*Check whether the return type of method is string type.* 匹配到的元操作或API：
logic: Check whether the return type of method is string type.
most similar meta operation: Check whether the return type of method is string type
cosine Similarity: 0.9892082214355469
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752806425094604
*Find all object creations in the method body.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the type of object created by constructor call is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object created by constructor call is String class type.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.8867563009262085
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Avoid instantiating String objects.;
The test case corresponding to the rule:
```
// Method returning new String
public class Foo {
    String foo() {
        return new String("foo");
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTConstructorCall
            ——ASTClassOrInterfaceType (this is a class type)
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getResultTypeNode()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()

1.  //Check whether the return type of method is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnValueStringType(ASTMethodDeclaration method) {
    return TypeTestUtil.isA(String.class, method.getResultTypeNode());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        if (TypeTestUtil.isA(String.class, typeNode)) {
            ASTMethodDeclaration method = node.getFirstParent(ASTMethodDeclaration.class);
            if (method != null && method.getBody().containsDescendant(node)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Check whether the return type of method is string type
    public boolean isReturnValueStringType(ASTMethodDeclaration method) {
        return TypeTestUtil.isA(String.class, method.getResultTypeNode());
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 2
1881
1495
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the method declaration from the method call.
        2. Get the signature of the called method.
        3. Get the return type of the called method.
        4. Get the body of the method.
        5. Get the return expression in return statement.
        6. Check whether the return expression is a constructor call.
        7. Get the type of object created by the constructor call.
        8. Check whether the type of object created is String.

If the return expression in the method body is a constructor call and the type of object created is String, then this test case violates the rule.
            
['Get the method declaration from the method call.', 'Get the signature of the called method.', 'Get the return type of the called method.', 'Get the body of the method.', 'Get the return expression in return statement.', 'Check whether the return expression is a constructor call.', 'Get the type of object created by the constructor call.', 'Check whether the type of object created is String.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclaratorId', 'ASTArgumentList', 'ASTBlock', 'SymbolResolutionPass', 'TypeConversion', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTFormalParameter', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTFormalParameters', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTCompilationUnit', 'TypesFromAst', 'ASTReturnStatement', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the method declaration from the method call.* 匹配到的元操作或API：
logic: Get the method declaration from the method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9715675115585327
*Get the signature of the called method.* 匹配到的元操作或API：
logic: Get the signature of the called method.
most similar meta operation: Get the signature of the called method
cosine Similarity: 0.9828987717628479
*Get the return type of the called method.* 匹配到的元操作或API：
logic: Get the return type of the called method.
most similar meta operation: Get the return type of called method
cosine Similarity: 0.9767904877662659
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Get the return expression in return statement.* 匹配到的元操作或API：
logic: Get the return expression in return statement.
most similar meta operation: Get the return expression in return statement
cosine Similarity: 0.9881546497344971
*Check whether the return expression is a constructor call.* 匹配到的元操作或API：
query: Check whether the return expression is a constructor call.
most similar API: Check whether the constructor call is expression
cosine Similarity: 0.9070413112640381
*Get the type of object created by the constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by the constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.983032763004303
*Check whether the type of object created is String.* 匹配到的元操作或API：
logic: Check whether the type of object created is String.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.8635118007659912
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Avoid instantiating String objects.;
The test case corresponding to the rule:
```
// Returns new String(str)
public class Foo {
    String foo(String str) {
        return new String(str);
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'str')
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTConstructorCall
            ——ASTClassOrInterfaceType (this is a class type)
            ——ASTArgumentList (size = 1)
              ——ASTVariableAccess (referenced variable name = 'str')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.types.JMethodSig getMethodType()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
3. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getExpr()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```
2.  //Get the return type of called method
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.JMethodSig;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getReturnType(ASTMethodCall call) {
    JMethodSig m = call.getMethodType();
    return m.getReturnType();
}
```
3.  //Check whether the field is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFieldStringType(ASTFieldDeclaration node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        if (TypeTestUtil.isA(String.class, typeNode)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    // Get method declaration from method call
    /*
    import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
    import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
    import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
        JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }
    */

    // Get the return type of called method
    /*
    import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
    import net.sourceforge.pmd.lang.java.types.JMethodSig;
    import net.sourceforge.pmd.lang.java.types.JTypeMirror;
    public JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
    */

    // Check whether the field is string type
    /*
    import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
    import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }
    */
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
True
此测试用例生成了first checker: bad 3


======================接下来开始迭代=====================
[ERROR]   "ok 2" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
97
81
111
94
94
79
94
78
87
72
88
73
95
78
97
81
99
82
116
101
=========================error_testcase_logics=========================
To perform a granular check to ascertain whether the test case adheres to the rule "Avoid instantiating String objects," we need to focus on the instantiation of `String` objects using the `new` keyword.

Here are the granular checks for the provided test case:

1. Get the type of object created by constructor call.
2. Check whether the type of object is String class type.
3. Get the signature of the called method.
4. Check whether the constructor is called with multiple parameters.

Let's go through each step:

1. Get the type of object created by constructor call.
   - In the test case, the type of object created by the constructor call is `String`.

2. Check whether the type of object is String class type.
   - The type of object created is indeed `String`.

3. Get the signature of the called method.
   - The signature of the called method is `String(byte[] bytes, int offset, int length)`.

4. Check whether the constructor is called with multiple parameters.
   - The constructor is called with three parameters: `bytes`, `0`, and `bytes.length`.

Given these checks, the test case does instantiate a `String` object using the `new` keyword with multiple parameters. Therefore, it should be considered as violating the rule.

The correct number of violations in this test case is: 1
['Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the signature of the called method.', 'Check whether the constructor is called with multiple parameters.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the signature of the called method.', 'Check whether the constructor is called with multiple parameters.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTArrayAllocation', 'TypeConversion', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTArrayDimExpr', 'ASTFieldAccess', 'ASTArrayType', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the signature of the called method.* 匹配到的元操作或API：
logic: Get the signature of the called method.
most similar meta operation: Get the signature of the called method
cosine Similarity: 0.9828987717628479
*Check whether the constructor is called with multiple parameters.* 匹配到的元操作或API：
query: Check whether the constructor is called with multiple parameters.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8434199094772339
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the signature of the called method.* 匹配到的元操作或API：
logic: Get the signature of the called method.
most similar meta operation: Get the signature of the called method
cosine Similarity: 0.9828987717628479
*Check whether the constructor is called with multiple parameters.* 匹配到的元操作或API：
query: Check whether the constructor is called with multiple parameters.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8434199094772339
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        if (TypeTestUtil.isA(String.class, typeNode)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    // Get method declaration from method call
    /*
    import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
    import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
    import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
        JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }
    */

    // Get the return type of called method
    /*
    import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
    import net.sourceforge.pmd.lang.java.types.JMethodSig;
    import net.sourceforge.pmd.lang.java.types.JTypeMirror;
    public JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
    */

    // Check whether the field is string type
    /*
    import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
    import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }
    */
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    String foo(String str) {
        return new String(str);
    }
}


This checker is failed(false positive) on this positive test case:
```
// using multiple parameter constructor
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bytes')
            ——ASTArrayAllocation
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayDimExpr
                    ——ASTNumericLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 3)
                ——ASTVariableAccess (referenced variable name = 'bytes')
                ——ASTNumericLiteral
                ——ASTFieldAccess
                  ——ASTVariableAccess (referenced variable name = 'bytes')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.types.JMethodSig getMethodType()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean equals(java.lang.Object)

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        if (TypeTestUtil.isA(String.class, typeNode)) {
            ASTArgumentList arguments = node.getArgumentList();
            if (arguments.jjtGetNumChildren() != 3 || 
                !TypeTestUtil.isA(byte[].class, arguments.jjtGetChild(0))) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
Let's perform granular checks to ascertain the adherence of the test case to the rule "Avoid instantiating String objects."

1. Get the type of object created by constructor call.
        2. Check whether the type of object is String class type.
        3. Get the signature of the called method.
        4. Check whether the called method is a constructor.
        5. Check whether the constructor is a String constructor.

Based on these checks, let's analyze the test case:

1. Get the type of object created by constructor call.  
   The object being created is of type `String`.

2. Check whether the type of object is String class type.  
   The object is indeed of type `String`.

3. Get the signature of the called method.  
   The signature of the called method is `String(byte[], int, int)`.

4. Check whether the called method is a constructor.  
   The method being called is a constructor.

5. Check whether the constructor is a String constructor.  
   The constructor being called is `String(byte[], int, int)`, which is a constructor of the `String` class.

Given these checks, it's clear that the test case is instantiating a `String` object using the `String(byte[], int, int)` constructor. Therefore, the number of violations of the rule in this test case is: 1.
['Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the signature of the called method.', 'Check whether the called method is a constructor.', 'Check whether the constructor is a String constructor.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the signature of the called method.', 'Check whether the called method is a constructor.', 'Check whether the constructor is a String constructor.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTArrayAllocation', 'TypeConversion', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTArrayDimExpr', 'ASTFieldAccess', 'ASTArrayType', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the signature of the called method.* 匹配到的元操作或API：
logic: Get the signature of the called method.
most similar meta operation: Get the signature of the called method
cosine Similarity: 0.9828987717628479
*Check whether the called method is a constructor.* 匹配到的元操作或API：
query: Check whether the called method is a constructor.
most similar API: Check whether the constructor call is qualified instance creation
cosine Similarity: 0.8676870465278625
*Check whether the constructor is a String constructor.* 匹配到的元操作或API：
query: Check whether the constructor is a String constructor.
most similar API: Check whether the constructor call is expression
cosine Similarity: 0.822106122970581
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the signature of the called method.* 匹配到的元操作或API：
logic: Get the signature of the called method.
most similar meta operation: Get the signature of the called method
cosine Similarity: 0.9828987717628479
*Check whether the called method is a constructor.* 匹配到的元操作或API：
query: Check whether the called method is a constructor.
most similar API: Check whether the constructor call is qualified instance creation
cosine Similarity: 0.8676870465278625
*Check whether the constructor is a String constructor.* 匹配到的元操作或API：
query: Check whether the constructor is a String constructor.
most similar API: Check whether the constructor call is expression
cosine Similarity: 0.822106122970581
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        if (TypeTestUtil.isA(String.class, typeNode)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    // Get method declaration from method call
    /*
    import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
    import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
    import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
        JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }
    */

    // Get the return type of called method
    /*
    import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
    import net.sourceforge.pmd.lang.java.types.JMethodSig;
    import net.sourceforge.pmd.lang.java.types.JTypeMirror;
    public JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
    */

    // Check whether the field is string type
    /*
    import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
    import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }
    */
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    String foo(String str) {
        return new String(str);
    }
}


This checker is failed(false positive) on this positive test case:
```
// using multiple parameter constructor
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bytes')
            ——ASTArrayAllocation
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayDimExpr
                    ——ASTNumericLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 3)
                ——ASTVariableAccess (referenced variable name = 'bytes')
                ——ASTNumericLiteral
                ——ASTFieldAccess
                  ——ASTVariableAccess (referenced variable name = 'bytes')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.types.JMethodSig getMethodType()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isQualifiedInstanceCreation(), //Returns true if this expression begins with a primary expression. Such an expression creates an instance of inner member classes and their anonymous subclasses. For example, {@code new Outer().new Inner()} evaluates to an instance of the Inner class, which is nested inside the new instance of Outer.
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        if (TypeTestUtil.isA(String.class, typeNode) && node.getArgumentCount() == 1) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
Let's perform granular checks to verify the adherence to the rule "Avoid instantiating String objects."

1. Get the type of object created by constructor call.
2. Check whether the type of object is String class type.
3. Get the name of called method (constructor).
4. Check whether the name is String.
5. Get the number of arguments of called method.
6. Check whether the number of arguments is greater than 0.

In this test case:

1. Get the type of object created by constructor call: The object created by the constructor call is of type `String`.
2. Check whether the type of object is String class type: Yes, the object is of type `String`.
3. Get the name of called method (constructor): The name of the called method (constructor) is `String`.
4. Check whether the name is String: Yes, the name is `String`.
5. Get the number of arguments of called method: The number of arguments is 3 (`byte[] bytes`, `0`, `bytes.length`).
6. Check whether the number of arguments is greater than 0: Yes, the number of arguments is greater than 0.

Since the test case involves instantiating a `String` object using its constructor, it violates the rule "Avoid instantiating String objects."

The number of violations in this test case is: 1
['Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the name of called method (constructor).', 'Check whether the name is String.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is greater than 0.', 'Get the type of object created by constructor call: The object created by the constructor call is of type `String`.', 'Check whether the type of object is String class type: Yes, the object is of type `String`.', 'Get the name of called method (constructor): The name of the called method (constructor) is `String`.', 'Check whether the name is String: Yes, the name is `String`.', 'Get the number of arguments of called method: The number of arguments is 3 (`byte[] bytes`, `0`, `bytes.length`).', 'Check whether the number of arguments is greater than 0: Yes, the number of arguments is greater than 0.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTArrayAllocation', 'TypeConversion', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTArrayDimExpr', 'ASTFieldAccess', 'ASTArrayType', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the name of called method (constructor).* 匹配到的元操作或API：
logic: Get the name of called method (constructor).
most similar meta operation: Get the name of called method
cosine Similarity: 0.926727294921875
*Check whether the name is String.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846129417419434
*Check whether the number of arguments is greater than 0.* 匹配到的元操作或API：
query: Check whether the number of arguments is greater than 0.
most similar API: Check whether the argument list is empty
cosine Similarity: 0.810643196105957
*Get the type of object created by constructor call: The object created by the constructor call is of type `String`.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call: The object created by the constructor call is of type `String`.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9358875751495361
*Check whether the type of object is String class type: Yes, the object is of type `String`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of called method (constructor): The name of the called method (constructor) is `String`.* 匹配到的元操作或API：
logic: Get the name of called method (constructor): The name of the called method (constructor) is `String`.
most similar meta operation: Get the name of called method
cosine Similarity: 0.8626598119735718
*Check whether the name is String: Yes, the name is `String`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the number of arguments of called method: The number of arguments is 3 (`byte[] bytes`, `0`, `bytes.length`).* 匹配到的元操作或API：
logic: Get the number of arguments of called method: The number of arguments is 3 (`byte[] bytes`, `0`, `bytes.length`).
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.8929973244667053
*Check whether the number of arguments is greater than 0: Yes, the number of arguments is greater than 0.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        if (TypeTestUtil.isA(String.class, typeNode)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    // Get method declaration from method call
    /*
    import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
    import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
    import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
    public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
        JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
        ASTMethodDeclaration declaration = symbol.tryGetNode();
        return declaration;
    }
    */

    // Get the return type of called method
    /*
    import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
    import net.sourceforge.pmd.lang.java.types.JMethodSig;
    import net.sourceforge.pmd.lang.java.types.JTypeMirror;
    public JTypeMirror getReturnType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType();
    }
    */

    // Check whether the field is string type
    /*
    import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
    import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }
    */
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    String foo(String str) {
        return new String(str);
    }
}


This checker is failed(false positive) on this positive test case:
```
// using multiple parameter constructor
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bytes')
            ——ASTArrayAllocation
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayDimExpr
                    ——ASTNumericLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 3)
                ——ASTVariableAccess (referenced variable name = 'bytes')
                ——ASTNumericLiteral
                ——ASTFieldAccess
                  ——ASTVariableAccess (referenced variable name = 'bytes')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
3. net.sourceforge.pmd.lang.java.ast.ASTArgumentList: public boolean isEmpty()

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        if (TypeTestUtil.isA(String.class, typeNode)) {
            int argumentCount = node.getArguments().size();
            if (argumentCount == 1 || argumentCount == 2) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "ok 4" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
97
81
111
94
94
79
94
78
87
72
88
73
97
81
99
82
116
101
=========================error_testcase_logics=========================
1. Get all object creations in the method.
2. Check whether the type of object created is String class type.
3. If the object creation is of type String, get the constructor arguments.
4. Check whether the constructor arguments are a byte array.

If the object creation of type String uses a byte array constructor, then it does not violate the rule. Based on your test case, we will perform these checks:

1. Get all object creations in the method foo.
        2. Check whether the type of object created is String class type.
        3. If the object creation is of type String, get the constructor arguments.
        4. Check whether the constructor arguments are a byte array.

1. Get all object creations in the method foo.
    - Found an object creation `String bar = new String(bytes);` in the method `foo`.

2. Check whether the type of object created is String class type.
    - The type of object created is String.

3. If the object creation is of type String, get the constructor arguments.
    - The constructor arguments are `bytes`.

4. Check whether the constructor arguments are a byte array.
    - The constructor arguments are indeed a byte array.

Since the String object is created using a byte array constructor, it does not violate the rule. Therefore, the number of violations in this test case is 0.
['Get all object creations in the method.', 'Check whether the type of object created is String class type.', 'If the object creation is of type String, get the constructor arguments.', 'Check whether the constructor arguments are a byte array.', 'Get all object creations in the method foo.', 'Check whether the type of object created is String class type.', 'If the object creation is of type String, get the constructor arguments.', 'Check whether the constructor arguments are a byte array.', 'Get all object creations in the method foo.', 'Check whether the type of object created is String class type.', 'If the object creation is of type String, get the constructor arguments.', 'Check whether the constructor arguments are a byte array.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTArrayAllocation', 'TypeConversion', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTArrayDimExpr', 'ASTArrayType', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get all object creations in the method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the type of object created is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object created is String class type.
most similar meta operation: Check whether the return type of method is string type
cosine Similarity: 0.8563871383666992
*If the object creation is of type String, get the constructor arguments.* 匹配到的元操作或API：
query: If the object creation is of type String, get the constructor arguments.
most similar API: get arguments of constructor call
cosine Similarity: 0.8489583730697632
*Check whether the constructor arguments are a byte array.* 匹配到的元操作或API：
logic: Check whether the constructor arguments are a byte array.
most similar meta operation: Check whether the argument is byte type
cosine Similarity: 0.8959416747093201
*Get all object creations in the method foo.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the type of object created is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object created is String class type.
most similar meta operation: Check whether the return type of method is string type
cosine Similarity: 0.8563871383666992
*If the object creation is of type String, get the constructor arguments.* 匹配到的元操作或API：
query: If the object creation is of type String, get the constructor arguments.
most similar API: get arguments of constructor call
cosine Similarity: 0.8489583730697632
*Check whether the constructor arguments are a byte array.* 匹配到的元操作或API：
logic: Check whether the constructor arguments are a byte array.
most similar meta operation: Check whether the argument is byte type
cosine Similarity: 0.8959416747093201
*Get all object creations in the method foo.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the type of object created is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object created is String class type.
most similar meta operation: Check whether the return type of method is string type
cosine Similarity: 0.8563871383666992
*If the object creation is of type String, get the constructor arguments.* 匹配到的元操作或API：
query: If the object creation is of type String, get the constructor arguments.
most similar API: get arguments of constructor call
cosine Similarity: 0.8489583730697632
*Check whether the constructor arguments are a byte array.* 匹配到的元操作或API：
logic: Check whether the constructor arguments are a byte array.
most similar meta operation: Check whether the argument is byte type
cosine Similarity: 0.8959416747093201
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        if (TypeTestUtil.isA(String.class, typeNode)) {
            int argumentCount = node.getArguments().size();
            if (argumentCount == 1 || argumentCount == 2) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this positive testcase:
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length);
    }
}
This checker has passed this negative testcase:
public class Foo {
    String foo(String str) {
        return new String(str);
    }
}


This checker is failed(false positive) on this positive test case:
```
// byte array constructor is ok
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bytes')
            ——ASTArrayAllocation
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayDimExpr
                    ——ASTNumericLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 1)
                ——ASTVariableAccess (referenced variable name = 'bytes')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()

1.  //Check whether the return type of method is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnValueStringType(ASTMethodDeclaration method) {
    return TypeTestUtil.isA(String.class, method.getResultTypeNode());
}
```
2.  //Check whether the argument is byte type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isMethodCallArgumentByteType(ASTMethodCall call) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        if (TypeTestUtil.isA(String.class, typeNode)) {
            int argumentCount = node.getArguments().size();
            if (argumentCount == 1 || argumentCount == 2) {
                ASTArgumentList astArgumentList = node.getArguments();
                ASTExpression firstArgument = astArgumentList.get(0);
                if (firstArgument.getTypeMirror().isArray() && firstArgument.getTypeMirror().getArrayComponentType().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the object creation expression.
2. Get the type of object created by constructor call.
3. Check whether the type of object is String class type.
4. Get the number of arguments of constructor call.
5. Get an argument of constructor call.
6. Check whether the argument is a byte array.

If the type of object created is String and the number of arguments is 1 and the argument is a byte array, then this instantiation is allowed by the rule.

Let's break down the test case:

1. Get the object creation expression (`new String(bytes)`).
2. Get the type of object created by constructor call (`String`).
3. Check whether the type of object is String class type (True).
4. Get the number of arguments of constructor call (1).
5. Get an argument of constructor call (`bytes`).
6. Check whether the argument is a byte array (True).

Since the argument is a byte array, this instantiation does not violate the rule. Therefore, the number of violations in this test case is: 0.
['Get the object creation expression.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the number of arguments of constructor call.', 'Get an argument of constructor call.', 'Check whether the argument is a byte array.', 'Get the object creation expression (`new String(bytes)`).', 'Get the type of object created by constructor call (`String`).', 'Check whether the type of object is String class type (True).', 'Get the number of arguments of constructor call (1).', 'Get an argument of constructor call (`bytes`).', 'Check whether the argument is a byte array (True).']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTArrayAllocation', 'TypeConversion', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTArrayDimExpr', 'ASTArrayType', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the object creation expression.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the number of arguments of constructor call.* 匹配到的元操作或API：
logic: Get the number of arguments of constructor call.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9035000801086426
*Get an argument of constructor call.* 匹配到的元操作或API：
logic: Get an argument of constructor call.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.8630561828613281
*Check whether the argument is a byte array.* 匹配到的元操作或API：
logic: Check whether the argument is a byte array.
most similar meta operation: Check whether the argument is byte type
cosine Similarity: 0.9360387921333313
*Get the object creation expression (`new String(bytes)`).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of object created by constructor call (`String`).* 匹配到的元操作或API：
logic: Get the type of object created by constructor call (`String`).
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9533967971801758
*Check whether the type of object is String class type (True).* 匹配到的元操作或API：
logic: Check whether the type of object is String class type (True).
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8554386496543884
*Get the number of arguments of constructor call (1).* 匹配到的元操作或API：
logic: Get the number of arguments of constructor call (1).
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.8891471028327942
*Get an argument of constructor call (`bytes`).* 匹配到的元操作或API：
query: Get an argument of constructor call (`bytes`).
most similar API: get arguments of constructor call
cosine Similarity: 0.8554732799530029
*Check whether the argument is a byte array (True).* 匹配到的元操作或API：
logic: Check whether the argument is a byte array (True).
most similar meta operation: Check whether the argument is byte type
cosine Similarity: 0.9084667563438416
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        if (TypeTestUtil.isA(String.class, typeNode)) {
            int argumentCount = node.getArguments().size();
            if (argumentCount == 1 || argumentCount == 2) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this positive testcase:
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length);
    }
}
This checker has passed this negative testcase:
public class Foo {
    String foo(String str) {
        return new String(str);
    }
}


This checker is failed(false positive) on this positive test case:
```
// byte array constructor is ok
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bytes')
            ——ASTArrayAllocation
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayDimExpr
                    ——ASTNumericLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 1)
                ——ASTVariableAccess (referenced variable name = 'bytes')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
3.  //Check whether the argument is byte type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isMethodCallArgumentByteType(ASTMethodCall call) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        if (TypeTestUtil.isA(String.class, typeNode)) {
            int argumentCount = node.getArguments().size();
            if (argumentCount == 1) {
                ASTExpression expression = node.getArguments().get(0);
                if (expression.getTypeMirror().isArrayType() && expression.getTypeMirror().getArrayComponentType().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE)) {
                    addViolation(data, node);
                }
            } else if (argumentCount == 2) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the method declaration from method call.
        2. Get the type of object created by constructor call.
        3. Check whether the type of object is String class type.
        4. Get the arguments of the constructor call.
        5. Check whether the arguments are a byte array.

Given the test case:

1. Get the method declaration from method call. (In this case, the method call is `String bar = new String(bytes);`)
2. Get the type of object created by constructor call. (The type is `String`)
3. Check whether the type of object is String class type. (True, it's a String)
4. Get the arguments of the constructor call. (The arguments are `bytes`)
5. Check whether the arguments are a byte array. (True, `bytes` is a byte array)

Since the rule allows instantiating a `String` object using a byte array constructor, this test case does not violate the rule. Therefore, the number of violations is: 0.
['Get the method declaration from method call.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the arguments of the constructor call.', 'Check whether the arguments are a byte array.', 'Get the method declaration from method call. (In this case, the method call is `String bar = new String(bytes);`)', 'Get the type of object created by constructor call. (The type is `String`)', "Check whether the type of object is String class type. (True, it's a String)", 'Get the arguments of the constructor call. (The arguments are `bytes`)', 'Check whether the arguments are a byte array. (True, `bytes` is a byte array)']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTArrayAllocation', 'TypeConversion', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTArrayDimExpr', 'ASTArrayType', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the method declaration from method call.* 匹配到的元操作或API：
logic: Get the method declaration from method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9787436127662659
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the arguments of the constructor call.* 匹配到的元操作或API：
query: Get the arguments of the constructor call.
most similar API: get arguments of constructor call
cosine Similarity: 0.9658721089363098
*Check whether the arguments are a byte array.* 匹配到的元操作或API：
logic: Check whether the arguments are a byte array.
most similar meta operation: Check whether the argument is byte type
cosine Similarity: 0.9296718835830688
*Get the method declaration from method call. (In this case, the method call is `String bar = new String(bytes);`)* 匹配到的元操作或API：
logic: Get the method declaration from method call. (In this case, the method call is `String bar = new String(bytes);`)
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9050458073616028
*Get the type of object created by constructor call. (The type is `String`)* 匹配到的元操作或API：
logic: Get the type of object created by constructor call. (The type is `String`)
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9643042683601379
*Check whether the type of object is String class type. (True, it's a String)* 匹配到的元操作或API：
logic: Check whether the type of object is String class type. (True, it's a String)
most similar meta operation: Check whether the array is string type
cosine Similarity: 0.8571958541870117
*Get the arguments of the constructor call. (The arguments are `bytes`)* 匹配到的元操作或API：
query: Get the arguments of the constructor call. (The arguments are `bytes`)
most similar API: get arguments of constructor call
cosine Similarity: 0.9046778678894043
*Check whether the arguments are a byte array. (True, `bytes` is a byte array)* 匹配到的元操作或API：
logic: Check whether the arguments are a byte array. (True, `bytes` is a byte array)
most similar meta operation: Check whether the argument is byte type
cosine Similarity: 0.9003958702087402
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        if (TypeTestUtil.isA(String.class, typeNode)) {
            int argumentCount = node.getArguments().size();
            if (argumentCount == 1 || argumentCount == 2) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this positive testcase:
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length);
    }
}
This checker has passed this negative testcase:
public class Foo {
    String foo(String str) {
        return new String(str);
    }
}


This checker is failed(false positive) on this positive test case:
```
// byte array constructor is ok
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bytes')
            ——ASTArrayAllocation
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayDimExpr
                    ——ASTNumericLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 1)
                ——ASTVariableAccess (referenced variable name = 'bytes')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```
2.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```
3.  //Check whether the argument is byte type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isMethodCallArgumentByteType(ASTMethodCall call) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
}
```
4.  //Check whether the array is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isArrayStringType(ASTVariableDeclaratorId node) {
    if(node.getType().isArray()){
        ASTArrayType arrayType = (ASTArrayType)node.getTypeNode();
        ASTType astType = (ASTType) arrayType.getChild(0);
        if(astType instanceof ASTClassOrInterfaceType){
            ASTClassOrInterfaceType classOrInterfaceType = (ASTClassOrInterfaceType)astType;
            return TypeTestUtil.isA(String.class, classOrInterfaceType);
        }
    }
    return false;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        if (TypeTestUtil.isA(String.class, typeNode)) {
            int argumentCount = node.getArguments().size();
            if (argumentCount == 1 || argumentCount == 2) {
                if (isByteArgument(node)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isByteArgument(ASTConstructorCall node) {
        ASTArgumentList arguments = node.getArguments();
        for (ASTExpression argument : arguments) {
            if (argument.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE)) {
                return true;
            }
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 3" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the type of object created by constructor call.
2. Check whether the type of object is String class type.
3. If the object created is a String, get the name of called constructor.
4. Check whether the called constructor is using a byte array as a parameter.
5. If the constructor uses a byte array as a parameter, the instantiation is allowed.
6. If the constructor does not use a byte array as a parameter, the instantiation is a violation of the rule.

In this test case:
- 1. The type of object created by the constructor call is String.
- 2. The type of object is indeed String class type.
- 3. The name of the called constructor is String.
- 4. The called constructor is using a byte array as a parameter.
- 5. Since the constructor uses a byte array as a parameter, the instantiation is allowed.

Therefore, the number of violations of the rule in this test case is: 0.
['Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'If the object created is a String, get the name of called constructor.', 'Check whether the called constructor is using a byte array as a parameter.', 'If the constructor uses a byte array as a parameter, the instantiation is allowed.', 'If the constructor does not use a byte array as a parameter, the instantiation is a violation of the rule.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTArrayAllocation', 'TypeConversion', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTArrayDimExpr', 'ASTArrayType', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*If the object created is a String, get the name of called constructor.* 匹配到的元操作或API：
logic: If the object created is a String, get the name of called constructor.
most similar meta operation: Get the name of constructor
cosine Similarity: 0.8767609000205994
*Check whether the called constructor is using a byte array as a parameter.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the constructor uses a byte array as a parameter, the instantiation is allowed.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the constructor does not use a byte array as a parameter, the instantiation is a violation of the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        if (TypeTestUtil.isA(String.class, typeNode)) {
            int argumentCount = node.getArguments().size();
            if (argumentCount == 1 || argumentCount == 2) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this positive testcase:
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length);
    }
}
This checker has passed this negative testcase:
public class Foo {
    String foo(String str) {
        return new String(str);
    }
}


This checker is failed(false positive) on this positive test case:
```
// byte array constructor is ok
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bytes')
            ——ASTArrayAllocation
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayDimExpr
                    ——ASTNumericLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 1)
                ——ASTVariableAccess (referenced variable name = 'bytes')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.String getName()

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        if (TypeTestUtil.isA(String.class, typeNode)) {
            ASTArgumentList arguments = node.getArguments();
            int argumentCount = arguments.size();
            if (argumentCount == 1 || argumentCount == 2) {
                boolean isByteArray = false;
                for (ASTExpression expr : arguments) {
                    if (expr instanceof ASTVariableAccess) {
                        ASTVariableAccess varAccess = (ASTVariableAccess) expr;
                        ASTLocalVariableDeclaration varDecl = varAccess.getVariableDeclaration();
                        if (varDecl != null && varDecl.getTypeNode() instanceof ASTArrayType) {
                            ASTArrayType arrayType = (ASTArrayType) varDecl.getTypeNode();
                            if (arrayType.getComponentType() instanceof ASTPrimitiveType) {
                                ASTPrimitiveType primitiveType = (ASTPrimitiveType) arrayType.getComponentType();
                                if ("byte".equals(primitiveType.getImage())) {
                                    isByteArray = true;
                                    break;
                                }
                            }
                        }
                    }
                }
                if (!isByteArray) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the type of object created by constructor call.
2. Check whether the type of object is String class type.
3. Get the number of arguments of called method.
4. Check whether the number of arguments is greater than 1.
5. Get the first argument of called method.
6. Get the type of the first argument.
7. Check whether the type is a byte array type.

In this test case:
- The type of object created by the constructor call is String class type.
- The number of arguments of the called method is 1.
- The argument is a byte array, which is allowed according to the rule description.

Therefore, there are no violations of the rule in this test case.
['Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is greater than 1.', 'Get the first argument of called method.', 'Get the type of the first argument.', 'Check whether the type is a byte array type.']
['SymbolicValueHelper', 'CommentAssignmentPass', 'ASTClassOrInterfaceType', 'ASTVariableDeclarator', 'ASTVariableDeclaratorId', 'ASTVoidType', 'ASTArgumentList', 'ASTBlock', 'ASTNumericLiteral', 'SymbolResolutionPass', 'ASTArrayAllocation', 'TypeConversion', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ClassNamesUtil', 'TestFrameworksUtil', 'JavaAstUtils', 'ASTArrayDimExpr', 'ASTArrayType', 'ASTVariableAccess', 'JavaRuleUtil', 'InternalApiBridge', 'JavadocTag', 'AstImplUtil', 'ASTClassOrInterfaceBody', 'ASTMethodDeclaration', 'TypesFromReflection', 'ASTPrimitiveType', 'ASTFormalParameters', 'TokenUtils', 'ASTConstructorCall', 'ASTClassOrInterfaceDeclaration', 'TypeTestUtil', 'ASTModifierList', 'ASTLocalVariableDeclaration', 'ASTCompilationUnit', 'TypesFromAst', 'JavaPropertyUtil', 'JavaSemanticErrors']
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846129417419434
*Check whether the number of arguments is greater than 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first argument of called method.* 匹配到的元操作或API：
logic: Get the first argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9160764217376709
*Get the type of the first argument.* 匹配到的元操作或API：
logic: Get the type of the first argument.
most similar meta operation: Get the type of argument
cosine Similarity: 0.9078184962272644
*Check whether the type is a byte array type.* 匹配到的元操作或API：
logic: Check whether the type is a byte array type.
most similar meta operation: Check whether the array is byte type
cosine Similarity: 0.9364995956420898
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        if (TypeTestUtil.isA(String.class, typeNode)) {
            int argumentCount = node.getArguments().size();
            if (argumentCount == 1 || argumentCount == 2) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this positive testcase:
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length);
    }
}
This checker has passed this negative testcase:
public class Foo {
    String foo(String str) {
        return new String(str);
    }
}


This checker is failed(false positive) on this positive test case:
```
// byte array constructor is ok
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bytes')
            ——ASTArrayAllocation
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayDimExpr
                    ——ASTNumericLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 1)
                ——ASTVariableAccess (referenced variable name = 'bytes')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
3.  //Get the type of argument
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getMethodCallArgumentType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror();
}
```
4.  //Check whether the array is byte type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.ast.ASTPrimitiveType;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isArrayByteType(ASTVariableDeclaratorId node) {
    if(node.getType().isArray()){
        ASTArrayType arrayType = (ASTArrayType)node.getTypeNode();
        ASTType astType = (ASTType) arrayType.getChild(0);
        if(astType instanceof ASTPrimitiveType){
            ASTPrimitiveType primitiveType = (ASTPrimitiveType)astType;
            if(primitiveType.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE)){
                return true;
            }
        }
    }
    return false;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        if (TypeTestUtil.isA(String.class, typeNode)) {
            int argumentCount = node.getArguments().size();
            if (argumentCount == 1 || argumentCount == 2) {
                if (argumentCount == 1) {
                    ASTExpression expression = node.getArguments().get(0);
                    if (expression instanceof ASTVariableAccess) {
                        ASTVariableAccess variableAccess = (ASTVariableAccess) expression;
                        ASTVariableDeclaratorId declaratorId = variableAccess.getDeclaratorId();
                        if (declaratorId != null && isArrayByteType(declaratorId)) {
                            addViolation(data, node);
                        }
                    }
                } else {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isArrayByteType(ASTVariableDeclaratorId node) {
        if (node.getType().isArray()) {
            ASTArrayType arrayType = (ASTArrayType) node.getTypeNode();
            ASTType astType = (ASTType) arrayType.getChild(0);
            if (astType instanceof ASTPrimitiveType) {
                ASTPrimitiveType primitiveType = (ASTPrimitiveType) astType;
                if (primitiveType.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE)) {
                    return true;
                }
            }
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 4
测试用例全部通过
最终通过 7 个测试用例
正例 4 个
反例 3 个
输入token：152773
输出token：89955
结束

规则执行完毕，时间总花销： 2986.8095428943634 秒
