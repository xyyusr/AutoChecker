开始

========================================== Rule ClassWithOnlyPrivateConstructorsShouldBeFinalRule ===========================================
一共 22 个测试用例
正例 15 个
反例 7 个
1117
839
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Check whether the class is public.
        2. Get all constructors declared in class.
        3. Get the signature of constructor.
        4. Check whether the constructor is private.
        5. Check whether the class has any non-private constructors.
        If the class is public and all its constructors are private, then the class may be made final because it cannot be extended from outside its compilation unit. In this test case, since the class is public and the constructor is private, and there are no non-private constructors, the class violates the rule.
            
['Check whether the class is public.', 'Get all constructors declared in class.', 'Get the signature of constructor.', 'Check whether the constructor is private.', 'Check whether the class has any non-private constructors.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828827381134033
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has any non-private constructors.* 匹配到的元操作或API：
logic: Check whether the class has any non-private constructors.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8846951127052307
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Simple violation
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isPublic() && node.getAllConstructors().allMatch(ASTConstructorDeclaration::isPrivate)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Check whether the class has declared constructors.
        2. Get the number of declared constructors.
        3. Iterate through each constructor.
        4. Check whether the constructor is private.
        5. Check whether the class is public.
        6. Check whether the class has non-private constructors.
        7. Check whether the class is final.

For the provided test case, the checks would be:

1. Check whether the class has declared constructors.
        2. Get the number of declared constructors. (Result: 1)
        3. Iterate through each constructor.
        4. Check whether the constructor is private. (Result: true)
        5. Check whether the class is public. (Result: true)
        6. Check whether the class has non-private constructors. (Result: false)
        7. Check whether the class is final. (Result: false)

Since the class is public, has only private constructors, and is not final, it violates the rule. The number of violating the rule in this test case is: 1.
['Check whether the class has declared constructors.', 'Get the number of declared constructors.', 'Iterate through each constructor.', 'Check whether the constructor is private.', 'Check whether the class is public.', 'Check whether the class has non-private constructors.', 'Check whether the class is final.', 'Check whether the class has declared constructors.', 'Get the number of declared constructors. (Result: 1)', 'Iterate through each constructor.', 'Check whether the constructor is private. (Result: true)', 'Check whether the class is public. (Result: true)', 'Check whether the class has non-private constructors. (Result: false)', 'Check whether the class is final. (Result: false)']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Check whether the class has declared constructors.* 匹配到的元操作或API：
logic: Check whether the class has declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.8875755667686462
*Get the number of declared constructors.* 匹配到的元操作或API：
query: Get the number of declared constructors.
most similar API: get num children of constructor
cosine Similarity: 0.8233407735824585
*Iterate through each constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class has non-private constructors.* 匹配到的元操作或API：
logic: Check whether the class has non-private constructors.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8880446553230286
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class has declared constructors.* 匹配到的元操作或API：
logic: Check whether the class has declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.8875755667686462
*Get the number of declared constructors. (Result: 1)* 匹配到的元操作或API：
query: Get the number of declared constructors. (Result: 1)
most similar API: get num children of constructor
cosine Similarity: 0.813753604888916
*Iterate through each constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private. (Result: true)* 匹配到的元操作或API：
logic: Check whether the constructor is private. (Result: true)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.97220778465271
*Check whether the class is public. (Result: true)* 匹配到的元操作或API：
logic: Check whether the class is public. (Result: true)
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9620252847671509
*Check whether the class has non-private constructors. (Result: false)* 匹配到的元操作或API：
logic: Check whether the class has non-private constructors. (Result: false)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8830259442329407
*Check whether the class is final. (Result: false)* 匹配到的元操作或API：
logic: Check whether the class is final. (Result: false)
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9640668630599976
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Simple violation
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public int getNumChildren()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()

1.  //Check whether constructor has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTConstructorDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isPublic() && !node.isFinal()) {
            boolean allConstructorsPrivate = node.children(ASTConstructorDeclaration.class)
                    .allMatch(constructor -> constructor.isPrivate() && !hasAnnotation(constructor));
            if (allConstructorsPrivate) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Check whether constructor has declared annotations
    public boolean hasAnnotation(ASTConstructorDeclaration node) {
        NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
        return declaredAnnotations.nonEmpty();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Check whether the class is public.
        2. Get all constructors declared in class.
        3. Get the signature of constructor.
        4. Check whether the constructor is private.
        5. Check whether there are any other constructors.
        6. If there are no other constructors, check whether there are any methods that can be overridden.
        7. Check whether any non-private fields exist.
        If the class is public and all its constructors are private and there are no other constructors and no non-private methods that can be overridden and no non-private fields, then this test case violates the rule.
        
In the given test case:
1. Check whether the class is public.
        The class `Foo` is public.
2. Get all constructors declared in class.
        There is one constructor declared in class `Foo`.
3. Get the signature of constructor.
        The constructor signature is `private Foo() { }`.
4. Check whether the constructor is private.
        The constructor is private.
5. Check whether there are any other constructors.
        There are no other constructors.
6. If there are no other constructors, check whether there are any methods that can be overridden.
        There are no methods declared in class `Foo`, so there are no methods that can be overridden.
7. Check whether any non-private fields exist.
        There are no fields declared in class `Foo`.

Since class `Foo` is public, has only one private constructor, and no other constructors, methods, or non-private fields, it violates the rule.
['Check whether the class is public.', 'Get all constructors declared in class.', 'Get the signature of constructor.', 'Check whether the constructor is private.', 'Check whether there are any other constructors.', 'If there are no other constructors, check whether there are any methods that can be overridden.', 'Check whether any non-private fields exist.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Get the signature of constructor.', 'Check whether the constructor is private.', 'Check whether there are any other constructors.', 'If there are no other constructors, check whether there are any methods that can be overridden.', 'Check whether any non-private fields exist.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828827381134033
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether there are any other constructors.* 匹配到的元操作或API：
query: Check whether there are any other constructors.
most similar API: Check whether the constructor equals
cosine Similarity: 0.8388510942459106
*If there are no other constructors, check whether there are any methods that can be overridden.* 匹配到的元操作或API：
logic: If there are no other constructors, check whether there are any methods that can be overridden.
most similar meta operation: Check whether the method is overridden
cosine Similarity: 0.8616748452186584
*Check whether any non-private fields exist.* 匹配到的元操作或API：
logic: Check whether any non-private fields exist.
most similar meta operation: Check whether the field is private
cosine Similarity: 0.868948757648468
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828827381134033
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether there are any other constructors.* 匹配到的元操作或API：
query: Check whether there are any other constructors.
most similar API: Check whether the constructor equals
cosine Similarity: 0.8388510942459106
*If there are no other constructors, check whether there are any methods that can be overridden.* 匹配到的元操作或API：
logic: If there are no other constructors, check whether there are any methods that can be overridden.
most similar meta operation: Check whether the method is overridden
cosine Similarity: 0.8616748452186584
*Check whether any non-private fields exist.* 匹配到的元操作或API：
logic: Check whether any non-private fields exist.
most similar meta operation: Check whether the field is private
cosine Similarity: 0.868948757648468
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Simple violation
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean equals(java.lang.Object)
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isOverridden()
7. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isPrivate()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isPublic()) {
            NodeStream<ASTConstructorDeclaration> constructors = node.children(ASTConstructorDeclaration.class);
            if (constructors.isNotEmpty() && constructors.allMatch(ASTConstructorDeclaration::isPrivate)) {
                if (!node.isFinal()) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class is public.
3. Get the constructors declared in class.
4. Get the number of constructors declared in class.
5. Check whether the constructor is private.
6. Check whether the constructor is static.
7. Check whether the class has declared annotations.
8. Get the declared annotations of class.
9. Check whether the class has extended any class.
10. Get the super class of class.
11. Check whether the class has implemented any interfaces.
12. Get a implemented interface of class.

For the provided test case:
1. Get the name of class: Foo
2. Check whether the class is public: True
3. Get the constructors declared in class: private Foo()
4. Get the number of constructors declared in class: 1
5. Check whether the constructor is private: True (since the constructor private Foo() is private)
6. Check whether the constructor is static: False (since the constructor private Foo() is not static)
7. Check whether the class has declared annotations: False (since there are no annotations in the class declaration)
8. Get the declared annotations of class: Not applicable (since there are no annotations)
9. Check whether the class has extended any class: False (since no super class is specified, it implicitly extends Object)
10. Get the super class of class: Object (since no super class is specified, it implicitly extends Object)
11. Check whether the class has implemented any interfaces: False (since no interfaces are implemented)
12. Get a implemented interface of class: Not applicable (since no interfaces are implemented)

Since the class is public and all its constructors are private, this test case violates the rule. The number of violating the rule in this test case is: 1.
['Get the name of class.', 'Check whether the class is public.', 'Get the constructors declared in class.', 'Get the number of constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the constructor is static.', 'Check whether the class has declared annotations.', 'Get the declared annotations of class.', 'Check whether the class has extended any class.', 'Get the super class of class.', 'Check whether the class has implemented any interfaces.', 'Get a implemented interface of class.', 'Get the name of class: Foo', 'Check whether the class is public: True', 'Get the constructors declared in class: private Foo()', 'Get the number of constructors declared in class: 1', 'Check whether the constructor is private: True (since the constructor private Foo() is private)', 'Check whether the constructor is static: False (since the constructor private Foo() is not static)', 'Check whether the class has declared annotations: False (since there are no annotations in the class declaration)', 'Get the declared annotations of class: Not applicable (since there are no annotations)', 'Check whether the class has extended any class: False (since no super class is specified, it implicitly extends Object)', 'Get the super class of class: Object (since no super class is specified, it implicitly extends Object)', 'Check whether the class has implemented any interfaces: False (since no interfaces are implemented)', 'Get a implemented interface of class: Not applicable (since no interfaces are implemented)']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get the constructors declared in class.* 匹配到的元操作或API：
query: Get the constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8616834878921509
*Get the number of constructors declared in class.* 匹配到的元操作或API：
query: Get the number of constructors declared in class.
most similar API: get num children of constructor
cosine Similarity: 0.8205664157867432
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the constructor is static.* 匹配到的元操作或API：
logic: Check whether the constructor is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9065665602684021
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the declared annotations of class.* 匹配到的元操作或API：
logic: Get the declared annotations of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9313310384750366
*Check whether the class has extended any class.* 匹配到的元操作或API：
logic: Check whether the class has extended any class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.899549126625061
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class has implemented any interfaces.* 匹配到的元操作或API：
logic: Check whether the class has implemented any interfaces.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.8998100161552429
*Get a implemented interface of class.* 匹配到的元操作或API：
logic: Get a implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9851537942886353
*Get the name of class: Foo* 匹配到的元操作或API：
logic: Get the name of class: Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9263077974319458
*Check whether the class is public: True* 匹配到的元操作或API：
logic: Check whether the class is public: True
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9707064628601074
*Get the constructors declared in class: private Foo()* 匹配到的元操作或API：
query: Get the constructors declared in class: private Foo()
most similar API: get declared annotations of constructor
cosine Similarity: 0.8462480902671814
*Get the number of constructors declared in class: 1* 匹配到的元操作或API：
query: Get the number of constructors declared in class: 1
most similar API: get num children of constructor
cosine Similarity: 0.8299345970153809
*Check whether the constructor is private: True (since the constructor private Foo() is private)* 匹配到的元操作或API：
logic: Check whether the constructor is private: True (since the constructor private Foo() is private)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9352457523345947
*Check whether the constructor is static: False (since the constructor private Foo() is not static)* 匹配到的元操作或API：
query: Check whether the constructor is static: False (since the constructor private Foo() is not static)
most similar API: Check whether the constructor is static
cosine Similarity: 0.9133907556533813
*Check whether the class has declared annotations: False (since there are no annotations in the class declaration)* 匹配到的元操作或API：
logic: Check whether the class has declared annotations: False (since there are no annotations in the class declaration)
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9283750057220459
*Get the declared annotations of class: Not applicable (since there are no annotations)* 匹配到的元操作或API：
logic: Get the declared annotations of class: Not applicable (since there are no annotations)
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.8563657999038696
*Check whether the class has extended any class: False (since no super class is specified, it implicitly extends Object)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the super class of class: Object (since no super class is specified, it implicitly extends Object)* 匹配到的元操作或API：
logic: Get the super class of class: Object (since no super class is specified, it implicitly extends Object)
most similar meta operation: Get the super class of class
cosine Similarity: 0.8658086657524109
*Check whether the class has implemented any interfaces: False (since no interfaces are implemented)* 匹配到的元操作或API：
logic: Check whether the class has implemented any interfaces: False (since no interfaces are implemented)
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.8683105111122131
*Get a implemented interface of class: Not applicable (since no interfaces are implemented)* 匹配到的元操作或API：
logic: Get a implemented interface of class: Not applicable (since no interfaces are implemented)
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9035525918006897
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Simple violation
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public int getNumChildren()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getSuperInterfaceTypeNodes()
10. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isStatic()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```
3.  //Check whether the class has implemented x interface
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node) {
    if (TypeTestUtil.isA(interfaceName.class, node)) {
        return true;
    }
    return false;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {

    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isPublic() && !node.isStatic() && !hasAnnotations(node)) {
            NodeStream<ASTConstructorDeclaration> constructors = node.children(ASTConstructorDeclaration.class);
            if (constructors.nonEmpty() && constructors.allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Check whether class has declared annotations
    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }

    // Check whether the class has extended a specific class
    public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node, Class<?> x) {
        ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
        return TypeTestUtil.isA(x, classOrInterfaceType);
    }

    // Check whether the class has implemented a specific interface
    public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node, Class<?> interfaceName) {
        return TypeTestUtil.isA(interfaceName, node);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class is public.
3. Get the signature of constructor.
4. Check whether the constructor is private.
5. Check whether the class has other declared constructors.
6. Check whether the class has any subclasses.
If the class is public, has a private constructor, no other declared constructors, and no subclasses, then this test case violates the rule. 

Based on the provided test case, here is the granular check:

1. Get the name of class.
   - The name of the class is `Foo`.
2. Check whether the class is public.
   - The class `Foo` is public.
3. Get the signature of constructor.
   - The constructor of `Foo` has the signature `private Foo()`.
4. Check whether the constructor is private.
   - The constructor `Foo()` is private.
5. Check whether the class has other declared constructors.
   - The class `Foo` does not have any other declared constructors.
6. Check whether the class has any subclasses.
   - The class `Foo` does not have any subclasses.

Since all these conditions are met, the provided test case violates the rule.
['Get the name of class.', 'Check whether the class is public.', 'Get the signature of constructor.', 'Check whether the constructor is private.', 'Check whether the class has other declared constructors.', 'Check whether the class has any subclasses.', 'Get the name of class.', 'Check whether the class is public.', 'Get the signature of constructor.', 'Check whether the constructor is private.', 'Check whether the class has other declared constructors.', 'Check whether the class has any subclasses.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828827381134033
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has other declared constructors.* 匹配到的元操作或API：
logic: Check whether the class has other declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.8618874549865723
*Check whether the class has any subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828827381134033
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has other declared constructors.* 匹配到的元操作或API：
logic: Check whether the class has other declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.8618874549865723
*Check whether the class has any subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Simple violation
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()

1.  //Check whether constructor has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTConstructorDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isPublic()) {
            boolean hasOnlyPrivateConstructors = true;
            boolean hasAnyConstructor = false;

            for (ASTConstructorDeclaration constructor : node.children(ASTConstructorDeclaration.class)) {
                hasAnyConstructor = true;
                if (!constructor.isPrivate()) {
                    hasOnlyPrivateConstructors = false;
                    break;
                }
            }

            if (hasAnyConstructor && hasOnlyPrivateConstructors && !node.isFinal()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Check whether constructor has declared annotations
    public boolean hasAnnotation(ASTConstructorDeclaration node) {
        NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
        return declaredAnnotations.nonEmpty();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 1
1117
839
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
        2. Check whether the class is abstract.
        3. Get all constructors declared in class.
        4. Check whether the constructor is private.
        If the class is not abstract and all its constructors are private, the class may be made final because it cannot be extended from outside its compilation unit. However, since the class is abstract, it is a violation for abstract class as per the provided test case description.
        
Given the description "bad 2" and the number of violations "1", it seems there might be a misunderstanding. The rule specifically targets non-abstract classes with private constructors. Since the provided test case is an abstract class, it does not violate the rule as described. If you intended to check for abstract classes with private constructors, the rule should be adjusted accordingly.

For the given test case, the checks align with the rule description, but the test case itself does not violate the rule:

1. Get the name of class.
        2. Check whether the class is abstract.
        3. Get all constructors declared in class.
        4. Check whether the constructor is private.

Since the class is abstract, this test case does not violate the provided rule description. If you want to check for a violation in a non-abstract class, the test case should be:

```java
public class Foo {
    private Foo() { }
}
```

For this adjusted test case:

1. Get the name of class.
        2. Check whether the class is abstract.
        3. Get all constructors declared in class.
        4. Check whether the constructor is private.
        5. Check whether the class has any subclasses outside its compilation unit.

If the class is not abstract and all its constructors are private, it violates the rule. However, since we cannot check for subclasses outside the compilation unit directly, we assume the rule is focused on the presence of private constructors in a non-abstract class.
['Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has any subclasses outside its compilation unit.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has any subclasses outside its compilation unit.* 匹配到的元操作或API：
query: Check whether the class has any subclasses outside its compilation unit.
most similar API: Check whether the compilation unit has descendant of type
cosine Similarity: 0.8128633499145508
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// violation for abstract class
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean hasDescendantOfType(java.lang.Class)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isAbstract()) {
            return data;
        }
        boolean hasPrivateConstructor = false;
        boolean hasNonPrivateConstructor = false;
        for (ASTConstructorDeclaration constructor : node.getDeclaredConstructors()) {
            if (constructor.isPrivate()) {
                hasPrivateConstructor = true;
            } else {
                hasNonPrivateConstructor = true;
            }
        }
        if (hasPrivateConstructor && !hasNonPrivateConstructor && !node.hasDescendantOfType(ASTClassOrInterfaceDeclaration.class)) {
            addViolation(data, node);
        }
        return data;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class is abstract.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Check whether the class is public.
6. Check whether the class is package-private (default access).

To ascertain adherence to the rule:

1. Get the name of class.
2. Check whether the class is abstract.
   - **Result**: The class `Foo` is not abstract.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
   - **Result**: The constructor of `Foo` is private.
5. Check whether the class is public.
   - **Result**: The class `Foo` is public.
6. Check whether the class is package-private (default access).
   - **Result**: The class `Foo` is not package-private.

Given the rule description, the class should be final because all its constructors are private, preventing extension from outside its compilation unit. However, the test case provided is specifically for a public abstract class with a private constructor, which does not violate the rule as stated because the class is abstract (and abstract classes are not meant to be final).

If the intention is to check for a non-abstract class with a private constructor:

1. Get the name of class.
2. Check whether the class is abstract.
   - **Result**: The class `Foo` is not abstract.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
   - **Result**: The constructor of `Foo` is private.
5. Check whether the class is public.
   - **Result**: The class `Foo` is public.
6. Check whether the class is package-private (default access).
   - **Result**: The class `Foo` is not package-private.

Since the class is public and non-abstract with a private constructor, it should be made final. Therefore, the provided test case does not violate the rule as it is abstract. However, if the class were non-abstract, it would violate the rule.

To clarify, here is the granular check for a non-abstract class:

1. Get the name of class.
2. Check whether the class is abstract.
   - **Result**: The class `Foo` is not abstract.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
   - **Result**: The constructor of `Foo` is private.
5. Check whether the class is public.
   - **Result**: The class `Foo` is public.
6. Check whether the class is package-private (default access).
   - **Result**: The class `Foo` is not package-private.
7. Check whether the class is final.
   - **Result**: The class `Foo` is not final.

If the class is public, non-abstract, has private constructors, and is not final, it violates the rule. In this specific test case, the class is abstract, so it does not violate the rule.
['Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is public.', 'Check whether the class is package-private (default access).', 'Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is public.', 'Check whether the class is package-private (default access).', 'Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is public.', 'Check whether the class is package-private (default access).', 'Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is public.', 'Check whether the class is package-private (default access).', 'Check whether the class is final.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is package-private (default access).* 匹配到的元操作或API：
logic: Check whether the class is package-private (default access).
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9266817569732666
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is package-private (default access).* 匹配到的元操作或API：
logic: Check whether the class is package-private (default access).
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9266817569732666
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is package-private (default access).* 匹配到的元操作或API：
logic: Check whether the class is package-private (default access).
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9266817569732666
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is package-private (default access).* 匹配到的元操作或API：
logic: Check whether the class is package-private (default access).
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9266817569732666
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// violation for abstract class
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isAbstract() && node.isPublic() && !node.isFinal()) {
            NodeStream<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class);
            if (constructors.allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Check whether the class is abstract.
        2. Check whether class has declared constructors.
        3. Get the signature of constructor.
        4. Check whether the constructor is private.
        5. Check whether there are any other constructors.
        6. Check whether the class is accessible outside its compilation unit (default package-private, public, protected).
        If the class is not abstract, has at least one private constructor, no other constructors, and the class is accessible outside its compilation unit, then this test case violates the rule. However, since the description mentions this as a violation for an abstract class, we need to explicitly check for that:

1. Check whether the class is abstract.
        2. Check whether class has declared constructors.
        3. Get the signature of constructor.
        4. Check whether the constructor is private.
        5. Check whether there are any other constructors.
        6. If the class is abstract and has at least one private constructor with no other constructors, then this test case violates the rule.
        
Given the provided test case, these steps would be:

1. Check whether the class is abstract.
        2. Check whether class has declared constructors.
        3. Get the signature of constructor.
        4. Check whether the constructor is private.
        5. Check whether there are any other constructors.
        6. Check whether the class is accessible outside its compilation unit (default package-private, public, protected).

In this specific test case:

1. Check whether the class is abstract.
        Result: The class `Foo` is not abstract.

Since the class is not abstract, the rule as described does not apply directly to this class. However, if we consider the test case to be a violation for an abstract class, we should add an abstract modifier to the class:

```java
public abstract class Foo {
    private Foo() { }
}
```

Then, the steps to check for adherence to the rule would be:

1. Check whether the class is abstract.
        Result: The class `Foo` is abstract.
2. Check whether class has declared constructors.
        Result: The class `Foo` has a declared constructor.
3. Get the signature of constructor.
4. Check whether the constructor is private.
        Result: The constructor is private.
5. Check whether there are any other constructors.
        Result: There are no other constructors.
6. Check whether the class is accessible outside its compilation unit (default package-private, public, protected).
        Result: The class `Foo` is public, thus accessible outside its compilation unit.

Since the class is abstract and has only one private constructor, this test case violates the rule.
['Check whether the class is abstract.', 'Check whether class has declared constructors.', 'Get the signature of constructor.', 'Check whether the constructor is private.', 'Check whether there are any other constructors.', 'Check whether the class is accessible outside its compilation unit (default package-private, public, protected).', 'Check whether the class is abstract.', 'Check whether class has declared constructors.', 'Get the signature of constructor.', 'Check whether the constructor is private.', 'Check whether there are any other constructors.', 'If the class is abstract and has at least one private constructor with no other constructors, then this test case violates the rule.', 'Check whether the class is abstract.', 'Check whether class has declared constructors.', 'Get the signature of constructor.', 'Check whether the constructor is private.', 'Check whether there are any other constructors.', 'Check whether the class is accessible outside its compilation unit (default package-private, public, protected).', 'Check whether the class is abstract.', 'Check whether the class is abstract.', 'Check whether class has declared constructors.', 'Get the signature of constructor.', 'Check whether the constructor is private.', 'Check whether there are any other constructors.', 'Check whether the class is accessible outside its compilation unit (default package-private, public, protected).']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether class has declared constructors.* 匹配到的元操作或API：
logic: Check whether class has declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.8889979124069214
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828827381134033
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether there are any other constructors.* 匹配到的元操作或API：
query: Check whether there are any other constructors.
most similar API: Check whether the constructor equals
cosine Similarity: 0.8388510942459106
*Check whether the class is accessible outside its compilation unit (default package-private, public, protected).* 匹配到的元操作或API：
logic: Check whether the class is accessible outside its compilation unit (default package-private, public, protected).
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.8511422276496887
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether class has declared constructors.* 匹配到的元操作或API：
logic: Check whether class has declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.8889979124069214
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828827381134033
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether there are any other constructors.* 匹配到的元操作或API：
query: Check whether there are any other constructors.
most similar API: Check whether the constructor equals
cosine Similarity: 0.8388510942459106
*If the class is abstract and has at least one private constructor with no other constructors, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether class has declared constructors.* 匹配到的元操作或API：
logic: Check whether class has declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.8889979124069214
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828827381134033
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether there are any other constructors.* 匹配到的元操作或API：
query: Check whether there are any other constructors.
most similar API: Check whether the constructor equals
cosine Similarity: 0.8388510942459106
*Check whether the class is accessible outside its compilation unit (default package-private, public, protected).* 匹配到的元操作或API：
logic: Check whether the class is accessible outside its compilation unit (default package-private, public, protected).
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.8511422276496887
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether class has declared constructors.* 匹配到的元操作或API：
logic: Check whether class has declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.8889979124069214
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828827381134033
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether there are any other constructors.* 匹配到的元操作或API：
query: Check whether there are any other constructors.
most similar API: Check whether the constructor equals
cosine Similarity: 0.8388510942459106
*Check whether the class is accessible outside its compilation unit (default package-private, public, protected).* 匹配到的元操作或API：
logic: Check whether the class is accessible outside its compilation unit (default package-private, public, protected).
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.8511422276496887
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// violation for abstract class
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean equals(java.lang.Object)
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()

1.  //Check whether constructor has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTConstructorDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isAbstract() && !node.isPackagePrivate()) {
            NodeStream<ASTConstructorDeclaration> constructors = node.children(ASTConstructorDeclaration.class);
            if (constructors.nonEmpty() && constructors.all(ASTConstructorDeclaration::isPrivate)) {
                // Ensure there are no declared annotations on any constructor
                if (constructors.noneMatch(this::hasAnnotation)) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }

    // Check whether constructor has declared annotations
    public boolean hasAnnotation(ASTConstructorDeclaration node) {
        NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
        return declaredAnnotations.nonEmpty();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class is abstract.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Count the number of private constructors.
6. Check whether the class is made final.
7. Get the name of the package where the class is located.
8. Check whether the class is accessible outside its compilation unit.

Let's perform the checks:

1. Get the name of class.
   - The name of the class is `Foo`.

2. Check whether the class is abstract.
   - The class is not abstract.

3. Get all constructors declared in class.
   - There is one constructor declared in the class.

4. Check whether the constructor is private.
   - The constructor is private.

5. Count the number of private constructors.
   - There is one private constructor.

6. Check whether the class is made final.
   - The class is not final.

7. Get the name of the package where the class is located.
   - The package name is not specified in the code snippet, so we assume it's in the default package.

8. Check whether the class is accessible outside its compilation unit.
   - Since the class is public and in the default package, it is accessible outside its compilation unit.

Given the description and the checks:

- The class `Foo` has a private constructor, which means it cannot be extended from outside its compilation unit.
- However, the class is not marked as final.
- The class is public and therefore accessible outside its compilation unit, but the constructor being private prevents it from being extended.

The description "bad 2" seems to be incorrect because the class is not abstract. The correct description based on the provided rule and test case would be:

The description of this test case is: violation for class with private constructor.
The number of violating the rule in this test case is: 1

If the intention is to report violations for abstract classes with private constructors that are not marked as final, the test case provided does not fit that description. If you intended to provide a test case for an abstract class with a private constructor, it should look something like this:

```java
// violation for abstract class
public abstract class Foo {
    private Foo() { }
}
```

For the provided test case, the correct checks and description would be:

1. Get the name of class.
   - The name of the class is `Foo`.

2. Check whether the class is abstract.
   - The class is not abstract.

3. Get all constructors declared in class.
   - There is one constructor declared in the class.

4. Check whether the constructor is private.
   - The constructor is private.

5. Count the number of private constructors.
   - There is one private constructor.

6. Check whether the class is made final.
   - The class is not final.

7. Get the name of the package where the class is located.
   - The package name is not specified in the code snippet, so we assume it's in the default package.

8. Check whether the class is accessible outside its compilation unit.
   - Since the class is public and in the default package, it is accessible outside its compilation unit.

The description should be:

The description of this test case is: violation for class with private constructor.
The number of violating the rule in this test case is: 1

However, since the class is not abstract, the correct number of violations based on the rule provided is 0 if we strictly adhere to the rule's requirement for abstract classes. If the rule should apply to any class with a private constructor (not just abstract classes), then the description and number of violations would be as above.
['Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Count the number of private constructors.', 'Check whether the class is made final.', 'Get the name of the package where the class is located.', 'Check whether the class is accessible outside its compilation unit.', 'Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Count the number of private constructors.', 'Check whether the class is made final.', 'Get the name of the package where the class is located.', 'Check whether the class is accessible outside its compilation unit.', 'Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Count the number of private constructors.', 'Check whether the class is made final.', 'Get the name of the package where the class is located.', 'Check whether the class is accessible outside its compilation unit.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Count the number of private constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is made final.* 匹配到的元操作或API：
logic: Check whether the class is made final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9664245247840881
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is accessible outside its compilation unit.* 匹配到的元操作或API：
query: Check whether the class is accessible outside its compilation unit.
most similar API: Check whether the compilation unit is find boundary
cosine Similarity: 0.8167688250541687
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Count the number of private constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is made final.* 匹配到的元操作或API：
logic: Check whether the class is made final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9664245247840881
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is accessible outside its compilation unit.* 匹配到的元操作或API：
query: Check whether the class is accessible outside its compilation unit.
most similar API: Check whether the compilation unit is find boundary
cosine Similarity: 0.8167688250541687
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Count the number of private constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is made final.* 匹配到的元操作或API：
logic: Check whether the class is made final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9664245247840881
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is accessible outside its compilation unit.* 匹配到的元操作或API：
query: Check whether the class is accessible outside its compilation unit.
most similar API: Check whether the compilation unit is find boundary
cosine Similarity: 0.8167688250541687
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// violation for abstract class
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
7. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean isFindBoundary()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class, ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isAbstract() || node.isFinal()) {
            return super.visit(node, data);
        }
        NodeStream<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class);
        if (constructors.noneMatch(c -> !c.isPrivate())) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
To ascertain whether the provided test case adheres to the rule, we need to perform the following granular checks:

1. Get the name of class.
2. Check whether the class is abstract.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Check whether the class is final.
6. Check whether the class is accessible outside its compilation unit.

Based on the provided test case:

1. Get the name of class.
        - The class name is `Foo`.

2. Check whether the class is abstract.
        - The class is not declared as abstract.

3. Get all constructors declared in class.
        - There is one constructor declared in the class `Foo`.

4. Check whether the constructor is private.
        - The constructor of `Foo` is private.

5. Check whether the class is final.
        - The class is not declared as final.

6. Check whether the class is accessible outside its compilation unit.
        - The class is declared as `public`, so it can be accessed outside its compilation unit.

Since the class is public and all its constructors are private, it cannot be extended from outside its compilation unit. Therefore, this class should be made final according to the rule. The test case does violate the rule because the class is public, has a private constructor, and is not declared as final.

The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

These checks confirm that the test case violates the rule as described.
['Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is final.', 'Check whether the class is accessible outside its compilation unit.', 'Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is final.', 'Check whether the class is accessible outside its compilation unit.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is accessible outside its compilation unit.* 匹配到的元操作或API：
query: Check whether the class is accessible outside its compilation unit.
most similar API: Check whether the compilation unit is find boundary
cosine Similarity: 0.8167688250541687
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is accessible outside its compilation unit.* 匹配到的元操作或API：
query: Check whether the class is accessible outside its compilation unit.
most similar API: Check whether the compilation unit is find boundary
cosine Similarity: 0.8167688250541687
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// violation for abstract class
public class Foo {
    private Foo() { }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
6. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean isFindBoundary()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        boolean hasOnlyPrivateConstructors = node.descendants(ASTConstructorDeclaration.class)
                .allMatch(ASTConstructorDeclaration::isPrivate);

        boolean hasNoPublicOrProtectedConstructors = node.descendants(ASTConstructorDeclaration.class)
                .noneMatch(c -> !c.isPrivate());

        if (hasOnlyPrivateConstructors && hasNoPublicOrProtectedConstructors && !node.isFinal() && !node.isAbstract()) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 2
1484
1157
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether class is inner class.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Check whether the class has declared annotations.
6. Get the javadoc comment of class.
7. Check whether the class is abstract.
8. Check whether the class is public.
9. Check whether the class is final.
10. Get the number of constructors of the class.
11. Check whether all constructors are private.

Based on the test case:
- The class name is `Main209`.
- It contains an inner class `InputBits`.
- `InputBits` has only one constructor, which is private.
- `InputBits` is not declared with any annotations.
- `InputBits` does not have a javadoc comment.
- `InputBits` is not abstract.
- `InputBits` is default package-private (not public).
- `InputBits` is not final.
- `InputBits` has one constructor, and it is private.

Since `InputBits` is an inner class with only private constructors and it is not final, it violates the rule that classes with only private constructors should be made final.
['Get the name of class.', 'Check whether class is inner class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has declared annotations.', 'Get the javadoc comment of class.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is final.', 'Get the number of constructors of the class.', 'Check whether all constructors are private.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether class is inner class.* 匹配到的元操作或API：
logic: Check whether class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9852281212806702
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get the number of constructors of the class.* 匹配到的元操作或API：
query: Get the number of constructors of the class.
most similar API: get num children of constructor
cosine Similarity: 0.8342469334602356
*Check whether all constructors are private.* 匹配到的元操作或API：
logic: Check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.936521589756012
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// #2536 [java] ClassWithOnlyPrivateConstructorsShouldBeFinal can't detect inner class with only private constructor
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
9. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public int getNumChildren()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal() && !node.isAbstract() && !node.isPublic() && !hasAnnotations(node)) {
            NodeStream<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class);
            if (constructors.allMatch(ASTConstructorDeclaration::isPrivate) && !constructors.isEmpty()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Check whether class has declared annotations
    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Get the class that method located in.
3. Check whether the class is inner class.
4. Check whether the inner class is static.
5. Get all constructors declared in the class.
6. Check whether the constructor is private.
7. Check whether the class is final.
8. Get the name of the package where the class is located.
9. Get the name of the package where the constructor is located.
10. Check whether the package name of the class is the same as the package name of the constructor.
11. Check whether the class has extended any x class.
12. Check whether the class has implemented any x interface.
13. Check whether the class can be extended from outside their compilation unit.

In this test case:
- The class `InputBits` is an inner class (Check whether the class is inner class).
- It is static (Check whether the inner class is static).
- It has only one constructor, which is private (Get all constructors declared in the class and Check whether the constructor is private).
- The class `InputBits` is not final (Check whether the class is final).
- Both the class and the constructor are located in the same package `Main209` (Get the name of the package where the class is located and Get the name of the package where the constructor is located).
- The class does not have any super class (Check whether the class has extended any x class).
- The class does not implement any interface (Check whether the class has implemented any x interface).
- Since all constructors are private, the class cannot be extended from outside its compilation unit (Check whether the class can be extended from outside their compilation unit).

This test case violates the rule because the class `InputBits` cannot be extended from outside its compilation unit due to its private constructor and is not declared as final.
['Get the name of class.', 'Get the class that method located in.', 'Check whether the class is inner class.', 'Check whether the inner class is static.', 'Get all constructors declared in the class.', 'Check whether the constructor is private.', 'Check whether the class is final.', 'Get the name of the package where the class is located.', 'Get the name of the package where the constructor is located.', 'Check whether the package name of the class is the same as the package name of the constructor.', 'Check whether the class has extended any x class.', 'Check whether the class has implemented any x interface.', 'Check whether the class can be extended from outside their compilation unit.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the class that method located in.* 匹配到的元操作或API：
logic: Get the class that method located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9805244207382202
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.987544596195221
*Check whether the inner class is static.* 匹配到的元操作或API：
logic: Check whether the inner class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9092438220977783
*Get all constructors declared in the class.* 匹配到的元操作或API：
query: Get all constructors declared in the class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8338632583618164
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Get the name of the package where the constructor is located.* 匹配到的元操作或API：
logic: Get the name of the package where the constructor is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9060468673706055
*Check whether the package name of the class is the same as the package name of the constructor.* 匹配到的元操作或API：
query: Check whether the package name of the class is the same as the package name of the constructor.
most similar API: Check whether the constructor equals
cosine Similarity: 0.8237757086753845
*Check whether the class has extended any x class.* 匹配到的元操作或API：
logic: Check whether the class has extended any x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9576523303985596
*Check whether the class has implemented any x interface.* 匹配到的元操作或API：
logic: Check whether the class has implemented any x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9741286039352417
*Check whether the class can be extended from outside their compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// #2536 [java] ClassWithOnlyPrivateConstructorsShouldBeFinal can't detect inner class with only private constructor
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
9. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean equals(java.lang.Object)

1.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```
2.  //Check whether the class has implemented x interface
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node) {
    if (TypeTestUtil.isA(interfaceName.class, node)) {
        return true;
    }
    return false;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }
    
    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && node.isStatic() && !node.isFinal() && node.getConstructors().allMatch(ASTConstructorDeclaration::isPrivate)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    // Check whether the class has extended x class
    public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node) {
        ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
        return TypeTestUtil.isA(x.class, classOrInterfaceType);
    }

    // Check whether the class has implemented x interface
    public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node) {
        if (TypeTestUtil.isA(interfaceName.class, node)) {
            return true;
        }
        return false;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
To check the adherence of the provided test case to the rule, we need to perform the following granular checks:

1. Get the name of class.
2. Check whether the class is an inner class.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Check whether the class is final.

Let's go through these checks for the test case:

1. Get the name of class.
   - The class name is `Main209`.

2. Check whether the class is an inner class.
   - `Main209` is not an inner class; it's a top-level class.

3. Get all constructors declared in class.
   - `Main209` does not have any constructors declared in its body.

4. Get all constructors declared in class InputBits.
   - `InputBits` has one constructor declared: `private InputBits(int number) { }`.

5. Check whether the constructor is private.
   - The constructor of `InputBits` is private.

6. Check whether the class InputBits is final.
   - The class `InputBits` is not final.

Since `InputBits` is an inner class with only private constructors and it is not final, it violates the rule. The top-level class `Main209` is not relevant to this specific rule check.

So, the test case includes one class (`InputBits`) that violates the rule.
['Get the name of class.', 'Check whether the class is an inner class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is final.', 'Get the name of class.', 'Check whether the class is an inner class.', 'Get all constructors declared in class.', 'Get all constructors declared in class InputBits.', 'Check whether the constructor is private.', 'Check whether the class InputBits is final.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Get all constructors declared in class InputBits.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class InputBits is final.* 匹配到的元操作或API：
logic: Check whether the class InputBits is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.8814274668693542
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// #2536 [java] ClassWithOnlyPrivateConstructorsShouldBeFinal can't detect inner class with only private constructor
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isFinal() && node.isNested()) {
            boolean hasOnlyPrivateConstructors = node.children(ASTConstructorDeclaration.class)
                .allMatch(ASTConstructorDeclaration::isPrivate);
            if (hasOnlyPrivateConstructors) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
        2. Check whether the class is an inner class.
        3. Get all constructors declared in class.
        4. Check whether all constructors are private.
        5. Check whether the class is final.
        If the class is an inner class, all its constructors are private, and the class is not final, then this test case violates the rule.
['Get the name of class.', 'Check whether the class is an inner class.', 'Get all constructors declared in class.', 'Check whether all constructors are private.', 'Check whether the class is final.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether all constructors are private.* 匹配到的元操作或API：
logic: Check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.936521589756012
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// #2536 [java] ClassWithOnlyPrivateConstructorsShouldBeFinal can't detect inner class with only private constructor
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isFinal() && node.isNested() && node.children(ASTConstructorDeclaration.class).allMatch(ASTConstructorDeclaration::isPrivate)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
        2. Check whether the class is inner class.
        3. Get the signature of all constructors in class.
        4. Check whether the constructor is private.
        5. Get all constructors declared in class.
        6. Check whether all constructors are private.
        7. Check whether the class is final.
        If the class is an inner class, all its constructors are private, and the class is not final, then this test case violates the rule.
['Get the name of class.', 'Check whether the class is inner class.', 'Get the signature of all constructors in class.', 'Check whether the constructor is private.', 'Get all constructors declared in class.', 'Check whether all constructors are private.', 'Check whether the class is final.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.987544596195221
*Get the signature of all constructors in class.* 匹配到的元操作或API：
logic: Get the signature of all constructors in class.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9086645245552063
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether all constructors are private.* 匹配到的元操作或API：
logic: Check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.936521589756012
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// #2536 [java] ClassWithOnlyPrivateConstructorsShouldBeFinal can't detect inner class with only private constructor
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && !node.isFinal()) {
            boolean hasOnlyPrivateConstructors = true;
            ASTClassOrInterfaceBody body = node.getFirstChildOfType(ASTClassOrInterfaceBody.class);
            if (body != null) {
                for (ASTConstructorDeclaration constructor : body.getChildrenOfType(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && body.getNumChildrenOfType(ASTConstructorDeclaration.class) > 0) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 3
804
574
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
        2. Check whether the class is an inner class.
        3. Check whether the class is private.
        4. Get the number of constructors of the class.
        5. Check whether the class has a constructor with public or default (package-private) access.
        6. Check whether the class has a constructor with protected access.

For the provided test case:
1. Get the name of class: Main209
2. Check whether the class is an inner class: No
3. Check whether the class is private: No
4. Get the number of constructors of the class: Main209 has 1 constructor (implicitly default).
5. Check whether the class has a constructor with public or default (package-private) access: Yes, Main209 has a default constructor.
6. Check whether the class has a constructor with protected access: No

Since the class Main209 is not private and has a constructor with default access, it can be extended from outside its compilation unit, and thus does not violate the rule.

Now, let's check the inner class:
1. Get the name of class: InputBits
2. Check whether the class is an inner class: Yes
3. Check whether the class is private: Yes
4. Get the number of constructors of the class: InputBits has 1 constructor (implicitly default).
5. Check whether the class has a constructor with public or default (package-private) access: No, the default constructor is implicitly private.
6. Check whether the class has a constructor with protected access: No

Since the inner class InputBits is private and has no constructors with public or default (package-private) access, it can only be extended within the same compilation unit. However, the rule states that the class should contain at least one abstract method to be considered for making final. Therefore, we need to check for abstract methods in InputBits:
7. Get all methods declared in class: InputBits has no methods declared.
8. Check whether method is abstract: No methods are abstract.

Since the inner class InputBits is private and has no constructors that can be called from outside its compilation unit, it can be made final. However, based on the rule description provided, it seems the rule also wants the class to contain at least one abstract method to be considered for making final. Since InputBits does not have any abstract methods, it does not violate the rule as per the provided description.

If the rule is only about the private constructor, then InputBits violates the rule as it can be made final.

For the provided description "bad 4" and number of violating the rule "1", it seems the rule might be interpreted differently or there might be additional context not provided. The provided test case does not have a final field reassignment, it has a private inner class without any abstract methods. If the rule is strictly about making private classes with private constructors final, then the provided test case does violate the rule.

So, based on the interpretation of the rule provided in the test case description:
1. Get the name of class: InputBits
2. Check whether the class is an inner class: Yes
3. Check whether the class is private: Yes
4. Get the number of constructors of the class: InputBits has 1 constructor (implicitly default).
5. Check whether the class has a constructor with public or default (package-private) access: No, the default constructor is implicitly private.
6. Check whether the class has a constructor with protected access: No

Since the inner class InputBits is private and has an implicitly private constructor, it can be made final. Therefore, it violates the rule.
            
['Get the name of class.', 'Check whether the class is an inner class.', 'Check whether the class is private.', 'Get the number of constructors of the class.', 'Check whether the class has a constructor with public or default (package-private) access.', 'Check whether the class has a constructor with protected access.', 'Get the name of class: Main209', 'Check whether the class is an inner class: No', 'Check whether the class is private: No', 'Get the number of constructors of the class: Main209 has 1 constructor (implicitly default).', 'Check whether the class has a constructor with public or default (package-private) access: Yes, Main209 has a default constructor.', 'Check whether the class has a constructor with protected access: No', 'Get the name of class: InputBits', 'Check whether the class is an inner class: Yes', 'Check whether the class is private: Yes', 'Get the number of constructors of the class: InputBits has 1 constructor (implicitly default).', 'Check whether the class has a constructor with public or default (package-private) access: No, the default constructor is implicitly private.', 'Check whether the class has a constructor with protected access: No', 'Get all methods declared in class: InputBits has no methods declared.', 'Check whether method is abstract: No methods are abstract.', 'Get the name of class: InputBits', 'Check whether the class is an inner class: Yes', 'Check whether the class is private: Yes', 'Get the number of constructors of the class: InputBits has 1 constructor (implicitly default).', 'Check whether the class has a constructor with public or default (package-private) access: No, the default constructor is implicitly private.', 'Check whether the class has a constructor with protected access: No']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Get the number of constructors of the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has a constructor with public or default (package-private) access.* 匹配到的元操作或API：
logic: Check whether the class has a constructor with public or default (package-private) access.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.8944991230964661
*Check whether the class has a constructor with protected access.* 匹配到的元操作或API：
logic: Check whether the class has a constructor with protected access.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9213904738426208
*Get the name of class: Main209* 匹配到的元操作或API：
logic: Get the name of class: Main209
most similar meta operation: Get the name of class
cosine Similarity: 0.8585509061813354
*Check whether the class is an inner class: No* 匹配到的元操作或API：
logic: Check whether the class is an inner class: No
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9571874141693115
*Check whether the class is private: No* 匹配到的元操作或API：
logic: Check whether the class is private: No
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9601792693138123
*Get the number of constructors of the class: Main209 has 1 constructor (implicitly default).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has a constructor with public or default (package-private) access: Yes, Main209 has a default constructor.* 匹配到的元操作或API：
logic: Check whether the class has a constructor with public or default (package-private) access: Yes, Main209 has a default constructor.
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.8640251755714417
*Check whether the class has a constructor with protected access: No* 匹配到的元操作或API：
logic: Check whether the class has a constructor with protected access: No
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.8904592990875244
*Get the name of class: InputBits* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is an inner class: Yes* 匹配到的元操作或API：
logic: Check whether the class is an inner class: Yes
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9616652727127075
*Check whether the class is private: Yes* 匹配到的元操作或API：
logic: Check whether the class is private: Yes
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9429656267166138
*Get the number of constructors of the class: InputBits has 1 constructor (implicitly default).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has a constructor with public or default (package-private) access: No, the default constructor is implicitly private.* 匹配到的元操作或API：
logic: Check whether the class has a constructor with public or default (package-private) access: No, the default constructor is implicitly private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8847201466560364
*Check whether the class has a constructor with protected access: No* 匹配到的元操作或API：
logic: Check whether the class has a constructor with protected access: No
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.8904592990875244
*Get all methods declared in class: InputBits has no methods declared.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether method is abstract: No methods are abstract.* 匹配到的元操作或API：
logic: Check whether method is abstract: No methods are abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9388583898544312
*Get the name of class: InputBits* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is an inner class: Yes* 匹配到的元操作或API：
logic: Check whether the class is an inner class: Yes
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9616652727127075
*Check whether the class is private: Yes* 匹配到的元操作或API：
logic: Check whether the class is private: Yes
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9429656267166138
*Get the number of constructors of the class: InputBits has 1 constructor (implicitly default).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has a constructor with public or default (package-private) access: No, the default constructor is implicitly private.* 匹配到的元操作或API：
logic: Check whether the class has a constructor with public or default (package-private) access: No, the default constructor is implicitly private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8847201466560364
*Check whether the class has a constructor with protected access: No* 匹配到的元操作或API：
logic: Check whether the class has a constructor with protected access: No
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.8904592990875244
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Private inner class with no ctor and no usage
public class Main209 {
    private static class InputBits {
        // default ctor is implicitly private
    }
}
The description of this test case is: bad 4
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isProtected()
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPackagePrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
8. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if the class is not abstract and has only private constructors
        if (!node.isAbstract() && node.isClass()) {
            boolean hasNonPrivateConstructor = node.children(ASTConstructorDeclaration.class)
                                                   .anyMatch(c -> !c.isPrivate());
            if (!hasNonPrivateConstructor && node.children(ASTConstructorDeclaration.class).findAny().isPresent()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class is an inner class.
3. Get the name of the package where the class is located.
4. Get the class that method located in.
5. Check whether the class has declared annotations.
6. Get the super class of class.
7. Check whether the class has extended super class.
8. Get all constructors declared in class.
9. Check whether the constructor is private.
10. Get the class that contains this inner class.
11. Check whether the class is public.
12. Get all inner classes of the containing class.
13. Check whether the inner class is used in the containing class.

For the provided test case:

1. Get the name of class: InputBits
2. Check whether the class is an inner class: True
3. Get the name of the package where the class is located: (not explicitly provided, assuming it's in the default package or the package of Main209)
4. Get the class that method located in: Main209 (but there are no methods in InputBits, so this check is not useful for this specific test case)
5. Check whether the class has declared annotations: False
6. Get the super class of class: Object (implicitly)
7. Check whether the class has extended super class: False (implicitly extends Object, but we're looking for explicit extensions)
8. Get all constructors declared in class: No explicitly declared constructors
9. Check whether the constructor is private: True (default constructor is implicitly private when the class is private)
10. Get the class that contains this inner class: Main209
11. Check whether the class is public: True (Main209 is public, but InputBits is private)
12. Get all inner classes of the containing class: InputBits
13. Check whether the inner class is used in the containing class: False (no usage of InputBits in Main209)

Since InputBits is a private inner class with no explicitly declared constructors (thus the default constructor is implicitly private) and it is not used outside of its containing class, this test case violates the rule. The class should be made final because it cannot be extended from outside its compilation unit.
['Get the name of class.', 'Check whether the class is an inner class.', 'Get the name of the package where the class is located.', 'Get the class that method located in.', 'Check whether the class has declared annotations.', 'Get the super class of class.', 'Check whether the class has extended super class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get the class that contains this inner class.', 'Check whether the class is public.', 'Get all inner classes of the containing class.', 'Check whether the inner class is used in the containing class.', 'Get the name of class: InputBits', 'Check whether the class is an inner class: True', "Get the name of the package where the class is located: (not explicitly provided, assuming it's in the default package or the package of Main209)", 'Get the class that method located in: Main209 (but there are no methods in InputBits, so this check is not useful for this specific test case)', 'Check whether the class has declared annotations: False', 'Get the super class of class: Object (implicitly)', "Check whether the class has extended super class: False (implicitly extends Object, but we're looking for explicit extensions)", 'Get all constructors declared in class: No explicitly declared constructors', 'Check whether the constructor is private: True (default constructor is implicitly private when the class is private)', 'Get the class that contains this inner class: Main209', 'Check whether the class is public: True (Main209 is public, but InputBits is private)', 'Get all inner classes of the containing class: InputBits', 'Check whether the inner class is used in the containing class: False (no usage of InputBits in Main209)']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Get the class that method located in.* 匹配到的元操作或API：
logic: Get the class that method located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9805244207382202
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class has extended super class.* 匹配到的元操作或API：
logic: Check whether the class has extended super class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.8976987600326538
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the class that contains this inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all inner classes of the containing class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is used in the containing class.* 匹配到的元操作或API：
logic: Check whether the inner class is used in the containing class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8826309442520142
*Get the name of class: InputBits* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is an inner class: True* 匹配到的元操作或API：
logic: Check whether the class is an inner class: True
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9726787209510803
*Get the name of the package where the class is located: (not explicitly provided, assuming it's in the default package or the package of Main209)* 匹配到的元操作或API：
logic: Get the name of the package where the class is located: (not explicitly provided, assuming it's in the default package or the package of Main209)
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9246881008148193
*Get the class that method located in: Main209 (but there are no methods in InputBits, so this check is not useful for this specific test case)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has declared annotations: False* 匹配到的元操作或API：
logic: Check whether the class has declared annotations: False
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.962430477142334
*Get the super class of class: Object (implicitly)* 匹配到的元操作或API：
logic: Get the super class of class: Object (implicitly)
most similar meta operation: Get the super class of class
cosine Similarity: 0.8930438756942749
*Check whether the class has extended super class: False (implicitly extends Object, but we're looking for explicit extensions)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors declared in class: No explicitly declared constructors* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: True (default constructor is implicitly private when the class is private)* 匹配到的元操作或API：
logic: Check whether the constructor is private: True (default constructor is implicitly private when the class is private)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9255286455154419
*Get the class that contains this inner class: Main209* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is public: True (Main209 is public, but InputBits is private)* 匹配到的元操作或API：
logic: Check whether the class is public: True (Main209 is public, but InputBits is private)
most similar meta operation: Check whether the class is public
cosine Similarity: 0.8650678396224976
*Get all inner classes of the containing class: InputBits* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is used in the containing class: False (no usage of InputBits in Main209)* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Private inner class with no ctor and no usage
public class Main209 {
    private static class InputBits {
        // default ctor is implicitly private
    }
}
The description of this test case is: bad 4
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && node.isPrivate() && !node.isAbstract() && !node.isFinal() && !hasAnnotations(node) && !extendsSpecificClass(node)) {
            List<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class).toList();
            if (constructors.isEmpty() || constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Check whether class has declared annotations
    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }

    // Check whether the class has extended a specific class
    public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node) {
        ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
        return TypeTestUtil.isA(x.class, classOrInterfaceType); // Replace 'x.class' with the actual class you want to check against
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
To perform granular checks on the provided test case to ascertain its adherence to the rule, we need to break down the test case and check each part individually:

1. Get the name of class.
2. Check whether the class has inner classes.
3. Get the name of the inner class.
4. Check whether the inner class is static.
5. Get the constructors of the inner class.
6. Check whether the constructors of the inner class are private.
7. Check whether the inner class has any method calls or usages outside its compilation unit.
8. Check whether the inner class is being extended from outside its compilation unit.

Given the test case:

```java
// Private inner class with no ctor and no usage
public class Main209 {
    private static class InputBits {
        // default ctor is implicitly private
    }
}
```

Let's perform the checks:

1. Get the name of class.
   - The name of the class is `Main209`.

2. Check whether the class has inner classes.
   - Yes, the class `Main209` has an inner class `InputBits`.

3. Get the name of the inner class.
   - The name of the inner class is `InputBits`.

4. Check whether the inner class is static.
   - Yes, the inner class `InputBits` is static.

5. Get the constructors of the inner class.
   - The inner class `InputBits` implicitly has a default constructor.

6. Check whether the constructors of the inner class are private.
   - No, the default constructor of `InputBits` is not explicitly marked as private, but since the class is private, its constructors are effectively not accessible from outside the `Main209` class.

7. Check whether the inner class has any method calls or usages outside its compilation unit.
   - No, the inner class `InputBits` is not used or extended outside its compilation unit.

8. Check whether the inner class is being extended from outside its compilation unit.
   - No, the inner class `InputBits` is not being extended from outside its compilation unit.

Based on these checks, the test case does not strictly violate the rule as described because the rule specifies that the constructors should be private, and while the constructors are not explicitly marked as private, the class itself being private means that its constructors are not accessible from outside the `Main209` class compilation unit. However, if we interpret the rule to mean that the constructors should explicitly be private, then the test case does violate the rule as it should have an explicitly private constructor to ensure that it cannot be extended from outside its compilation unit.

If the interpretation is that the constructors are implicitly private due to the class being private, then the test case does not violate the rule as per the provided description. The description of the test case seems to imply that there is a violation, which could be due to an implicit assumption that the constructors should be explicitly private.

To clarify and align with the provided description:

1. Get the constructors of the inner class.
   - The inner class `InputBits` implicitly has a default constructor.

2. Check whether the constructors of the inner class are explicitly private.
   - No, the constructors of `InputBits` are not explicitly private.

If the rule strictly requires explicit private constructors in such cases:

The test case violates the rule because the inner class `InputBits` does not have an explicitly private constructor, even though the class itself is private, making the constructors effectively not accessible from outside the `Main209` class.
['Get the name of class.', 'Check whether the class has inner classes.', 'Get the name of the inner class.', 'Check whether the inner class is static.', 'Get the constructors of the inner class.', 'Check whether the constructors of the inner class are private.', 'Check whether the inner class has any method calls or usages outside its compilation unit.', 'Check whether the inner class is being extended from outside its compilation unit.', 'Get the name of class.', 'Check whether the class has inner classes.', 'Get the name of the inner class.', 'Check whether the inner class is static.', 'Get the constructors of the inner class.', 'Check whether the constructors of the inner class are private.', 'Check whether the inner class has any method calls or usages outside its compilation unit.', 'Check whether the inner class is being extended from outside its compilation unit.', 'Get the constructors of the inner class.', 'Check whether the constructors of the inner class are explicitly private.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has inner classes.* 匹配到的元操作或API：
logic: Check whether the class has inner classes.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9536193609237671
*Get the name of the inner class.* 匹配到的元操作或API：
logic: Get the name of the inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.878083348274231
*Check whether the inner class is static.* 匹配到的元操作或API：
logic: Check whether the inner class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9092438220977783
*Get the constructors of the inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructors of the inner class are private.* 匹配到的元操作或API：
logic: Check whether the constructors of the inner class are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9142563343048096
*Check whether the inner class has any method calls or usages outside its compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is being extended from outside its compilation unit.* 匹配到的元操作或API：
query: Check whether the inner class is being extended from outside its compilation unit.
most similar API: Check whether the compilation unit is unnamed class
cosine Similarity: 0.8017095923423767
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has inner classes.* 匹配到的元操作或API：
logic: Check whether the class has inner classes.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9536193609237671
*Get the name of the inner class.* 匹配到的元操作或API：
logic: Get the name of the inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.878083348274231
*Check whether the inner class is static.* 匹配到的元操作或API：
logic: Check whether the inner class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9092438220977783
*Get the constructors of the inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructors of the inner class are private.* 匹配到的元操作或API：
logic: Check whether the constructors of the inner class are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9142563343048096
*Check whether the inner class has any method calls or usages outside its compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is being extended from outside its compilation unit.* 匹配到的元操作或API：
query: Check whether the inner class is being extended from outside its compilation unit.
most similar API: Check whether the compilation unit is unnamed class
cosine Similarity: 0.8017095923423767
*Get the constructors of the inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructors of the inner class are explicitly private.* 匹配到的元操作或API：
logic: Check whether the constructors of the inner class are explicitly private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8953495025634766
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Private inner class with no ctor and no usage
public class Main209 {
    private static class InputBits {
        // default ctor is implicitly private
    }
}
The description of this test case is: bad 4
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean isUnnamedClass()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }
    
    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && node.isStatic() && !node.isInterface() && !node.isAbstract()) {
            ASTModifierList modifiers = node.getFirstChildOfType(ASTModifierList.class);
            if (modifiers != null && !modifiers.hasModifier(ASTModifierList.Modifier.FINAL)) {
                boolean hasNonPrivateConstructor = node.descendants(ASTConstructorDeclaration.class).anyMatch(ctor -> !ctor.isPrivate());
                if (!hasNonPrivateConstructor) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Check whether the class has declared annotations.
3. Get the declared annotation of class.
4. Check whether the class has x annotation.
5. Get the name of the package where the class is located.
6. Check whether the class is abstract.
7. Check whether the class is public.
8. Check whether the class is private.
9. Check whether the class is protected.
10. Check whether the class is default package-private.
11. Check whether the class is final.
12. Check whether the class is static.
13. Get the super class of class.
14. Check whether the class has extended x class.
15. Get a implemented interface of class.
16. Check whether the class has implemented x interface.
17. Get the name of the package where the class is located.
18. Check whether the class is interface.
19. Check whether the class is inner class.
20. Check whether the class is anonymous class.
21. Get all constructors declared in class.
22. Check whether the constructor is private.

Based on the test case provided:

1. Get the name of class: `Main209`
2. Check whether the class has declared annotations: No annotations found.
3. Get the declared annotation of class: No annotations to get.
4. Check whether the class has x annotation: No specific annotation to check for.
5. Get the name of the package where the class is located: Not explicitly specified, so it’s in the default package.
6. Check whether the class is abstract: No, it is not abstract.
7. Check whether the class is public: Yes, it is public.
8. Check whether the class is private: No, it is not private.
9. Check whether the class is protected: No, it is not protected.
10. Check whether the class is default package-private: Since no package is specified, it is default package-private.
11. Check whether the class is final: No, it is not final.
12. Check whether the class is static: No, it is not static.
13. Get the super class of class: Super class is `Object`.
14. Check whether the class has extended x class: No specific superclass to check for.
15. Get a implemented interface of class: No interfaces implemented.
16. Check whether the class has implemented x interface: No specific interface to check for.
17. Get the name of the package where the class is located: Not explicitly specified, so it’s in the default package.
18. Check whether the class is interface: No, it is not an interface.
19. Check whether the class is inner class: No, it is not an inner class.
20. Check whether the class is anonymous class: No, it is not an anonymous class.
21. Get all constructors declared in class: `Main209` has no explicitly declared constructors, but it has the default public constructor.
22. Get all constructors declared in class: `InputBits` has no explicitly declared constructors, so the default constructor is present.
23. Check whether the constructor is private: The default constructor of `InputBits` is implicitly package-private, not private.

Based on these checks, `InputBits` does not violate the rule because its constructor is not private, it is implicitly package-private. Therefore, the test case description "bad 4" and number of violations "1" are incorrect according to the rule description provided. 

The correct checks to identify a class that violates this rule should be:
- The class should be private.
- The class should not be an interface.
- The class should not have any non-private constructors.

In this test case, `InputBits` is private, but it does not have any explicitly declared constructors, so its default constructor is package-private, not private. Therefore, it does not violate the rule.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get the declared annotation of class.', 'Check whether the class has x annotation.', 'Get the name of the package where the class is located.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get a implemented interface of class.', 'Check whether the class has implemented x interface.', 'Get the name of the package where the class is located.', 'Check whether the class is interface.', 'Check whether the class is inner class.', 'Check whether the class is anonymous class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get the name of class: `Main209`', 'Check whether the class has declared annotations: No annotations found.', 'Get the declared annotation of class: No annotations to get.', 'Check whether the class has x annotation: No specific annotation to check for.', 'Get the name of the package where the class is located: Not explicitly specified, so it’s in the default package.', 'Check whether the class is abstract: No, it is not abstract.', 'Check whether the class is public: Yes, it is public.', 'Check whether the class is private: No, it is not private.', 'Check whether the class is protected: No, it is not protected.', 'Check whether the class is default package-private: Since no package is specified, it is default package-private.', 'Check whether the class is final: No, it is not final.', 'Check whether the class is static: No, it is not static.', 'Get the super class of class: Super class is `Object`.', 'Check whether the class has extended x class: No specific superclass to check for.', 'Get a implemented interface of class: No interfaces implemented.', 'Check whether the class has implemented x interface: No specific interface to check for.', 'Get the name of the package where the class is located: Not explicitly specified, so it’s in the default package.', 'Check whether the class is interface: No, it is not an interface.', 'Check whether the class is inner class: No, it is not an inner class.', 'Check whether the class is anonymous class: No, it is not an anonymous class.', 'Get all constructors declared in class: `Main209` has no explicitly declared constructors, but it has the default public constructor.', 'Get all constructors declared in class: `InputBits` has no explicitly declared constructors, so the default constructor is present.', 'Check whether the constructor is private: The default constructor of `InputBits` is implicitly package-private, not private.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the declared annotation of class.* 匹配到的元操作或API：
logic: Get the declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9817171692848206
*Check whether the class has x annotation.* 匹配到的元操作或API：
logic: Check whether the class has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9908236265182495
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844120740890503
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a implemented interface of class.* 匹配到的元操作或API：
logic: Get a implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9851537942886353
*Check whether the class has implemented x interface.* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9905824661254883
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is interface.* 匹配到的元操作或API：
logic: Check whether the class is interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9844173789024353
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.987544596195221
*Check whether the class is anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9849605560302734
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the name of class: `Main209`* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has declared annotations: No annotations found.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations: No annotations found.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9445676803588867
*Get the declared annotation of class: No annotations to get.* 匹配到的元操作或API：
logic: Get the declared annotation of class: No annotations to get.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9393631219863892
*Check whether the class has x annotation: No specific annotation to check for.* 匹配到的元操作或API：
logic: Check whether the class has x annotation: No specific annotation to check for.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9649633169174194
*Get the name of the package where the class is located: Not explicitly specified, so it’s in the default package.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located: Not explicitly specified, so it’s in the default package.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.927012026309967
*Check whether the class is abstract: No, it is not abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract: No, it is not abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9373423457145691
*Check whether the class is public: Yes, it is public.* 匹配到的元操作或API：
logic: Check whether the class is public: Yes, it is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9412388801574707
*Check whether the class is private: No, it is not private.* 匹配到的元操作或API：
logic: Check whether the class is private: No, it is not private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9350518584251404
*Check whether the class is protected: No, it is not protected.* 匹配到的元操作或API：
logic: Check whether the class is protected: No, it is not protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9336436986923218
*Check whether the class is default package-private: Since no package is specified, it is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private: Since no package is specified, it is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9337329864501953
*Check whether the class is final: No, it is not final.* 匹配到的元操作或API：
logic: Check whether the class is final: No, it is not final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9417860507965088
*Check whether the class is static: No, it is not static.* 匹配到的元操作或API：
logic: Check whether the class is static: No, it is not static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9273737668991089
*Get the super class of class: Super class is `Object`.* 匹配到的元操作或API：
logic: Get the super class of class: Super class is `Object`.
most similar meta operation: Get the super class of class
cosine Similarity: 0.8991490602493286
*Check whether the class has extended x class: No specific superclass to check for.* 匹配到的元操作或API：
logic: Check whether the class has extended x class: No specific superclass to check for.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9659268260002136
*Get a implemented interface of class: No interfaces implemented.* 匹配到的元操作或API：
logic: Get a implemented interface of class: No interfaces implemented.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9385616183280945
*Check whether the class has implemented x interface: No specific interface to check for.* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface: No specific interface to check for.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9653905630111694
*Get the name of the package where the class is located: Not explicitly specified, so it’s in the default package.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located: Not explicitly specified, so it’s in the default package.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.927012026309967
*Check whether the class is interface: No, it is not an interface.* 匹配到的元操作或API：
logic: Check whether the class is interface: No, it is not an interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9270178079605103
*Check whether the class is inner class: No, it is not an inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class: No, it is not an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9250194430351257
*Check whether the class is anonymous class: No, it is not an anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class: No, it is not an anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9216850399971008
*Get all constructors declared in class: `Main209` has no explicitly declared constructors, but it has the default public constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors declared in class: `InputBits` has no explicitly declared constructors, so the default constructor is present.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: The default constructor of `InputBits` is implicitly package-private, not private.* 匹配到的元操作或API：
logic: Check whether the constructor is private: The default constructor of `InputBits` is implicitly package-private, not private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8715677857398987
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Private inner class with no ctor and no usage
public class Main209 {
    private static class InputBits {
        // default ctor is implicitly private
    }
}
The description of this test case is: bad 4
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isProtected()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
11. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
12. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
13. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getSuperInterfaceTypeNodes()
14. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()
15. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
16. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnonymous()
17. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```
3.  //Check whether the class has implemented x interface
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node) {
    if (TypeTestUtil.isA(interfaceName.class, node)) {
        return true;
    }
    return false;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {

    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isNested() && node.isPrivate() && !node.isFinal() && !hasAnnotations(node) && !node.isInterface()) {
            NodeStream<ASTConstructorDeclaration> constructors = node.descendants(ASTConstructorDeclaration.class);
            boolean allPrivate = constructors.nonEmpty() ? constructors.allMatch(ASTConstructorDeclaration::isPrivate) : true;
            if (allPrivate) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Check whether class has declared annotations
    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }

    // Check whether the class has extended x class
    public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node, Class<?> x) {
        ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
        return TypeTestUtil.isA(x, classOrInterfaceType);
    }

    // Check whether the class has implemented x interface
    public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node, Class<?> interfaceName) {
        return TypeTestUtil.isA(interfaceName, node);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
To verify the adherence of the provided test case to the rule, we need to perform the following granular checks:

1. Get the name of class.
2. Check whether the class is public.
3. Get the name of the inner class.
4. Check whether the inner class is static.
5. Check whether the inner class is private.
6. Check whether the inner class has declared constructors.
7. If the inner class has declared constructors, get the number of declared constructors.
8. For each declared constructor, check whether it is private.
9. Check whether the inner class has any method calls or object creations that reference the inner class.
10. Check whether the inner class is used in any other part of the compilation unit.

Let's perform these checks step-by-step:

1. Get the name of class: `Main209`
2. Check whether the class is public: `true`
3. Get the name of the inner class: `InputBits`
4. Check whether the inner class is static: `true`
5. Check whether the inner class is private: `true`
6. Check whether the inner class has declared constructors: `false` (The inner class has an implicit no-argument constructor, but it is not declared explicitly.)
7. Since the inner class does not have explicitly declared constructors, we need to check the implicit constructor:
8. Check whether the implicit no-argument constructor is private: `false` (In Java, an implicit constructor has the same access level as the class itself, so the implicit constructor in `InputBits` is private because the class is private.)
9. Check whether the inner class has any method calls or object creations that reference the inner class: `false`
10. Check whether the inner class is used in any other part of the compilation unit: `false`

Based on these checks, the inner class `InputBits` is a private static inner class without any explicitly declared constructors, and it is not used or instantiated within the same compilation unit. Therefore, it should be made final as per the rule. However, since the rule specifically mentions that a subclass could not call the super constructor due to private constructors, and the implicit constructor is indeed private, the rule is violated in this case.

The number of violating the rule in this test case is: 1

The description of this test case is: bad 4

This test case adheres to the rule description provided and correctly identifies a violation.
['Get the name of class.', 'Check whether the class is public.', 'Get the name of the inner class.', 'Check whether the inner class is static.', 'Check whether the inner class is private.', 'Check whether the inner class has declared constructors.', 'If the inner class has declared constructors, get the number of declared constructors.', 'For each declared constructor, check whether it is private.', 'Check whether the inner class has any method calls or object creations that reference the inner class.', 'Check whether the inner class is used in any other part of the compilation unit.', 'Get the name of class: `Main209`', 'Check whether the class is public: `true`', 'Get the name of the inner class: `InputBits`', 'Check whether the inner class is static: `true`', 'Check whether the inner class is private: `true`', 'Check whether the inner class has declared constructors: `false` (The inner class has an implicit no-argument constructor, but it is not declared explicitly.)', 'Since the inner class does not have explicitly declared constructors, we need to check the implicit constructor:', 'Check whether the implicit no-argument constructor is private: `false` (In Java, an implicit constructor has the same access level as the class itself, so the implicit constructor in `InputBits` is private because the class is private.)', 'Check whether the inner class has any method calls or object creations that reference the inner class: `false`', 'Check whether the inner class is used in any other part of the compilation unit: `false`']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get the name of the inner class.* 匹配到的元操作或API：
logic: Get the name of the inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.878083348274231
*Check whether the inner class is static.* 匹配到的元操作或API：
logic: Check whether the inner class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9092438220977783
*Check whether the inner class is private.* 匹配到的元操作或API：
logic: Check whether the inner class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9290029406547546
*Check whether the inner class has declared constructors.* 匹配到的元操作或API：
logic: Check whether the inner class has declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.8522486090660095
*If the inner class has declared constructors, get the number of declared constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each declared constructor, check whether it is private.* 匹配到的元操作或API：
logic: For each declared constructor, check whether it is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9383894801139832
*Check whether the inner class has any method calls or object creations that reference the inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is used in any other part of the compilation unit.* 匹配到的元操作或API：
query: Check whether the inner class is used in any other part of the compilation unit.
most similar API: Check whether the compilation unit is unnamed class
cosine Similarity: 0.8072705268859863
*Get the name of class: `Main209`* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is public: `true`* 匹配到的元操作或API：
logic: Check whether the class is public: `true`
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9467447996139526
*Get the name of the inner class: `InputBits`* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is static: `true`* 匹配到的元操作或API：
logic: Check whether the inner class is static: `true`
most similar meta operation: Check whether the class is static
cosine Similarity: 0.8819562196731567
*Check whether the inner class is private: `true`* 匹配到的元操作或API：
logic: Check whether the inner class is private: `true`
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9016240835189819
*Check whether the inner class has declared constructors: `false` (The inner class has an implicit no-argument constructor, but it is not declared explicitly.)* 匹配到的元操作或API：
未匹配成功元操作或API
*Since the inner class does not have explicitly declared constructors, we need to check the implicit constructor:* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the implicit no-argument constructor is private: `false` (In Java, an implicit constructor has the same access level as the class itself, so the implicit constructor in `InputBits` is private because the class is private.)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class has any method calls or object creations that reference the inner class: `false`* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is used in any other part of the compilation unit: `false`* 匹配到的元操作或API：
query: Check whether the inner class is used in any other part of the compilation unit: `false`
most similar API: Check whether the compilation unit is unnamed class
cosine Similarity: 0.803428590297699
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Private inner class with no ctor and no usage
public class Main209 {
    private static class InputBits {
        // default ctor is implicitly private
    }
}
The description of this test case is: bad 4
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean isUnnamedClass()

1.  //Check whether constructor has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTConstructorDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isPrivate() || node.isPublic() && node.isStatic()) {
            boolean hasNonPrivateConstructor = node.descendants(ASTConstructorDeclaration.class)
                    .anyMatch(constructor -> !constructor.isPrivate() && !hasAnnotation(constructor));
            if (!hasNonPrivateConstructor && node.getNumChildren() == 0) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Check whether constructor has declared annotations
    public boolean hasAnnotation(ASTConstructorDeclaration node) {
        NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
        return declaredAnnotations.nonEmpty();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 4
1233
939
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
To perform granular checks on the provided test case to ascertain adherence to the rule, we will follow these steps:

1. Get the name of class.
2. Check whether the class is public.
3. Get the name of inner class.
4. Check whether the inner class is abstract.
5. Get the constructors of inner class.
6. Check whether the constructor is private.
7. Check whether the inner class has any declared methods.
8. Check whether the declared methods in the inner class are abstract.
9. Check whether the inner class has any subclasses.

Let's break down the test case:

1. Get the name of class.
   - The class name is `Outer`.

2. Check whether the class is public.
   - `Outer` is public.

3. Get the name of inner class.
   - The inner class name is `Base`.

4. Check whether the inner class is abstract.
   - `Base` is abstract.

5. Get the constructors of inner class.
   - Get all constructors of `Base`.

6. Check whether the constructor is private.
   - If there are constructors, check if they are private.
   - In the provided code, there are no constructors explicitly defined for `Base`, so the default constructor is used.

7. Check whether the default constructor is private.
   - Since no constructors are explicitly defined, the default constructor is not private.

8. Check whether the inner class has any declared methods.
   - `Base` has one declared method `run`.

9. Check whether the declared methods in the inner class are abstract.
   - `run` is not abstract.

10. Check whether the inner class has any subclasses.
    - The provided code does not show any subclasses of `Base`.

Given the rule, we need to check if all constructors of the inner class are private. In the provided test case, `Base` does not have any explicitly defined constructors, so the default constructor is not private. Therefore, `Base` can be extended from outside its compilation unit, and this test case does not violate the rule.

However, if the intention is to ensure that no subclasses can be created due to the absence of public or protected constructors, we can infer that the default constructor (which is not explicitly defined) is package-private, and since it is within the same compilation unit, it can still be extended from outside the class but within the same package. But since the rule specifically mentions "private", and there are no private constructors defined, the test case does not violate the rule as per the given description.

To explicitly make the test case violate the rule, we should ensure that all constructors are private. Here is the modified test case for the rule to be violated:

```java
public class Outer {
    private abstract class Base {
        private Base() {}
        private void run() {}
    }
}
```

For the modified test case:

1. Get the name of class.
   - The class name is `Outer`.

2. Check whether the class is public.
   - `Outer` is public.

3. Get the name of inner class.
   - The inner class name is `Base`.

4. Check whether the inner class is abstract.
   - `Base` is abstract.

5. Get the constructors of inner class.
   - Get all constructors of `Base`.

6. Check whether the constructor is private.
   - The constructor `Base()` is private.

7. Check whether the inner class has any declared methods.
   - `Base` has one declared method `run`.

8. Check whether the declared methods in the inner class are abstract.
   - `run` is not abstract.

9. Check whether the inner class has any subclasses.
    - The provided code does not show any subclasses of `Base`.

Since all constructors are private, the inner class `Base` cannot be extended from outside its compilation unit, and the rule is not violated by the presence of an abstract method. However, the rule states that the class should contain at least one abstract method to be reported. In this case, `Base` does not have any abstract methods, so it does not violate the rule as per the provided rule description.

Therefore, the original test case does not violate the rule. If you want to make it violate the rule, you should ensure that all constructors are private and there are no abstract methods.
['Get the name of class.', 'Check whether the class is public.', 'Get the name of inner class.', 'Check whether the inner class is abstract.', 'Get the constructors of inner class.', 'Check whether the constructor is private.', 'Check whether the inner class has any declared methods.', 'Check whether the declared methods in the inner class are abstract.', 'Check whether the inner class has any subclasses.', 'Get the name of class.', 'Check whether the class is public.', 'Get the name of inner class.', 'Check whether the inner class is abstract.', 'Get the constructors of inner class.', 'Check whether the constructor is private.', 'Check whether the default constructor is private.', 'Check whether the inner class has any declared methods.', 'Check whether the declared methods in the inner class are abstract.', 'Check whether the inner class has any subclasses.', 'Get the name of class.', 'Check whether the class is public.', 'Get the name of inner class.', 'Check whether the inner class is abstract.', 'Get the constructors of inner class.', 'Check whether the constructor is private.', 'Check whether the inner class has any declared methods.', 'Check whether the declared methods in the inner class are abstract.', 'Check whether the inner class has any subclasses.']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get the name of inner class.* 匹配到的元操作或API：
logic: Get the name of inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.8755847811698914
*Check whether the inner class is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9326449036598206
*Get the constructors of inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the inner class has any declared methods.* 匹配到的元操作或API：
query: Check whether the inner class has any declared methods.
most similar API: Check whether the method is any annotation present
cosine Similarity: 0.8225457668304443
*Check whether the declared methods in the inner class are abstract.* 匹配到的元操作或API：
logic: Check whether the declared methods in the inner class are abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9166382551193237
*Check whether the inner class has any subclasses.* 匹配到的元操作或API：
logic: Check whether the inner class has any subclasses.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8827981352806091
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get the name of inner class.* 匹配到的元操作或API：
logic: Get the name of inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.8755847811698914
*Check whether the inner class is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9326449036598206
*Get the constructors of inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the default constructor is private.* 匹配到的元操作或API：
logic: Check whether the default constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9495748281478882
*Check whether the inner class has any declared methods.* 匹配到的元操作或API：
query: Check whether the inner class has any declared methods.
most similar API: Check whether the method is any annotation present
cosine Similarity: 0.8225457668304443
*Check whether the declared methods in the inner class are abstract.* 匹配到的元操作或API：
logic: Check whether the declared methods in the inner class are abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9166382551193237
*Check whether the inner class has any subclasses.* 匹配到的元操作或API：
logic: Check whether the inner class has any subclasses.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8827981352806091
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get the name of inner class.* 匹配到的元操作或API：
logic: Get the name of inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.8755847811698914
*Check whether the inner class is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9326449036598206
*Get the constructors of inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the inner class has any declared methods.* 匹配到的元操作或API：
query: Check whether the inner class has any declared methods.
most similar API: Check whether the method is any annotation present
cosine Similarity: 0.8225457668304443
*Check whether the declared methods in the inner class are abstract.* 匹配到的元操作或API：
logic: Check whether the declared methods in the inner class are abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9166382551193237
*Check whether the inner class has any subclasses.* 匹配到的元操作或API：
logic: Check whether the inner class has any subclasses.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8827981352806091
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Private abstract classes without abstract methods and subclasses #3668
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
The description of this test case is: bad 5
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection), //Checks whether any annotation is present on this node. @param binaryNames            Collection that contains binary names of annotations.            Note: for now, canonical names are tolerated, this may be changed in PMD 7. @return <code>true</code> if any annotation is present on this node, else <code>false</code>
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.List;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        // Check if the class is not an interface and not already final
        if (!node.isInterface() && !node.isFinal()) {
            // Check if all constructors are private
            List<ASTConstructorDeclaration> constructors = node.findDescendantsOfType(ASTConstructorDeclaration.class);
            boolean allConstructorsPrivate = constructors.stream().allMatch(ASTConstructorDeclaration::isPrivate);
            if (allConstructorsPrivate) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
2. Get the name of the package where the class is located.
3. Check whether the class is public.
4. Get the name of inner class.
5. Get the name of the package where the inner class is located.
6. Check whether the inner class is private.
7. Get all constructors declared in inner class.
8. Check whether the constructor is private.
9. Check whether the inner class is abstract.
10. Get all methods declared in inner class.
11. Check whether the method is abstract.

For the provided test case:
1. Get the name of class: Outer
2. Get the name of the package where the class is located: (assuming the package name is not specified, it's default package-private)
3. Check whether the class is public: Yes
4. Get the name of inner class: Base
5. Get the name of the package where the inner class is located: (default package-private, same as Outer)
6. Check whether the inner class is private: Yes
7. Get all constructors declared in inner class: (implicitly there is a default constructor, but it's not visible due to the inner class being private)
8. Check whether the constructor is private: (default constructor is not visible, but since the inner class is private, no external subclass can call the constructor anyway)
9. Check whether the inner class is abstract: Yes
10. Get all methods declared in inner class: run
11. Check whether the method is abstract: No

This test case violates the rule because `Base` is an abstract private inner class, meaning it cannot be extended from outside the compilation unit of `Outer`, and it does not have any abstract methods. However, the rule specifically states that classes with abstract methods are ignored, so since `Base` has a method `run` that is not abstract, it does not strictly meet the criteria of the rule. But given the description "bad 5", it seems the intention is to flag this case as a violation regardless of the presence of abstract methods. Therefore, the test case is flagged as violating the rule based on the provided description.
['Get the name of class.', 'Get the name of the package where the class is located.', 'Check whether the class is public.', 'Get the name of inner class.', 'Get the name of the package where the inner class is located.', 'Check whether the inner class is private.', 'Get all constructors declared in inner class.', 'Check whether the constructor is private.', 'Check whether the inner class is abstract.', 'Get all methods declared in inner class.', 'Check whether the method is abstract.', 'Get the name of class: Outer', "Get the name of the package where the class is located: (assuming the package name is not specified, it's default package-private)", 'Check whether the class is public: Yes', 'Get the name of inner class: Base', 'Get the name of the package where the inner class is located: (default package-private, same as Outer)', 'Check whether the inner class is private: Yes', "Get all constructors declared in inner class: (implicitly there is a default constructor, but it's not visible due to the inner class being private)", 'Check whether the constructor is private: (default constructor is not visible, but since the inner class is private, no external subclass can call the constructor anyway)', 'Check whether the inner class is abstract: Yes', 'Get all methods declared in inner class: run', 'Check whether the method is abstract: No']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get the name of inner class.* 匹配到的元操作或API：
logic: Get the name of inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.8755847811698914
*Get the name of the package where the inner class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the inner class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9266864657402039
*Check whether the inner class is private.* 匹配到的元操作或API：
logic: Check whether the inner class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9290029406547546
*Get all constructors declared in inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the inner class is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9326449036598206
*Get all methods declared in inner class.* 匹配到的元操作或API：
query: Get all methods declared in inner class.
most similar API: get declared annotations of method
cosine Similarity: 0.8129565119743347
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Get the name of class: Outer* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the package where the class is located: (assuming the package name is not specified, it's default package-private)* 匹配到的元操作或API：
logic: Get the name of the package where the class is located: (assuming the package name is not specified, it's default package-private)
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9165878891944885
*Check whether the class is public: Yes* 匹配到的元操作或API：
logic: Check whether the class is public: Yes
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9447720050811768
*Get the name of inner class: Base* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the package where the inner class is located: (default package-private, same as Outer)* 匹配到的元操作或API：
logic: Get the name of the package where the inner class is located: (default package-private, same as Outer)
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.8719553351402283
*Check whether the inner class is private: Yes* 匹配到的元操作或API：
logic: Check whether the inner class is private: Yes
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9116483926773071
*Get all constructors declared in inner class: (implicitly there is a default constructor, but it's not visible due to the inner class being private)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: (default constructor is not visible, but since the inner class is private, no external subclass can call the constructor anyway)* 匹配到的元操作或API：
logic: Check whether the constructor is private: (default constructor is not visible, but since the inner class is private, no external subclass can call the constructor anyway)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9016314744949341
*Check whether the inner class is abstract: Yes* 匹配到的元操作或API：
logic: Check whether the inner class is abstract: Yes
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9212698936462402
*Get all methods declared in inner class: run* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is abstract: No* 匹配到的元操作或API：
logic: Check whether the method is abstract: No
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.938342809677124
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Private abstract classes without abstract methods and subclasses #3668
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
The description of this test case is: bad 5
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
8. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (!node.isInterface() && !node.isFinal() && node.getChildren(ASTConstructorDeclaration.class).allMatch(ASTConstructorDeclaration::isPrivate)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of class.
        2. Check whether the class is abstract.
        3. Get all constructors declared in class.
        4. Check whether the constructor is private.
        5. Check whether the class is public.
        6. Check whether the class has subclasses.
        If the class is public, abstract, has no abstract methods, and all its constructors are private, but it still has subclasses, then this test case violates the rule.

In this specific test case:
1. Get the name of class. // Base
2. Check whether the class is abstract. // true
3. Get all constructors declared in class. // No constructors are explicitly declared.
4. Check whether the constructor is private. // Not applicable as there are no constructors.
5. Check whether the class is public. // false, Base is a private class.
6. Check whether the class has subclasses. // Not applicable for this exact test case as no subclasses are shown, but if it did, it would be relevant.

However, to fully ascertain adherence to the rule, we should also check:
7. Get the class that method located in. // Outer
8. Check whether the class has declared annotations. // Not applicable for this specific test case.
9. Get all methods declared in class. // run is declared
10. Check whether the method is abstract. // false, run is not an abstract method.

Since the `Base` class in your test case is private, it cannot be extended outside its compilation unit, so it does not violate the rule. The description "bad 5" and the number of violations being "1" might suggest that there is a misunderstanding or misinterpretation of the rule or the test case.

To clarify:
- The rule is about public abstract classes that cannot be extended from outside their compilation unit because all their constructors are private.
- The `Base` class in the test case is private, so it cannot be extended from outside its compilation unit, regardless of the constructors or the presence of abstract methods.

Therefore, this test case does not violate the rule as described.
['Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is public.', 'Check whether the class has subclasses.', 'Get the name of class. // Base', 'Check whether the class is abstract. // true', 'Get all constructors declared in class. // No constructors are explicitly declared.', 'Check whether the constructor is private. // Not applicable as there are no constructors.', 'Check whether the class is public. // false, Base is a private class.', 'Check whether the class has subclasses. // Not applicable for this exact test case as no subclasses are shown, but if it did, it would be relevant.', 'Get the class that method located in. // Outer', 'Check whether the class has declared annotations. // Not applicable for this specific test case.', 'Get all methods declared in class. // run is declared', 'Check whether the method is abstract. // false, run is not an abstract method.']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class has subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class. // Base* 匹配到的元操作或API：
logic: Get the name of class. // Base
most similar meta operation: Get the name of class
cosine Similarity: 0.8772722482681274
*Check whether the class is abstract. // true* 匹配到的元操作或API：
logic: Check whether the class is abstract. // true
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.956919252872467
*Get all constructors declared in class. // No constructors are explicitly declared.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private. // Not applicable as there are no constructors.* 匹配到的元操作或API：
logic: Check whether the constructor is private. // Not applicable as there are no constructors.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9389607310295105
*Check whether the class is public. // false, Base is a private class.* 匹配到的元操作或API：
logic: Check whether the class is public. // false, Base is a private class.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.879530668258667
*Check whether the class has subclasses. // Not applicable for this exact test case as no subclasses are shown, but if it did, it would be relevant.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the class that method located in. // Outer* 匹配到的元操作或API：
logic: Get the class that method located in. // Outer
most similar meta operation: Get the class that method located in
cosine Similarity: 0.8777629733085632
*Check whether the class has declared annotations. // Not applicable for this specific test case.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations. // Not applicable for this specific test case.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9292714595794678
*Get all methods declared in class. // run is declared* 匹配到的元操作或API：
query: Get all methods declared in class. // run is declared
most similar API: get declared annotations of method
cosine Similarity: 0.8101767897605896
*Check whether the method is abstract. // false, run is not an abstract method.* 匹配到的元操作或API：
logic: Check whether the method is abstract. // false, run is not an abstract method.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9002688527107239
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Private abstract classes without abstract methods and subclasses #3668
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
The description of this test case is: bad 5
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTClassOrInterfaceDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (node.isAbstract() && node.isPublic()) {
            boolean allConstructorsPrivate = true;
            for (ASTConstructorDeclaration constructor : node.children(ASTConstructorDeclaration.class)) {
                if (!constructor.isPrivate()) {
                    allConstructorsPrivate = false;
                    break;
                }
            }
            if (allConstructorsPrivate && !hasAnnotations(node)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    // Check whether class has declared annotations
    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
To evaluate the adherence of the provided test case to the rule, we will perform the following granular checks:

1. Get the name of class.
   - The class name is `Outer`.

2. Check whether the class is public.
   - `Outer` is public.

3. Get all inner classes of `Outer`.
   - The inner class name is `Base`.

4. Check whether the inner class `Base` is abstract.
   - `Base` is abstract.

5. Get all constructors of `Base`.
   - `Base` has one constructor, which is implicitly provided.

6. Check whether the constructor of `Base` is private.
   - The constructor of `Base` is not explicitly declared private, so it defaults to package-private.

7. Check whether `Base` has any declared constructors.
   - `Base` has one declared constructor, which is `private void run() {}`. However, this is not a constructor; it is a method. Therefore, no constructors are declared.

8. Check whether `Base` has any methods.
   - `Base` has one method, `run`.

9. Get the signature of the method `run`.
   - The signature of `run` is `private void run()`.

10. Check whether the method `run` is a constructor.
    - `run` is not a constructor.

11. Check whether `Base` has any declared constructors that are private.
    - `Base` does not have any declared constructors, so this check is not applicable.

12. Check whether `Base` has any subclasses in the same compilation unit.
    - This requires analyzing the entire compilation unit, which is not provided here. However, based on the description, we assume that there are no subclasses.

13. Check whether `Base` can be extended from outside its compilation unit.
    - Since the constructor of `Base` is not private, it can be extended from outside its compilation unit. Therefore, this test case does not violate the rule.

Based on the above checks, the test case provided does not violate the rule because the constructor of the inner class `Base` is not private. It is package-private, which means it can be extended from other classes in the same package, not just within the same compilation unit. Hence, the number of violations is 0, not 1 as stated. If the constructor were private, it would violate the rule.
['Get the name of class.', 'Check whether the class is public.', 'Get all inner classes of `Outer`.', 'Check whether the inner class `Base` is abstract.', 'Get all constructors of `Base`.', 'Check whether the constructor of `Base` is private.', 'Check whether `Base` has any declared constructors.', 'Check whether `Base` has any methods.', 'Get the signature of the method `run`.', 'Check whether the method `run` is a constructor.', 'Check whether `Base` has any declared constructors that are private.', 'Check whether `Base` has any subclasses in the same compilation unit.', 'Check whether `Base` can be extended from outside its compilation unit.']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all inner classes of `Outer`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class `Base` is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class `Base` is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.8673754334449768
*Get all constructors of `Base`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor of `Base` is private.* 匹配到的元操作或API：
logic: Check whether the constructor of `Base` is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.925423264503479
*Check whether `Base` has any declared constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether `Base` has any methods.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the signature of the method `run`.* 匹配到的元操作或API：
logic: Get the signature of the method `run`.
most similar meta operation: Get the signature of method
cosine Similarity: 0.8701595664024353
*Check whether the method `run` is a constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether `Base` has any declared constructors that are private.* 匹配到的元操作或API：
logic: Check whether `Base` has any declared constructors that are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8815256357192993
*Check whether `Base` has any subclasses in the same compilation unit.* 匹配到的元操作或API：
query: Check whether `Base` has any subclasses in the same compilation unit.
most similar API: Check whether the compilation unit has descendant of type
cosine Similarity: 0.8274280428886414
*Check whether `Base` can be extended from outside its compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
The test case corresponding to the rule:
```
// Private abstract classes without abstract methods and subclasses #3668
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
The description of this test case is: bad 5
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
6. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean hasDescendantOfType(java.lang.Class)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
True
此测试用例生成了first checker: bad 5


======================接下来开始迭代=====================
[ERROR]   "ok 2" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
107
91
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is public.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Check whether the constructor is public.

In this test case:

1. Get the name of class. -> The name of the class is `Foo`.
2. Check whether the class is public. -> The class `Foo` is public.
3. Get all constructors declared in class. -> There are two constructors: `private Foo() { }` and `public Foo(String param) { }`.
4. Check whether the constructor is private. -> The first constructor is private.
5. Check whether the constructor is public. -> The second constructor is public.

Since the class has at least one public constructor, it can be extended from outside its compilation unit. Therefore, the test case does not violate the rule. The number of violations is indeed 0.
['Get the name of class.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the constructor is public.', 'Get the name of class. -> The name of the class is `Foo`.', 'Check whether the class is public. -> The class `Foo` is public.', 'Get all constructors declared in class. -> There are two constructors: `private Foo() { }` and `public Foo(String param) { }`.', 'Check whether the constructor is private. -> The first constructor is private.', 'Check whether the constructor is public. -> The second constructor is public.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Get the name of class. -> The name of the class is `Foo`.* 匹配到的元操作或API：
logic: Get the name of class. -> The name of the class is `Foo`.
most similar meta operation: Get the name of class
cosine Similarity: 0.889954149723053
*Check whether the class is public. -> The class `Foo` is public.* 匹配到的元操作或API：
logic: Check whether the class is public. -> The class `Foo` is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9065209627151489
*Get all constructors declared in class. -> There are two constructors: `private Foo() { }` and `public Foo(String param) { }`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private. -> The first constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private. -> The first constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9314801096916199
*Check whether the constructor is public. -> The second constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public. -> The second constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.9221858382225037
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}


This checker is failed(false positive) on this positive test case:
```
// One public constructor, not required to be final
public class Foo {
    private Foo() { }
    public Foo(String param) { }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'param')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 2" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 2" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Check whether class has declared constructors.
        3. Get the number of declared constructors.
        4. Iterate through each declared constructor.
        5. Check whether the constructor is private.
        6. Check whether class is public.
        If the class has at least one public constructor and at least one constructor is not private, then this class does not violate the rule.
        
Based on the provided test case:
1. The class name is Foo.
2. The class has declared constructors.
3. The number of declared constructors is 2.
4. Iterating through each constructor:
   5. The first constructor is private.
   6. The second constructor is public.
7. The class is public.
   
Since the class has a public constructor and not all constructors are private, it does not violate the rule. The number of violations in this test case is indeed 0.
['Get the name of class.', 'Check whether class has declared constructors.', 'Get the number of declared constructors.', 'Iterate through each declared constructor.', 'Check whether the constructor is private.', 'Check whether class is public.', 'The class name is Foo.', 'The class has declared constructors.', 'The number of declared constructors is 2.', 'Iterating through each constructor:', 'The first constructor is private.', 'The second constructor is public.', 'The class is public.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether class has declared constructors.* 匹配到的元操作或API：
logic: Check whether class has declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.8889979124069214
*Get the number of declared constructors.* 匹配到的元操作或API：
query: Get the number of declared constructors.
most similar API: get num children of constructor
cosine Similarity: 0.8233407735824585
*Iterate through each declared constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether class is public.* 匹配到的元操作或API：
logic: Check whether class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9831418991088867
*The class name is Foo.* 匹配到的元操作或API：
未匹配成功元操作或API
*The class has declared constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
*The number of declared constructors is 2.* 匹配到的元操作或API：
未匹配成功元操作或API
*Iterating through each constructor:* 匹配到的元操作或API：
query: Iterating through each constructor:
most similar API: get nth parent of constructor
cosine Similarity: 0.8162338733673096
*The first constructor is private.* 匹配到的元操作或API：
query: The first constructor is private.
most similar API: Check whether the constructor is private
cosine Similarity: 0.8183459639549255
*The second constructor is public.* 匹配到的元操作或API：
未匹配成功元操作或API
*The class is public.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}


This checker is failed(false positive) on this positive test case:
```
// One public constructor, not required to be final
public class Foo {
    private Foo() { }
    public Foo(String param) { }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'param')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public int getNumChildren()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.Node getNthParent(int)

1.  //Check whether constructor has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTConstructorDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 2" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 2" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Check whether the class is public.
        2. Get all constructors declared in class.
        3. Loop through each constructor:
            3.1. Check whether the constructor is private.
        4. Determine if there is at least one non-private constructor.
        5. If the class is public and there is at least one non-private constructor, then the class may be extended from outside its compilation unit.

For the provided test case:
1. Check whether the class is public. (True, as class Foo is declared public)
2. Get all constructors declared in class. (There are two constructors: `private Foo()` and `public Foo(String param)`)
3. Loop through each constructor:
    3.1. Check whether the constructor is private. (First constructor is private, second constructor is public)
4. Determine if there is at least one non-private constructor. (True, as the second constructor is public)

Based on the checks, the class `Foo` has a public constructor, which means it can be extended from outside its compilation unit, so it does not violate the rule. The number of violations in this test case is indeed 0.
['Check whether the class is public.', 'Get all constructors declared in class.', 'Loop through each constructor:', 'Check whether the constructor is private.', 'Determine if there is at least one non-private constructor.', 'If the class is public and there is at least one non-private constructor, then the class may be extended from outside its compilation unit.', 'Check whether the class is public. (True, as class Foo is declared public)', 'Get all constructors declared in class. (There are two constructors: `private Foo()` and `public Foo(String param)`)', 'Loop through each constructor:', 'Check whether the constructor is private. (First constructor is private, second constructor is public)', 'Determine if there is at least one non-private constructor. (True, as the second constructor is public)']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Loop through each constructor:* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Determine if there is at least one non-private constructor.* 匹配到的元操作或API：
logic: Determine if there is at least one non-private constructor.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8861942887306213
*If the class is public and there is at least one non-private constructor, then the class may be extended from outside its compilation unit.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is public. (True, as class Foo is declared public)* 匹配到的元操作或API：
logic: Check whether the class is public. (True, as class Foo is declared public)
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9228312373161316
*Get all constructors declared in class. (There are two constructors: `private Foo()` and `public Foo(String param)`)* 匹配到的元操作或API：
query: Get all constructors declared in class. (There are two constructors: `private Foo()` and `public Foo(String param)`)
most similar API: get declared annotations of constructor
cosine Similarity: 0.8020176887512207
*Loop through each constructor:* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private. (First constructor is private, second constructor is public)* 匹配到的元操作或API：
logic: Check whether the constructor is private. (First constructor is private, second constructor is public)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.934274435043335
*Determine if there is at least one non-private constructor. (True, as the second constructor is public)* 匹配到的元操作或API：
logic: Determine if there is at least one non-private constructor. (True, as the second constructor is public)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8805443048477173
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}


This checker is failed(false positive) on this positive test case:
```
// One public constructor, not required to be final
public class Foo {
    private Foo() { }
    public Foo(String param) { }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'param')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract() && classNode.isPublic()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 2" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 2" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Check whether the class is public.
        2. Get all constructors declared in class.
        3. Check whether the constructor is private.
        4. Check whether the constructor is public.
        5. Count the number of public constructors.
        6. Check whether the number of public constructors is greater than 0.
        If the class is public and has at least one public constructor, then this test case does not violate the rule.
            
In this test case:
1. The class `Foo` is public.
2. The first constructor `Foo()` is private.
3. The second constructor `Foo(String param)` is public.
4. There is one public constructor.
5. Since there is one public constructor, the class can be extended from outside its compilation unit, thus it does not violate the rule.
            
The number of violations in this test case is: 0
['Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the constructor is public.', 'Count the number of public constructors.', 'Check whether the number of public constructors is greater than 0.', 'The class `Foo` is public.', 'The first constructor `Foo()` is private.', 'The second constructor `Foo(String param)` is public.', 'There is one public constructor.', 'Since there is one public constructor, the class can be extended from outside its compilation unit, thus it does not violate the rule.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Count the number of public constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the number of public constructors is greater than 0.* 匹配到的元操作或API：
query: Check whether the number of public constructors is greater than 0.
most similar API: Check whether the constructor is public
cosine Similarity: 0.8070359230041504
*The class `Foo` is public.* 匹配到的元操作或API：
未匹配成功元操作或API
*The first constructor `Foo()` is private.* 匹配到的元操作或API：
query: The first constructor `Foo()` is private.
most similar API: Check whether the constructor is private
cosine Similarity: 0.8111959099769592
*The second constructor `Foo(String param)` is public.* 匹配到的元操作或API：
未匹配成功元操作或API
*There is one public constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Since there is one public constructor, the class can be extended from outside its compilation unit, thus it does not violate the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}


This checker is failed(false positive) on this positive test case:
```
// One public constructor, not required to be final
public class Foo {
    private Foo() { }
    public Foo(String param) { }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'param')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract() && classNode.isPublic()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 2" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 2" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is public.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Check whether the constructor is public.
6. Count the number of non-private constructors.

In this test case:
- The class `Foo` has one public constructor and one private constructor.
- Since there is at least one non-private constructor, the class can be extended from outside its compilation unit.
- Therefore, the number of violations of the rule in this test case is: 0.

If the class had only private constructors, then it would be a violation of the rule. However, in this case, the presence of a public constructor means that the class can be extended, and thus, it does not violate the rule.
['Get the name of class.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the constructor is public.', 'Count the number of non-private constructors.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Count the number of non-private constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}


This checker is failed(false positive) on this positive test case:
```
// One public constructor, not required to be final
public class Foo {
    private Foo() { }
    public Foo(String param) { }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'param')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 2" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 2" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 2
[ERROR]   "ok 4" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
94
78
107
91
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Check whether the class has declared annotations.
        3. Get the number of constructors in class.
        4. Get a constructor of class.
        5. Check whether the constructor is private.
        6. Repeat steps 4-5 for each constructor in class.
        7. Check whether the class has declared any inner classes.
        8. Get a declared inner class of class.
        9. Check whether the inner class extends the outer class.
        10. Check whether the inner class is private.
        11. Repeat steps 8-10 for each inner class in class.
        12. Check whether the class has any subclasses outside its compilation unit.
        13. Repeat steps 7-12 for each class in the test case.

In this test case, the outer class `Foo` has a private constructor, which adheres to step 5. However, step 12 checks if there are any subclasses outside its compilation unit. Since `Bar` is defined within the same Java file as `Foo`, it is inside the same compilation unit. Therefore, the class `Foo` can be considered for the rule because it has a private constructor and a subclass within the same compilation unit.

However, the rule specifically mentions that subclasses within the same compilation unit are ignored. Therefore, the test case does not violate the rule.

The number of violations is: 0
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get the number of constructors in class.', 'Get a constructor of class.', 'Check whether the constructor is private.', 'Repeat steps 4-5 for each constructor in class.', 'Check whether the class has declared any inner classes.', 'Get a declared inner class of class.', 'Check whether the inner class extends the outer class.', 'Check whether the inner class is private.', 'Repeat steps 8-10 for each inner class in class.', 'Check whether the class has any subclasses outside its compilation unit.', 'Repeat steps 7-12 for each class in the test case.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the number of constructors in class.* 匹配到的元操作或API：
query: Get the number of constructors in class.
most similar API: get num children of constructor
cosine Similarity: 0.8426800966262817
*Get a constructor of class.* 匹配到的元操作或API：
query: Get a constructor of class.
most similar API: get class of constructor
cosine Similarity: 0.8336949348449707
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Repeat steps 4-5 for each constructor in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has declared any inner classes.* 匹配到的元操作或API：
logic: Check whether the class has declared any inner classes.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8949255347251892
*Get a declared inner class of class.* 匹配到的元操作或API：
query: Get a declared inner class of class.
most similar API: get class of class or interface
cosine Similarity: 0.8176978826522827
*Check whether the inner class extends the outer class.* 匹配到的元操作或API：
logic: Check whether the inner class extends the outer class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8522326350212097
*Check whether the inner class is private.* 匹配到的元操作或API：
logic: Check whether the inner class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9290029406547546
*Repeat steps 8-10 for each inner class in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has any subclasses outside its compilation unit.* 匹配到的元操作或API：
query: Check whether the class has any subclasses outside its compilation unit.
most similar API: Check whether the compilation unit has descendant of type
cosine Similarity: 0.8128633499145508
*Repeat steps 7-12 for each class in the test case.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor
public class Foo {
    private Foo() { }

    public static class Bar extends Foo {
        public Bar() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public int getNumChildren()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.Class<Class<?> getClass()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
8. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean hasDescendantOfType(java.lang.Class)

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal() && !hasNestedSubclass(classNode, node)) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean hasNestedSubclass(ASTClassOrInterfaceDeclaration classNode, ASTCompilationUnit compilationUnit) {
        String className = classNode.getSimpleName();
        for (ASTClassOrInterfaceDeclaration potentialSubclass : compilationUnit.children(ASTClassOrInterfaceDeclaration.class)) {
            if (potentialSubclass.isNested() && potentialSubclass.hasDescendantOfType(ASTExtendsList.class)) {
                for (ASTExtendsList extendsList : potentialSubclass.children(ASTExtendsList.class)) {
                    for (ASTType extendedType : extendsList.children(ASTType.class)) {
                        if (extendedType.getType().getSimpleName().equals(className)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 4" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 4" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get the name of the package where the class is located.
3. Get all constructors declared in class.
4. Check whether a constructor is private.
5. Get the name of the inner class.
6. Get the super class of inner class.
7. Check whether the super class is declared in the same package.
8. Check whether the super class has a private constructor.
9. Check whether the inner class is extending the super class with a private constructor.

For the given test case:
1. Get the name of class: Foo
2. Get the name of the package where the class is located: Assuming it's in some package, let's denote it as `com.example`.
3. Get all constructors declared in class: Foo has one constructor.
4. Check whether a constructor is private: The constructor of Foo is private.
5. Get the name of the inner class: Bar
6. Get the super class of inner class: Bar extends Foo.
7. Check whether the super class is declared in the same package: Yes, Foo is in `com.example`.
8. Check whether the super class has a private constructor: Yes, Foo has a private constructor.
9. Check whether the inner class is extending the super class with a private constructor: Yes, Bar extends Foo which has a private constructor.

Since the inner class `Bar` is in the same compilation unit (package) as the super class `Foo` and `Foo` has a private constructor, the rule does not apply to this test case. Therefore, the number of violations in this test case is 0.
['Get the name of class.', 'Get the name of the package where the class is located.', 'Get all constructors declared in class.', 'Check whether a constructor is private.', 'Get the name of the inner class.', 'Get the super class of inner class.', 'Check whether the super class is declared in the same package.', 'Check whether the super class has a private constructor.', 'Check whether the inner class is extending the super class with a private constructor.', 'Get the name of class: Foo', "Get the name of the package where the class is located: Assuming it's in some package, let's denote it as `com.example`.", 'Get all constructors declared in class: Foo has one constructor.', 'Check whether a constructor is private: The constructor of Foo is private.', 'Get the name of the inner class: Bar', 'Get the super class of inner class: Bar extends Foo.', 'Check whether the super class is declared in the same package: Yes, Foo is in `com.example`.', 'Check whether the super class has a private constructor: Yes, Foo has a private constructor.', 'Check whether the inner class is extending the super class with a private constructor: Yes, Bar extends Foo which has a private constructor.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether a constructor is private.* 匹配到的元操作或API：
logic: Check whether a constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9856699109077454
*Get the name of the inner class.* 匹配到的元操作或API：
logic: Get the name of the inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.878083348274231
*Get the super class of inner class.* 匹配到的元操作或API：
logic: Get the super class of inner class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9238667488098145
*Check whether the super class is declared in the same package.* 匹配到的元操作或API：
query: Check whether the super class is declared in the same package.
most similar API: Check whether is declared in class
cosine Similarity: 0.8013877868652344
*Check whether the super class has a private constructor.* 匹配到的元操作或API：
logic: Check whether the super class has a private constructor.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.88674396276474
*Check whether the inner class is extending the super class with a private constructor.* 匹配到的元操作或API：
query: Check whether the inner class is extending the super class with a private constructor.
most similar API: Check whether the constructor is private
cosine Similarity: 0.8145533204078674
*Get the name of class: Foo* 匹配到的元操作或API：
logic: Get the name of class: Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9263077974319458
*Get the name of the package where the class is located: Assuming it's in some package, let's denote it as `com.example`.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located: Assuming it's in some package, let's denote it as `com.example`.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.8938791155815125
*Get all constructors declared in class: Foo has one constructor.* 匹配到的元操作或API：
query: Get all constructors declared in class: Foo has one constructor.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8044599294662476
*Check whether a constructor is private: The constructor of Foo is private.* 匹配到的元操作或API：
logic: Check whether a constructor is private: The constructor of Foo is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442178010940552
*Get the name of the inner class: Bar* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the super class of inner class: Bar extends Foo.* 匹配到的元操作或API：
logic: Get the super class of inner class: Bar extends Foo.
most similar meta operation: Get the super class of class
cosine Similarity: 0.8681724071502686
*Check whether the super class is declared in the same package: Yes, Foo is in `com.example`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the super class has a private constructor: Yes, Foo has a private constructor.* 匹配到的元操作或API：
logic: Check whether the super class has a private constructor: Yes, Foo has a private constructor.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8688718676567078
*Check whether the inner class is extending the super class with a private constructor: Yes, Bar extends Foo which has a private constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor
public class Foo {
    private Foo() { }

    public static class Bar extends Foo {
        public Bar() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
6. net.sourceforge.pmd.lang.java.types.TypeTestUtil: static public boolean isDeclaredInClass(java.lang.Class, net.sourceforge.pmd.lang.java.types.JMethodSig), //Returns true if the signature is that of a method declared in the given class. @param klass Class @param sig   Method signature to test @throws NullPointerException If any argument is null



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    JClassType classType = classNode.getType();
                    boolean hasSubclassInSameCompilationUnit = false;
                    for (ASTClassOrInterfaceDeclaration subclassNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
                        JClassType superClassType = subclassNode.getSuperClassTypeNode() != null ? subclassNode.getSuperClassTypeNode().getType() : null;
                        if (superClassType != null && superClassType.equals(classType)) {
                            hasSubclassInSameCompilationUnit = true;
                            break;
                        }
                    }
                    if (!hasSubclassInSameCompilationUnit) {
                        addViolation(data, classNode);
                    }
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all constructors of class.
3. Check whether the constructor is private.
4. Get the class that constructor located in.
5. Check whether the class has any subclasses in the same compilation unit.
6. Check whether the class has any subclasses in different compilation units.
If the class has all private constructors and has subclasses in different compilation units, then this class violates the rule.
In this test case:
1. Get the name of class: Foo.
2. Get all constructors of class: Foo().
3. Check whether the constructor is private: True.
4. Get the class that constructor located in: Foo.
5. Check whether the class has any subclasses in the same compilation unit: True (Bar).
6. Check whether the class has any subclasses in different compilation units: False.

Since Foo has a subclass in the same compilation unit (Bar), it does not violate the rule. Therefore, the number of violations in this test case is 0.
['Get the name of class.', 'Get all constructors of class.', 'Check whether the constructor is private.', 'Get the class that constructor located in.', 'Check whether the class has any subclasses in the same compilation unit.', 'Check whether the class has any subclasses in different compilation units.', 'Get the name of class: Foo.', 'Get all constructors of class: Foo().', 'Check whether the constructor is private: True.', 'Get the class that constructor located in: Foo.', 'Check whether the class has any subclasses in the same compilation unit: True (Bar).', 'Check whether the class has any subclasses in different compilation units: False.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all constructors of class.* 匹配到的元操作或API：
query: Get all constructors of class.
most similar API: get class of constructor
cosine Similarity: 0.8041397333145142
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the class that constructor located in.* 匹配到的元操作或API：
logic: Get the class that constructor located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.8542751669883728
*Check whether the class has any subclasses in the same compilation unit.* 匹配到的元操作或API：
query: Check whether the class has any subclasses in the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8382202386856079
*Check whether the class has any subclasses in different compilation units.* 匹配到的元操作或API：
query: Check whether the class has any subclasses in different compilation units.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8205220699310303
*Get the name of class: Foo.* 匹配到的元操作或API：
logic: Get the name of class: Foo.
most similar meta operation: Get the name of class
cosine Similarity: 0.9150534272193909
*Get all constructors of class: Foo().* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: True.* 匹配到的元操作或API：
logic: Check whether the constructor is private: True.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.957306444644928
*Get the class that constructor located in: Foo.* 匹配到的元操作或API：
query: Get the class that constructor located in: Foo.
most similar API: get class of constructor
cosine Similarity: 0.8354803323745728
*Check whether the class has any subclasses in the same compilation unit: True (Bar).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has any subclasses in different compilation units: False.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor
public class Foo {
    private Foo() { }

    public static class Bar extends Foo {
        public Bar() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    boolean hasSubclassInSameCompilationUnit = false;
                    for (ASTClassOrInterfaceDeclaration subclassNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
                        for (ASTClassOrInterfaceType superClassType : subclassNode.children(ASTClassOrInterfaceType.class)) {
                            if (superClassType.isReferenceToClassSameCompilationUnit() && superClassType.getSimpleName().equals(classNode.getSimpleName())) {
                                hasSubclassInSameCompilationUnit = true;
                                break;
                            }
                        }
                        if (hasSubclassInSameCompilationUnit) {
                            break;
                        }
                    }
                    if (!hasSubclassInSameCompilationUnit) {
                        addViolation(data, classNode);
                    }
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 4" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 4" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
To perform the granular checks for the given rule and test case, we need to verify whether the class `Foo` has any private constructors and whether it is being extended from outside its compilation unit. Here's how we can do it:

1. Get the name of class.
2. Get all constructors declared in class Foo.
3. Check whether the constructor is private.
        - If any constructor is private, proceed to the next check.
4. Get all declared inner classes of class Foo.
        - Check whether the inner class extends class Foo.
        - If any inner class extends class Foo, it means the class is being extended within its compilation unit.
5. Get all declared classes in the same compilation unit as class Foo.
        - Check whether any class other than Foo and its inner classes extends class Foo.
        - If any class extends class Foo, it means the class is being extended from outside its compilation unit.
6. Check whether the class has at least one private constructor.
7. Check whether the class has any subclasses from outside its compilation unit.
8. If the class has at least one private constructor and no subclasses from outside its compilation unit, report the class as potentially final.

For the provided test case:

1. Get the name of class.
        - The class name is Foo.
2. Get all constructors declared in class Foo.
        - There is one constructor declared: `private Foo() { }`.
3. Check whether the constructor is private.
        - The constructor is private.
4. Get all declared inner classes of class Foo.
        - There is one inner class declared: `public static class Bar extends Foo { }`.
5. Check whether the inner class extends class Foo.
        - The inner class `Bar` extends `Foo`.
6. Get all declared classes in the same compilation unit as class Foo.
        - The declared classes are `Foo` and `Foo.Bar`.
7. Check whether any class other than Foo and its inner classes extends class Foo.
        - There is no other class outside `Foo` and `Foo.Bar` that extends `Foo`.
8. Check whether the class has at least one private constructor.
        - Yes, `Foo` has a private constructor.
9. Check whether the class has any subclasses from outside its compilation unit.
        - No, `Foo` is only extended by `Bar`, which is an inner class within the same compilation unit.
10. If the class has at least one private constructor and no subclasses from outside its compilation unit, report the class as potentially final.
        - The class `Foo` does not violate the rule because it has a private constructor and all subclasses are within the same compilation unit.

Thus, the number of violations in the test case is 0.
['Get the name of class.', 'Get all constructors declared in class Foo.', 'Check whether the constructor is private.', 'Get all declared inner classes of class Foo.', 'Get all declared classes in the same compilation unit as class Foo.', 'Check whether the class has at least one private constructor.', 'Check whether the class has any subclasses from outside its compilation unit.', 'If the class has at least one private constructor and no subclasses from outside its compilation unit, report the class as potentially final.', 'Get the name of class.', 'Get all constructors declared in class Foo.', 'Check whether the constructor is private.', 'Get all declared inner classes of class Foo.', 'Check whether the inner class extends class Foo.', 'Get all declared classes in the same compilation unit as class Foo.', 'Check whether any class other than Foo and its inner classes extends class Foo.', 'Check whether the class has at least one private constructor.', 'Check whether the class has any subclasses from outside its compilation unit.', 'If the class has at least one private constructor and no subclasses from outside its compilation unit, report the class as potentially final.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all constructors declared in class Foo.* 匹配到的元操作或API：
query: Get all constructors declared in class Foo.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8184826970100403
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get all declared inner classes of class Foo.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all declared classes in the same compilation unit as class Foo.* 匹配到的元操作或API：
query: Get all declared classes in the same compilation unit as class Foo.
most similar API: get class of compilation unit
cosine Similarity: 0.8262948989868164
*Check whether the class has at least one private constructor.* 匹配到的元操作或API：
logic: Check whether the class has at least one private constructor.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8770287036895752
*Check whether the class has any subclasses from outside its compilation unit.* 匹配到的元操作或API：
query: Check whether the class has any subclasses from outside its compilation unit.
most similar API: Check whether the compilation unit has descendant of type
cosine Similarity: 0.8125539422035217
*If the class has at least one private constructor and no subclasses from outside its compilation unit, report the class as potentially final.* 匹配到的元操作或API：
query: If the class has at least one private constructor and no subclasses from outside its compilation unit, report the class as potentially final.
most similar API: Check whether the constructor is final
cosine Similarity: 0.8359953165054321
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all constructors declared in class Foo.* 匹配到的元操作或API：
query: Get all constructors declared in class Foo.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8184826970100403
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get all declared inner classes of class Foo.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class extends class Foo.* 匹配到的元操作或API：
logic: Check whether the inner class extends class Foo.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8694177269935608
*Get all declared classes in the same compilation unit as class Foo.* 匹配到的元操作或API：
query: Get all declared classes in the same compilation unit as class Foo.
most similar API: get class of compilation unit
cosine Similarity: 0.8262948989868164
*Check whether any class other than Foo and its inner classes extends class Foo.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has at least one private constructor.* 匹配到的元操作或API：
logic: Check whether the class has at least one private constructor.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8770287036895752
*Check whether the class has any subclasses from outside its compilation unit.* 匹配到的元操作或API：
query: Check whether the class has any subclasses from outside its compilation unit.
most similar API: Check whether the compilation unit has descendant of type
cosine Similarity: 0.8125539422035217
*If the class has at least one private constructor and no subclasses from outside its compilation unit, report the class as potentially final.* 匹配到的元操作或API：
query: If the class has at least one private constructor and no subclasses from outside its compilation unit, report the class as potentially final.
most similar API: Check whether the constructor is final
cosine Similarity: 0.8359953165054321
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor
public class Foo {
    private Foo() { }

    public static class Bar extends Foo {
        public Bar() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public java.lang.Class<Class<?> getClass()
5. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean hasDescendantOfType(java.lang.Class)
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isFinal()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract() && !classNode.isNested()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal() && !node.hasDescendantOfType(ASTClassOrInterfaceDeclaration.class)) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Get all constructors declared in class.
        3. Check whether the constructor is private.
        4. Check whether there is at least one non-private constructor.
        5. If there is no non-private constructor, get all inner classes declared in class.
        6. Check whether the inner class is extending the outer class.
        7. Check whether the inner class is located in the same compilation unit (same file).

For the given test case:

1. Get the name of class: Foo
2. Get all constructors declared in class: Foo()
3. Check whether the constructor is private: True (Foo() is private)
4. Check whether there is at least one non-private constructor: False (No non-private constructors)
5. Get all inner classes declared in class: Bar
6. Check whether the inner class is extending the outer class: True (Bar extends Foo)
7. Check whether the inner class is located in the same compilation unit (same file): True (Assuming Bar is in the same file as Foo)

Since there is a subclass (Bar) that extends the outer class (Foo) using its private constructor, the class Foo does not violate the rule of being made final due to its constructors being private. Therefore, the number of violations in this test case is indeed 0.
['Get the name of class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether there is at least one non-private constructor.', 'If there is no non-private constructor, get all inner classes declared in class.', 'Check whether the inner class is extending the outer class.', 'Check whether the inner class is located in the same compilation unit (same file).', 'Get the name of class: Foo', 'Get all constructors declared in class: Foo()', 'Check whether the constructor is private: True (Foo() is private)', 'Check whether there is at least one non-private constructor: False (No non-private constructors)', 'Get all inner classes declared in class: Bar', 'Check whether the inner class is extending the outer class: True (Bar extends Foo)', 'Check whether the inner class is located in the same compilation unit (same file): True (Assuming Bar is in the same file as Foo)']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether there is at least one non-private constructor.* 匹配到的元操作或API：
logic: Check whether there is at least one non-private constructor.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8879873156547546
*If there is no non-private constructor, get all inner classes declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is extending the outer class.* 匹配到的元操作或API：
logic: Check whether the inner class is extending the outer class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8529925346374512
*Check whether the inner class is located in the same compilation unit (same file).* 匹配到的元操作或API：
query: Check whether the inner class is located in the same compilation unit (same file).
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8438115119934082
*Get the name of class: Foo* 匹配到的元操作或API：
logic: Get the name of class: Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9263077974319458
*Get all constructors declared in class: Foo()* 匹配到的元操作或API：
query: Get all constructors declared in class: Foo()
most similar API: get declared annotations of constructor
cosine Similarity: 0.8273404240608215
*Check whether the constructor is private: True (Foo() is private)* 匹配到的元操作或API：
logic: Check whether the constructor is private: True (Foo() is private)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9371521472930908
*Check whether there is at least one non-private constructor: False (No non-private constructors)* 匹配到的元操作或API：
logic: Check whether there is at least one non-private constructor: False (No non-private constructors)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8590014576911926
*Get all inner classes declared in class: Bar* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is extending the outer class: True (Bar extends Foo)* 匹配到的元操作或API：
query: Check whether the inner class is extending the outer class: True (Bar extends Foo)
most similar API: Check whether the extends list equals
cosine Similarity: 0.8049197196960449
*Check whether the inner class is located in the same compilation unit (same file): True (Assuming Bar is in the same file as Foo)* 匹配到的元操作或API：
query: Check whether the inner class is located in the same compilation unit (same file): True (Assuming Bar is in the same file as Foo)
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.81754070520401
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor
public class Foo {
    private Foo() { }

    public static class Bar extends Foo {
        public Bar() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot
6. net.sourceforge.pmd.lang.java.ast.ASTExtendsList: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    boolean hasSubclassInSameCompilationUnit = false;
                    for (ASTClassOrInterfaceDeclaration subclassNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
                        if (subclassNode.isNested()) {
                            ASTExtendsList extendsList = subclassNode.getFirstChildOfType(ASTExtendsList.class);
                            if (extendsList != null) {
                                for (ASTClassOrInterfaceType extendsType : extendsList.children(ASTClassOrInterfaceType.class)) {
                                    if (extendsType.isReferenceToClassSameCompilationUnit() && extendsType.getType().getSimpleName().equals(classNode.getSimpleName())) {
                                        hasSubclassInSameCompilationUnit = true;
                                        break;
                                    }
                                }
                            }
                        }
                        if (hasSubclassInSameCompilationUnit) {
                            break;
                        }
                    }
                    if (!hasSubclassInSameCompilationUnit) {
                        addViolation(data, classNode);
                    }
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 4" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 4" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 4
[ERROR]   "ok 5" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
94
78
107
91
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all constructors declared in class.
3. Check whether each constructor is private.
4. If all constructors are private, check whether the class is extended by any class outside the compilation unit.
5. Get all inner classes declared in class.
6. Check whether each inner class is a subclass.
7. If an inner class is a subclass, get the constructor call in the subclass.
8. Check whether the constructor call refers to a private constructor of the outer class.
9. Check whether the subclass is declared within the same compilation unit as the outer class.

For the given test case:

1. Get the name of class: Foo.
2. Get all constructors declared in class: Foo().
3. Check whether each constructor is private: Foo() is not private.
4. Since not all constructors are private, further checks are not needed for Foo.

5. Get all inner classes declared in class: Bar, Barbie.
6. Check whether each inner class is a subclass: Bar is not a subclass, Barbie is a subclass of Bar.
7. If an inner class is a subclass, get the constructor call in the subclass: Barbie has no explicit constructor call.
8. Check whether the constructor call refers to a private constructor of the outer class: Not applicable as Barbie does not have an explicit constructor call.
9. Check whether the subclass is declared within the same compilation unit as the outer class: Barbie is declared within the same compilation unit as Foo.

10. Get the name of class: Bar.
11. Get all constructors declared in class: private Bar().
12. Check whether each constructor is private: Bar() is private.
13. If all constructors are private, check whether the class is extended by any class outside the compilation unit: Bar is extended by Barbie, but Barbie is within the same compilation unit.
14. Get all inner classes declared in class: Barbie.
15. Check whether each inner class is a subclass: Barbie is a subclass of Bar.
16. If an inner class is a subclass, get the constructor call in the subclass: Barbie has a public Barbie().
17. Check whether the constructor call refers to a private constructor of the outer class: Not applicable as Barbie does not call Bar's private constructor directly.
18. Check whether the subclass is declared within the same compilation unit as the outer class: Barbie is declared within the same compilation unit as Bar.

19. Get the name of class: Barbie.
20. Get the super class of class: Bar.
21. Check whether the super class has a private constructor: Bar has a private constructor.
22. Get all constructors declared in class: public Barbie().
23. Check whether the constructor is trying to call a private constructor of the super class: Not applicable as the constructor call is not shown in the provided snippet, but based on the description, it is clear that Barbie is not calling Bar's private constructor.
24. Check whether the subclass is declared within the same compilation unit as the outer class: Barbie is declared within the same compilation unit as Bar.

Based on the provided test case and the rule description, the number of classes violating the rule is 0. The class Foo does not have all private constructors, and Barbie, which is a subclass of Bar, is within the same compilation unit and does not attempt to call Bar's private constructor directly.
['Get the name of class.', 'Get all constructors declared in class.', 'Check whether each constructor is private.', 'If all constructors are private, check whether the class is extended by any class outside the compilation unit.', 'Get all inner classes declared in class.', 'Check whether each inner class is a subclass.', 'If an inner class is a subclass, get the constructor call in the subclass.', 'Check whether the constructor call refers to a private constructor of the outer class.', 'Check whether the subclass is declared within the same compilation unit as the outer class.', 'Get the name of class: Foo.', 'Get all constructors declared in class: Foo().', 'Check whether each constructor is private: Foo() is not private.', 'Since not all constructors are private, further checks are not needed for Foo.', 'Get all inner classes declared in class: Bar, Barbie.', 'Check whether each inner class is a subclass: Bar is not a subclass, Barbie is a subclass of Bar.', 'If an inner class is a subclass, get the constructor call in the subclass: Barbie has no explicit constructor call.', 'Check whether the constructor call refers to a private constructor of the outer class: Not applicable as Barbie does not have an explicit constructor call.', 'Check whether the subclass is declared within the same compilation unit as the outer class: Barbie is declared within the same compilation unit as Foo.', 'Get the name of class: Bar.', 'Get all constructors declared in class: private Bar().', 'Check whether each constructor is private: Bar() is private.', 'If all constructors are private, check whether the class is extended by any class outside the compilation unit: Bar is extended by Barbie, but Barbie is within the same compilation unit.', 'Get all inner classes declared in class: Barbie.', 'Check whether each inner class is a subclass: Barbie is a subclass of Bar.', 'If an inner class is a subclass, get the constructor call in the subclass: Barbie has a public Barbie().', "Check whether the constructor call refers to a private constructor of the outer class: Not applicable as Barbie does not call Bar's private constructor directly.", 'Check whether the subclass is declared within the same compilation unit as the outer class: Barbie is declared within the same compilation unit as Bar.', 'Get the name of class: Barbie.', 'Get the super class of class: Bar.', 'Check whether the super class has a private constructor: Bar has a private constructor.', 'Get all constructors declared in class: public Barbie().', "Check whether the constructor is trying to call a private constructor of the super class: Not applicable as the constructor call is not shown in the provided snippet, but based on the description, it is clear that Barbie is not calling Bar's private constructor.", 'Check whether the subclass is declared within the same compilation unit as the outer class: Barbie is declared within the same compilation unit as Bar.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether each constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442476630210876
*If all constructors are private, check whether the class is extended by any class outside the compilation unit.* 匹配到的元操作或API：
query: If all constructors are private, check whether the class is extended by any class outside the compilation unit.
most similar API: Check whether the constructor is private
cosine Similarity: 0.8434821367263794
*Get all inner classes declared in class.* 匹配到的元操作或API：
query: Get all inner classes declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8037846684455872
*Check whether each inner class is a subclass.* 匹配到的元操作或API：
logic: Check whether each inner class is a subclass.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8977389335632324
*If an inner class is a subclass, get the constructor call in the subclass.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor call refers to a private constructor of the outer class.* 匹配到的元操作或API：
query: Check whether the constructor call refers to a private constructor of the outer class.
most similar API: Check whether the constructor is private
cosine Similarity: 0.8441858887672424
*Check whether the subclass is declared within the same compilation unit as the outer class.* 匹配到的元操作或API：
query: Check whether the subclass is declared within the same compilation unit as the outer class.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8410360217094421
*Get the name of class: Foo.* 匹配到的元操作或API：
logic: Get the name of class: Foo.
most similar meta operation: Get the name of class
cosine Similarity: 0.9150534272193909
*Get all constructors declared in class: Foo().* 匹配到的元操作或API：
query: Get all constructors declared in class: Foo().
most similar API: get declared annotations of constructor
cosine Similarity: 0.8027556538581848
*Check whether each constructor is private: Foo() is not private.* 匹配到的元操作或API：
logic: Check whether each constructor is private: Foo() is not private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9156093597412109
*Since not all constructors are private, further checks are not needed for Foo.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all inner classes declared in class: Bar, Barbie.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each inner class is a subclass: Bar is not a subclass, Barbie is a subclass of Bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*If an inner class is a subclass, get the constructor call in the subclass: Barbie has no explicit constructor call.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor call refers to a private constructor of the outer class: Not applicable as Barbie does not have an explicit constructor call.* 匹配到的元操作或API：
query: Check whether the constructor call refers to a private constructor of the outer class: Not applicable as Barbie does not have an explicit constructor call.
most similar API: Check whether the constructor is private
cosine Similarity: 0.8125237226486206
*Check whether the subclass is declared within the same compilation unit as the outer class: Barbie is declared within the same compilation unit as Foo.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: Bar.* 匹配到的元操作或API：
logic: Get the name of class: Bar.
most similar meta operation: Get the name of class
cosine Similarity: 0.8558183908462524
*Get all constructors declared in class: private Bar().* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each constructor is private: Bar() is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private: Bar() is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8940434455871582
*If all constructors are private, check whether the class is extended by any class outside the compilation unit: Bar is extended by Barbie, but Barbie is within the same compilation unit.* 匹配到的元操作或API：
query: If all constructors are private, check whether the class is extended by any class outside the compilation unit: Bar is extended by Barbie, but Barbie is within the same compilation unit.
most similar API: Check whether the constructor is private
cosine Similarity: 0.8002604246139526
*Get all inner classes declared in class: Barbie.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each inner class is a subclass: Barbie is a subclass of Bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*If an inner class is a subclass, get the constructor call in the subclass: Barbie has a public Barbie().* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor call refers to a private constructor of the outer class: Not applicable as Barbie does not call Bar's private constructor directly.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass is declared within the same compilation unit as the outer class: Barbie is declared within the same compilation unit as Bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: Barbie.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the super class of class: Bar.* 匹配到的元操作或API：
logic: Get the super class of class: Bar.
most similar meta operation: Get the super class of class
cosine Similarity: 0.8875105381011963
*Check whether the super class has a private constructor: Bar has a private constructor.* 匹配到的元操作或API：
query: Check whether the super class has a private constructor: Bar has a private constructor.
most similar API: Check whether the constructor is private
cosine Similarity: 0.8418800234794617
*Get all constructors declared in class: public Barbie().* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is trying to call a private constructor of the super class: Not applicable as the constructor call is not shown in the provided snippet, but based on the description, it is clear that Barbie is not calling Bar's private constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass is declared within the same compilation unit as the outer class: Barbie is declared within the same compilation unit as Bar.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor of another subclass
public class Foo {
    public Foo() { }

    public static class Bar {
        private Bar() { }
    }

    public static class Barbie extends Bar {
        public Barbie() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Barbie')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    boolean isSubclassedInSameCompilationUnit = false;
                    for (ASTClassOrInterfaceDeclaration subclassNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
                        ASTExtendsList extendsList = subclassNode.getFirstChildOfType(ASTExtendsList.class);
                        if (extendsList != null) {
                            for (ASTClassOrInterfaceType superClassType : extendsList.children(ASTClassOrInterfaceType.class)) {
                                if (superClassType.isReferenceToClassSameCompilationUnit() && superClassType.getType().getSimpleName().equals(classNode.getSimpleName())) {
                                    isSubclassedInSameCompilationUnit = true;
                                    break;
                                }
                            }
                        }
                        if (isSubclassedInSameCompilationUnit) {
                            break;
                        }
                    }
                    if (!isSubclassedInSameCompilationUnit) {
                        addViolation(data, classNode);
                    }
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 5" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 5" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get all constructors declared in class.
3. Check whether the constructor is private.
4. Get the name of the package where the class is located.
5. Get all subclasses declared in the class.
6. Check whether the subclass is declared in the same package.
7. If the class has a constructor and all constructors are private, check whether there are any subclasses declared in the same compilation unit.

Let's perform these checks for the given test case:

1. Get the name of class.
   - Class name: Foo

2. Get all constructors declared in class.
   - Constructors: Foo()

3. Check whether the constructor is private.
   - Constructor Foo(): Not private

Since the constructor of `Foo` is not private, we can conclude that `Foo` does not meet the criteria for being reported by this rule. However, let's continue checking the nested classes `Bar` and `Barbie`:

1. Get the name of class.
   - Class name: Bar

2. Get all constructors declared in class.
   - Constructors: Bar()

3. Check whether the constructor is private.
   - Constructor Bar(): Private

4. Get the name of the package where the class is located.
   - Package: default (since no package is specified)

5. Get all subclasses declared in the class.
   - Subclasses: Barbie

6. Check whether the subclass is declared in the same package.
   - Barbie is declared in the same package (default)

7. If the class has a constructor and all constructors are private, check whether there are any subclasses declared in the same compilation unit.
   - Bar has a private constructor, and Barbie is a subclass declared in the same compilation unit.

Since `Bar` has a private constructor and `Barbie` is a subclass declared in the same compilation unit, the rule is not violated for `Bar`.

1. Get the name of class.
   - Class name: Barbie

2. Get all constructors declared in class.
   - Constructors: Barbie()

3. Check whether the constructor is private.
   - Constructor Barbie(): Not private

Since `Barbie` has a non-private constructor, it does not meet the criteria for being reported by this rule either.

Therefore, the number of classes violating the rule in this test case is: 0
['Get the name of class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get the name of the package where the class is located.', 'Get all subclasses declared in the class.', 'Check whether the subclass is declared in the same package.', 'If the class has a constructor and all constructors are private, check whether there are any subclasses declared in the same compilation unit.', 'Get the name of class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get the name of class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get the name of the package where the class is located.', 'Get all subclasses declared in the class.', 'Check whether the subclass is declared in the same package.', 'If the class has a constructor and all constructors are private, check whether there are any subclasses declared in the same compilation unit.', 'Get the name of class.', 'Get all constructors declared in class.', 'Check whether the constructor is private.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Get all subclasses declared in the class.* 匹配到的元操作或API：
query: Get all subclasses declared in the class.
most similar API: get permitted subclasses of class or interface
cosine Similarity: 0.8221598863601685
*Check whether the subclass is declared in the same package.* 匹配到的元操作或API：
query: Check whether the subclass is declared in the same package.
most similar API: Check whether is declared in class
cosine Similarity: 0.8143336176872253
*If the class has a constructor and all constructors are private, check whether there are any subclasses declared in the same compilation unit.* 匹配到的元操作或API：
query: If the class has a constructor and all constructors are private, check whether there are any subclasses declared in the same compilation unit.
most similar API: Check whether the constructor is private
cosine Similarity: 0.8481019139289856
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Get all subclasses declared in the class.* 匹配到的元操作或API：
query: Get all subclasses declared in the class.
most similar API: get permitted subclasses of class or interface
cosine Similarity: 0.8221598863601685
*Check whether the subclass is declared in the same package.* 匹配到的元操作或API：
query: Check whether the subclass is declared in the same package.
most similar API: Check whether is declared in class
cosine Similarity: 0.8143336176872253
*If the class has a constructor and all constructors are private, check whether there are any subclasses declared in the same compilation unit.* 匹配到的元操作或API：
query: If the class has a constructor and all constructors are private, check whether there are any subclasses declared in the same compilation unit.
most similar API: Check whether the constructor is private
cosine Similarity: 0.8481019139289856
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor of another subclass
public class Foo {
    public Foo() { }

    public static class Bar {
        private Bar() { }
    }

    public static class Barbie extends Bar {
        public Barbie() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Barbie')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.util.List<ASTClassOrInterfaceType> getPermittedSubclasses()
6. net.sourceforge.pmd.lang.java.types.TypeTestUtil: static public boolean isDeclaredInClass(java.lang.Class, net.sourceforge.pmd.lang.java.types.JMethodSig), //Returns true if the signature is that of a method declared in the given class. @param klass Class @param sig   Method signature to test @throws NullPointerException If any argument is null



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    JClassType classType = classNode.getType();
                    boolean canBeExtendedOutside = false;
                    for (ASTClassOrInterfaceDeclaration otherClassNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
                        if (!otherClassNode.equals(classNode)) {
                            for (ASTConstructorDeclaration otherConstructor : otherClassNode.children(ASTConstructorDeclaration.class)) {
                                if (!otherConstructor.isPrivate()) {
                                    canBeExtendedOutside = true;
                                    break;
                                }
                            }
                            if (canBeExtendedOutside) break;
                        }
                    }
                    if (!canBeExtendedOutside) {
                        addViolation(data, classNode);
                    }
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether class has declared annotations.
3. Check whether the class is abstract.
4. Check whether the class is public.
5. Get all constructors declared in class.
6. Check whether the constructor is private.
7. Check whether the class is static.
8. Get the name of the package where the class is located.
9. Get all inner classes declared in class.
10. Check whether inner class has declared annotations.
11. Check whether inner class is abstract.
12. Check whether inner class is public.
13. Get all constructors declared in inner class.
14. Check whether the constructor is private.
15. Check whether the inner class is static.
16. Get the name of the package where the inner class is located.
17. Get all inner class declarations in the class.
18. For each inner class, check whether it extends another class.
19. For each superclass, check whether its constructor is private.
20. Check whether the superclass is in the same package as the inner class.

For the given test case:
1. Get the name of class: Foo
2. Check whether class has declared annotations: False
3. Check whether the class is abstract: False
4. Check whether the class is public: True
5. Get all constructors declared in class: public Foo() { }
6. Check whether the constructor is private: False
7. Check whether the class is static: False
8. Get the name of the package where the class is located: Not specified, but it's the same package.
9. Get all inner classes declared in class: Bar, Barbie
10. Check whether inner class has declared annotations (Bar): False
11. Check whether inner class is abstract (Bar): False
12. Check whether inner class is public (Bar): True
13. Get all constructors declared in inner class (Bar): private Bar() { }
14. Check whether the constructor is private (Bar): True
15. Check whether the inner class is static (Bar): True
16. Get the name of the package where the inner class is located (Bar): Not specified, but it's the same package.
17. Check whether inner class has declared annotations (Barbie): False
18. Check whether inner class is abstract (Barbie): False
19. Check whether inner class is public (Barbie): True
20. Get all constructors declared in inner class (Barbie): public Barbie() { }
21. Check whether the constructor is private (Barbie): False
22. Check whether the inner class is static (Barbie): True
23. Get the name of the package where the inner class is located (Barbie): Not specified, but it's the same package.
24. Get all inner class declarations in the class: Bar, Barbie
25. For each inner class, check whether it extends another class (Barbie extends Bar): True
26. For each superclass, check whether its constructor is private (Bar's constructor is private): True
27. Check whether the superclass is in the same package as the inner class (Bar and Barbie are in the same package): True

In this case, Barbie is a subclass that uses a private constructor from its superclass Bar, which is in the same package. Therefore, the test case does not violate the rule because the subclass is still able to use the private constructor within the same compilation unit. The number of violations is 0.
['Get the name of class.', 'Check whether class has declared annotations.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is static.', 'Get the name of the package where the class is located.', 'Get all inner classes declared in class.', 'Check whether inner class has declared annotations.', 'Check whether inner class is abstract.', 'Check whether inner class is public.', 'Get all constructors declared in inner class.', 'Check whether the constructor is private.', 'Check whether the inner class is static.', 'Get the name of the package where the inner class is located.', 'Get all inner class declarations in the class.', 'For each inner class, check whether it extends another class.', 'For each superclass, check whether its constructor is private.', 'Check whether the superclass is in the same package as the inner class.', 'Get the name of class: Foo', 'Check whether class has declared annotations: False', 'Check whether the class is abstract: False', 'Check whether the class is public: True', 'Get all constructors declared in class: public Foo() { }', 'Check whether the constructor is private: False', 'Check whether the class is static: False', "Get the name of the package where the class is located: Not specified, but it's the same package.", 'Get all inner classes declared in class: Bar, Barbie', 'Check whether inner class has declared annotations (Bar): False', 'Check whether inner class is abstract (Bar): False', 'Check whether inner class is public (Bar): True', 'Get all constructors declared in inner class (Bar): private Bar() { }', 'Check whether the constructor is private (Bar): True', 'Check whether the inner class is static (Bar): True', "Get the name of the package where the inner class is located (Bar): Not specified, but it's the same package.", 'Check whether inner class has declared annotations (Barbie): False', 'Check whether inner class is abstract (Barbie): False', 'Check whether inner class is public (Barbie): True', 'Get all constructors declared in inner class (Barbie): public Barbie() { }', 'Check whether the constructor is private (Barbie): False', 'Check whether the inner class is static (Barbie): True', "Get the name of the package where the inner class is located (Barbie): Not specified, but it's the same package.", 'Get all inner class declarations in the class: Bar, Barbie', 'For each inner class, check whether it extends another class (Barbie extends Bar): True', "For each superclass, check whether its constructor is private (Bar's constructor is private): True", 'Check whether the superclass is in the same package as the inner class (Bar and Barbie are in the same package): True']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether class has declared annotations.* 匹配到的元操作或API：
logic: Check whether class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9901518821716309
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Get all inner classes declared in class.* 匹配到的元操作或API：
query: Get all inner classes declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8037846684455872
*Check whether inner class has declared annotations.* 匹配到的元操作或API：
logic: Check whether inner class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9293761849403381
*Check whether inner class is abstract.* 匹配到的元操作或API：
logic: Check whether inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9198651313781738
*Check whether inner class is public.* 匹配到的元操作或API：
logic: Check whether inner class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9126129150390625
*Get all constructors declared in inner class.* 匹配到的元操作或API：
query: Get all constructors declared in inner class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8095777034759521
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the inner class is static.* 匹配到的元操作或API：
logic: Check whether the inner class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9092438220977783
*Get the name of the package where the inner class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the inner class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9266864657402039
*Get all inner class declarations in the class.* 匹配到的元操作或API：
query: Get all inner class declarations in the class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8531970977783203
*For each inner class, check whether it extends another class.* 匹配到的元操作或API：
logic: For each inner class, check whether it extends another class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8548963069915771
*For each superclass, check whether its constructor is private.* 匹配到的元操作或API：
logic: For each superclass, check whether its constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8982240557670593
*Check whether the superclass is in the same package as the inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: Foo* 匹配到的元操作或API：
logic: Get the name of class: Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9263077974319458
*Check whether class has declared annotations: False* 匹配到的元操作或API：
logic: Check whether class has declared annotations: False
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.972063422203064
*Check whether the class is abstract: False* 匹配到的元操作或API：
logic: Check whether the class is abstract: False
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9601572751998901
*Check whether the class is public: True* 匹配到的元操作或API：
logic: Check whether the class is public: True
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9707064628601074
*Get all constructors declared in class: public Foo() { }* 匹配到的元操作或API：
query: Get all constructors declared in class: public Foo() { }
most similar API: get declared annotations of constructor
cosine Similarity: 0.8474277853965759
*Check whether the constructor is private: False* 匹配到的元操作或API：
logic: Check whether the constructor is private: False
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9771820306777954
*Check whether the class is static: False* 匹配到的元操作或API：
logic: Check whether the class is static: False
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9610258340835571
*Get the name of the package where the class is located: Not specified, but it's the same package.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located: Not specified, but it's the same package.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9343446493148804
*Get all inner classes declared in class: Bar, Barbie* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether inner class has declared annotations (Bar): False* 匹配到的元操作或API：
logic: Check whether inner class has declared annotations (Bar): False
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.8855811357498169
*Check whether inner class is abstract (Bar): False* 匹配到的元操作或API：
logic: Check whether inner class is abstract (Bar): False
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.8742210865020752
*Check whether inner class is public (Bar): True* 匹配到的元操作或API：
logic: Check whether inner class is public (Bar): True
most similar meta operation: Check whether the class is public
cosine Similarity: 0.8720147013664246
*Get all constructors declared in inner class (Bar): private Bar() { }* 匹配到的元操作或API：
query: Get all constructors declared in inner class (Bar): private Bar() { }
most similar API: get declared annotations of constructor
cosine Similarity: 0.8135519623756409
*Check whether the constructor is private (Bar): True* 匹配到的元操作或API：
logic: Check whether the constructor is private (Bar): True
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9274352788925171
*Check whether the inner class is static (Bar): True* 匹配到的元操作或API：
logic: Check whether the inner class is static (Bar): True
most similar meta operation: Check whether the class is static
cosine Similarity: 0.8736209273338318
*Get the name of the package where the inner class is located (Bar): Not specified, but it's the same package.* 匹配到的元操作或API：
logic: Get the name of the package where the inner class is located (Bar): Not specified, but it's the same package.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.8695307970046997
*Check whether inner class has declared annotations (Barbie): False* 匹配到的元操作或API：
logic: Check whether inner class has declared annotations (Barbie): False
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.8682429194450378
*Check whether inner class is abstract (Barbie): False* 匹配到的元操作或API：
query: Check whether inner class is abstract (Barbie): False
most similar API: Check whether the class or interface is abstract
cosine Similarity: 0.8208306431770325
*Check whether inner class is public (Barbie): True* 匹配到的元操作或API：
logic: Check whether inner class is public (Barbie): True
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8520656824111938
*Get all constructors declared in inner class (Barbie): public Barbie() { }* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private (Barbie): False* 匹配到的元操作或API：
logic: Check whether the constructor is private (Barbie): False
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9059344530105591
*Check whether the inner class is static (Barbie): True* 匹配到的元操作或API：
query: Check whether the inner class is static (Barbie): True
most similar API: Check whether the class or interface is static
cosine Similarity: 0.8126276135444641
*Get the name of the package where the inner class is located (Barbie): Not specified, but it's the same package.* 匹配到的元操作或API：
logic: Get the name of the package where the inner class is located (Barbie): Not specified, but it's the same package.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.8521578907966614
*Get all inner class declarations in the class: Bar, Barbie* 匹配到的元操作或API：
query: Get all inner class declarations in the class: Bar, Barbie
most similar API: get declarations of class or interface
cosine Similarity: 0.8098722696304321
*For each inner class, check whether it extends another class (Barbie extends Bar): True* 匹配到的元操作或API：
未匹配成功元操作或API
*For each superclass, check whether its constructor is private (Bar's constructor is private): True* 匹配到的元操作或API：
logic: For each superclass, check whether its constructor is private (Bar's constructor is private): True
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8564488291740417
*Check whether the superclass is in the same package as the inner class (Bar and Barbie are in the same package): True* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor of another subclass
public class Foo {
    public Foo() { }

    public static class Bar {
        private Bar() { }
    }

    public static class Barbie extends Bar {
        public Barbie() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Barbie')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract(), //Returns true if this is an abstract type. Interfaces and annotations types are implicitly abstract.

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    if (!canBeSubclassedOutsideCompilationUnit(classNode, node)) {
                        addViolation(data, classNode);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean canBeSubclassedOutsideCompilationUnit(ASTClassOrInterfaceDeclaration classNode, ASTCompilationUnit compilationUnit) {
        if (classNode.isNested() && !classNode.isStatic()) {
            return true;
        }
        for (ASTClassOrInterfaceDeclaration otherClassNode : compilationUnit.children(ASTClassOrInterfaceDeclaration.class)) {
            if (otherClassNode != classNode && otherClassNode.extendsType(classNode.getSimpleName())) {
                return true;
            }
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To ascertain whether the provided test case adheres to the rule, let's perform the following granular checks:

1. Get the name of class.
        2. Check whether the class is public.
        3. Get all constructors declared in class.
        4. Check whether the constructor is private.
        5. Get all nested classes declared in class.
        6. Check whether nested class is public.
        7. Get all constructors declared in nested class.
        8. Check whether the nested class constructor is private.
        9. Check whether the nested class has any super classes.
        10. Get the super class of nested class.
        11. Check whether the super class constructor is private.
        12. Check whether the super class is declared within the same compilation unit.

Let's apply these checks to the provided code:

1. Get the name of class: Foo
2. Check whether the class is public: True
3. Get all constructors declared in class Foo: public Foo()
4. Check whether the constructor is private: False (public Foo() constructor)
5. Get all nested classes declared in class Foo: Bar, Barbie
6. Check whether nested class Bar is public: True
7. Get all constructors declared in nested class Bar: private Bar()
8. Check whether the nested class Bar constructor is private: True
9. Check whether the nested class Bar has any super classes: True (inherits from Object)
10. Get the super class of nested class Bar: Object
11. Check whether the super class constructor is private: False (Object's constructor is public)
12. Check whether the super class is declared within the same compilation unit: False (Object is not declared in the same compilation unit)

6. Check whether nested class Barbie is public: True
7. Get all constructors declared in nested class Barbie: public Barbie()
8. Check whether the nested class Barbie constructor is private: False
9. Check whether the nested class Barbie has any super classes: True (inherits from Bar)
10. Get the super class of nested class Barbie: Bar
11. Check whether the super class constructor is private: True (Bar's constructor is private)
12. Check whether the super class is declared within the same compilation unit: True (Bar is declared in the same compilation unit)

Given the checks, the nested class `Barbie` extends `Bar`, which has a private constructor. However, since `Bar` is declared within the same compilation unit, it is possible to create a subclass `Barbie` that calls the private constructor of `Bar`. Therefore, the class `Foo` does not violate the rule as there is a subclass `Barbie` that can extend `Bar` within the same compilation unit.

The number of violations in this test case is: 0
['Get the name of class.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get all nested classes declared in class.', 'Check whether nested class is public.', 'Get all constructors declared in nested class.', 'Check whether the nested class constructor is private.', 'Check whether the nested class has any super classes.', 'Get the super class of nested class.', 'Check whether the super class constructor is private.', 'Check whether the super class is declared within the same compilation unit.', 'Get the name of class: Foo', 'Check whether the class is public: True', 'Get all constructors declared in class Foo: public Foo()', 'Check whether the constructor is private: False (public Foo() constructor)', 'Get all nested classes declared in class Foo: Bar, Barbie', 'Check whether nested class Bar is public: True', 'Get all constructors declared in nested class Bar: private Bar()', 'Check whether the nested class Bar constructor is private: True', 'Check whether the nested class Bar has any super classes: True (inherits from Object)', 'Get the super class of nested class Bar: Object', "Check whether the super class constructor is private: False (Object's constructor is public)", 'Check whether the super class is declared within the same compilation unit: False (Object is not declared in the same compilation unit)', 'Check whether nested class Barbie is public: True', 'Get all constructors declared in nested class Barbie: public Barbie()', 'Check whether the nested class Barbie constructor is private: False', 'Check whether the nested class Barbie has any super classes: True (inherits from Bar)', 'Get the super class of nested class Barbie: Bar', "Check whether the super class constructor is private: True (Bar's constructor is private)", 'Check whether the super class is declared within the same compilation unit: True (Bar is declared in the same compilation unit)']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get all nested classes declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether nested class is public.* 匹配到的元操作或API：
logic: Check whether nested class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9152304530143738
*Get all constructors declared in nested class.* 匹配到的元操作或API：
query: Get all constructors declared in nested class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8004669547080994
*Check whether the nested class constructor is private.* 匹配到的元操作或API：
logic: Check whether the nested class constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9357007741928101
*Check whether the nested class has any super classes.* 匹配到的元操作或API：
query: Check whether the nested class has any super classes.
most similar API: Check whether the class or interface is nested
cosine Similarity: 0.8314303755760193
*Get the super class of nested class.* 匹配到的元操作或API：
logic: Get the super class of nested class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9103674292564392
*Check whether the super class constructor is private.* 匹配到的元操作或API：
logic: Check whether the super class constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9259912371635437
*Check whether the super class is declared within the same compilation unit.* 匹配到的元操作或API：
query: Check whether the super class is declared within the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8411706686019897
*Get the name of class: Foo* 匹配到的元操作或API：
logic: Get the name of class: Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9263077974319458
*Check whether the class is public: True* 匹配到的元操作或API：
logic: Check whether the class is public: True
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9707064628601074
*Get all constructors declared in class Foo: public Foo()* 匹配到的元操作或API：
query: Get all constructors declared in class Foo: public Foo()
most similar API: get declared annotations of constructor
cosine Similarity: 0.8321502804756165
*Check whether the constructor is private: False (public Foo() constructor)* 匹配到的元操作或API：
logic: Check whether the constructor is private: False (public Foo() constructor)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9433282017707825
*Get all nested classes declared in class Foo: Bar, Barbie* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether nested class Bar is public: True* 匹配到的元操作或API：
logic: Check whether nested class Bar is public: True
most similar meta operation: Check whether the class is public
cosine Similarity: 0.866420567035675
*Get all constructors declared in nested class Bar: private Bar()* 匹配到的元操作或API：
query: Get all constructors declared in nested class Bar: private Bar()
most similar API: get declared annotations of constructor
cosine Similarity: 0.8020159006118774
*Check whether the nested class Bar constructor is private: True* 匹配到的元操作或API：
logic: Check whether the nested class Bar constructor is private: True
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8834487199783325
*Check whether the nested class Bar has any super classes: True (inherits from Object)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the super class of nested class Bar: Object* 匹配到的元操作或API：
logic: Get the super class of nested class Bar: Object
most similar meta operation: Get the super class of class
cosine Similarity: 0.8517828583717346
*Check whether the super class constructor is private: False (Object's constructor is public)* 匹配到的元操作或API：
logic: Check whether the super class constructor is private: False (Object's constructor is public)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8997547030448914
*Check whether the super class is declared within the same compilation unit: False (Object is not declared in the same compilation unit)* 匹配到的元操作或API：
query: Check whether the super class is declared within the same compilation unit: False (Object is not declared in the same compilation unit)
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8087548613548279
*Check whether nested class Barbie is public: True* 匹配到的元操作或API：
query: Check whether nested class Barbie is public: True
most similar API: Check whether the class or interface is public
cosine Similarity: 0.8074596524238586
*Get all constructors declared in nested class Barbie: public Barbie()* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the nested class Barbie constructor is private: False* 匹配到的元操作或API：
logic: Check whether the nested class Barbie constructor is private: False
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8535086512565613
*Check whether the nested class Barbie has any super classes: True (inherits from Bar)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the super class of nested class Barbie: Bar* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the super class constructor is private: True (Bar's constructor is private)* 匹配到的元操作或API：
logic: Check whether the super class constructor is private: True (Bar's constructor is private)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8701012134552002
*Check whether the super class is declared within the same compilation unit: True (Bar is declared in the same compilation unit)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor of another subclass
public class Foo {
    public Foo() { }

    public static class Bar {
        private Bar() { }
    }

    public static class Barbie extends Bar {
        public Barbie() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Barbie')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested(), //Returns true if this type declaration is nested inside an interface, class or annotation.
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    boolean canBeExtendedOutside = false;
                    for (ASTClassOrInterfaceDeclaration subclassNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
                        ASTClassOrInterfaceType superClassType = subclassNode.getSuperClassTypeNode();
                        if (superClassType != null && superClassType.getSimpleName().equals(classNode.getSimpleName()) && !superClassType.isReferenceToClassSameCompilationUnit()) {
                            canBeExtendedOutside = true;
                            break;
                        }
                    }
                    if (!canBeExtendedOutside) {
                        addViolation(data, classNode);
                    }
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 5" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 5" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is final.
3. Get all constructors declared in class.
4. Check whether the constructor is private for each constructor.
5. Check whether the class has any subclasses declared within the same compilation unit.
6. Check whether the subclass has a constructor that calls the superclass constructor.
7. If the class is not final, check if all its constructors are private.
8. If all constructors are private, check if any subclasses are declared within the same compilation unit.
9. If subclasses are declared within the same compilation unit, check if they have constructors that call the superclass constructor.

Let's apply these checks to the provided test case:

1. Get the name of class.
   - The class name is Foo.

2. Check whether the class is final.
   - Foo is not final.

3. Get all constructors declared in class.
   - Foo has one public constructor `public Foo() { }`.

4. Check whether the constructor is private for each constructor.
   - The constructor in Foo is not private.

Since Foo has a public constructor, it does not violate the rule. Now, let's check the inner classes Bar and Barbie:

1. Get the name of class.
   - The class name is Bar.

2. Check whether the class is final.
   - Bar is not final.

3. Get all constructors declared in class.
   - Bar has one private constructor `private Bar() { }`.

4. Check whether the constructor is private for each constructor.
   - The constructor in Bar is private.

5. Check whether the class has any subclasses declared within the same compilation unit.
   - Bar has a subclass Barbie declared within the same compilation unit.

6. Check whether the subclass has a constructor that calls the superclass constructor.
   - Barbie has a constructor `public Barbie() { }` but it does not explicitly call the superclass constructor, which is private. This implies that the subclass cannot instantiate the superclass due to the private constructor.

Given that Bar has a private constructor and a subclass within the same compilation unit, it violates the rule because the subclass cannot extend it due to the private constructor.

So, the number of violating the rule in this test case is: 1

To clarify, let's recheck Barbie:

1. Get the name of class.
   - The class name is Barbie.

2. Check whether the class is final.
   - Barbie is not final.

3. Get all constructors declared in class.
   - Barbie has one public constructor `public Barbie() { }`.

4. Check whether the constructor is private for each constructor.
   - The constructor in Barbie is not private.

5. Check whether the class has any subclasses declared within the same compilation unit.
   - Barbie does not have any subclasses declared within the same compilation unit.

6. Check whether the subclass has a constructor that calls the superclass constructor.
   - Barbie's constructor does not call the superclass constructor.

Barbie does not violate the rule because it is not a superclass with private constructors that can't be extended.

Thus, the number of violating the rule in this test case is: 1 (Bar class)
['Get the name of class.', 'Check whether the class is final.', 'Get all constructors declared in class.', 'Check whether the constructor is private for each constructor.', 'Check whether the class has any subclasses declared within the same compilation unit.', 'Check whether the subclass has a constructor that calls the superclass constructor.', 'If the class is not final, check if all its constructors are private.', 'If all constructors are private, check if any subclasses are declared within the same compilation unit.', 'If subclasses are declared within the same compilation unit, check if they have constructors that call the superclass constructor.', 'Get the name of class.', 'Check whether the class is final.', 'Get all constructors declared in class.', 'Check whether the constructor is private for each constructor.', 'Get the name of class.', 'Check whether the class is final.', 'Get all constructors declared in class.', 'Check whether the constructor is private for each constructor.', 'Check whether the class has any subclasses declared within the same compilation unit.', 'Check whether the subclass has a constructor that calls the superclass constructor.', 'Get the name of class.', 'Check whether the class is final.', 'Get all constructors declared in class.', 'Check whether the constructor is private for each constructor.', 'Check whether the class has any subclasses declared within the same compilation unit.', 'Check whether the subclass has a constructor that calls the superclass constructor.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private for each constructor.* 匹配到的元操作或API：
logic: Check whether the constructor is private for each constructor.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9468938112258911
*Check whether the class has any subclasses declared within the same compilation unit.* 匹配到的元操作或API：
query: Check whether the class has any subclasses declared within the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8370040059089661
*Check whether the subclass has a constructor that calls the superclass constructor.* 匹配到的元操作或API：
query: Check whether the subclass has a constructor that calls the superclass constructor.
most similar API: Check whether the constructor equals
cosine Similarity: 0.8118511438369751
*If the class is not final, check if all its constructors are private.* 匹配到的元操作或API：
logic: If the class is not final, check if all its constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8950669765472412
*If all constructors are private, check if any subclasses are declared within the same compilation unit.* 匹配到的元操作或API：
query: If all constructors are private, check if any subclasses are declared within the same compilation unit.
most similar API: Check whether the constructor is package private
cosine Similarity: 0.8408035039901733
*If subclasses are declared within the same compilation unit, check if they have constructors that call the superclass constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private for each constructor.* 匹配到的元操作或API：
logic: Check whether the constructor is private for each constructor.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9468938112258911
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private for each constructor.* 匹配到的元操作或API：
logic: Check whether the constructor is private for each constructor.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9468938112258911
*Check whether the class has any subclasses declared within the same compilation unit.* 匹配到的元操作或API：
query: Check whether the class has any subclasses declared within the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8370040059089661
*Check whether the subclass has a constructor that calls the superclass constructor.* 匹配到的元操作或API：
query: Check whether the subclass has a constructor that calls the superclass constructor.
most similar API: Check whether the constructor equals
cosine Similarity: 0.8118511438369751
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private for each constructor.* 匹配到的元操作或API：
logic: Check whether the constructor is private for each constructor.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9468938112258911
*Check whether the class has any subclasses declared within the same compilation unit.* 匹配到的元操作或API：
query: Check whether the class has any subclasses declared within the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8370040059089661
*Check whether the subclass has a constructor that calls the superclass constructor.* 匹配到的元操作或API：
query: Check whether the subclass has a constructor that calls the superclass constructor.
most similar API: Check whether the constructor equals
cosine Similarity: 0.8118511438369751
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}


This checker is failed(false positive) on this positive test case:
```
// Ok, subclass using the private constructor of another subclass
public class Foo {
    public Foo() { }

    public static class Bar {
        private Bar() { }
    }

    public static class Barbie extends Bar {
        public Barbie() { }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Bar')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Barbie')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean equals(java.lang.Object)
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPackagePrivate()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    boolean isSubclassedInSameCompilationUnit = false;
                    for (ASTClassOrInterfaceDeclaration subclassNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
                        ASTExtendsList extendsList = subclassNode.getFirstChildOfType(ASTExtendsList.class);
                        if (extendsList != null) {
                            for (ASTClassOrInterfaceType extendedType : extendsList.children(ASTClassOrInterfaceType.class)) {
                                if (extendedType.isReferenceToClassSameCompilationUnit() && extendedType.getSimpleName().equals(classNode.getSimpleName())) {
                                    isSubclassedInSameCompilationUnit = true;
                                    break;
                                }
                            }
                        }
                        if (isSubclassedInSameCompilationUnit) {
                            break;
                        }
                    }
                    if (!isSubclassedInSameCompilationUnit) {
                        addViolation(data, classNode);
                    }
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 5" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 5" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 5
[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Check whether the class is abstract.
2. Check whether the class is public.
3. Get the constructor list of class.
4. Check whether the constructor list size is greater than 0.
5. Get the first constructor of class.
6. Check whether the constructor is private.
7. Check whether the class has extended any class.
8. Get the super class of class.
9. Check whether the super class is outside the same compilation unit.
10. Get the list of implemented interfaces of class.
11. Check whether the implemented interface list size is greater than 0.
12. Get the first implemented interface of class.
13. Check whether the implemented interface is outside the same compilation unit.

If the class is abstract and public, it has at least one constructor which is private, it has not extended any class outside the compilation unit, and it has not implemented any interfaces outside the compilation unit, then this class violates the rule. 

In the given test case:
- The class `FooUtils` is abstract.
- The class `FooUtils` is public.
- It has a private constructor.
- It does not extend any class outside the compilation unit (as not explicitly shown, it implicitly extends `Object` which is in the same compilation unit).
- It does not implement any interfaces outside the compilation unit (as not explicitly shown).

Thus, this test case violates the rule.
['Check whether the class is abstract.', 'Check whether the class is public.', 'Get the constructor list of class.', 'Check whether the constructor list size is greater than 0.', 'Get the first constructor of class.', 'Check whether the constructor is private.', 'Check whether the class has extended any class.', 'Get the super class of class.', 'Check whether the super class is outside the same compilation unit.', 'Get the list of implemented interfaces of class.', 'Check whether the implemented interface list size is greater than 0.', 'Get the first implemented interface of class.', 'Check whether the implemented interface is outside the same compilation unit.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get the constructor list of class.* 匹配到的元操作或API：
query: Get the constructor list of class.
most similar API: get class of constructor
cosine Similarity: 0.817323625087738
*Check whether the constructor list size is greater than 0.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the first constructor of class.* 匹配到的元操作或API：
query: Get the first constructor of class.
most similar API: get first child of constructor
cosine Similarity: 0.8626230955123901
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has extended any class.* 匹配到的元操作或API：
logic: Check whether the class has extended any class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.899549126625061
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the super class is outside the same compilation unit.* 匹配到的元操作或API：
query: Check whether the super class is outside the same compilation unit.
most similar API: Check whether the compilation unit is find boundary
cosine Similarity: 0.8184025287628174
*Get the list of implemented interfaces of class.* 匹配到的元操作或API：
logic: Get the list of implemented interfaces of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.8937219381332397
*Check whether the implemented interface list size is greater than 0.* 匹配到的元操作或API：
query: Check whether the implemented interface list size is greater than 0.
most similar API: size or zero of class or interface body
cosine Similarity: 0.8092355728149414
*Get the first implemented interface of class.* 匹配到的元操作或API：
logic: Get the first implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9086511135101318
*Check whether the implemented interface is outside the same compilation unit.* 匹配到的元操作或API：
query: Check whether the implemented interface is outside the same compilation unit.
most similar API: Check whether the compilation unit is find boundary
cosine Similarity: 0.8313721418380737
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}


This checker is failed(false negative) on this negative test case:
```
// Abstract outer classes should be flagged #3668
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'FooUtils')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.Node getFirstChild()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
7. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean isFindBoundary()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getSuperInterfaceTypeNodes()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody: static public int sizeOrZero(net.sourceforge.pmd.lang.java.ast.ASTList)

1.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract() && !classNode.isPublic()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (!classNode.isInterface() && classNode.isPublic() && classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && classNode.children(ASTMethodDeclaration.class).noneMatch(ASTMethodDeclaration::isAbstract) && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Check whether the class is abstract.
2. Check whether the class has declared annotations.
3. Get the name of class.
4. Check whether the class is public.
5. Check whether the class is private.
6. Check whether the class is protected.
7. Check whether the class is default package-private.
8. Check whether the class is final.
9. Check whether the class is static.
10. Get the super class of class.
11. Get a declared constructor of class.
12. Check whether the declared constructor is private.
13. Check whether the class has any other constructors.
14. Check whether the class has methods.
15. Check whether the class has fields.
16. Check whether the class has extended x class.
17. Get a implemented interface of class.
18. Check whether the class has implemented x interface.

For the given test case:
1. Check whether the class is abstract.
        - Result: True (The class is declared as abstract)
2. Check whether the class has declared annotations.
        - Result: False (No annotations are declared on the class)
3. Get the name of class.
        - Result: FooUtils (The name of the class is FooUtils)
4. Check whether the class is public.
        - Result: True (The class is declared as public)
5. Check whether the class is private.
        - Result: False (The class is not declared as private)
6. Check whether the class is protected.
        - Result: False (The class is not declared as protected)
7. Check whether the class is default package-private.
        - Result: False (The class is not default package-private)
8. Check whether the class is final.
        - Result: False (The class is not declared as final)
9. Check whether the class is static.
        - Result: False (The class is not declared as static)
10. Get the super class of class.
        - Result: Object (The super class of FooUtils is Object)
11. Get a declared constructor of class.
        - Result: FooUtils() (Found a declared constructor)
12. Check whether the declared constructor is private.
        - Result: True (The constructor is declared as private)
13. Check whether the class has any other constructors.
        - Result: False (No other constructors are found)
14. Check whether the class has methods.
        - Result: False (No methods are found in the class)
15. Check whether the class has fields.
        - Result: False (No fields are found in the class)

Based on the checks performed, the test case violates the rule because the class is declared as public, abstract, and has a private constructor, meaning it cannot be extended from outside its compilation unit. The fact that it is abstract does not negate the rule, as the rule specifically targets the ability to extend the class due to private constructors.
['Check whether the class is abstract.', 'Check whether the class has declared annotations.', 'Get the name of class.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the super class of class.', 'Get a declared constructor of class.', 'Check whether the declared constructor is private.', 'Check whether the class has any other constructors.', 'Check whether the class has methods.', 'Check whether the class has fields.', 'Check whether the class has extended x class.', 'Get a implemented interface of class.', 'Check whether the class has implemented x interface.', 'Check whether the class is abstract.', 'Check whether the class has declared annotations.', 'Get the name of class.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the super class of class.', 'Get a declared constructor of class.', 'Check whether the declared constructor is private.', 'Check whether the class has any other constructors.', 'Check whether the class has methods.', 'Check whether the class has fields.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844120740890503
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Get a declared constructor of class.* 匹配到的元操作或API：
logic: Get a declared constructor of class.
most similar meta operation: Get a declared annotation of constructor
cosine Similarity: 0.8581584095954895
*Check whether the declared constructor is private.* 匹配到的元操作或API：
logic: Check whether the declared constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9762377738952637
*Check whether the class has any other constructors.* 匹配到的元操作或API：
query: Check whether the class has any other constructors.
most similar API: Check whether the constructor is any annotation present
cosine Similarity: 0.8521175980567932
*Check whether the class has methods.* 匹配到的元操作或API：
query: Check whether the class has methods.
most similar API: Check whether is test method
cosine Similarity: 0.8479976654052734
*Check whether the class has fields.* 匹配到的元操作或API：
query: Check whether the class has fields.
most similar API: Check whether has field
cosine Similarity: 0.8486732840538025
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a implemented interface of class.* 匹配到的元操作或API：
logic: Get a implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9851537942886353
*Check whether the class has implemented x interface.* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9905824661254883
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844120740890503
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Get a declared constructor of class.* 匹配到的元操作或API：
logic: Get a declared constructor of class.
most similar meta operation: Get a declared annotation of constructor
cosine Similarity: 0.8581584095954895
*Check whether the declared constructor is private.* 匹配到的元操作或API：
logic: Check whether the declared constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9762377738952637
*Check whether the class has any other constructors.* 匹配到的元操作或API：
query: Check whether the class has any other constructors.
most similar API: Check whether the constructor is any annotation present
cosine Similarity: 0.8521175980567932
*Check whether the class has methods.* 匹配到的元操作或API：
query: Check whether the class has methods.
most similar API: Check whether is test method
cosine Similarity: 0.8479976654052734
*Check whether the class has fields.* 匹配到的元操作或API：
query: Check whether the class has fields.
most similar API: Check whether has field
cosine Similarity: 0.8486732840538025
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}


This checker is failed(false negative) on this negative test case:
```
// Abstract outer classes should be flagged #3668
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'FooUtils')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isProtected()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
10. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
11. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
12. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection), //Checks whether any annotation is present on this node. @param binaryNames            Collection that contains binary names of annotations.            Note: for now, canonical names are tolerated, this may be changed in PMD 7. @return <code>true</code> if any annotation is present on this node, else <code>false</code>
13. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
14. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean hasField(net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration, java.lang.String)
15. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getSuperInterfaceTypeNodes()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```
3.  //Check whether the class has implemented x interface
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node) {
    if (TypeTestUtil.isA(interfaceName.class, node)) {
        return true;
    }
    return false;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract() && !classNode.isPublic() && !classNode.isPrivate() && !classNode.isProtected() && !classNode.isPackagePrivate()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract() && !classNode.isPublic() && !classNode.isPrivate() && !classNode.isProtected() && !classNode.isPackagePrivate()) {
                boolean hasPrivateConstructor = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (constructor.isPrivate()) {
                        hasPrivateConstructor = true;
                        break;
                    }
                }
                if (hasPrivateConstructor && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}, {'error_rules_info': '[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is abstract.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. If the class is abstract, check whether all constructors are private.

If the class is abstract and all its constructors are private, then this test case violates the rule, as the class can be made final since it cannot be extended from outside its compilation unit.
In this case, the class `FooUtils` is abstract and it has a private constructor, so it violates the rule.
['Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'If the class is abstract, check whether all constructors are private.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*If the class is abstract, check whether all constructors are private.* 匹配到的元操作或API：
logic: If the class is abstract, check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8954407572746277
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}


This checker is failed(false negative) on this negative test case:
```
// Abstract outer classes should be flagged #3668
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'FooUtils')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal() && !hasNonPrivateSubclasses(classNode)) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean hasNonPrivateSubclasses(ASTClassOrInterfaceDeclaration classNode) {
        JClassSymbol classSymbol = classNode.getSymbol();
        TypeSystem typeSystem = classNode.getTypeSystem();
        for (JClassSymbol subclass : typeSystem.getDeclaredClasses()) {
            if (subclass.isSubclassOf(classSymbol) && !subclass.isPrivate() && !subclass.isFinal()) {
                return true;
            }
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is abstract.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Get the number of constructors declared in class.
6. Check whether all constructors are private.

If the class is abstract and all constructors are private, then this class may be made final and it violates the rule. 

In this specific test case:

7. Check whether there are any abstract methods in the class.
8. Check whether the class has any subclasses within the same compilation unit.

Since the class is abstract and has a private constructor, it should be flagged as a potential candidate to be final. However, the rule explicitly states that abstract classes should be flagged, so despite not having abstract methods, it still violates the rule as per the description provided. 

The test case does not mention any subclasses within the same compilation unit, so we assume there are none. Therefore, the number of violations in this test case is 1.
['Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get the number of constructors declared in class.', 'Check whether all constructors are private.', 'Check whether there are any abstract methods in the class.', 'Check whether the class has any subclasses within the same compilation unit.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the number of constructors declared in class.* 匹配到的元操作或API：
query: Get the number of constructors declared in class.
most similar API: get num children of constructor
cosine Similarity: 0.8205664157867432
*Check whether all constructors are private.* 匹配到的元操作或API：
logic: Check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.936521589756012
*Check whether there are any abstract methods in the class.* 匹配到的元操作或API：
logic: Check whether there are any abstract methods in the class.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9192245006561279
*Check whether the class has any subclasses within the same compilation unit.* 匹配到的元操作或API：
query: Check whether the class has any subclasses within the same compilation unit.
most similar API: Check whether the compilation unit has descendant of type
cosine Similarity: 0.8082830905914307
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}


This checker is failed(false negative) on this negative test case:
```
// Abstract outer classes should be flagged #3668
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'FooUtils')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public int getNumChildren()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
7. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean hasDescendantOfType(java.lang.Class)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "ok 3" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
107
91
=========================error_testcase_logics=========================
1. Check whether the class is abstract.
2. Get all constructors declared in class.
3. Check whether the constructor is private.
4. Check whether the constructor is public.

Let's break down the test case:

1. Check whether the class is abstract.
        - This is true. The class `Foo` is declared as `abstract`.

2. Get all constructors declared in class.
        - There are two constructors: `private Foo() { }` and `public Foo(String param) { }`.

3. Check whether the constructor is private.
        - For the first constructor, this is true.
        - For the second constructor, this is false.

4. Check whether the constructor is public.
        - For the first constructor, this is false.
        - For the second constructor, this is true.

Since the class has a public constructor, it can be extended from outside its compilation unit. Therefore, it does not violate the rule.

The number of violations in this test case is: 0.
['Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the constructor is public.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the constructor is public.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// abstract class, one public constructor, not required to be final
public abstract class Foo {
    private Foo() { }
    public Foo(String param) { }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'param')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 3" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 3" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Check whether class is abstract.
        3. Get the constructors of class.
        4. Check whether the constructor is private.
        5. Check whether the constructor is public.
        6. Check whether all constructors are private.
        7. Check whether there is at least one public constructor.

Explanation:
- 1. Get the name of class: This identifies the class named `Foo`.
- 2. Check whether class is abstract: This confirms that `Foo` is an abstract class.
- 3. Get the constructors of class: This retrieves the constructors of `Foo`.
- 4. Check whether the constructor is private: This checks if any constructor is private.
- 5. Check whether the constructor is public: This checks if any constructor is public.
- 6. Check whether all constructors are private: This ensures that not all constructors are private.
- 7. Check whether there is at least one public constructor: This confirms that there is a public constructor available.

Since the class `Foo` is abstract and has a public constructor, it does not meet the criteria to be made final based on the rule provided. Therefore, the number of violations in this test case is: 0.
['Get the name of class.', 'Check whether class is abstract.', 'Get the constructors of class.', 'Check whether the constructor is private.', 'Check whether the constructor is public.', 'Check whether all constructors are private.', 'Check whether there is at least one public constructor.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether class is abstract.* 匹配到的元操作或API：
logic: Check whether class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9810292720794678
*Get the constructors of class.* 匹配到的元操作或API：
query: Get the constructors of class.
most similar API: get class of constructor
cosine Similarity: 0.8381321430206299
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Check whether all constructors are private.* 匹配到的元操作或API：
logic: Check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.936521589756012
*Check whether there is at least one public constructor.* 匹配到的元操作或API：
logic: Check whether there is at least one public constructor.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.8867713212966919
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// abstract class, one public constructor, not required to be final
public abstract class Foo {
    private Foo() { }
    public Foo(String param) { }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'param')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 3" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 3" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Check whether class is abstract.
        3. Get all constructors of class.
        4. Check whether a constructor is private.
        5. Check whether a constructor is public.
        6. Count the number of private constructors.
        7. Count the number of public constructors.
        8. Check whether the number of public constructors is greater than 0.
        9. Check whether the number of private constructors is equal to the total number of constructors.
        If the class is abstract and there is at least one public constructor, then it does not violate the rule. If all constructors are private and there is at least one constructor, the class might be considered for making final, but the rule specifies it should not report if there are public constructors.
        
In this test case:
- The class is abstract (Check whether class is abstract).
- There is one public constructor (Check whether a constructor is public).
- There is one private constructor (Check whether a constructor is private).
- The number of public constructors is greater than 0 (Check whether the number of public constructors is greater than 0).
- Since there is at least one public constructor, the class does not violate the rule (The number of violating the rule in this test case is: 0).
['Get the name of class.', 'Check whether class is abstract.', 'Get all constructors of class.', 'Check whether a constructor is private.', 'Check whether a constructor is public.', 'Count the number of private constructors.', 'Count the number of public constructors.', 'Check whether the number of public constructors is greater than 0.', 'Check whether the number of private constructors is equal to the total number of constructors.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether class is abstract.* 匹配到的元操作或API：
logic: Check whether class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9810292720794678
*Get all constructors of class.* 匹配到的元操作或API：
query: Get all constructors of class.
most similar API: get class of constructor
cosine Similarity: 0.8041397333145142
*Check whether a constructor is private.* 匹配到的元操作或API：
logic: Check whether a constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9856699109077454
*Check whether a constructor is public.* 匹配到的元操作或API：
logic: Check whether a constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.9840468168258667
*Count the number of private constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
*Count the number of public constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the number of public constructors is greater than 0.* 匹配到的元操作或API：
query: Check whether the number of public constructors is greater than 0.
most similar API: Check whether the constructor is public
cosine Similarity: 0.8070359230041504
*Check whether the number of private constructors is equal to the total number of constructors.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// abstract class, one public constructor, not required to be final
public abstract class Foo {
    private Foo() { }
    public Foo(String param) { }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'param')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 3" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 3" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Check whether the class is abstract.
        3. Get all constructors declared in class.
        4. Check whether the constructor is private.
        5. Check whether the constructor is public.
        If the class is not abstract and all its constructors are private, then the class may be made final. However, in this case:
        6. Check whether there is at least one public constructor.
        If there is at least one public constructor, then the class cannot be made final because it can be extended outside its compilation unit.
             
Given the test case:
1. Get the name of class. // Foo
2. Check whether the class is abstract. // True
3. Get all constructors declared in class. // Two constructors: private Foo() and public Foo(String param)
4. Check whether the constructor is private. // First constructor is private
5. Check whether the constructor is public. // First constructor is not public
4. Check whether the constructor is private. // Second constructor is not private
5. Check whether the constructor is public. // Second constructor is public
6. Check whether there is at least one public constructor. // True

Since the class is abstract and has a public constructor, it does not violate the rule. The number of violations in this test case is: 0.
['Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the constructor is public.', 'Check whether there is at least one public constructor.', 'Get the name of class. // Foo', 'Check whether the class is abstract. // True', 'Get all constructors declared in class. // Two constructors: private Foo() and public Foo(String param)', 'Check whether the constructor is private. // First constructor is private', 'Check whether the constructor is public. // First constructor is not public', 'Check whether the constructor is private. // Second constructor is not private', 'Check whether the constructor is public. // Second constructor is public', 'Check whether there is at least one public constructor. // True']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Check whether there is at least one public constructor.* 匹配到的元操作或API：
logic: Check whether there is at least one public constructor.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.8867713212966919
*Get the name of class. // Foo* 匹配到的元操作或API：
logic: Get the name of class. // Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9075836539268494
*Check whether the class is abstract. // True* 匹配到的元操作或API：
logic: Check whether the class is abstract. // True
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.956919252872467
*Get all constructors declared in class. // Two constructors: private Foo() and public Foo(String param)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private. // First constructor is private* 匹配到的元操作或API：
logic: Check whether the constructor is private. // First constructor is private
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9420715570449829
*Check whether the constructor is public. // First constructor is not public* 匹配到的元操作或API：
logic: Check whether the constructor is public. // First constructor is not public
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.935430109500885
*Check whether the constructor is private. // Second constructor is not private* 匹配到的元操作或API：
logic: Check whether the constructor is private. // Second constructor is not private
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.939350426197052
*Check whether the constructor is public. // Second constructor is public* 匹配到的元操作或API：
logic: Check whether the constructor is public. // Second constructor is public
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.9351024627685547
*Check whether there is at least one public constructor. // True* 匹配到的元操作或API：
logic: Check whether there is at least one public constructor. // True
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.8658435940742493
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// abstract class, one public constructor, not required to be final
public abstract class Foo {
    private Foo() { }
    public Foo(String param) { }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'param')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate() && constructor.isPublic()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 3" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 3" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Check whether the class is abstract.
        2. Get all constructors declared in class.
        3. Check whether the constructor is private.
        4. Check whether the constructor is public.
        5. Get the number of public constructors in the class.
        6. Check whether the number of public constructors is greater than 0.

In this test case:
1. The class is abstract.
2. There are two constructors declared in the class.
3. The first constructor is private.
4. The second constructor is public.
5. The number of public constructors in the class is 1.
6. Since the number of public constructors is greater than 0, the class can be instantiated from outside its compilation unit, and thus, the class does not violate the rule.

Therefore, the number of violations of the rule in this test case is indeed 0.
['Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the constructor is public.', 'Get the number of public constructors in the class.', 'Check whether the number of public constructors is greater than 0.', 'The class is abstract.', 'There are two constructors declared in the class.', 'The first constructor is private.', 'The second constructor is public.', 'The number of public constructors in the class is 1.', 'Since the number of public constructors is greater than 0, the class can be instantiated from outside its compilation unit, and thus, the class does not violate the rule.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the constructor is public.* 匹配到的元操作或API：
logic: Check whether the constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.985020637512207
*Get the number of public constructors in the class.* 匹配到的元操作或API：
query: Get the number of public constructors in the class.
most similar API: get num children of constructor
cosine Similarity: 0.8169864416122437
*Check whether the number of public constructors is greater than 0.* 匹配到的元操作或API：
query: Check whether the number of public constructors is greater than 0.
most similar API: Check whether the constructor is public
cosine Similarity: 0.8070359230041504
*The class is abstract.* 匹配到的元操作或API：
未匹配成功元操作或API
*There are two constructors declared in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*The first constructor is private.* 匹配到的元操作或API：
query: The first constructor is private.
most similar API: Check whether the constructor is private
cosine Similarity: 0.8183459639549255
*The second constructor is public.* 匹配到的元操作或API：
未匹配成功元操作或API
*The number of public constructors in the class is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Since the number of public constructors is greater than 0, the class can be instantiated from outside its compilation unit, and thus, the class does not violate the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// abstract class, one public constructor, not required to be final
public abstract class Foo {
    private Foo() { }
    public Foo(String param) { }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 1)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclaratorId (declared variable name = 'param')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public int getNumChildren()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasPublicConstructors = false;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        if (constructor.isPublic()) {
                            hasPublicConstructors = true;
                        }
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasPublicConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 3" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 3" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 3
[ERROR]   "ok 6" resulted in wrong number of failures, ==> expected: <0> but was: <2>不通过
94
78
107
91
=========================error_testcase_logics=========================
To check whether the test case adheres to the rule, we need to perform the following granular checks:

1. Get the name of class.
2. Get the name of constructor.
3. Check whether the constructor is private.
4. Get the name of the package where the class is located.
5. Get the name of another class in the same compilation unit.
6. Check whether the second class is an inner class.
7. Get the name of the super class of class.
8. Check whether the second class is extending the first class.
9. Check whether the second class has a public constructor.

These checks will help us determine if the class `Foo` can be made final because it cannot be extended from outside its compilation unit.

Let's perform the checks:

1. Get the name of class.
   - Class name: `Foo`
   - Class name: `Bar`

2. Get the name of constructor.
   - Constructor name: `Foo` (for the first class)
   - Constructor name: `Bar` (for the second class)

3. Check whether the constructor is private.
   - For `Foo`, the constructor is private: `true`
   - For `Bar`, the constructor is private: `false`

4. Get the name of the package where the class is located.
   - Package name: (default package) (for both classes)

5. Get the name of another class in the same compilation unit.
   - Another class name: `Bar`

6. Check whether the second class is an inner class.
   - `Bar` is an inner class: `false`

7. Get the super class of class.
   - Super class of `Bar`: `Foo`

8. Check whether the second class is extending the first class.
   - `Bar` extends `Foo`: `true`

9. Check whether the second class has a public constructor.
   - `Bar` has a public constructor: `true`

Based on these checks, we can see that `Foo` has a private constructor, but it is being extended by `Bar`, which has a public constructor. Since `Bar` can be created outside of the compilation unit, `Foo` should not be made final according to the rule. Therefore, the test case does not violate the rule, as expected.
['Get the name of class.', 'Get the name of constructor.', 'Check whether the constructor is private.', 'Get the name of the package where the class is located.', 'Get the name of another class in the same compilation unit.', 'Check whether the second class is an inner class.', 'Get the name of the super class of class.', 'Check whether the second class is extending the first class.', 'Check whether the second class has a public constructor.', 'Get the name of class.', 'Get the name of constructor.', 'Check whether the constructor is private.', 'Get the name of the package where the class is located.', 'Get the name of another class in the same compilation unit.', 'Check whether the second class is an inner class.', 'Get the super class of class.', 'Check whether the second class is extending the first class.', 'Check whether the second class has a public constructor.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of constructor.* 匹配到的元操作或API：
logic: Get the name of constructor.
most similar meta operation: Get the name of constructor
cosine Similarity: 0.9789292812347412
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Get the name of another class in the same compilation unit.* 匹配到的元操作或API：
query: Get the name of another class in the same compilation unit.
most similar API: get class of compilation unit
cosine Similarity: 0.8826794624328613
*Check whether the second class is an inner class.* 匹配到的元操作或API：
logic: Check whether the second class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9256272315979004
*Get the name of the super class of class.* 匹配到的元操作或API：
logic: Get the name of the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9248480796813965
*Check whether the second class is extending the first class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the second class has a public constructor.* 匹配到的元操作或API：
logic: Check whether the second class has a public constructor.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.8817511796951294
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of constructor.* 匹配到的元操作或API：
logic: Get the name of constructor.
most similar meta operation: Get the name of constructor
cosine Similarity: 0.9789292812347412
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Get the name of another class in the same compilation unit.* 匹配到的元操作或API：
query: Get the name of another class in the same compilation unit.
most similar API: get class of compilation unit
cosine Similarity: 0.8826794624328613
*Check whether the second class is an inner class.* 匹配到的元操作或API：
logic: Check whether the second class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9256272315979004
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the second class is extending the first class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the second class has a public constructor.* 匹配到的元操作或API：
logic: Check whether the second class has a public constructor.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.8817511796951294
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Ok, two classes
public class Foo {
    private Foo() { }
}
class Bar extends Foo {
    public Bar() { }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
——ASTClassOrInterfaceDeclaration (class name = 'Bar')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.String getName()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
5. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public java.lang.Class<Class<?> getClass()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
8. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal() && !isExtendedOutsideCompilationUnit(classNode, node)) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal() && !isExtendedOutsideCompilationUnit(classNode, node)) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isExtendedOutsideCompilationUnit(ASTClassOrInterfaceDeclaration classNode, ASTCompilationUnit compilationUnit) {
        for (ASTClassOrInterfaceDeclaration otherClass : compilationUnit.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!otherClass.equals(classNode)) {
                ASTClassOrInterfaceType superClassTypeNode = otherClass.getSuperClassTypeNode();
                if (superClassTypeNode != null && superClassTypeNode.getSimpleName().equals(classNode.getSimpleName())) {
                    return true;
                }
            }
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 6" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 6" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
To ascertain whether the test case adheres to the rule, we need to perform the following granular checks:

1. Get the name of class.
2. Check whether the class has declared annotations.
3. Get the javadoc comment of class.
4. Check whether the class is abstract.
5. Check whether the class is public.
6. Check whether the class is private.
7. Check whether the class is protected.
8. Check whether the class is default package-private.
9. Check whether the class is final.
10. Check whether the class is static.
11. Get the super class of class.
12. Check whether the class has extended x class.
13. Get a declared method or constructor of class.
14. Check whether the method or constructor is private.
15. Get the name of class.
16. Check whether the class has declared annotations.
17. Get the javadoc comment of class.
18. Check whether the class is abstract.
19. Check whether the class is public.
20. Check whether the class is private.
21. Check whether the class is protected.
22. Check whether the class is default package-private.
23. Check whether the class is final.
24. Check whether the class is static.
25. Get the super class of class.
26. Check whether the class has extended x class.
27. Get a declared method or constructor of class.
28. Check whether the method or constructor is private.

Let's perform these checks on the provided test case:

1. Get the name of class.
   - Class name is `Foo`.

2. Check whether the class has declared annotations.
   - No annotations declared for `Foo`.

3. Get the javadoc comment of class.
   - No javadoc comment for `Foo`.

4. Check whether the class is abstract.
   - `Foo` is abstract.

5. Check whether the class is public.
   - `Foo` is public.

6. Check whether the class is private.
   - `Foo` is not private.

7. Check whether the class is protected.
   - `Foo` is not protected.

8. Check whether the class is default package-private.
   - `Foo` is not default package-private.

9. Check whether the class is final.
   - `Foo` is not final.

10. Check whether the class is static.
    - `Foo` is not static.

11. Get the super class of class.
    - Super class is `Object`.

12. Check whether the class has extended x class.
    - `Foo` extends `Object`, but this check is not relevant to the rule.

13. Get a declared method or constructor of class.
    - Constructor `Foo()` is declared.

14. Check whether the method or constructor is private.
    - Constructor `Foo()` is private.

15. Get the name of class.
    - Class name is `Bar`.

16. Check whether the class has declared annotations.
    - No annotations declared for `Bar`.

17. Get the javadoc comment of class.
    - No javadoc comment for `Bar`.

18. Check whether the class is abstract.
    - `Bar` is not abstract.

19. Check whether the class is public.
    - `Bar` is public.

20. Check whether the class is private.
    - `Bar` is not private.

21. Check whether the class is protected.
    - `Bar` is not protected.

22. Check whether the class is default package-private.
    - `Bar` is default package-private.

23. Check whether the class is final.
    - `Bar` is not final.

24. Check whether the class is static.
    - `Bar` is not static.

25. Get the super class of class.
    - Super class is `Foo`.

26. Check whether the class has extended x class.
    - `Bar` extends `Foo`, which is relevant.

27. Get a declared method or constructor of class.
    - Constructor `Bar()` is declared.

28. Check whether the method or constructor is private.
    - Constructor `Bar()` is not private.

Based on these checks:

- `Foo` has a private constructor, which means it cannot be extended from outside its compilation unit.
- `Bar` extends `Foo`, which means this test case violates the rule.

However, the provided description of the test case states that the number of violations is 0. This indicates an error in the test case description since `Bar` extending `Foo` violates the rule given that `Foo` has a private constructor. 

If the intention is to check a class that does not have a private constructor, the test case should be revised. If the intention is to correctly identify the violation, the test case's description should be updated to reflect the violation.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get the javadoc comment of class.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get a declared method or constructor of class.', 'Check whether the method or constructor is private.', 'Get the name of class.', 'Check whether the class has declared annotations.', 'Get the javadoc comment of class.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get a declared method or constructor of class.', 'Check whether the method or constructor is private.', 'Get the name of class.', 'Check whether the class has declared annotations.', 'Get the javadoc comment of class.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get a declared method or constructor of class.', 'Check whether the method or constructor is private.', 'Get the name of class.', 'Check whether the class has declared annotations.', 'Get the javadoc comment of class.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get a declared method or constructor of class.', 'Check whether the method or constructor is private.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844120740890503
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a declared method or constructor of class.* 匹配到的元操作或API：
logic: Get a declared method or constructor of class.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.8640865087509155
*Check whether the method or constructor is private.* 匹配到的元操作或API：
logic: Check whether the method or constructor is private.
most similar meta operation: Check whether the method is private
cosine Similarity: 0.9494327306747437
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844120740890503
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a declared method or constructor of class.* 匹配到的元操作或API：
logic: Get a declared method or constructor of class.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.8640865087509155
*Check whether the method or constructor is private.* 匹配到的元操作或API：
logic: Check whether the method or constructor is private.
most similar meta operation: Check whether the method is private
cosine Similarity: 0.9494327306747437
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844120740890503
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a declared method or constructor of class.* 匹配到的元操作或API：
logic: Get a declared method or constructor of class.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.8640865087509155
*Check whether the method or constructor is private.* 匹配到的元操作或API：
logic: Check whether the method or constructor is private.
most similar meta operation: Check whether the method is private
cosine Similarity: 0.9494327306747437
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844120740890503
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a declared method or constructor of class.* 匹配到的元操作或API：
logic: Get a declared method or constructor of class.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.8640865087509155
*Check whether the method or constructor is private.* 匹配到的元操作或API：
logic: Check whether the method or constructor is private.
most similar meta operation: Check whether the method is private
cosine Similarity: 0.9494327306747437
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Ok, two classes
public class Foo {
    private Foo() { }
}
class Bar extends Foo {
    public Bar() { }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
——ASTClassOrInterfaceDeclaration (class name = 'Bar')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isProtected()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
11. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPrivate()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```
3.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal() && !isExtendedInSameCompilationUnit(classNode, node)) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal() && !isExtendedInSameCompilationUnit(classNode, node)) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isExtendedInSameCompilationUnit(ASTClassOrInterfaceDeclaration classNode, ASTCompilationUnit compilationUnit) {
        String className = classNode.getSimpleName();
        for (ASTClassOrInterfaceDeclaration otherClass : compilationUnit.children(ASTClassOrInterfaceDeclaration.class)) {
            ASTExtendsList extendsList = otherClass.getFirstChildOfType(ASTExtendsList.class);
            if (extendsList != null) {
                for (ASTClassOrInterfaceType type : extendsList.children(ASTClassOrInterfaceType.class)) {
                    if (type.getSimpleName().equals(className)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 6" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 6" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is public.
3. Get the number of constructors of class.
4. Get a constructor of class.
5. Check whether the constructor is private.
6. Repeat step 4 and 5 for each constructor of class.
7. Check whether the class is extended by any other class.
8. Get the name of the package where the class is located.
9. Get the classes declared in the same package.
10. Check whether any of the classes declared in the same package extend this class.
11. Check whether the class is extended by any class outside the same package.

For `Foo` class:
1. Get the name of class - Foo
2. Check whether the class is public - True
3. Get the number of constructors of class - 1
4. Get a constructor of class - Foo()
5. Check whether the constructor is private - True
6. Repeat step 4 and 5 for each constructor of class - Only one constructor, already checked.
7. Check whether the class is extended by any other class - True, by `Bar`
8. Get the name of the package where the class is located - Assume it's `com.example`
9. Get the classes declared in the same package - Assume it includes `Foo` and `Bar`
10. Check whether any of the classes declared in the same package extend this class - True, `Bar` extends `Foo`
11. Check whether the class is extended by any class outside the same package - False, assuming no other classes outside `com.example` extend `Foo`

For `Bar` class:
1. Get the name of class - Bar
2. Check whether the class is public - False, default package-private
3. Get the number of constructors of class - 1
4. Get a constructor of class - Bar()
5. Check whether the constructor is private - False
6. Repeat step 4 and 5 for each constructor of class - Only one constructor, already checked.
7. Check whether the class is extended by any other class - False
8. Get the name of the package where the class is located - Assume it's `com.example`
9. Get the classes declared in the same package - Assume it includes `Foo` and `Bar`
10. Check whether any of the classes declared in the same package extend this class - False, `Bar` does not extend any other class declared in the same package that is not already checked.
11. Check whether the class is extended by any class outside the same package - False

Based on these steps, the `Foo` class is incorrectly identified as potentially final because it has a subclass `Bar` outside its compilation unit. However, since the `Bar` class is not in the same compilation unit (package), the `Foo` class cannot be made final according to the rule. The `Bar` class does not have any constructors or fields, so it does not violate the rule.

The number of classes violating the rule in this test case is indeed 0, as `Foo` has a private constructor but is extended by `Bar`, which is outside its compilation unit.
['Get the name of class.', 'Check whether the class is public.', 'Get the number of constructors of class.', 'Get a constructor of class.', 'Check whether the constructor is private.', 'Repeat step 4 and 5 for each constructor of class.', 'Check whether the class is extended by any other class.', 'Get the name of the package where the class is located.', 'Get the classes declared in the same package.', 'Check whether any of the classes declared in the same package extend this class.', 'Check whether the class is extended by any class outside the same package.', 'Get the name of class - Foo', 'Check whether the class is public - True', 'Get the number of constructors of class - 1', 'Get a constructor of class - Foo()', 'Check whether the constructor is private - True', 'Repeat step 4 and 5 for each constructor of class - Only one constructor, already checked.', 'Check whether the class is extended by any other class - True, by `Bar`', "Get the name of the package where the class is located - Assume it's `com.example`", 'Get the classes declared in the same package - Assume it includes `Foo` and `Bar`', 'Check whether any of the classes declared in the same package extend this class - True, `Bar` extends `Foo`', 'Check whether the class is extended by any class outside the same package - False, assuming no other classes outside `com.example` extend `Foo`', 'Get the name of class - Bar', 'Check whether the class is public - False, default package-private', 'Get the number of constructors of class - 1', 'Get a constructor of class - Bar()', 'Check whether the constructor is private - False', 'Repeat step 4 and 5 for each constructor of class - Only one constructor, already checked.', 'Check whether the class is extended by any other class - False', "Get the name of the package where the class is located - Assume it's `com.example`", 'Get the classes declared in the same package - Assume it includes `Foo` and `Bar`', 'Check whether any of the classes declared in the same package extend this class - False, `Bar` does not extend any other class declared in the same package that is not already checked.', 'Check whether the class is extended by any class outside the same package - False']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get the number of constructors of class.* 匹配到的元操作或API：
query: Get the number of constructors of class.
most similar API: get num children of constructor
cosine Similarity: 0.8339141607284546
*Get a constructor of class.* 匹配到的元操作或API：
query: Get a constructor of class.
most similar API: get class of constructor
cosine Similarity: 0.8336949348449707
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Repeat step 4 and 5 for each constructor of class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is extended by any other class.* 匹配到的元操作或API：
logic: Check whether the class is extended by any other class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.8706234693527222
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Get the classes declared in the same package.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any of the classes declared in the same package extend this class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is extended by any class outside the same package.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class - Foo* 匹配到的元操作或API：
logic: Get the name of class - Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.918709933757782
*Check whether the class is public - True* 匹配到的元操作或API：
logic: Check whether the class is public - True
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9742798805236816
*Get the number of constructors of class - 1* 匹配到的元操作或API：
query: Get the number of constructors of class - 1
most similar API: get num children of constructor
cosine Similarity: 0.8354119062423706
*Get a constructor of class - Foo()* 匹配到的元操作或API：
query: Get a constructor of class - Foo()
most similar API: get class of constructor
cosine Similarity: 0.8326075673103333
*Check whether the constructor is private - True* 匹配到的元操作或API：
logic: Check whether the constructor is private - True
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866958856582642
*Repeat step 4 and 5 for each constructor of class - Only one constructor, already checked.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is extended by any other class - True, by `Bar`* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the package where the class is located - Assume it's `com.example`* 匹配到的元操作或API：
logic: Get the name of the package where the class is located - Assume it's `com.example`
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9216124415397644
*Get the classes declared in the same package - Assume it includes `Foo` and `Bar`* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any of the classes declared in the same package extend this class - True, `Bar` extends `Foo`* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is extended by any class outside the same package - False, assuming no other classes outside `com.example` extend `Foo`* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class - Bar* 匹配到的元操作或API：
logic: Get the name of class - Bar
most similar meta operation: Get the name of class
cosine Similarity: 0.8641326427459717
*Check whether the class is public - False, default package-private* 匹配到的元操作或API：
logic: Check whether the class is public - False, default package-private
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9527445435523987
*Get the number of constructors of class - 1* 匹配到的元操作或API：
query: Get the number of constructors of class - 1
most similar API: get num children of constructor
cosine Similarity: 0.8354119062423706
*Get a constructor of class - Bar()* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private - False* 匹配到的元操作或API：
logic: Check whether the constructor is private - False
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9836255311965942
*Repeat step 4 and 5 for each constructor of class - Only one constructor, already checked.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is extended by any other class - False* 匹配到的元操作或API：
logic: Check whether the class is extended by any other class - False
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.8561618328094482
*Get the name of the package where the class is located - Assume it's `com.example`* 匹配到的元操作或API：
logic: Get the name of the package where the class is located - Assume it's `com.example`
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9216124415397644
*Get the classes declared in the same package - Assume it includes `Foo` and `Bar`* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any of the classes declared in the same package extend this class - False, `Bar` does not extend any other class declared in the same package that is not already checked.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is extended by any class outside the same package - False* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Ok, two classes
public class Foo {
    private Foo() { }
}
class Bar extends Foo {
    public Bar() { }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
——ASTClassOrInterfaceDeclaration (class name = 'Bar')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public int getNumChildren()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()

1.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal() && !canBeExtendedFromOutside(node, classNode)) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal() && !canBeExtendedFromOutside(node, classNode)) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean canBeExtendedFromOutside(ASTCompilationUnit node, ASTClassOrInterfaceDeclaration classNode) {
        for (ASTClassOrInterfaceDeclaration otherClass : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!otherClass.equals(classNode)) {
                ASTClassOrInterfaceType superClassType = otherClass.getSuperClassTypeNode();
                if (superClassType != null && superClassType.getPackageName().equals(classNode.getPackageName()) && superClassType.getSimpleName().equals(classNode.getSimpleName())) {
                    return true;
                }
            }
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Check whether the class is public.
        3. Get all constructors of class.
        4. Check whether the constructor is private.
        5. Get the number of private constructors.
        6. Get the name of class.
        7. Check whether the class has extended x class.
        8. Get the number of extending classes.

For `Foo` class:
1. Get the name of class: Foo
2. Check whether the class is public: true
3. Get all constructors of class: [Foo()]
4. Check whether the constructor is private: true
5. Get the number of private constructors: 1
6. Get the name of class: Foo
7. Check whether the class has extended x class: true (Bar extends Foo)
8. Get the number of extending classes: 1

For `Bar` class:
1. Get the name of class: Bar
2. Check whether the class is public: false
3. Get all constructors of class: [Bar()]
4. Check whether the constructor is private: false
5. Get the number of private constructors: 0
6. Get the name of class: Bar
7. Check whether the class has extended x class: true (Bar extends Foo)
8. Get the number of extending classes: 0

Since `Foo` has a private constructor and `Bar` extends it, `Foo` should be made final according to the rule. Therefore, the number of violations in this test case is: 1

However, if the intent is to demonstrate that the rule checker should not report `Foo` as a violation because it can be extended within the same compilation unit (which is the case here), then:

The number of violations in this test case is: 0

The rule checker should not report `Foo` as a violation because `Bar` is in the same compilation unit and can extend `Foo` despite the private constructor.
['Get the name of class.', 'Check whether the class is public.', 'Get all constructors of class.', 'Check whether the constructor is private.', 'Get the number of private constructors.', 'Get the name of class.', 'Check whether the class has extended x class.', 'Get the number of extending classes.', 'Get the name of class: Foo', 'Check whether the class is public: true', 'Get all constructors of class: [Foo()]', 'Check whether the constructor is private: true', 'Get the number of private constructors: 1', 'Get the name of class: Foo', 'Check whether the class has extended x class: true (Bar extends Foo)', 'Get the number of extending classes: 1', 'Get the name of class: Bar', 'Check whether the class is public: false', 'Get all constructors of class: [Bar()]', 'Check whether the constructor is private: false', 'Get the number of private constructors: 0', 'Get the name of class: Bar', 'Check whether the class has extended x class: true (Bar extends Foo)', 'Get the number of extending classes: 0']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors of class.* 匹配到的元操作或API：
query: Get all constructors of class.
most similar API: get class of constructor
cosine Similarity: 0.8041397333145142
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the number of private constructors.* 匹配到的元操作或API：
query: Get the number of private constructors.
most similar API: get num children of constructor
cosine Similarity: 0.8175932765007019
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get the number of extending classes.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: Foo* 匹配到的元操作或API：
logic: Get the name of class: Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9263077974319458
*Check whether the class is public: true* 匹配到的元操作或API：
logic: Check whether the class is public: true
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9707064628601074
*Get all constructors of class: [Foo()]* 匹配到的元操作或API：
query: Get all constructors of class: [Foo()]
most similar API: get parents of type of constructor
cosine Similarity: 0.8157392740249634
*Check whether the constructor is private: true* 匹配到的元操作或API：
logic: Check whether the constructor is private: true
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9794564843177795
*Get the number of private constructors: 1* 匹配到的元操作或API：
query: Get the number of private constructors: 1
most similar API: get num children of constructor
cosine Similarity: 0.8240189552307129
*Get the name of class: Foo* 匹配到的元操作或API：
logic: Get the name of class: Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9263077974319458
*Check whether the class has extended x class: true (Bar extends Foo)* 匹配到的元操作或API：
logic: Check whether the class has extended x class: true (Bar extends Foo)
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.935807466506958
*Get the number of extending classes: 1* 匹配到的元操作或API：
query: Get the number of extending classes: 1
most similar API: get num children of extends list
cosine Similarity: 0.8038555383682251
*Get the name of class: Bar* 匹配到的元操作或API：
logic: Get the name of class: Bar
most similar meta operation: Get the name of class
cosine Similarity: 0.8756611347198486
*Check whether the class is public: false* 匹配到的元操作或API：
logic: Check whether the class is public: false
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9623566269874573
*Get all constructors of class: [Bar()]* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private: false* 匹配到的元操作或API：
logic: Check whether the constructor is private: false
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9771820306777954
*Get the number of private constructors: 0* 匹配到的元操作或API：
query: Get the number of private constructors: 0
most similar API: get num children of constructor
cosine Similarity: 0.8088661432266235
*Get the name of class: Bar* 匹配到的元操作或API：
logic: Get the name of class: Bar
most similar meta operation: Get the name of class
cosine Similarity: 0.8756611347198486
*Check whether the class has extended x class: true (Bar extends Foo)* 匹配到的元操作或API：
logic: Check whether the class has extended x class: true (Bar extends Foo)
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.935807466506958
*Get the number of extending classes: 0* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Ok, two classes
public class Foo {
    private Foo() { }
}
class Bar extends Foo {
    public Bar() { }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
——ASTClassOrInterfaceDeclaration (class name = 'Bar')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public int getNumChildren()
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.util.List<List<T> getParentsOfType(java.lang.Class)
7. net.sourceforge.pmd.lang.java.ast.ASTExtendsList: public int getNumChildren()

1.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    if (!isExtendedByAnotherClassInSameCompilationUnit(classNode, node)) {
                        addViolation(data, classNode);
                    }
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    if (!isExtendedByAnotherClassInSameCompilationUnit(classNode, node)) {
                        addViolation(data, classNode);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isExtendedByAnotherClassInSameCompilationUnit(ASTClassOrInterfaceDeclaration classNode, ASTCompilationUnit compilationUnit) {
        for (ASTClassOrInterfaceDeclaration candidate : compilationUnit.children(ASTClassOrInterfaceDeclaration.class)) {
            ASTExtendsList extendsList = candidate.getFirstDescendantOfType(ASTExtendsList.class);
            if (extendsList != null && extendsList.getNumChildren() > 0) {
                for (ASTClassOrInterfaceType type : extendsList.children(ASTClassOrInterfaceType.class)) {
                    if (type.getSimpleName().equals(classNode.getSimpleName())) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 6" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 6" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Check whether the class has declared annotations.
        3. Get the number of constructors of the class.
        4. Get a constructor of the class.
        5. Check whether the constructor is private.
        6. Repeat steps 4 and 5 for all constructors of the class.
        7. Check whether the class is public.
        8. Check whether the class has subclasses in the same compilation unit.
        9. Get the name of the subclass.
        10. Check whether the subclass has a constructor that calls the superclass constructor.
        
For class `Foo`:
1. Get the name of class. // Foo
2. Check whether the class has declared annotations. // No
3. Get the number of constructors of the class. // 1
4. Get a constructor of the class. // private Foo() { }
5. Check whether the constructor is private. // Yes
6. Repeat steps 4 and 5 for all constructors of the class. // Only one constructor, already checked.
7. Check whether the class is public. // Yes
8. Check whether the class has subclasses in the same compilation unit. // Yes, Bar
9. Get the name of the subclass. // Bar
10. Check whether the subclass has a constructor that calls the superclass constructor. // No, Bar's constructor does not call Foo's constructor.

Since class `Foo` has a public constructor that is private, and there is a subclass `Bar` in the same compilation unit, the test case does not violate the rule. The number of violating the rule in this test case is: 0.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get the number of constructors of the class.', 'Get a constructor of the class.', 'Check whether the constructor is private.', 'Repeat steps 4 and 5 for all constructors of the class.', 'Check whether the class is public.', 'Check whether the class has subclasses in the same compilation unit.', 'Get the name of the subclass.', 'Check whether the subclass has a constructor that calls the superclass constructor.', 'Get the name of class. // Foo', 'Check whether the class has declared annotations. // No', 'Get the number of constructors of the class. // 1', 'Get a constructor of the class. // private Foo() { }', 'Check whether the constructor is private. // Yes', 'Repeat steps 4 and 5 for all constructors of the class. // Only one constructor, already checked.', 'Check whether the class is public. // Yes', 'Check whether the class has subclasses in the same compilation unit. // Yes, Bar', 'Get the name of the subclass. // Bar', "Check whether the subclass has a constructor that calls the superclass constructor. // No, Bar's constructor does not call Foo's constructor."]
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the number of constructors of the class.* 匹配到的元操作或API：
query: Get the number of constructors of the class.
most similar API: get num children of constructor
cosine Similarity: 0.8342469334602356
*Get a constructor of the class.* 匹配到的元操作或API：
query: Get a constructor of the class.
most similar API: get class of constructor
cosine Similarity: 0.8243112564086914
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Repeat steps 4 and 5 for all constructors of the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class has subclasses in the same compilation unit.* 匹配到的元操作或API：
query: Check whether the class has subclasses in the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.83914715051651
*Get the name of the subclass.* 匹配到的元操作或API：
logic: Get the name of the subclass.
most similar meta operation: Get the name of class
cosine Similarity: 0.8767187595367432
*Check whether the subclass has a constructor that calls the superclass constructor.* 匹配到的元操作或API：
query: Check whether the subclass has a constructor that calls the superclass constructor.
most similar API: Check whether the constructor equals
cosine Similarity: 0.8118511438369751
*Get the name of class. // Foo* 匹配到的元操作或API：
logic: Get the name of class. // Foo
most similar meta operation: Get the name of class
cosine Similarity: 0.9075836539268494
*Check whether the class has declared annotations. // No* 匹配到的元操作或API：
logic: Check whether the class has declared annotations. // No
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9501485824584961
*Get the number of constructors of the class. // 1* 匹配到的元操作或API：
query: Get the number of constructors of the class. // 1
most similar API: get num children of constructor
cosine Similarity: 0.8248465657234192
*Get a constructor of the class. // private Foo() { }* 匹配到的元操作或API：
query: Get a constructor of the class. // private Foo() { }
most similar API: get class of constructor
cosine Similarity: 0.8022168874740601
*Check whether the constructor is private. // Yes* 匹配到的元操作或API：
logic: Check whether the constructor is private. // Yes
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9567610621452332
*Repeat steps 4 and 5 for all constructors of the class. // Only one constructor, already checked.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is public. // Yes* 匹配到的元操作或API：
logic: Check whether the class is public. // Yes
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9455323219299316
*Check whether the class has subclasses in the same compilation unit. // Yes, Bar* 匹配到的元操作或API：
query: Check whether the class has subclasses in the same compilation unit. // Yes, Bar
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.80987548828125
*Get the name of the subclass. // Bar* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass has a constructor that calls the superclass constructor. // No, Bar's constructor does not call Foo's constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false positive) on this positive test case:
```
// Ok, two classes
public class Foo {
    private Foo() { }
}
class Bar extends Foo {
    public Bar() { }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
——ASTClassOrInterfaceDeclaration (class name = 'Bar')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public int getNumChildren()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean equals(java.lang.Object)

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    boolean isExtendedOutsideCompilationUnit = false;
                    for (ASTClassOrInterfaceDeclaration potentialSubclass : node.children(ASTClassOrInterfaceDeclaration.class)) {
                        ASTExtendsList extendsList = potentialSubclass.getFirstChildOfType(ASTExtendsList.class);
                        if (extendsList != null) {
                            for (ASTClassOrInterfaceType type : extendsList) {
                                if (type.isReferenceToClassSameCompilationUnit() && type.getType() != null && type.getType().getSimpleName().equals(classNode.getSimpleName())) {
                                    isExtendedOutsideCompilationUnit = true;
                                    break;
                                }
                            }
                        }
                    }
                    if (!isExtendedOutsideCompilationUnit) {
                        addViolation(data, classNode);
                    }
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 6" resulted in wrong number of failures, ==> expected: <0> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 6" resulted in wrong number of failures, ==> expected: <0> but was: <2>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 6
[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Check whether the class is public.
        3. Get all constructors declared in class.
        4. Check whether the constructor is private.
        5. Check whether the class has other constructors.
        6. Check whether the class is declared in the same compilation unit as another class.
        7. Check whether the class is final.

If the class is public, has only private constructors, is not already declared final, and is declared in the same compilation unit as another class, then this class should be made final according to the rule.

Let's perform the checks on the provided test case:

1. Get the name of class: Example
2. Check whether the class is public: true
3. Get all constructors declared in class: private Example()
4. Check whether the constructor is private: true
5. Check whether the class has other constructors: false
6. Check whether the class is declared in the same compilation unit as another class: true (Another class is in the same compilation unit)
7. Check whether the class is final: false

Since all checks except the last one are true, this class should be made final according to the rule, indicating a violation. However, the provided test case states that the violation count is 1, which aligns with our analysis.

For the `Another` class:

1. Get the name of class: Another
2. Check whether the class is public: false
3. Get all constructors declared in class: default constructor (implicitly public)
4. Check whether the constructor is private: false
5. Check whether the class has other constructors: false
6. Check whether the class is declared in the same compilation unit as another class: true (Example class is in the same compilation unit)
7. Check whether the class is final: false

Since the `Another` class does not meet all the criteria (it is not public and its constructor is implicitly public), it does not violate the rule.
['Get the name of class.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has other constructors.', 'Check whether the class is declared in the same compilation unit as another class.', 'Check whether the class is final.', 'Get the name of class: Example', 'Check whether the class is public: true', 'Get all constructors declared in class: private Example()', 'Check whether the constructor is private: true', 'Check whether the class has other constructors: false', 'Check whether the class is declared in the same compilation unit as another class: true (Another class is in the same compilation unit)', 'Check whether the class is final: false', 'Get the name of class: Another', 'Check whether the class is public: false', 'Get all constructors declared in class: default constructor (implicitly public)', 'Check whether the constructor is private: false', 'Check whether the class has other constructors: false', 'Check whether the class is declared in the same compilation unit as another class: true (Example class is in the same compilation unit)', 'Check whether the class is final: false']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has other constructors.* 匹配到的元操作或API：
query: Check whether the class has other constructors.
most similar API: Check whether the constructor equals
cosine Similarity: 0.8463876247406006
*Check whether the class is declared in the same compilation unit as another class.* 匹配到的元操作或API：
query: Check whether the class is declared in the same compilation unit as another class.
most similar API: Check whether the compilation unit equals
cosine Similarity: 0.862909197807312
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get the name of class: Example* 匹配到的元操作或API：
logic: Get the name of class: Example
most similar meta operation: Get the name of class
cosine Similarity: 0.9322656989097595
*Check whether the class is public: true* 匹配到的元操作或API：
logic: Check whether the class is public: true
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9707064628601074
*Get all constructors declared in class: private Example()* 匹配到的元操作或API：
query: Get all constructors declared in class: private Example()
most similar API: get declared annotations of constructor
cosine Similarity: 0.8102943897247314
*Check whether the constructor is private: true* 匹配到的元操作或API：
logic: Check whether the constructor is private: true
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9794564843177795
*Check whether the class has other constructors: false* 匹配到的元操作或API：
query: Check whether the class has other constructors: false
most similar API: Check whether the constructor equals
cosine Similarity: 0.8451715111732483
*Check whether the class is declared in the same compilation unit as another class: true (Another class is in the same compilation unit)* 匹配到的元操作或API：
query: Check whether the class is declared in the same compilation unit as another class: true (Another class is in the same compilation unit)
most similar API: Check whether the compilation unit equals
cosine Similarity: 0.8525612950325012
*Check whether the class is final: false* 匹配到的元操作或API：
logic: Check whether the class is final: false
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9627463817596436
*Get the name of class: Another* 匹配到的元操作或API：
logic: Get the name of class: Another
most similar meta operation: Get the name of class
cosine Similarity: 0.8873497247695923
*Check whether the class is public: false* 匹配到的元操作或API：
logic: Check whether the class is public: false
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9623566269874573
*Get all constructors declared in class: default constructor (implicitly public)* 匹配到的元操作或API：
query: Get all constructors declared in class: default constructor (implicitly public)
most similar API: get declared annotations of constructor
cosine Similarity: 0.8126890063285828
*Check whether the constructor is private: false* 匹配到的元操作或API：
logic: Check whether the constructor is private: false
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9771820306777954
*Check whether the class has other constructors: false* 匹配到的元操作或API：
query: Check whether the class has other constructors: false
most similar API: Check whether the constructor equals
cosine Similarity: 0.8451715111732483
*Check whether the class is declared in the same compilation unit as another class: true (Example class is in the same compilation unit)* 匹配到的元操作或API：
query: Check whether the class is declared in the same compilation unit as another class: true (Example class is in the same compilation unit)
most similar API: Check whether the compilation unit equals
cosine Similarity: 0.8370209336280823
*Check whether the class is final: false* 匹配到的元操作或API：
logic: Check whether the class is final: false
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9627463817596436
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false negative) on this negative test case:
```
// [java] ClassWithOnlyPrivateConstructorsShouldBeFinal - false negative when a compilation unit contains two class declarations #3851
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Example')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
——ASTClassOrInterfaceDeclaration (class name = 'Another')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean equals(java.lang.Object)
6. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean equals(java.lang.Object)
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is public.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Count the number of private constructors in the class.
6. Check whether the number of private constructors is equal to the total number of constructors declared in the class.
7. Check whether the class is final.

To determine if the test case violates the rule:
- Step 1 to Step 2: Identify the public class `Example`.
- Step 3 to Step 5: Check that `Example` has one constructor, and it is private.
- Step 6: Confirm that the number of private constructors (1) equals the total number of constructors (1).
- Step 7: Check if `Example` is final.

Based on the test case provided:
- Step 1: Get the name of class -> `Example`
- Step 2: Check whether the class is public -> True
- Step 3: Get all constructors declared in class -> One constructor found
- Step 4: Check whether the constructor is private -> True
- Step 5: Count the number of private constructors in the class -> 1 private constructor
- Step 6: Check whether the number of private constructors is equal to the total number of constructors declared in the class -> True
- Step 7: Check whether the class is final -> False

Since `Example` is public, all its constructors are private, and it is not final, this test case violates the rule.
['Get the name of class.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Count the number of private constructors in the class.', 'Check whether the number of private constructors is equal to the total number of constructors declared in the class.', 'Check whether the class is final.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Count the number of private constructors in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the number of private constructors is equal to the total number of constructors declared in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false negative) on this negative test case:
```
// [java] ClassWithOnlyPrivateConstructorsShouldBeFinal - false negative when a compilation unit contains two class declarations #3851
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Example')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
——ASTClassOrInterfaceDeclaration (class name = 'Another')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        NodeStream<ASTClassOrInterfaceDeclaration> classNodes = node.children(ASTClassOrInterfaceDeclaration.class);
        for (ASTClassOrInterfaceDeclaration classNode : classNodes) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <2>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <2>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is public.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Determine if there is more than one class declared in the compilation unit.
6. Get the name of the second class.
7. Check whether the second class has any constructors.
8. Check whether the second class has any public constructors.

If the class is public, all its constructors are private, and there is only one class in the compilation unit, then this class should be final. If these conditions are met, but the class is not final, it is a violation of the rule. In this test case, `Example` class is public and has only private constructors, but it is not final, so it should be reported as a violation. `Another` class does not need to be checked as it is not public and thus cannot be extended from outside its compilation unit.

Therefore, the number of violations in this test case is: 1
['Get the name of class.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Determine if there is more than one class declared in the compilation unit.', 'Get the name of the second class.', 'Check whether the second class has any constructors.', 'Check whether the second class has any public constructors.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Determine if there is more than one class declared in the compilation unit.* 匹配到的元操作或API：
query: Determine if there is more than one class declared in the compilation unit.
most similar API: Check whether the compilation unit is unnamed class
cosine Similarity: 0.8171294927597046
*Get the name of the second class.* 匹配到的元操作或API：
logic: Get the name of the second class.
most similar meta operation: Get the name of class
cosine Similarity: 0.8666036128997803
*Check whether the second class has any constructors.* 匹配到的元操作或API：
query: Check whether the second class has any constructors.
most similar API: Check whether the constructor is any annotation present
cosine Similarity: 0.8309801816940308
*Check whether the second class has any public constructors.* 匹配到的元操作或API：
query: Check whether the second class has any public constructors.
most similar API: Check whether the constructor is public
cosine Similarity: 0.8457008600234985
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    addViolation(data, classNode);
                }
            }
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}


This checker is failed(false negative) on this negative test case:
```
// [java] ClassWithOnlyPrivateConstructorsShouldBeFinal - false negative when a compilation unit contains two class declarations #3851
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Example')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
——ASTClassOrInterfaceDeclaration (class name = 'Another')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean isUnnamedClass()
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection), //Checks whether any annotation is present on this node. @param binaryNames            Collection that contains binary names of annotations.            Note: for now, canonical names are tolerated, this may be changed in PMD 7. @return <code>true</code> if any annotation is present on this node, else <code>false</code>
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "ok 9" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
94
78
95
80
111
94
94
78
107
91
=========================error_testcase_logics=========================
To determine if the provided test case adheres to the rule, we will perform the following granular checks:

1. Get the name of class.
2. Get the name of constructor of class.
3. Check whether the constructor is private.
4. Check whether the class has declared annotations.
5. Get all methods declared in class.
6. Check whether the class has extended x class.
7. Check whether the extended class is in the same compilation unit.
8. Get the name of the superclass.
9. Get the name of constructor of superclass.
10. Check whether the superclass constructor is private.
11. Check whether the class is abstract.
12. Check whether the class is public.

Performing these checks on the `Main209` class:

1. Get the name of class.
   - The name of the class is `Main209`.

2. Get the name of constructor of class.
   - `Main209` does not have any explicitly defined constructors.

3. Check whether the constructor is private.
   - Not applicable as `Main209` does not have any explicitly defined constructors.

Performing these checks on the `InputBits` inner class:

4. Get the name of class.
   - The name of the class is `InputBits`.

5. Get the name of constructor of class.
   - The name of the constructor is `InputBits`.

6. Check whether the constructor is private.
   - The constructor `InputBits(int number)` is private.

7. Check whether the class has declared annotations.
   - `InputBits` does not have any declared annotations.

8. Get all methods declared in class.
   - `InputBits` does not have any methods declared.

9. Check whether the class has extended x class.
   - `InputBits` does not extend any other class.

10. Check whether the extended class is in the same compilation unit.
    - Not applicable as `InputBits` does not extend any other class.

11. Check whether the class is abstract.
    - `InputBits` is not abstract.

12. Check whether the class is public.
    - `InputBits` is private.

Performing these checks on the `Sub` inner class:

13. Get the name of class.
    - The name of the class is `Sub`.

14. Get the name of constructor of class.
    - The name of the constructor is `Sub`.

15. Check whether the constructor is private.
    - The constructor `Sub()` is private.

16. Check whether the class has declared annotations.
    - `Sub` has a declared annotation `final`.

17. Get all methods declared in class.
    - `Sub` does not have any methods declared.

18. Check whether the class has extended x class.
    - `Sub` extends `InputBits`.

19. Check whether the extended class is in the same compilation unit.
    - `InputBits` is an inner class in the same outer class `Main209`, so it is in the same compilation unit.

20. Get the name of the superclass.
    - The superclass of `Sub` is `InputBits`.

21. Get the name of constructor of superclass.
    - The name of the constructor of `InputBits` is `InputBits`.

22. Check whether the superclass constructor is private.
    - The constructor `InputBits(int number)` is private.

23. Check whether the class is abstract.
    - `Sub` is not abstract.

24. Check whether the class is public.
    - `Sub` is public.

Based on these checks:
- `InputBits` has a private constructor, making it non-extendable from outside its compilation unit.
- `Sub` is a public final class that extends `InputBits`.
- Since `InputBits` is private and cannot be extended from outside its compilation unit, making `Sub` final does not violate the rule.

Therefore, the number of violations in this test case is indeed 0.
['Get the name of class.', 'Get the name of constructor of class.', 'Check whether the constructor is private.', 'Check whether the class has declared annotations.', 'Get all methods declared in class.', 'Check whether the class has extended x class.', 'Check whether the extended class is in the same compilation unit.', 'Get the name of the superclass.', 'Get the name of constructor of superclass.', 'Check whether the superclass constructor is private.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Get the name of class.', 'Get the name of constructor of class.', 'Check whether the constructor is private.', 'Get the name of class.', 'Get the name of constructor of class.', 'Check whether the constructor is private.', 'Check whether the class has declared annotations.', 'Get all methods declared in class.', 'Check whether the class has extended x class.', 'Check whether the extended class is in the same compilation unit.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Get the name of class.', 'Get the name of constructor of class.', 'Check whether the constructor is private.', 'Check whether the class has declared annotations.', 'Get all methods declared in class.', 'Check whether the class has extended x class.', 'Check whether the extended class is in the same compilation unit.', 'Get the name of the superclass.', 'Get the name of constructor of superclass.', 'Check whether the superclass constructor is private.', 'Check whether the class is abstract.', 'Check whether the class is public.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTExplicitConstructorInvocation', 'ASTFormalParameters', 'ASTBlock', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'ASTNumericLiteral', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of constructor of class.* 匹配到的元操作或API：
logic: Get the name of constructor of class.
most similar meta operation: Get the name of constructor
cosine Similarity: 0.9532394409179688
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8142814636230469
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Check whether the extended class is in the same compilation unit.* 匹配到的元操作或API：
query: Check whether the extended class is in the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8744760751724243
*Get the name of the superclass.* 匹配到的元操作或API：
logic: Get the name of the superclass.
most similar meta operation: Get the super class of class
cosine Similarity: 0.8648006319999695
*Get the name of constructor of superclass.* 匹配到的元操作或API：
logic: Get the name of constructor of superclass.
most similar meta operation: Get the name of constructor
cosine Similarity: 0.9053577184677124
*Check whether the superclass constructor is private.* 匹配到的元操作或API：
logic: Check whether the superclass constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9311612248420715
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of constructor of class.* 匹配到的元操作或API：
logic: Get the name of constructor of class.
most similar meta operation: Get the name of constructor
cosine Similarity: 0.9532394409179688
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of constructor of class.* 匹配到的元操作或API：
logic: Get the name of constructor of class.
most similar meta operation: Get the name of constructor
cosine Similarity: 0.9532394409179688
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8142814636230469
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Check whether the extended class is in the same compilation unit.* 匹配到的元操作或API：
query: Check whether the extended class is in the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8744760751724243
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of constructor of class.* 匹配到的元操作或API：
logic: Get the name of constructor of class.
most similar meta operation: Get the name of constructor
cosine Similarity: 0.9532394409179688
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8142814636230469
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Check whether the extended class is in the same compilation unit.* 匹配到的元操作或API：
query: Check whether the extended class is in the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8744760751724243
*Get the name of the superclass.* 匹配到的元操作或API：
logic: Get the name of the superclass.
most similar meta operation: Get the super class of class
cosine Similarity: 0.8648006319999695
*Get the name of constructor of superclass.* 匹配到的元操作或API：
logic: Get the name of constructor of superclass.
most similar meta operation: Get the name of constructor
cosine Similarity: 0.9053577184677124
*Check whether the superclass constructor is private.* 匹配到的元操作或API：
logic: Check whether the superclass constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9311612248420715
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Inner class with only private constructor extended within compilation unit (#2536)
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
    public static final class Sub extends InputBits {
        private Sub() {
            super(1);
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
            ——ASTExplicitConstructorInvocation
              ——ASTArgumentList (size = 1)
                ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.String getName()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        Set<String> innerClassNames = new HashSet<>();

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
            innerClassNames.add(classNode.getSimpleName());
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                ASTClassOrInterfaceType superClassTypeNode = classNode.getSuperClassTypeNode();
                if (superClassTypeNode != null && !superClassTypeNode.isReferenceToClassSameCompilationUnit()) {
                    continue;
                }
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 9" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 9" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
To verify whether the given test case adheres to the rule, we need to perform the following granular checks:

1. Get the name of class.
2. Check whether the class is abstract.
3. Check whether the class has declared annotations.
4. Get the super class of class.
5. Check whether the super class has constructors.
6. Get the number of constructors of super class.
7. Get a constructor of super class.
8. Check whether the constructor is private.
9. Check whether the class is extended by any other class within the same compilation unit.
10. Get the name of the class that extends the super class.
11. Check whether the extending class has declared constructors.
12. Get the number of constructors of the extending class.
13. Get a constructor of the extending class.
14. Get the type of method caller in the super constructor call.
15. Check whether the method caller is the super class.

For the provided test case, we will perform the checks on both `Main209.InputBits` and `Main209.Sub`:

### Checks on `Main209.InputBits`

1. Get the name of class.
   - `InputBits`
2. Check whether the class is abstract.
   - `false`
3. Check whether the class has declared annotations.
   - `false`
4. Get the super class of class.
   - `Object`
5. Check whether the super class has constructors.
   - `true` (Object has a default constructor)
6. Get the number of constructors of super class.
   - `1` (Object has one default constructor)
7. Get a constructor of super class.
   - `Object()`
8. Check whether the constructor is private.
   - `false` (Object's default constructor is not private)
9. Check whether the class is extended by any other class within the same compilation unit.
   - `true` (Sub extends InputBits)
10. Get the name of the class that extends the super class.
    - `Sub`
11. Check whether the extending class has declared constructors.
    - `true` (Sub has a constructor)
12. Get the number of constructors of the extending class.
    - `1` (Sub has one constructor)
13. Get a constructor of the extending class.
    - `Sub()`
14. Get the type of method caller in the super constructor call.
    - `InputBits`
15. Check whether the method caller is the super class.
    - `true` (InputBits is the super class of Sub)

### Checks on `Main209.InputBits` (Constructor Specific)

1. Check whether the constructor is private.
   - `true` (InputBits constructor is private)

### Checks on `Main209.Sub`

1. Get the name of class.
   - `Sub`
2. Check whether the class is abstract.
   - `false`
3. Check whether the class has declared annotations.
   - `false`
4. Get the super class of class.
   - `InputBits`
5. Check whether the super class has constructors.
   - `true` (InputBits has a constructor)
6. Get the number of constructors of super class.
   - `1` (InputBits has one constructor)
7. Get a constructor of super class.
   - `InputBits(int number)`
8. Check whether the constructor is private.
   - `true` (InputBits constructor is private)
9. Check whether the class is extended by any other class within the same compilation unit.
   - `false` (Sub is not extended by any other class)
10. Get the name of the class that extends the super class.
    - `N/A` (Sub is not extended by any other class)
11. Check whether the extending class has declared constructors.
    - `true` (Sub has a constructor)
12. Get the number of constructors of the extending class.
    - `1` (Sub has one constructor)
13. Get a constructor of the extending class.
    - `Sub()`
14. Get the type of method caller in the super constructor call.
    - `InputBits`
15. Check whether the method caller is the super class.
    - `true` (InputBits is the super class of Sub)

### Final Analysis

- `Main209.InputBits` has a private constructor, which prevents it from being extended from outside its compilation unit.
- `Main209.Sub` is extending `InputBits` within the same compilation unit, which is allowed.
- Since `Main209.InputBits` does not violate the rule (it has a private constructor and is extended within the same compilation unit), the number of violations is `0`.

The provided test case does not violate the rule as `InputBits` is an abstract class with a private constructor and is extended within the same compilation unit by `Sub`.
['Get the name of class.', 'Check whether the class is abstract.', 'Check whether the class has declared annotations.', 'Get the super class of class.', 'Check whether the super class has constructors.', 'Get the number of constructors of super class.', 'Get a constructor of super class.', 'Check whether the constructor is private.', 'Check whether the class is extended by any other class within the same compilation unit.', 'Get the name of the class that extends the super class.', 'Check whether the extending class has declared constructors.', 'Get the number of constructors of the extending class.', 'Get a constructor of the extending class.', 'Get the type of method caller in the super constructor call.', 'Check whether the method caller is the super class.', 'Get the name of class.', 'Check whether the class is abstract.', 'Check whether the class has declared annotations.', 'Get the super class of class.', 'Check whether the super class has constructors.', 'Get the number of constructors of super class.', 'Get a constructor of super class.', 'Check whether the constructor is private.', 'Check whether the class is extended by any other class within the same compilation unit.', 'Get the name of the class that extends the super class.', 'Check whether the extending class has declared constructors.', 'Get the number of constructors of the extending class.', 'Get a constructor of the extending class.', 'Get the type of method caller in the super constructor call.', 'Check whether the method caller is the super class.', 'Check whether the constructor is private.', 'Get the name of class.', 'Check whether the class is abstract.', 'Check whether the class has declared annotations.', 'Get the super class of class.', 'Check whether the super class has constructors.', 'Get the number of constructors of super class.', 'Get a constructor of super class.', 'Check whether the constructor is private.', 'Check whether the class is extended by any other class within the same compilation unit.', 'Get the name of the class that extends the super class.', 'Check whether the extending class has declared constructors.', 'Get the number of constructors of the extending class.', 'Get a constructor of the extending class.', 'Get the type of method caller in the super constructor call.', 'Check whether the method caller is the super class.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTExplicitConstructorInvocation', 'ASTFormalParameters', 'ASTBlock', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'ASTNumericLiteral', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the super class has constructors.* 匹配到的元操作或API：
query: Check whether the super class has constructors.
most similar API: Check whether the explicit constructor invocation is super
cosine Similarity: 0.8504078984260559
*Get the number of constructors of super class.* 匹配到的元操作或API：
query: Get the number of constructors of super class.
most similar API: get num children of constructor
cosine Similarity: 0.8129885196685791
*Get a constructor of super class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is extended by any other class within the same compilation unit.* 匹配到的元操作或API：
query: Check whether the class is extended by any other class within the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8361928462982178
*Get the name of the class that extends the super class.* 匹配到的元操作或API：
logic: Get the name of the class that extends the super class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.8597248792648315
*Check whether the extending class has declared constructors.* 匹配到的元操作或API：
logic: Check whether the extending class has declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.862841784954071
*Get the number of constructors of the extending class.* 匹配到的元操作或API：
query: Get the number of constructors of the extending class.
most similar API: get argument count of explicit constructor invocation: Returns the number of arguments of the called constructor.
cosine Similarity: 0.8083180785179138
*Get a constructor of the extending class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of method caller in the super constructor call.* 匹配到的元操作或API：
logic: Get the type of method caller in the super constructor call.
most similar meta operation: Get the type of method caller
cosine Similarity: 0.9157773852348328
*Check whether the method caller is the super class.* 匹配到的元操作或API：
logic: Check whether the method caller is the super class.
most similar meta operation: Check whether the method caller is super
cosine Similarity: 0.9377152323722839
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the super class has constructors.* 匹配到的元操作或API：
query: Check whether the super class has constructors.
most similar API: Check whether the explicit constructor invocation is super
cosine Similarity: 0.8504078984260559
*Get the number of constructors of super class.* 匹配到的元操作或API：
query: Get the number of constructors of super class.
most similar API: get num children of constructor
cosine Similarity: 0.8129885196685791
*Get a constructor of super class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is extended by any other class within the same compilation unit.* 匹配到的元操作或API：
query: Check whether the class is extended by any other class within the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8361928462982178
*Get the name of the class that extends the super class.* 匹配到的元操作或API：
logic: Get the name of the class that extends the super class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.8597248792648315
*Check whether the extending class has declared constructors.* 匹配到的元操作或API：
logic: Check whether the extending class has declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.862841784954071
*Get the number of constructors of the extending class.* 匹配到的元操作或API：
query: Get the number of constructors of the extending class.
most similar API: get argument count of explicit constructor invocation: Returns the number of arguments of the called constructor.
cosine Similarity: 0.8083180785179138
*Get a constructor of the extending class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of method caller in the super constructor call.* 匹配到的元操作或API：
logic: Get the type of method caller in the super constructor call.
most similar meta operation: Get the type of method caller
cosine Similarity: 0.9157773852348328
*Check whether the method caller is the super class.* 匹配到的元操作或API：
logic: Check whether the method caller is the super class.
most similar meta operation: Check whether the method caller is super
cosine Similarity: 0.9377152323722839
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the super class has constructors.* 匹配到的元操作或API：
query: Check whether the super class has constructors.
most similar API: Check whether the explicit constructor invocation is super
cosine Similarity: 0.8504078984260559
*Get the number of constructors of super class.* 匹配到的元操作或API：
query: Get the number of constructors of super class.
most similar API: get num children of constructor
cosine Similarity: 0.8129885196685791
*Get a constructor of super class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is extended by any other class within the same compilation unit.* 匹配到的元操作或API：
query: Check whether the class is extended by any other class within the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8361928462982178
*Get the name of the class that extends the super class.* 匹配到的元操作或API：
logic: Get the name of the class that extends the super class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.8597248792648315
*Check whether the extending class has declared constructors.* 匹配到的元操作或API：
logic: Check whether the extending class has declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.862841784954071
*Get the number of constructors of the extending class.* 匹配到的元操作或API：
query: Get the number of constructors of the extending class.
most similar API: get argument count of explicit constructor invocation: Returns the number of arguments of the called constructor.
cosine Similarity: 0.8083180785179138
*Get a constructor of the extending class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of method caller in the super constructor call.* 匹配到的元操作或API：
logic: Get the type of method caller in the super constructor call.
most similar meta operation: Get the type of method caller
cosine Similarity: 0.9157773852348328
*Check whether the method caller is the super class.* 匹配到的元操作或API：
logic: Check whether the method caller is the super class.
most similar meta operation: Check whether the method caller is super
cosine Similarity: 0.9377152323722839
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Inner class with only private constructor extended within compilation unit (#2536)
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
    public static final class Sub extends InputBits {
        private Sub() {
            super(1);
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
            ——ASTExplicitConstructorInvocation
              ——ASTArgumentList (size = 1)
                ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
4. net.sourceforge.pmd.lang.java.ast.ASTExplicitConstructorInvocation: public boolean isSuper(), //Returns true if this statement calls a constructor of the direct superclass. The JLS calls that a <i>superclass constructor invocation</i>.
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public int getNumChildren()
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot
8. net.sourceforge.pmd.lang.java.ast.ASTExplicitConstructorInvocation: public int getArgumentCount(), //Returns the number of arguments of the called constructor.

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether constructor has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTConstructorDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```
3.  //Get the type of method caller
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getMethodCallerType(ASTMethodCall node){
    ASTExpression expression = node.getQualifier();
    if(expression != null){
        return expression.getTypeMirror();
    }
    return null;
}
```
4.  //Check whether the method caller is super
```java
import net.sourceforge.pmd.lang.java.ast.ASTSuperExpression;
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
public boolean isMethodCallerSuper(ASTMethodCall methodCall){
    if (methodCall.getQualifier() instanceof ASTSuperExpression){
        return true;
    }
    return false;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                ASTClassOrInterfaceType superClassType = classNode.getSuperClassTypeNode();
                if (superClassType != null && !superClassType.isReferenceToClassSameCompilationUnit()) {
                    privateConstructorClassNames.remove(classNode.getSimpleName());
                } else {
                    for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                        for (ASTExplicitConstructorInvocation ecci : constructor.children(ASTExplicitConstructorInvocation.class)) {
                            if (ecci.isSuper() && ecci.getArgumentCount() > 0) {
                                privateConstructorClassNames.remove(classNode.getSimpleName());
                                break;
                            }
                        }
                    }
                }
                if (privateConstructorClassNames.contains(classNode.getSimpleName())) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 9" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 9" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
To ascertain whether the provided test case adheres to the rule, we need to perform the following granular checks:

1. Get the name of class.
2. Check whether the class is an inner class.
3. Get the constructors of class.
4. Check whether each constructor is private.
5. Get the subclasses of class.
6. Check whether the subclass is within the same compilation unit.

Let's perform these checks for both `InputBits` and `Sub` classes:

### InputBits Class Checks
1. Get the name of class.
        -> The name of the class is `InputBits`.
2. Check whether the class is an inner class.
        -> Yes, `InputBits` is an inner class of `Main209`.
3. Get the constructors of class.
        -> The constructor of `InputBits` is `private InputBits(int number)`.
4. Check whether each constructor is private.
        -> Yes, the constructor is private.
5. Get the subclasses of class.
        -> `Sub` is a subclass of `InputBits`.
6. Check whether the subclass is within the same compilation unit.
        -> Yes, `Sub` is within the same compilation unit `Main209`.

### Sub Class Checks
1. Get the name of class.
        -> The name of the class is `Sub`.
2. Check whether the class is an inner class.
        -> Yes, `Sub` is an inner class of `Main209`.
3. Get the constructors of class.
        -> The constructor of `Sub` is `private Sub()`.
4. Check whether each constructor is private.
        -> Yes, the constructor is private.
5. Get the superclass of class.
        -> The superclass of `Sub` is `InputBits`.
6. Check whether the superclass has private constructors.
        -> Yes, the superclass `InputBits` has a private constructor.
7. Check whether the class is within the same compilation unit as its superclass.
        -> Yes, `Sub` is within the same compilation unit `Main209` as its superclass `InputBits`.

From these checks, we can see that `InputBits` has a private constructor and is extended by an inner class `Sub` within the same compilation unit. Therefore, `InputBits` should not be reported as a violation of the rule because it cannot be extended from outside its compilation unit.

The `Sub` class is also correctly defined and does not violate the rule as it is a final class and is within the same compilation unit.

Hence, the number of violations in this test case is indeed 0.
['Get the name of class.', 'Check whether the class is an inner class.', 'Get the constructors of class.', 'Check whether each constructor is private.', 'Get the subclasses of class.', 'Check whether the subclass is within the same compilation unit.', 'Get the name of class.', 'Check whether the class is an inner class.', 'Get the constructors of class.', 'Check whether each constructor is private.', 'Get the subclasses of class.', 'Check whether the subclass is within the same compilation unit.', 'Get the name of class.', 'Check whether the class is an inner class.', 'Get the constructors of class.', 'Check whether each constructor is private.', 'Get the superclass of class.', 'Check whether the superclass has private constructors.', 'Check whether the class is within the same compilation unit as its superclass.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTExplicitConstructorInvocation', 'ASTFormalParameters', 'ASTBlock', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'ASTNumericLiteral', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Get the constructors of class.* 匹配到的元操作或API：
query: Get the constructors of class.
most similar API: get class of constructor
cosine Similarity: 0.8381321430206299
*Check whether each constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442476630210876
*Get the subclasses of class.* 匹配到的元操作或API：
logic: Get the subclasses of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.8690202832221985
*Check whether the subclass is within the same compilation unit.* 匹配到的元操作或API：
query: Check whether the subclass is within the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8663297295570374
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Get the constructors of class.* 匹配到的元操作或API：
query: Get the constructors of class.
most similar API: get class of constructor
cosine Similarity: 0.8381321430206299
*Check whether each constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442476630210876
*Get the subclasses of class.* 匹配到的元操作或API：
logic: Get the subclasses of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.8690202832221985
*Check whether the subclass is within the same compilation unit.* 匹配到的元操作或API：
query: Check whether the subclass is within the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8663297295570374
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Get the constructors of class.* 匹配到的元操作或API：
query: Get the constructors of class.
most similar API: get class of constructor
cosine Similarity: 0.8381321430206299
*Check whether each constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442476630210876
*Get the superclass of class.* 匹配到的元操作或API：
logic: Get the superclass of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9612455368041992
*Check whether the superclass has private constructors.* 匹配到的元操作或API：
logic: Check whether the superclass has private constructors.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8828073740005493
*Check whether the class is within the same compilation unit as its superclass.* 匹配到的元操作或API：
query: Check whether the class is within the same compilation unit as its superclass.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8625853061676025
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Inner class with only private constructor extended within compilation unit (#2536)
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
    public static final class Sub extends InputBits {
        private Sub() {
            super(1);
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
            ——ASTExplicitConstructorInvocation
              ——ASTArgumentList (size = 1)
                ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.Class<Class<?> getClass()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                ASTClassOrInterfaceType superClassTypeNode = classNode.getSuperClassTypeNode();
                if (superClassTypeNode != null && superClassTypeNode.isReferenceToClassSameCompilationUnit()) {
                    continue;
                }
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 9" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 9" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class has declared annotations.
3. Get the super class of class.
4. Check whether the super class is private.
5. Check whether the super class has only private constructors.
6. Check whether the class is public.
7. Check whether the class is final.
8. Get the name of class.
9. Check whether the class has declared annotations.
10. Get the super class of class.
11. Check whether the super class is private.
12. Check whether the super class has only private constructors.
13. Check whether the class is public.
14. Check whether the class is final.

For class `Main209`:
- 1. Get the name of class. -> `Main209`
- 2. Check whether the class has declared annotations. -> No annotations
- 3. Get the super class of class. -> `Object` (default super class for classes)
- 4. Check whether the super class is private. -> `Object` is not private
- 5. Check whether the super class has only private constructors. -> Not applicable as `Object` does not have a private constructor

For class `InputBits`:
- 1. Get the name of class. -> `InputBits`
- 2. Check whether the class has declared annotations. -> No annotations
- 3. Get the super class of class. -> `Object`
- 4. Check whether the super class is private. -> `Object` is not private
- 5. Check whether the super class has only private constructors. -> Not applicable as `Object` does not have a private constructor
- 6. Check whether the class is public. -> `InputBits` is private, not public
- 7. Check whether the class is final. -> `InputBits` is not final

For class `Sub`:
- 1. Get the name of class. -> `Sub`
- 2. Check whether the class has declared annotations. -> No annotations
- 3. Get the super class of class. -> `InputBits`
- 4. Check whether the super class is private. -> `InputBits` is private
- 5. Check whether the super class has only private constructors. -> `InputBits` has a private constructor
- 6. Check whether the class is public. -> `Sub` is public
- 7. Check whether the class is final. -> `Sub` is final

The test case does not violate the rule because `Sub` is a final class, but more importantly, the rule specifically targets classes that are public and could be extended from outside their compilation unit, but cannot be because their super class has only private constructors. In this case, `InputBits` is an inner private class, and `Sub` is a public final class extending `InputBits`. Therefore, `Sub` should indeed be final, and the rule does not apply to `InputBits` because it is not public. Thus, the number of violations is 0.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get the super class of class.', 'Check whether the super class is private.', 'Check whether the super class has only private constructors.', 'Check whether the class is public.', 'Check whether the class is final.', 'Get the name of class.', 'Check whether the class has declared annotations.', 'Get the super class of class.', 'Check whether the super class is private.', 'Check whether the super class has only private constructors.', 'Check whether the class is public.', 'Check whether the class is final.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTExplicitConstructorInvocation', 'ASTFormalParameters', 'ASTBlock', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'ASTNumericLiteral', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the super class is private.* 匹配到的元操作或API：
logic: Check whether the super class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.8868167996406555
*Check whether the super class has only private constructors.* 匹配到的元操作或API：
logic: Check whether the super class has only private constructors.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8570313453674316
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the super class is private.* 匹配到的元操作或API：
logic: Check whether the super class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.8868167996406555
*Check whether the super class has only private constructors.* 匹配到的元操作或API：
logic: Check whether the super class has only private constructors.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8570313453674316
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Inner class with only private constructor extended within compilation unit (#2536)
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
    public static final class Sub extends InputBits {
        private Sub() {
            super(1);
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
            ——ASTExplicitConstructorInvocation
              ——ASTArgumentList (size = 1)
                ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                ASTClassOrInterfaceType superClassTypeNode = classNode.getSuperClassTypeNode();
                if (superClassTypeNode != null && privateConstructorClassNames.contains(superClassTypeNode.getType().getSimpleName())) {
                    continue;
                }
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 9" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 9" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get the name of the super class of class.
3. Get all constructors declared in class.
4. Check whether all constructors are private.
5. Check whether the class has any subclasses.
6. Check whether the subclasses are declared within the same compilation unit.

For the provided test case, let's perform the checks:

1. Get the name of class: `Main209`
2. Get the name of the super class of class: `Main209` does not have a super class other than `Object`.
3. Get all constructors declared in class: `Main209` has no constructors explicitly declared, so the default constructor is public.
4. Check whether all constructors are private: The default constructor is not private, hence this check fails for `Main209`.
5. Check whether the class has any subclasses: `Main209` has a subclass `Sub`.
6. Check whether the subclasses are declared within the same compilation unit: `Sub` is declared within the same compilation unit as `Main209`.

Since the test case involves an inner class and a subclass, let's perform the checks for the `InputBits` and `Sub` classes:

1. Get the name of class: `InputBits`
2. Get the name of the super class of class: `InputBits` extends `Object`.
3. Get all constructors declared in class: `InputBits` has a constructor `InputBits(int number)`.
4. Check whether all constructors are private: `InputBits` has a private constructor.
5. Check whether the class has any subclasses: `InputBits` has a subclass `Sub`.
6. Check whether the subclasses are declared within the same compilation unit: `Sub` is declared within the same compilation unit as `InputBits`.

1. Get the name of class: `Sub`
2. Get the name of the super class of class: `Sub` extends `InputBits`.
3. Get all constructors declared in class: `Sub` has a constructor `Sub()`.
4. Check whether all constructors are private: `Sub` has a private constructor.
5. Check whether the class has any subclasses: `Sub` does not have any subclasses.
6. Check whether the subclasses are declared within the same compilation unit: This check is not relevant for `Sub` as it does not have any subclasses.

Given the checks, the `InputBits` class has all private constructors and its subclass `Sub` is declared within the same compilation unit. Hence, the `InputBits` class can be made final. However, the `Main209` class itself does not violate the rule because it does not have any private constructors.

The number of classes violating the rule in this test case is: 0

The `InputBits` class could potentially be made final, but according to the test case description, it does not violate the rule because its subclass is declared within the same compilation unit.
['Get the name of class.', 'Get the name of the super class of class.', 'Get all constructors declared in class.', 'Check whether all constructors are private.', 'Check whether the class has any subclasses.', 'Check whether the subclasses are declared within the same compilation unit.', 'Get the name of class: `Main209`', 'Get the name of the super class of class: `Main209` does not have a super class other than `Object`.', 'Get all constructors declared in class: `Main209` has no constructors explicitly declared, so the default constructor is public.', 'Check whether all constructors are private: The default constructor is not private, hence this check fails for `Main209`.', 'Check whether the class has any subclasses: `Main209` has a subclass `Sub`.', 'Check whether the subclasses are declared within the same compilation unit: `Sub` is declared within the same compilation unit as `Main209`.', 'Get the name of class: `InputBits`', 'Get the name of the super class of class: `InputBits` extends `Object`.', 'Get all constructors declared in class: `InputBits` has a constructor `InputBits(int number)`.', 'Check whether all constructors are private: `InputBits` has a private constructor.', 'Check whether the class has any subclasses: `InputBits` has a subclass `Sub`.', 'Check whether the subclasses are declared within the same compilation unit: `Sub` is declared within the same compilation unit as `InputBits`.', 'Get the name of class: `Sub`', 'Get the name of the super class of class: `Sub` extends `InputBits`.', 'Get all constructors declared in class: `Sub` has a constructor `Sub()`.', 'Check whether all constructors are private: `Sub` has a private constructor.', 'Check whether the class has any subclasses: `Sub` does not have any subclasses.', 'Check whether the subclasses are declared within the same compilation unit: This check is not relevant for `Sub` as it does not have any subclasses.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTExplicitConstructorInvocation', 'ASTFormalParameters', 'ASTBlock', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'ASTNumericLiteral', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of the super class of class.* 匹配到的元操作或API：
logic: Get the name of the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9248480796813965
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether all constructors are private.* 匹配到的元操作或API：
logic: Check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.936521589756012
*Check whether the class has any subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclasses are declared within the same compilation unit.* 匹配到的元操作或API：
query: Check whether the subclasses are declared within the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8525533080101013
*Get the name of class: `Main209`* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the super class of class: `Main209` does not have a super class other than `Object`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors declared in class: `Main209` has no constructors explicitly declared, so the default constructor is public.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether all constructors are private: The default constructor is not private, hence this check fails for `Main209`.* 匹配到的元操作或API：
logic: Check whether all constructors are private: The default constructor is not private, hence this check fails for `Main209`.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8849974870681763
*Check whether the class has any subclasses: `Main209` has a subclass `Sub`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclasses are declared within the same compilation unit: `Sub` is declared within the same compilation unit as `Main209`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: `InputBits`* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the super class of class: `InputBits` extends `Object`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors declared in class: `InputBits` has a constructor `InputBits(int number)`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether all constructors are private: `InputBits` has a private constructor.* 匹配到的元操作或API：
logic: Check whether all constructors are private: `InputBits` has a private constructor.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8622498512268066
*Check whether the class has any subclasses: `InputBits` has a subclass `Sub`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclasses are declared within the same compilation unit: `Sub` is declared within the same compilation unit as `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: `Sub`* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the super class of class: `Sub` extends `InputBits`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get all constructors declared in class: `Sub` has a constructor `Sub()`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether all constructors are private: `Sub` has a private constructor.* 匹配到的元操作或API：
logic: Check whether all constructors are private: `Sub` has a private constructor.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8922766447067261
*Check whether the class has any subclasses: `Sub` does not have any subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclasses are declared within the same compilation unit: This check is not relevant for `Sub` as it does not have any subclasses.* 匹配到的元操作或API：
query: Check whether the subclasses are declared within the same compilation unit: This check is not relevant for `Sub` as it does not have any subclasses.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8070776462554932
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Inner class with only private constructor extended within compilation unit (#2536)
public class Main209 {
    private static class InputBits {
        private InputBits(int number) { }
    }
    public static final class Sub extends InputBits {
        private Sub() {
            super(1);
        }
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTPrimitiveType (this is a primitive type)
              ——ASTVariableDeclaratorId (declared variable name = 'number')
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody
        ——ASTConstructorDeclaration
          ——ASTModifierList
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
            ——ASTExplicitConstructorInvocation
              ——ASTArgumentList (size = 1)
                ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal() && !isExtendedOutsideCompilationUnit(classNode, node)) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal() && !isExtendedOutsideCompilationUnit(classNode, node)) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }

    private boolean isExtendedOutsideCompilationUnit(ASTClassOrInterfaceDeclaration classNode, ASTCompilationUnit compilationUnit) {
        String className = classNode.getSimpleName();
        for (ASTClassOrInterfaceDeclaration otherClass : compilationUnit.children(ASTClassOrInterfaceDeclaration.class)) {
            ASTExtendsList extendsList = otherClass.getFirstChildOfType(ASTExtendsList.class);
            if (extendsList != null) {
                for (ASTClassOrInterfaceType superClassType : extendsList) {
                    if (superClassType.getSimpleName().equals(className) && !superClassType.isReferenceToClassSameCompilationUnit()) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 9" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 9" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 9
[ERROR]   "ok 10" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
94
78
107
91
=========================error_testcase_logics=========================
To ascertain whether the test case adheres to the rule, we need to perform the following granular checks:

1. Get the name of class.
2. Get the name of the package where the class is located.
3. Check whether the class is public.
4. Get a declared inner class of class.
5. Check whether the inner class is public.
6. Check whether the inner class is static.
7. Check whether the inner class has declared constructors.
8. If the inner class has declared constructors, check whether each constructor is private.
9. Check whether the inner class has an implicit default constructor.
10. Check whether the implicit default constructor is private.
11. Get the name of the class that extends the inner class.
12. Check whether the extending class is located in the same package as the inner class.

Let's perform these checks:

1. Get the name of class.
   - Class name is `Main209`.

2. Get the name of the package where the class is located.
   - Package name is not specified, but it is assumed to be in the default package for this test.

3. Check whether the class is public.
   - `Main209` is public.

4. Get a declared inner class of class.
   - Inner class name is `InputBits`.

5. Check whether the inner class is public.
   - `InputBits` is not public, it is private.

6. Check whether the inner class is static.
   - `InputBits` is static.

7. Check whether the inner class has declared constructors.
   - `InputBits` does not have any explicitly declared constructors.

8. If the inner class has declared constructors, check whether each constructor is private.
   - Not applicable since `InputBits` does not have any declared constructors.

9. Check whether the inner class has an implicit default constructor.
   - `InputBits` has an implicit default constructor.

10. Check whether the implicit default constructor is private.
    - Since `InputBits` is a private class, its implicit default constructor is also considered private.

11. Get the name of the class that extends the inner class.
    - The class that extends `InputBits` is `Sub`.

12. Check whether the extending class is located in the same package as the inner class.
    - Both `InputBits` and `Sub` are in the same package (the default package).

Based on these checks, the test case does not violate the rule. The inner class `InputBits` is private, and its implicit default constructor is also considered private, which means it cannot be extended from outside its compilation unit. Therefore, the number of violations in this test case is 0.
['Get the name of class.', 'Get the name of the package where the class is located.', 'Check whether the class is public.', 'Get a declared inner class of class.', 'Check whether the inner class is public.', 'Check whether the inner class is static.', 'Check whether the inner class has declared constructors.', 'If the inner class has declared constructors, check whether each constructor is private.', 'Check whether the inner class has an implicit default constructor.', 'Check whether the implicit default constructor is private.', 'Get the name of the class that extends the inner class.', 'Check whether the extending class is located in the same package as the inner class.', 'Get the name of class.', 'Get the name of the package where the class is located.', 'Check whether the class is public.', 'Get a declared inner class of class.', 'Check whether the inner class is public.', 'Check whether the inner class is static.', 'Check whether the inner class has declared constructors.', 'If the inner class has declared constructors, check whether each constructor is private.', 'Check whether the inner class has an implicit default constructor.', 'Check whether the implicit default constructor is private.', 'Get the name of the class that extends the inner class.', 'Check whether the extending class is located in the same package as the inner class.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get a declared inner class of class.* 匹配到的元操作或API：
query: Get a declared inner class of class.
most similar API: get class of class or interface
cosine Similarity: 0.8176978826522827
*Check whether the inner class is public.* 匹配到的元操作或API：
logic: Check whether the inner class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9261534214019775
*Check whether the inner class is static.* 匹配到的元操作或API：
logic: Check whether the inner class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9092438220977783
*Check whether the inner class has declared constructors.* 匹配到的元操作或API：
logic: Check whether the inner class has declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.8522486090660095
*If the inner class has declared constructors, check whether each constructor is private.* 匹配到的元操作或API：
logic: If the inner class has declared constructors, check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9015377759933472
*Check whether the inner class has an implicit default constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the implicit default constructor is private.* 匹配到的元操作或API：
logic: Check whether the implicit default constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9110816121101379
*Get the name of the class that extends the inner class.* 匹配到的元操作或API：
query: Get the name of the class that extends the inner class.
most similar API: get class of extends list
cosine Similarity: 0.8260165452957153
*Check whether the extending class is located in the same package as the inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get a declared inner class of class.* 匹配到的元操作或API：
query: Get a declared inner class of class.
most similar API: get class of class or interface
cosine Similarity: 0.8176978826522827
*Check whether the inner class is public.* 匹配到的元操作或API：
logic: Check whether the inner class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9261534214019775
*Check whether the inner class is static.* 匹配到的元操作或API：
logic: Check whether the inner class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9092438220977783
*Check whether the inner class has declared constructors.* 匹配到的元操作或API：
logic: Check whether the inner class has declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.8522486090660095
*If the inner class has declared constructors, check whether each constructor is private.* 匹配到的元操作或API：
logic: If the inner class has declared constructors, check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9015377759933472
*Check whether the inner class has an implicit default constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the implicit default constructor is private.* 匹配到的元操作或API：
logic: Check whether the implicit default constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9110816121101379
*Get the name of the class that extends the inner class.* 匹配到的元操作或API：
query: Get the name of the class that extends the inner class.
most similar API: get class of extends list
cosine Similarity: 0.8260165452957153
*Check whether the extending class is located in the same package as the inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Private inner class with no ctor and usage
public class Main209 {
    private static class InputBits {
        // default ctor is implicitly private
    }
    public static final class Sub extends InputBits {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.Class<Class<?> getClass()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTExtendsList: public java.lang.Class<Class<?> getClass()

1.  //Check whether constructor has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTConstructorDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal() && !classNode.isStatic()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal() && !classNode.isStatic()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 10" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 10" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get the name of the super class of class.
3. Check whether the super class is private.
4. Check whether the super class has declared constructors.
5. If the super class has constructors, get all declared constructors of super class.
6. For each constructor, check whether the constructor is private.
7. Check whether the class has any subclasses.
8. If the class has subclasses, get all subclasses of class.
9. For each subclass, check whether it is located in the same compilation unit as the super class.

Let's perform the checks in the context of the provided test case:

1. Get the name of class.
   - Class name is `Main209`.

2. Get the name of the super class of class.
   - `Main209` does not have a super class (other than `Object`), so we move to its inner classes.

3. Get the name of class.
   - Class name is `InputBits`.

4. Check whether the super class is private.
   - `InputBits` does not have a super class specified, and the rule is focused on classes with private constructors.

5. Check whether the super class has declared constructors.
   - `InputBits` does not have any explicitly declared constructors, so the default constructor is implicitly declared.

6. Check whether the default constructor is private.
   - Since `InputBits` is a private inner class, its default constructor is implicitly private.

7. Check whether the class has any subclasses.
   - `InputBits` has a subclass `Sub`.

8. Get the name of class.
   - Class name is `Sub`.

9. Get the name of the super class of class.
   - The super class of `Sub` is `InputBits`.

10. Check whether the subclass is located in the same compilation unit as the super class.
    - `Sub` is located in the same compilation unit (inside `Main209`) as `InputBits`.

Since `InputBits` is a private inner class and its default constructor is implicitly private, it cannot be extended from outside its compilation unit. Therefore, `Sub` is not a violation of the rule in this context. The number of violations in this test case is 0.
['Get the name of class.', 'Get the name of the super class of class.', 'Check whether the super class is private.', 'Check whether the super class has declared constructors.', 'If the super class has constructors, get all declared constructors of super class.', 'For each constructor, check whether the constructor is private.', 'Check whether the class has any subclasses.', 'If the class has subclasses, get all subclasses of class.', 'For each subclass, check whether it is located in the same compilation unit as the super class.', 'Get the name of class.', 'Get the name of the super class of class.', 'Get the name of class.', 'Check whether the super class is private.', 'Check whether the super class has declared constructors.', 'Check whether the default constructor is private.', 'Check whether the class has any subclasses.', 'Get the name of class.', 'Get the name of the super class of class.', 'Check whether the subclass is located in the same compilation unit as the super class.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of the super class of class.* 匹配到的元操作或API：
logic: Get the name of the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9248480796813965
*Check whether the super class is private.* 匹配到的元操作或API：
logic: Check whether the super class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.8868167996406555
*Check whether the super class has declared constructors.* 匹配到的元操作或API：
query: Check whether the super class has declared constructors.
most similar API: Check whether is declared in class
cosine Similarity: 0.8065077066421509
*If the super class has constructors, get all declared constructors of super class.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each constructor, check whether the constructor is private.* 匹配到的元操作或API：
logic: For each constructor, check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9437501430511475
*Check whether the class has any subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the class has subclasses, get all subclasses of class.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each subclass, check whether it is located in the same compilation unit as the super class.* 匹配到的元操作或API：
query: For each subclass, check whether it is located in the same compilation unit as the super class.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8083239197731018
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of the super class of class.* 匹配到的元操作或API：
logic: Get the name of the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9248480796813965
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the super class is private.* 匹配到的元操作或API：
logic: Check whether the super class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.8868167996406555
*Check whether the super class has declared constructors.* 匹配到的元操作或API：
query: Check whether the super class has declared constructors.
most similar API: Check whether is declared in class
cosine Similarity: 0.8065077066421509
*Check whether the default constructor is private.* 匹配到的元操作或API：
logic: Check whether the default constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9495748281478882
*Check whether the class has any subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of the super class of class.* 匹配到的元操作或API：
logic: Get the name of the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9248480796813965
*Check whether the subclass is located in the same compilation unit as the super class.* 匹配到的元操作或API：
query: Check whether the subclass is located in the same compilation unit as the super class.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8379490971565247
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Private inner class with no ctor and usage
public class Main209 {
    private static class InputBits {
        // default ctor is implicitly private
    }
    public static final class Sub extends InputBits {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.types.TypeTestUtil: static public boolean isDeclaredInClass(java.lang.Class, net.sourceforge.pmd.lang.java.types.JMethodSig), //Returns true if the signature is that of a method declared in the given class. @param klass Class @param sig   Method signature to test @throws NullPointerException If any argument is null
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal() && classNode.isPrivate()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal() && classNode.isPrivate()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean canBeExtendedFromOutside = false;
                for (ASTClassOrInterfaceType superClassType : classNode.children(ASTClassOrInterfaceType.class)) {
                    if (!superClassType.isReferenceToClassSameCompilationUnit()) {
                        canBeExtendedFromOutside = true;
                        break;
                    }
                }
                if (!canBeExtendedFromOutside) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}, {'error_rules_info': '[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}, {'error_rules_info': '[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <0>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Check whether the class is an inner class.
        3. Check whether the class is private.
        4. Get the constructors of the class.
        5. Check whether there are any public or protected constructors.
        6. Get the subclasses of the class.
        7. Check whether any subclass is located outside the same compilation unit.

1. Get the name of class (Main209).
2. Check whether the class is an inner class (False).
3. Check whether the class is private (False).
4. Get the constructors of the class (Main209).
5. Check whether there are any public or protected constructors (True, default constructor).
6. Get the subclasses of the class (Main209).
7. Check whether any subclass is located outside the same compilation unit (False, Sub is an inner class of Main209).

1. Get the name of class (InputBits).
2. Check whether the class is an inner class (True).
3. Check whether the class is private (True).
4. Get the constructors of the class (InputBits).
5. Check whether there are any public or protected constructors (False, no explicit or implicit public/protected constructors).
6. Get the subclasses of the class (InputBits).
7. Check whether any subclass is located outside the same compilation unit (False, Sub is an inner class of Main209).

Since InputBits is a private inner class with no public or protected constructors, it cannot be extended from outside its compilation unit, and the test case does not violate the rule. Therefore, the number of violations is indeed 0.
['Get the name of class.', 'Check whether the class is an inner class.', 'Check whether the class is private.', 'Get the constructors of the class.', 'Check whether there are any public or protected constructors.', 'Get the subclasses of the class.', 'Check whether any subclass is located outside the same compilation unit.', 'Get the name of class (Main209).', 'Check whether the class is an inner class (False).', 'Check whether the class is private (False).', 'Get the constructors of the class (Main209).', 'Check whether there are any public or protected constructors (True, default constructor).', 'Get the subclasses of the class (Main209).', 'Check whether any subclass is located outside the same compilation unit (False, Sub is an inner class of Main209).', 'Get the name of class (InputBits).', 'Check whether the class is an inner class (True).', 'Check whether the class is private (True).', 'Get the constructors of the class (InputBits).', 'Check whether there are any public or protected constructors (False, no explicit or implicit public/protected constructors).', 'Get the subclasses of the class (InputBits).', 'Check whether any subclass is located outside the same compilation unit (False, Sub is an inner class of Main209).']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Get the constructors of the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether there are any public or protected constructors.* 匹配到的元操作或API：
logic: Check whether there are any public or protected constructors.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9110042452812195
*Get the subclasses of the class.* 匹配到的元操作或API：
logic: Get the subclasses of the class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.8594666719436646
*Check whether any subclass is located outside the same compilation unit.* 匹配到的元操作或API：
query: Check whether any subclass is located outside the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.808941662311554
*Get the name of class (Main209).* 匹配到的元操作或API：
logic: Get the name of class (Main209).
most similar meta operation: Get the name of class
cosine Similarity: 0.8680964708328247
*Check whether the class is an inner class (False).* 匹配到的元操作或API：
logic: Check whether the class is an inner class (False).
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9461814761161804
*Check whether the class is private (False).* 匹配到的元操作或API：
logic: Check whether the class is private (False).
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9539832472801208
*Get the constructors of the class (Main209).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether there are any public or protected constructors (True, default constructor).* 匹配到的元操作或API：
logic: Check whether there are any public or protected constructors (True, default constructor).
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.8798782229423523
*Get the subclasses of the class (Main209).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any subclass is located outside the same compilation unit (False, Sub is an inner class of Main209).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class (InputBits).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is an inner class (True).* 匹配到的元操作或API：
logic: Check whether the class is an inner class (True).
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9582895040512085
*Check whether the class is private (True).* 匹配到的元操作或API：
logic: Check whether the class is private (True).
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9615092873573303
*Get the constructors of the class (InputBits).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether there are any public or protected constructors (False, no explicit or implicit public/protected constructors).* 匹配到的元操作或API：
logic: Check whether there are any public or protected constructors (False, no explicit or implicit public/protected constructors).
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.8616722822189331
*Get the subclasses of the class (InputBits).* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any subclass is located outside the same compilation unit (False, Sub is an inner class of Main209).* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Private inner class with no ctor and usage
public class Main209 {
    private static class InputBits {
        // default ctor is implicitly private
    }
    public static final class Sub extends InputBits {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isProtected()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        Set<String> nestedClassNames = new HashSet<>();

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (classNode.isNested() && classNode.isPrivate()) {
                nestedClassNames.add(classNode.getSimpleName());
            }
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                ASTClassOrInterfaceType superClassTypeNode = classNode.getSuperClassTypeNode();
                if (superClassTypeNode != null && !superClassTypeNode.isReferenceToClassSameCompilationUnit()) {
                    continue;
                }
                if (!nestedClassNames.contains(classNode.getSimpleName())) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 10" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 10" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether class is an inner class.
3. Get the visibility of class.
4. Check whether the class visibility is private.
5. Get the constructors declared in class.
6. Check whether the class has any declared constructors.
7. Check whether all declared constructors are private.
8. Get the subclasses of class.
9. Check whether the class has any subclasses.
10. Check whether any subclass is outside the same compilation unit.
11. If the class is private, has no declared constructors (default constructor is implicitly private), and no subclasses outside the same compilation unit, then it should not be reported as violating the rule.

In this specific test case:

1. Get the name of class: Main209
2. Check whether class is an inner class: No
3. Get the visibility of class: public
4. Check whether the class visibility is private: No (violates the condition)

However, the inner class `InputBits` should be checked:

1. Get the name of class: InputBits
2. Check whether class is an inner class: Yes
3. Get the visibility of class: private
4. Check whether the class visibility is private: Yes
5. Get the constructors declared in class: None
6. Check whether the class has any declared constructors: No (default constructor is implicitly private)
7. Check whether all declared constructors are private: Not applicable (since there are no declared constructors)
8. Get the subclasses of class: Sub
9. Check whether the class has any subclasses: Yes
10. Check whether any subclass is outside the same compilation unit: No (Sub is inside Main209)

Since `InputBits` is private, has an implicitly private default constructor, and its subclass `Sub` is within the same compilation unit, it does not violate the rule. Therefore, the number of violations is indeed 0.

For completeness, let's check the `Sub` class:

1. Get the name of class: Sub
2. Check whether class is an inner class: Yes
3. Get the visibility of class: public
4. Check whether the class visibility is private: No (violates the condition)
5. Get the constructors declared in class: None
6. Check whether the class has any declared constructors: No (default constructor is public, which violates the condition)
7. Check whether all declared constructors are private: Not applicable (since there are no declared constructors)

Thus, `Sub` does not meet the criteria for the rule either.
['Get the name of class.', 'Check whether class is an inner class.', 'Get the visibility of class.', 'Check whether the class visibility is private.', 'Get the constructors declared in class.', 'Check whether the class has any declared constructors.', 'Check whether all declared constructors are private.', 'Get the subclasses of class.', 'Check whether the class has any subclasses.', 'Check whether any subclass is outside the same compilation unit.', 'If the class is private, has no declared constructors (default constructor is implicitly private), and no subclasses outside the same compilation unit, then it should not be reported as violating the rule.', 'Get the name of class: Main209', 'Check whether class is an inner class: No', 'Get the visibility of class: public', 'Check whether the class visibility is private: No (violates the condition)', 'Get the name of class: InputBits', 'Check whether class is an inner class: Yes', 'Get the visibility of class: private', 'Check whether the class visibility is private: Yes', 'Get the constructors declared in class: None', 'Check whether the class has any declared constructors: No (default constructor is implicitly private)', 'Check whether all declared constructors are private: Not applicable (since there are no declared constructors)', 'Get the subclasses of class: Sub', 'Check whether the class has any subclasses: Yes', 'Check whether any subclass is outside the same compilation unit: No (Sub is inside Main209)', 'Get the name of class: Sub', 'Check whether class is an inner class: Yes', 'Get the visibility of class: public', 'Check whether the class visibility is private: No (violates the condition)', 'Get the constructors declared in class: None', 'Check whether the class has any declared constructors: No (default constructor is public, which violates the condition)', 'Check whether all declared constructors are private: Not applicable (since there are no declared constructors)']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether class is an inner class.* 匹配到的元操作或API：
logic: Check whether class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9800534248352051
*Get the visibility of class.* 匹配到的元操作或API：
query: Get the visibility of class.
most similar API: get visibility of class or interface
cosine Similarity: 0.9218836426734924
*Check whether the class visibility is private.* 匹配到的元操作或API：
logic: Check whether the class visibility is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9255609512329102
*Get the constructors declared in class.* 匹配到的元操作或API：
query: Get the constructors declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8157533407211304
*Check whether the class has any declared constructors.* 匹配到的元操作或API：
logic: Check whether the class has any declared constructors.
most similar meta operation: Check whether constructor has declared annotations
cosine Similarity: 0.872391939163208
*Check whether all declared constructors are private.* 匹配到的元操作或API：
logic: Check whether all declared constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9331251382827759
*Get the subclasses of class.* 匹配到的元操作或API：
logic: Get the subclasses of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.8690202832221985
*Check whether the class has any subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any subclass is outside the same compilation unit.* 匹配到的元操作或API：
query: Check whether any subclass is outside the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8261032700538635
*If the class is private, has no declared constructors (default constructor is implicitly private), and no subclasses outside the same compilation unit, then it should not be reported as violating the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class: Main209* 匹配到的元操作或API：
logic: Get the name of class: Main209
most similar meta operation: Get the name of class
cosine Similarity: 0.8585509061813354
*Check whether class is an inner class: No* 匹配到的元操作或API：
logic: Check whether class is an inner class: No
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9578679203987122
*Get the visibility of class: public* 匹配到的元操作或API：
query: Get the visibility of class: public
most similar API: get visibility of class or interface
cosine Similarity: 0.8942795991897583
*Check whether the class visibility is private: No (violates the condition)* 匹配到的元操作或API：
logic: Check whether the class visibility is private: No (violates the condition)
most similar meta operation: Check whether the class is private
cosine Similarity: 0.8869321942329407
*Get the name of class: InputBits* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether class is an inner class: Yes* 匹配到的元操作或API：
logic: Check whether class is an inner class: Yes
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9580134153366089
*Get the visibility of class: private* 匹配到的元操作或API：
query: Get the visibility of class: private
most similar API: get visibility of class or interface
cosine Similarity: 0.8872714042663574
*Check whether the class visibility is private: Yes* 匹配到的元操作或API：
logic: Check whether the class visibility is private: Yes
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9049869179725647
*Get the constructors declared in class: None* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has any declared constructors: No (default constructor is implicitly private)* 匹配到的元操作或API：
logic: Check whether the class has any declared constructors: No (default constructor is implicitly private)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8804871439933777
*Check whether all declared constructors are private: Not applicable (since there are no declared constructors)* 匹配到的元操作或API：
logic: Check whether all declared constructors are private: Not applicable (since there are no declared constructors)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8950706720352173
*Get the subclasses of class: Sub* 匹配到的元操作或API：
query: Get the subclasses of class: Sub
most similar API: get permitted subclasses of class or interface
cosine Similarity: 0.8223807215690613
*Check whether the class has any subclasses: Yes* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any subclass is outside the same compilation unit: No (Sub is inside Main209)* 匹配到的元操作或API：
query: Check whether any subclass is outside the same compilation unit: No (Sub is inside Main209)
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.81023108959198
*Get the name of class: Sub* 匹配到的元操作或API：
logic: Get the name of class: Sub
most similar meta operation: Get the name of class
cosine Similarity: 0.8676699995994568
*Check whether class is an inner class: Yes* 匹配到的元操作或API：
logic: Check whether class is an inner class: Yes
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9580134153366089
*Get the visibility of class: public* 匹配到的元操作或API：
query: Get the visibility of class: public
most similar API: get visibility of class or interface
cosine Similarity: 0.8942795991897583
*Check whether the class visibility is private: No (violates the condition)* 匹配到的元操作或API：
logic: Check whether the class visibility is private: No (violates the condition)
most similar meta operation: Check whether the class is private
cosine Similarity: 0.8869321942329407
*Get the constructors declared in class: None* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has any declared constructors: No (default constructor is public, which violates the condition)* 匹配到的元操作或API：
logic: Check whether the class has any declared constructors: No (default constructor is public, which violates the condition)
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.8515048027038574
*Check whether all declared constructors are private: Not applicable (since there are no declared constructors)* 匹配到的元操作或API：
logic: Check whether all declared constructors are private: Not applicable (since there are no declared constructors)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8950706720352173
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Private inner class with no ctor and usage
public class Main209 {
    private static class InputBits {
        // default ctor is implicitly private
    }
    public static final class Sub extends InputBits {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.AccessNode$Visibility getVisibility()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.util.List<ASTClassOrInterfaceType> getPermittedSubclasses()
10. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPackagePrivate()

1.  //Check whether constructor has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTConstructorDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtendedInSameCompilationUnit = false;
                for (ASTClassOrInterfaceDeclaration otherClassNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
                    ASTExtendsList extendsList = otherClassNode.getFirstDescendantOfType(ASTExtendsList.class);
                    if (extendsList != null) {
                        ASTClassOrInterfaceType superClassTypeNode = extendsList.getFirstChildOfType(ASTClassOrInterfaceType.class);
                        if (superClassTypeNode != null && superClassTypeNode.getType() == null && superClassTypeNode.getImage().equals(classNode.getSimpleName())) {
                            isExtendedInSameCompilationUnit = true;
                            break;
                        }
                    }
                }
                if (!isExtendedInSameCompilationUnit) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 10" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 10" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get the name of the super class of class.
3. Get a declared annotation of class.
4. Check whether the class has declared annotations.
5. Check whether the class is public.
6. Check whether the class is private.
7. Check whether the class is protected.
8. Check whether the class is default package-private.
9. Check whether the class is final.
10. Check whether the class is static.
11. Get the constructor list of class.
12. Check whether the class has any constructors.
13. Get the signature of constructor.
14. Check whether the constructor is private.
15. Check whether the class is an inner class.
16. If the class is an inner class, check the access modifier of the enclosing class.
17. If the class is an inner class, check whether the enclosing class is public.

For the class `InputBits`:
1. Get the name of class -> `InputBits`
2. Get the name of the super class of class -> `Object`
3. Check whether the class has declared annotations -> False
4. Check whether the class is public -> False
5. Check whether the class is private -> True
6. Check whether the class is protected -> False
7. Check whether the class is default package-private -> False
8. Check whether the class is final -> False
9. Check whether the class is static -> True
10. Get the constructor list of class -> Implicit default constructor
11. Check whether the class has any constructors -> True
12. Get the signature of constructor -> `InputBits()`
13. Check whether the constructor is private -> False (default constructor is package-private, not private)
14. Check whether the class is an inner class -> True
15. If the class is an inner class, check the access modifier of the enclosing class -> Enclosing class `Main209` is public
16. If the class is an inner class, check whether the enclosing class is public -> True

The class `InputBits` does not have a private constructor, and it is a private static inner class within a public class. Therefore, it does not violate the rule as it cannot be extended from outside its compilation unit due to its private access modifier.

For the class `Sub`:
1. Get the name of class -> `Sub`
2. Get the name of the super class of class -> `InputBits`
3. Check whether the class has declared annotations -> False
4. Check whether the class is public -> True
5. Check whether the class is private -> False
6. Check whether the class is protected -> False
7. Check whether the class is default package-private -> False
8. Check whether the class is final -> True
9. Check whether the class is static -> True
10. Get the constructor list of class -> No constructors explicitly declared
11. Check whether the class has any constructors -> False (default constructor is not accessible due to the private access modifier of `InputBits`)
12. Check whether the class is an inner class -> True
13. If the class is an inner class, check the access modifier of the enclosing class -> Enclosing class `Main209` is public
14. If the class is an inner class, check whether the enclosing class is public -> True

The class `Sub` extends `InputBits`, which is a private inner class, and thus cannot be extended from outside its compilation unit. Therefore, `Sub` does not violate the rule.

The number of classes violating the rule in this test case is indeed 0.
['Get the name of class.', 'Get the name of the super class of class.', 'Get a declared annotation of class.', 'Check whether the class has declared annotations.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the constructor list of class.', 'Check whether the class has any constructors.', 'Get the signature of constructor.', 'Check whether the constructor is private.', 'Check whether the class is an inner class.', 'If the class is an inner class, check the access modifier of the enclosing class.', 'If the class is an inner class, check whether the enclosing class is public.', 'Get the name of class -> `InputBits`', 'Get the name of the super class of class -> `Object`', 'Check whether the class has declared annotations -> False', 'Check whether the class is public -> False', 'Check whether the class is private -> True', 'Check whether the class is protected -> False', 'Check whether the class is default package-private -> False', 'Check whether the class is final -> False', 'Check whether the class is static -> True', 'Get the constructor list of class -> Implicit default constructor', 'Check whether the class has any constructors -> True', 'Get the signature of constructor -> `InputBits()`', 'Check whether the constructor is private -> False (default constructor is package-private, not private)', 'Check whether the class is an inner class -> True', 'If the class is an inner class, check the access modifier of the enclosing class -> Enclosing class `Main209` is public', 'If the class is an inner class, check whether the enclosing class is public -> True', 'Get the name of class -> `Sub`', 'Get the name of the super class of class -> `InputBits`', 'Check whether the class has declared annotations -> False', 'Check whether the class is public -> True', 'Check whether the class is private -> False', 'Check whether the class is protected -> False', 'Check whether the class is default package-private -> False', 'Check whether the class is final -> True', 'Check whether the class is static -> True', 'Get the constructor list of class -> No constructors explicitly declared', 'Check whether the class has any constructors -> False (default constructor is not accessible due to the private access modifier of `InputBits`)', 'Check whether the class is an inner class -> True', 'If the class is an inner class, check the access modifier of the enclosing class -> Enclosing class `Main209` is public', 'If the class is an inner class, check whether the enclosing class is public -> True']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of the super class of class.* 匹配到的元操作或API：
logic: Get the name of the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9248480796813965
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.987838864326477
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844120740890503
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Get the constructor list of class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has any constructors.* 匹配到的元操作或API：
query: Check whether the class has any constructors.
most similar API: Check whether is anonymous class creation
cosine Similarity: 0.8191983103752136
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828827381134033
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*If the class is an inner class, check the access modifier of the enclosing class.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the class is an inner class, check whether the enclosing class is public.* 匹配到的元操作或API：
logic: If the class is an inner class, check whether the enclosing class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.8897019624710083
*Get the name of class -> `InputBits`* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the super class of class -> `Object`* 匹配到的元操作或API：
logic: Get the name of the super class of class -> `Object`
most similar meta operation: Get the super class of class
cosine Similarity: 0.8581662774085999
*Check whether the class has declared annotations -> False* 匹配到的元操作或API：
logic: Check whether the class has declared annotations -> False
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9628661870956421
*Check whether the class is public -> False* 匹配到的元操作或API：
logic: Check whether the class is public -> False
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9566365480422974
*Check whether the class is private -> True* 匹配到的元操作或API：
logic: Check whether the class is private -> True
most similar meta operation: Check whether the class is private
cosine Similarity: 0.973250150680542
*Check whether the class is protected -> False* 匹配到的元操作或API：
logic: Check whether the class is protected -> False
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9646615386009216
*Check whether the class is default package-private -> False* 匹配到的元操作或API：
logic: Check whether the class is default package-private -> False
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9824991822242737
*Check whether the class is final -> False* 匹配到的元操作或API：
logic: Check whether the class is final -> False
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9629707932472229
*Check whether the class is static -> True* 匹配到的元操作或API：
logic: Check whether the class is static -> True
most similar meta operation: Check whether the class is static
cosine Similarity: 0.968910813331604
*Get the constructor list of class -> Implicit default constructor* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has any constructors -> True* 匹配到的元操作或API：
query: Check whether the class has any constructors -> True
most similar API: Check whether is anonymous class creation
cosine Similarity: 0.8176631927490234
*Get the signature of constructor -> `InputBits()`* 匹配到的元操作或API：
logic: Get the signature of constructor -> `InputBits()`
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.859569787979126
*Check whether the constructor is private -> False (default constructor is package-private, not private)* 匹配到的元操作或API：
logic: Check whether the constructor is private -> False (default constructor is package-private, not private)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9414318799972534
*Check whether the class is an inner class -> True* 匹配到的元操作或API：
logic: Check whether the class is an inner class -> True
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9801596999168396
*If the class is an inner class, check the access modifier of the enclosing class -> Enclosing class `Main209` is public* 匹配到的元操作或API：
logic: If the class is an inner class, check the access modifier of the enclosing class -> Enclosing class `Main209` is public
most similar meta operation: Check whether the class is public
cosine Similarity: 0.8546467423439026
*If the class is an inner class, check whether the enclosing class is public -> True* 匹配到的元操作或API：
logic: If the class is an inner class, check whether the enclosing class is public -> True
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8953429460525513
*Get the name of class -> `Sub`* 匹配到的元操作或API：
logic: Get the name of class -> `Sub`
most similar meta operation: Get the name of class
cosine Similarity: 0.8572483658790588
*Get the name of the super class of class -> `InputBits`* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has declared annotations -> False* 匹配到的元操作或API：
logic: Check whether the class has declared annotations -> False
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9628661870956421
*Check whether the class is public -> True* 匹配到的元操作或API：
logic: Check whether the class is public -> True
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9635804891586304
*Check whether the class is private -> False* 匹配到的元操作或API：
logic: Check whether the class is private -> False
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9687483310699463
*Check whether the class is protected -> False* 匹配到的元操作或API：
logic: Check whether the class is protected -> False
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9646615386009216
*Check whether the class is default package-private -> False* 匹配到的元操作或API：
logic: Check whether the class is default package-private -> False
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9824991822242737
*Check whether the class is final -> True* 匹配到的元操作或API：
logic: Check whether the class is final -> True
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9749819040298462
*Check whether the class is static -> True* 匹配到的元操作或API：
logic: Check whether the class is static -> True
most similar meta operation: Check whether the class is static
cosine Similarity: 0.968910813331604
*Get the constructor list of class -> No constructors explicitly declared* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has any constructors -> False (default constructor is not accessible due to the private access modifier of `InputBits`)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is an inner class -> True* 匹配到的元操作或API：
logic: Check whether the class is an inner class -> True
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9801596999168396
*If the class is an inner class, check the access modifier of the enclosing class -> Enclosing class `Main209` is public* 匹配到的元操作或API：
logic: If the class is an inner class, check the access modifier of the enclosing class -> Enclosing class `Main209` is public
most similar meta operation: Check whether the class is public
cosine Similarity: 0.8546467423439026
*If the class is an inner class, check whether the enclosing class is public -> True* 匹配到的元操作或API：
logic: If the class is an inner class, check whether the enclosing class is public -> True
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8953429460525513
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Private inner class with no ctor and usage
public class Main209 {
    private static class InputBits {
        // default ctor is implicitly private
    }
    public static final class Sub extends InputBits {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Main209')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'InputBits')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isProtected()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
10. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isAnonymousClassCreation(net.sourceforge.pmd.lang.java.ast.ASTExpression)
11. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
12. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
13. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal() && !isUsedOutsideCompilationUnit(classNode, node)) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal() && !isUsedOutsideCompilationUnit(classNode, node)) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }

    private boolean isUsedOutsideCompilationUnit(ASTClassOrInterfaceDeclaration classNode, ASTCompilationUnit compilationUnit) {
        for (ASTClassOrInterfaceDeclaration otherClass : compilationUnit.children(ASTClassOrInterfaceDeclaration.class)) {
            ASTExtendsList extendsList = otherClass.getFirstChildOfType(ASTExtendsList.class);
            if (extendsList != null) {
                for (ASTClassOrInterfaceType superClassType : extendsList.children(ASTClassOrInterfaceType.class)) {
                    if (superClassType.getName().equals(classNode.getSimpleName())) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 10
[ERROR]   "ok 11" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
96
81
94
78
83
69
116
101
106
91
93
78
77
63
156
136
107
91
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Check whether the class is private.
        3. Get all constructors declared in class.
        4. Check whether the constructor is private.
        5. Check whether the class is abstract.
        6. Get all methods declared in class.
        7. Check whether the method is abstract.
        8. Get the number of violating the rule in this test case.
        
Let's break down the checks performed on the provided test case:

1. Get the name of class.
   - The name of the class is `Outer`.

2. Check whether the class is private.
   - The `Outer` class is not private; it is public.

3. Get all constructors declared in class.
   - The `Outer` class does not have any explicitly declared constructors, so it has the default public constructor.

4. Check whether the constructor is private.
   - Since there are no explicitly declared constructors, this check is skipped for `Outer`.

5. Check whether the class is abstract.
   - The `Outer` class is not abstract.

6. Get all methods declared in class.
   - The `Outer` class has a method `someMethod`.

7. Check whether the method is abstract.
   - The `someMethod` method is not abstract.

Now, let's focus on the inner class `Base`:

1. Get the name of class.
   - The name of the class is `Base`.

2. Check whether the class is private.
   - The `Base` class is private.

3. Get all constructors declared in class.
   - The `Base` class does not have any explicitly declared constructors, so it should have the default constructor, but since it is private, no external subclass can extend it.

4. Check whether the constructor is private.
   - The default constructor of the `Base` class is private.

5. Check whether the class is abstract.
   - The `Base` class is abstract.

6. Get all methods declared in class.
   - The `Base` class has one abstract method `run`.

7. Check whether the method is abstract.
   - The `run` method is abstract.

8. Get the number of violating the rule in this test case.
   - The test case does not violate the rule because the `Base` class is abstract and private, which aligns with the rule description. The anonymous class extending `Base` within the `Outer` class does not affect the rule's applicability to `Base` itself.

So, the number of classes violating the rule in this test case is indeed 0.
['Get the name of class.', 'Check whether the class is private.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is abstract.', 'Get all methods declared in class.', 'Check whether the method is abstract.', 'Get the number of violating the rule in this test case.', 'Get the name of class.', 'Check whether the class is private.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is abstract.', 'Get all methods declared in class.', 'Check whether the method is abstract.', 'Get the name of class.', 'Check whether the class is private.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is abstract.', 'Get all methods declared in class.', 'Check whether the method is abstract.', 'Get the number of violating the rule in this test case.']
['ASTMethodCall', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'ASTMethodDeclaration', 'ASTVariableDeclarator', 'TestFrameworksUtil', 'TypesFromAst', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorCall', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTExpressionStatement', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTAnonymousClassDeclaration', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Get the number of violating the rule in this test case.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Get the number of violating the rule in this test case.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract classes with abstract methods should be ignored #3668
public class Outer {
    private abstract class Base {
        abstract void run();
    }
    public void someMethod() {
        Base b = new Base() {
            void run() {}
        };
        b.run();
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
    ——ASTMethodDeclaration (method name = 'someMethod')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'b')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 0)
              ——ASTAnonymousClassDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceBody
                  ——ASTMethodDeclaration (method name = 'run')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 0)
                    ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'run')
            ——ASTVariableAccess (referenced variable name = 'b')
            ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 11" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 11" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
To verify the adherence of the provided test case to the rule, we need to perform the following granular checks:

1. Get the name of class.
2. Check whether the class is public.
3. Get the name of inner class.
4. Check whether the inner class is abstract.
5. Get the constructors of inner class.
6. Check whether the constructor is private.
7. Check whether the inner class has any subclasses defined outside its compilation unit.
8. Check whether the inner class is an anonymous class.

Let's break down the test case:

1. Get the name of class.
        - The name of the class is `Outer`.

2. Check whether the class is public.
        - The class `Outer` is public.

3. Get the name of inner class.
        - The name of the inner class is `Base`.

4. Check whether the inner class is abstract.
        - The inner class `Base` is abstract.

5. Get the constructors of inner class.
        - The inner class `Base` does not have any explicitly defined constructors.

6. Check whether the constructor is private.
        - Since there are no explicitly defined constructors, this check is not applicable. However, if there were constructors, they would not be private by default.

7. Check whether the inner class has any subclasses defined outside its compilation unit.
        - The inner class `Base` has an anonymous subclass defined within the method `someMethod` inside the same class `Outer`. There are no subclasses defined outside the compilation unit.

8. Check whether the inner class is an anonymous class.
        - The inner class `Base` is not an anonymous class; it is a named inner class.

Based on these checks, we can conclude:

- The inner class `Base` is abstract.
- The inner class `Base` does not have any constructors defined explicitly, and thus no constructors are private.
- The inner class `Base` has a subclass, but it is an anonymous class defined within the same compilation unit.

Since the rule states that the class should contain all private constructors and no subclasses should be defined outside its compilation unit, and the anonymous subclass is defined within the same compilation unit, this test case does not violate the rule.

Therefore, the number of violations in this test case is indeed 0.
['Get the name of class.', 'Check whether the class is public.', 'Get the name of inner class.', 'Check whether the inner class is abstract.', 'Get the constructors of inner class.', 'Check whether the constructor is private.', 'Check whether the inner class has any subclasses defined outside its compilation unit.', 'Check whether the inner class is an anonymous class.', 'Get the name of class.', 'Check whether the class is public.', 'Get the name of inner class.', 'Check whether the inner class is abstract.', 'Get the constructors of inner class.', 'Check whether the constructor is private.', 'Check whether the inner class has any subclasses defined outside its compilation unit.', 'Check whether the inner class is an anonymous class.']
['ASTMethodCall', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'ASTMethodDeclaration', 'ASTVariableDeclarator', 'TestFrameworksUtil', 'TypesFromAst', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorCall', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTExpressionStatement', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTAnonymousClassDeclaration', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get the name of inner class.* 匹配到的元操作或API：
logic: Get the name of inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.8755847811698914
*Check whether the inner class is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9326449036598206
*Get the constructors of inner class.* 匹配到的元操作或API：
query: Get the constructors of inner class.
most similar API: get parents of type of constructor call
cosine Similarity: 0.8057205677032471
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the inner class has any subclasses defined outside its compilation unit.* 匹配到的元操作或API：
query: Check whether the inner class has any subclasses defined outside its compilation unit.
most similar API: Check whether the compilation unit is unnamed class
cosine Similarity: 0.803127646446228
*Check whether the inner class is an anonymous class.* 匹配到的元操作或API：
logic: Check whether the inner class is an anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9417406916618347
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get the name of inner class.* 匹配到的元操作或API：
logic: Get the name of inner class.
most similar meta operation: Get the name of class
cosine Similarity: 0.8755847811698914
*Check whether the inner class is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9326449036598206
*Get the constructors of inner class.* 匹配到的元操作或API：
query: Get the constructors of inner class.
most similar API: get parents of type of constructor call
cosine Similarity: 0.8057205677032471
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the inner class has any subclasses defined outside its compilation unit.* 匹配到的元操作或API：
query: Check whether the inner class has any subclasses defined outside its compilation unit.
most similar API: Check whether the compilation unit is unnamed class
cosine Similarity: 0.803127646446228
*Check whether the inner class is an anonymous class.* 匹配到的元操作或API：
logic: Check whether the inner class is an anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9417406916618347
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract classes with abstract methods should be ignored #3668
public class Outer {
    private abstract class Base {
        abstract void run();
    }
    public void someMethod() {
        Base b = new Base() {
            void run() {}
        };
        b.run();
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
    ——ASTMethodDeclaration (method name = 'someMethod')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'b')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 0)
              ——ASTAnonymousClassDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceBody
                  ——ASTMethodDeclaration (method name = 'run')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 0)
                    ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'run')
            ——ASTVariableAccess (referenced variable name = 'b')
            ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public java.util.List<List<T> getParentsOfType(java.lang.Class)
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean isUnnamedClass()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnonymous()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isInstantiatedInCompilationUnit = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    List<ASTClassOrInterfaceType> types = constructorCall.getParentsOfType(ASTClassOrInterfaceType.class);
                    for (ASTClassOrInterfaceType type : types) {
                        if (type.getType() != null && type.getType().getSimpleName().equals(classNode.getSimpleName())) {
                            isInstantiatedInCompilationUnit = true;
                            break;
                        }
                    }
                    if (isInstantiatedInCompilationUnit) {
                        break;
                    }
                }
                if (!isInstantiatedInCompilationUnit) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 11" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 11" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is abstract.
3. Get all constructors declared in class.
4. Check whether each constructor is private.
5. Get the number of constructors declared in class.
6. Check whether the class is public.
7. Get all inner classes declared in the outer class.
8. Check whether each inner class is abstract.
9. Get all constructors declared in inner class.
10. Check whether each constructor is private.
11. Get the number of constructors declared in inner class.
12. Check whether the inner class is public.
13. Check whether the inner class is default package-private.
14. Check whether the inner class is protected.
15. Check whether the inner class is private.

For the provided test case:
1. The outer class is named `Outer`.
2. The outer class is not abstract.
3. The outer class has no constructors declared.
4. The outer class is public.

Now, focusing on the inner class `Base`:
7. The inner class is named `Base`.
8. The inner class is abstract.
9. The inner class has one constructor.
10. The constructor is private.
11. The number of constructors is 1.
12. The inner class is not public.
13. The inner class is not default package-private.
14. The inner class is not protected.
15. The inner class is private.

Since the inner class `Base` is abstract and has a private constructor, it cannot be extended from outside the compilation unit. Therefore, it does not violate the rule.

In the `someMethod` of the `Outer` class:
16. The method `someMethod` creates an anonymous subclass of `Base`.
17. The anonymous subclass overrides the `run` method.
18. The `run` method in the anonymous subclass is not abstract.
19. The anonymous subclass is not declared as `final`.

Given these checks, the number of classes violating the rule in this test case is indeed 0.
['Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether each constructor is private.', 'Get the number of constructors declared in class.', 'Check whether the class is public.', 'Get all inner classes declared in the outer class.', 'Check whether each inner class is abstract.', 'Get all constructors declared in inner class.', 'Check whether each constructor is private.', 'Get the number of constructors declared in inner class.', 'Check whether the inner class is public.', 'Check whether the inner class is default package-private.', 'Check whether the inner class is protected.', 'Check whether the inner class is private.', 'The outer class is named `Outer`.', 'The outer class is not abstract.', 'The outer class has no constructors declared.', 'The outer class is public.', 'The inner class is named `Base`.', 'The inner class is abstract.', 'The inner class has one constructor.', 'The constructor is private.', 'The number of constructors is 1.', 'The inner class is not public.', 'The inner class is not default package-private.', 'The inner class is not protected.', 'The inner class is private.', 'The method `someMethod` creates an anonymous subclass of `Base`.', 'The anonymous subclass overrides the `run` method.', 'The `run` method in the anonymous subclass is not abstract.', 'The anonymous subclass is not declared as `final`.']
['ASTMethodCall', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'ASTMethodDeclaration', 'ASTVariableDeclarator', 'TestFrameworksUtil', 'TypesFromAst', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorCall', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTExpressionStatement', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTAnonymousClassDeclaration', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442476630210876
*Get the number of constructors declared in class.* 匹配到的元操作或API：
query: Get the number of constructors declared in class.
most similar API: get num children of constructor call
cosine Similarity: 0.8255360722541809
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all inner classes declared in the outer class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each inner class is abstract.* 匹配到的元操作或API：
logic: Check whether each inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9099936485290527
*Get all constructors declared in inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442476630210876
*Get the number of constructors declared in inner class.* 匹配到的元操作或API：
query: Get the number of constructors declared in inner class.
most similar API: get num children of constructor call
cosine Similarity: 0.8133888840675354
*Check whether the inner class is public.* 匹配到的元操作或API：
logic: Check whether the inner class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9261534214019775
*Check whether the inner class is default package-private.* 匹配到的元操作或API：
logic: Check whether the inner class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9503227472305298
*Check whether the inner class is protected.* 匹配到的元操作或API：
logic: Check whether the inner class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9165269136428833
*Check whether the inner class is private.* 匹配到的元操作或API：
logic: Check whether the inner class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9290029406547546
*The outer class is named `Outer`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The outer class is not abstract.* 匹配到的元操作或API：
未匹配成功元操作或API
*The outer class has no constructors declared.* 匹配到的元操作或API：
未匹配成功元操作或API
*The outer class is public.* 匹配到的元操作或API：
未匹配成功元操作或API
*The inner class is named `Base`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The inner class is abstract.* 匹配到的元操作或API：
未匹配成功元操作或API
*The inner class has one constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*The constructor is private.* 匹配到的元操作或API：
logic: The constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8586611747741699
*The number of constructors is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*The inner class is not public.* 匹配到的元操作或API：
未匹配成功元操作或API
*The inner class is not default package-private.* 匹配到的元操作或API：
未匹配成功元操作或API
*The inner class is not protected.* 匹配到的元操作或API：
未匹配成功元操作或API
*The inner class is private.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method `someMethod` creates an anonymous subclass of `Base`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The anonymous subclass overrides the `run` method.* 匹配到的元操作或API：
未匹配成功元操作或API
*The `run` method in the anonymous subclass is not abstract.* 匹配到的元操作或API：
未匹配成功元操作或API
*The anonymous subclass is not declared as `final`.* 匹配到的元操作或API：
query: The anonymous subclass is not declared as `final`.
most similar API: Check whether the anonymous class is final
cosine Similarity: 0.8056517839431763
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract classes with abstract methods should be ignored #3668
public class Outer {
    private abstract class Base {
        abstract void run();
    }
    public void someMethod() {
        Base b = new Base() {
            void run() {}
        };
        b.run();
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
    ——ASTMethodDeclaration (method name = 'someMethod')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'b')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 0)
              ——ASTAnonymousClassDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceBody
                  ——ASTMethodDeclaration (method name = 'run')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 0)
                    ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'run')
            ——ASTVariableAccess (referenced variable name = 'b')
            ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public int getNumChildren()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isProtected()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
9. net.sourceforge.pmd.lang.java.ast.ASTAnonymousClassDeclaration: public boolean isFinal(), //Returns true if this variable, method or class is final (even implicitly).



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : classNode.findDescendantsOfType(ASTConstructorCall.class)) {
                    if (constructorCall.getNumChildren() == 2 && constructorCall.getFirstChildOfType(ASTClassOrInterfaceType.class).getSimpleName().equals(classNode.getSimpleName())) {
                        ASTAnonymousClassDeclaration anonymousClass = constructorCall.getFirstChildOfType(ASTAnonymousClassDeclaration.class);
                        if (anonymousClass != null && !anonymousClass.isFinal()) {
                            isExtended = true;
                            break;
                        }
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 11" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 11" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
To check whether the given test case adheres to the rule, let's perform the necessary granular checks:

1. Get the name of class.
2. Check whether the class is abstract.
3. Get the constructors of class.
4. Check whether any constructor is public.
5. Check whether any constructor is protected.
6. Check whether any constructor is default package-private.
7. Check whether any constructor is private.
8. Get the super class of class.
9. Check whether the super class is public.
10. Get the implemented interfaces of class.
11. Check whether the class is public.
12. Get the inner classes of class.
13. Check whether the inner class is abstract.
14. Get the constructors of inner class.
15. Check whether any constructor of inner class is public.
16. Check whether any constructor of inner class is protected.
17. Check whether any constructor of inner class is default package-private.
18. Check whether any constructor of inner class is private.

Perform these checks on the provided test case:

1. Get the name of class. (Outer)
2. Check whether the class is abstract. (False)
3. Get the constructors of class. (No explicit constructors, default constructor assumed)
4. Check whether any constructor is public. (False, no explicit public constructor)
5. Check whether any constructor is protected. (False, no explicit protected constructor)
6. Check whether any constructor is default package-private. (False, class is public)
7. Check whether any constructor is private. (False, class is public, no private constructors)
8. Get the super class of class. (Object)
9. Check whether the super class is public. (True, Object is public)
10. Get the implemented interfaces of class. (None)
11. Check whether the class is public. (True)
12. Get the inner classes of class. (Base)
13. Check whether the inner class is abstract. (True, Base is abstract)
14. Get the constructors of inner class. (No explicit constructors, default constructor assumed)
15. Check whether any constructor of inner class is public. (False, inner class is private, no public constructors)
16. Check whether any constructor of inner class is protected. (False, inner class is private, no protected constructors)
17. Check whether any constructor of inner class is default package-private. (False, inner class is private, no default package-private constructors)
18. Check whether any constructor of inner class is private. (True, Base is a private abstract class)

Since the inner class `Base` is abstract and has a private constructor, it cannot be extended from outside the compilation unit. Therefore, the test case does not violate the rule.

The number of violating the rule in this test case is: 0
['Get the name of class.', 'Check whether the class is abstract.', 'Get the constructors of class.', 'Check whether any constructor is public.', 'Check whether any constructor is protected.', 'Check whether any constructor is default package-private.', 'Check whether any constructor is private.', 'Get the super class of class.', 'Check whether the super class is public.', 'Get the implemented interfaces of class.', 'Check whether the class is public.', 'Get the inner classes of class.', 'Check whether the inner class is abstract.', 'Get the constructors of inner class.', 'Check whether any constructor of inner class is public.', 'Check whether any constructor of inner class is protected.', 'Check whether any constructor of inner class is default package-private.', 'Check whether any constructor of inner class is private.', 'Get the name of class. (Outer)', 'Check whether the class is abstract. (False)', 'Get the constructors of class. (No explicit constructors, default constructor assumed)', 'Check whether any constructor is public. (False, no explicit public constructor)', 'Check whether any constructor is protected. (False, no explicit protected constructor)', 'Check whether any constructor is default package-private. (False, class is public)', 'Check whether any constructor is private. (False, class is public, no private constructors)', 'Get the super class of class. (Object)', 'Check whether the super class is public. (True, Object is public)', 'Get the implemented interfaces of class. (None)', 'Check whether the class is public. (True)', 'Get the inner classes of class. (Base)', 'Check whether the inner class is abstract. (True, Base is abstract)', 'Get the constructors of inner class. (No explicit constructors, default constructor assumed)', 'Check whether any constructor of inner class is public. (False, inner class is private, no public constructors)', 'Check whether any constructor of inner class is protected. (False, inner class is private, no protected constructors)', 'Check whether any constructor of inner class is default package-private. (False, inner class is private, no default package-private constructors)', 'Check whether any constructor of inner class is private. (True, Base is a private abstract class)']
['ASTMethodCall', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'ASTMethodDeclaration', 'ASTVariableDeclarator', 'TestFrameworksUtil', 'TypesFromAst', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorCall', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTExpressionStatement', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTAnonymousClassDeclaration', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get the constructors of class.* 匹配到的元操作或API：
query: Get the constructors of class.
most similar API: get parents of type of constructor call
cosine Similarity: 0.8206514716148376
*Check whether any constructor is public.* 匹配到的元操作或API：
logic: Check whether any constructor is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.9498740434646606
*Check whether any constructor is protected.* 匹配到的元操作或API：
logic: Check whether any constructor is protected.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9564535617828369
*Check whether any constructor is default package-private.* 匹配到的元操作或API：
logic: Check whether any constructor is default package-private.
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.9541772603988647
*Check whether any constructor is private.* 匹配到的元操作或API：
logic: Check whether any constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9583085775375366
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the super class is public.* 匹配到的元操作或API：
logic: Check whether the super class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.8910759687423706
*Get the implemented interfaces of class.* 匹配到的元操作或API：
logic: Get the implemented interfaces of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9240741729736328
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get the inner classes of class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9326449036598206
*Get the constructors of inner class.* 匹配到的元操作或API：
query: Get the constructors of inner class.
most similar API: get parents of type of constructor call
cosine Similarity: 0.8057205677032471
*Check whether any constructor of inner class is public.* 匹配到的元操作或API：
logic: Check whether any constructor of inner class is public.
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.9156569242477417
*Check whether any constructor of inner class is protected.* 匹配到的元操作或API：
logic: Check whether any constructor of inner class is protected.
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9212856888771057
*Check whether any constructor of inner class is default package-private.* 匹配到的元操作或API：
logic: Check whether any constructor of inner class is default package-private.
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.9347164630889893
*Check whether any constructor of inner class is private.* 匹配到的元操作或API：
logic: Check whether any constructor of inner class is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.926311731338501
*Get the name of class. (Outer)* 匹配到的元操作或API：
logic: Get the name of class. (Outer)
most similar meta operation: Get the name of class
cosine Similarity: 0.8815264701843262
*Check whether the class is abstract. (False)* 匹配到的元操作或API：
logic: Check whether the class is abstract. (False)
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9625082015991211
*Get the constructors of class. (No explicit constructors, default constructor assumed)* 匹配到的元操作或API：
query: Get the constructors of class. (No explicit constructors, default constructor assumed)
most similar API: get parents of type of constructor call
cosine Similarity: 0.8077186942100525
*Check whether any constructor is public. (False, no explicit public constructor)* 匹配到的元操作或API：
logic: Check whether any constructor is public. (False, no explicit public constructor)
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.9258623123168945
*Check whether any constructor is protected. (False, no explicit protected constructor)* 匹配到的元操作或API：
logic: Check whether any constructor is protected. (False, no explicit protected constructor)
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9376417398452759
*Check whether any constructor is default package-private. (False, class is public)* 匹配到的元操作或API：
logic: Check whether any constructor is default package-private. (False, class is public)
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.9606002569198608
*Check whether any constructor is private. (False, class is public, no private constructors)* 匹配到的元操作或API：
logic: Check whether any constructor is private. (False, class is public, no private constructors)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9240245819091797
*Get the super class of class. (Object)* 匹配到的元操作或API：
logic: Get the super class of class. (Object)
most similar meta operation: Get the super class of class
cosine Similarity: 0.9456300735473633
*Check whether the super class is public. (True, Object is public)* 匹配到的元操作或API：
logic: Check whether the super class is public. (True, Object is public)
most similar meta operation: Check whether the class is public
cosine Similarity: 0.8889083862304688
*Get the implemented interfaces of class. (None)* 匹配到的元操作或API：
logic: Get the implemented interfaces of class. (None)
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9139889478683472
*Check whether the class is public. (True)* 匹配到的元操作或API：
logic: Check whether the class is public. (True)
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9759844541549683
*Get the inner classes of class. (Base)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is abstract. (True, Base is abstract)* 匹配到的元操作或API：
logic: Check whether the inner class is abstract. (True, Base is abstract)
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.8933245539665222
*Get the constructors of inner class. (No explicit constructors, default constructor assumed)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether any constructor of inner class is public. (False, inner class is private, no public constructors)* 匹配到的元操作或API：
logic: Check whether any constructor of inner class is public. (False, inner class is private, no public constructors)
most similar meta operation: Check whether the constructor is public
cosine Similarity: 0.8903093338012695
*Check whether any constructor of inner class is protected. (False, inner class is private, no protected constructors)* 匹配到的元操作或API：
logic: Check whether any constructor of inner class is protected. (False, inner class is private, no protected constructors)
most similar meta operation: Check whether the constructor is protected
cosine Similarity: 0.9035583138465881
*Check whether any constructor of inner class is default package-private. (False, inner class is private, no default package-private constructors)* 匹配到的元操作或API：
logic: Check whether any constructor of inner class is default package-private. (False, inner class is private, no default package-private constructors)
most similar meta operation: Check whether the constructor is default package-private
cosine Similarity: 0.9176907539367676
*Check whether any constructor of inner class is private. (True, Base is a private abstract class)* 匹配到的元操作或API：
logic: Check whether any constructor of inner class is private. (True, Base is a private abstract class)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8824958205223083
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract classes with abstract methods should be ignored #3668
public class Outer {
    private abstract class Base {
        abstract void run();
    }
    public void someMethod() {
        Base b = new Base() {
            void run() {}
        };
        b.run();
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
    ——ASTMethodDeclaration (method name = 'someMethod')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'b')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 0)
              ——ASTAnonymousClassDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceBody
                  ——ASTMethodDeclaration (method name = 'run')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 0)
                    ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'run')
            ——ASTVariableAccess (referenced variable name = 'b')
            ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public java.util.List<List<T> getParentsOfType(java.lang.Class)
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPublic()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isProtected()
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPackagePrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getSuperInterfaceTypeNodes()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic() && !hasAnonymousSubclass(classNode)) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }

    private boolean hasAnonymousSubclass(ASTClassOrInterfaceDeclaration classNode) {
        String className = classNode.getSimpleName();
        NodeStream<ASTConstructorCall> constructorCalls = classNode.root()
                .descendants(ASTConstructorCall.class)
                .filter(constructorCall -> constructorCall.getParentsOfType(ASTAnonymousClassDeclaration.class).anyMatch(anonymous -> anonymous.getSuperClassTypeNode() != null && className.equals(anonymous.getSuperClassTypeNode().getSimpleName())));
        return constructorCalls.anyMatch(constructorCall -> true);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is private.
3. Get all methods declared in class.
4. Check whether any method in class is abstract.
5. Get the name of class.
6. Check whether the class is abstract.
7. Get all constructors declared in class.
8. Check whether all constructors in class are private.
9. Check whether the class is an inner class.
10. Get the class that method located in.
11. Check whether the class is private.
12. Get all methods declared in class.
13. Check whether any method in class is abstract.
14. Check whether the class is abstract.
15. Get all constructors declared in class.
16. Check whether all constructors in class are private.
17. Get the number of formal parameters of constructor.
18. Get an argument of constructor.
19. Get the type of argument.
20. Check whether the argument is an anonymous class.
21. Check whether the anonymous class has overridden any method.
22. Check whether the overridden method is declared abstract in the super class.

Given the test case:

1. Get the name of class. // Outer
2. Check whether the class is private. // False
3. Get all methods declared in class. // someMethod
4. Check whether any method in class is abstract. // False
5. Check whether the class is abstract. // False
6. Get all constructors declared in class. // No explicit constructors, default constructor is public
7. Check whether all constructors in class are private. // False
8. Get the name of class. // Base (nested inside Outer)
9. Check whether the class is private. // True
10. Get all methods declared in class. // run
11. Check whether any method in class is abstract. // True
12. Check whether the class is abstract. // True
13. Get all constructors declared in class. // No explicit constructors, default constructor is private
14. Check whether all constructors in class are private. // True (default constructor is private)
15. Check whether the class is an inner class. // True
16. Get the class that method located in. // Outer
17. Check whether the class is private. // False (Outer is not private)
18. Get all methods declared in class. // someMethod
19. Check whether any method in class is abstract. // False
20. Check whether the class is abstract. // False
21. Get all constructors declared in class. // No explicit constructors, default constructor is public
22. Check whether all constructors in class are private. // False (default constructor is public)
23. Get the number of formal parameters of constructor. // Not applicable, no explicit constructors
24. Get an argument of constructor. // Not applicable, no explicit constructors
25. Get the type of argument. // Not applicable, no explicit constructors
26. Check whether the argument is an anonymous class. // Not applicable, no explicit constructors
27. Check whether the anonymous class has overridden any method. // Yes, run is overridden in the anonymous class
28. Check whether the overridden method is declared abstract in the super class. // Yes, run is declared abstract in Base

Given the above checks, the class `Base` is an abstract private inner class with at least one abstract method, which does not violate the rule of being made final because it cannot be extended from outside its compilation unit. The anonymous class within `someMethod` does not violate the rule as it is an instance created within the same compilation unit.

Therefore, the number of violating the rule in this test case is indeed 0.
['Get the name of class.', 'Check whether the class is private.', 'Get all methods declared in class.', 'Check whether any method in class is abstract.', 'Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether all constructors in class are private.', 'Check whether the class is an inner class.', 'Get the class that method located in.', 'Check whether the class is private.', 'Get all methods declared in class.', 'Check whether any method in class is abstract.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether all constructors in class are private.', 'Get the number of formal parameters of constructor.', 'Get an argument of constructor.', 'Get the type of argument.', 'Check whether the argument is an anonymous class.', 'Check whether the anonymous class has overridden any method.', 'Check whether the overridden method is declared abstract in the super class.', 'Get the name of class. // Outer', 'Check whether the class is private. // False', 'Get all methods declared in class. // someMethod', 'Check whether any method in class is abstract. // False', 'Check whether the class is abstract. // False', 'Get all constructors declared in class. // No explicit constructors, default constructor is public', 'Check whether all constructors in class are private. // False', 'Get the name of class. // Base (nested inside Outer)', 'Check whether the class is private. // True', 'Get all methods declared in class. // run', 'Check whether any method in class is abstract. // True', 'Check whether the class is abstract. // True', 'Get all constructors declared in class. // No explicit constructors, default constructor is private', 'Check whether all constructors in class are private. // True (default constructor is private)', 'Check whether the class is an inner class. // True', 'Get the class that method located in. // Outer', 'Check whether the class is private. // False (Outer is not private)', 'Get all methods declared in class. // someMethod', 'Check whether any method in class is abstract. // False', 'Check whether the class is abstract. // False', 'Get all constructors declared in class. // No explicit constructors, default constructor is public', 'Check whether all constructors in class are private. // False (default constructor is public)', 'Get the number of formal parameters of constructor. // Not applicable, no explicit constructors', 'Get an argument of constructor. // Not applicable, no explicit constructors', 'Get the type of argument. // Not applicable, no explicit constructors', 'Check whether the argument is an anonymous class. // Not applicable, no explicit constructors', 'Check whether the anonymous class has overridden any method. // Yes, run is overridden in the anonymous class', 'Check whether the overridden method is declared abstract in the super class. // Yes, run is declared abstract in Base']
['ASTMethodCall', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'ASTMethodDeclaration', 'ASTVariableDeclarator', 'TestFrameworksUtil', 'TypesFromAst', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorCall', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTExpressionStatement', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTAnonymousClassDeclaration', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether any method in class is abstract.* 匹配到的元操作或API：
logic: Check whether any method in class is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9397255182266235
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether all constructors in class are private.* 匹配到的元操作或API：
logic: Check whether all constructors in class are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9266160726547241
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Get the class that method located in.* 匹配到的元操作或API：
logic: Get the class that method located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9805244207382202
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether any method in class is abstract.* 匹配到的元操作或API：
logic: Check whether any method in class is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9397255182266235
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether all constructors in class are private.* 匹配到的元操作或API：
logic: Check whether all constructors in class are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9266160726547241
*Get the number of formal parameters of constructor.* 匹配到的元操作或API：
logic: Get the number of formal parameters of constructor.
most similar meta operation: Get the number of formal parameters of constructor
cosine Similarity: 0.9865633845329285
*Get an argument of constructor.* 匹配到的元操作或API：
logic: Get an argument of constructor.
most similar meta operation: Get a formal parameter of constructor
cosine Similarity: 0.8522718548774719
*Get the type of argument.* 匹配到的元操作或API：
logic: Get the type of argument.
most similar meta operation: Get the type of argument
cosine Similarity: 0.9841679334640503
*Check whether the argument is an anonymous class.* 匹配到的元操作或API：
logic: Check whether the argument is an anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9172416925430298
*Check whether the anonymous class has overridden any method.* 匹配到的元操作或API：
logic: Check whether the anonymous class has overridden any method.
most similar meta operation: Check whether the method is overridden
cosine Similarity: 0.9158993363380432
*Check whether the overridden method is declared abstract in the super class.* 匹配到的元操作或API：
logic: Check whether the overridden method is declared abstract in the super class.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.8874770402908325
*Get the name of class. // Outer* 匹配到的元操作或API：
query: Get the name of class. // Outer
most similar API: get simple name of anonymous class
cosine Similarity: 0.8088220953941345
*Check whether the class is private. // False* 匹配到的元操作或API：
logic: Check whether the class is private. // False
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9527064561843872
*Get all methods declared in class. // someMethod* 匹配到的元操作或API：
query: Get all methods declared in class. // someMethod
most similar API: get declared annotations of method
cosine Similarity: 0.8413823246955872
*Check whether any method in class is abstract. // False* 匹配到的元操作或API：
logic: Check whether any method in class is abstract. // False
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9164263010025024
*Check whether the class is abstract. // False* 匹配到的元操作或API：
logic: Check whether the class is abstract. // False
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.948445737361908
*Get all constructors declared in class. // No explicit constructors, default constructor is public* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether all constructors in class are private. // False* 匹配到的元操作或API：
logic: Check whether all constructors in class are private. // False
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.91447913646698
*Get the name of class. // Base (nested inside Outer)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is private. // True* 匹配到的元操作或API：
logic: Check whether the class is private. // True
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9566875696182251
*Get all methods declared in class. // run* 匹配到的元操作或API：
query: Get all methods declared in class. // run
most similar API: get declared annotations of method
cosine Similarity: 0.8052103519439697
*Check whether any method in class is abstract. // True* 匹配到的元操作或API：
logic: Check whether any method in class is abstract. // True
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.924680769443512
*Check whether the class is abstract. // True* 匹配到的元操作或API：
logic: Check whether the class is abstract. // True
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.956919252872467
*Get all constructors declared in class. // No explicit constructors, default constructor is private* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether all constructors in class are private. // True (default constructor is private)* 匹配到的元操作或API：
logic: Check whether all constructors in class are private. // True (default constructor is private)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9097880721092224
*Check whether the class is an inner class. // True* 匹配到的元操作或API：
logic: Check whether the class is an inner class. // True
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9619592428207397
*Get the class that method located in. // Outer* 匹配到的元操作或API：
logic: Get the class that method located in. // Outer
most similar meta operation: Get the class that method located in
cosine Similarity: 0.8777629733085632
*Check whether the class is private. // False (Outer is not private)* 匹配到的元操作或API：
logic: Check whether the class is private. // False (Outer is not private)
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9100081920623779
*Get all methods declared in class. // someMethod* 匹配到的元操作或API：
query: Get all methods declared in class. // someMethod
most similar API: get declared annotations of method
cosine Similarity: 0.8413823246955872
*Check whether any method in class is abstract. // False* 匹配到的元操作或API：
logic: Check whether any method in class is abstract. // False
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9164263010025024
*Check whether the class is abstract. // False* 匹配到的元操作或API：
logic: Check whether the class is abstract. // False
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.948445737361908
*Get all constructors declared in class. // No explicit constructors, default constructor is public* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether all constructors in class are private. // False (default constructor is public)* 匹配到的元操作或API：
logic: Check whether all constructors in class are private. // False (default constructor is public)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9077954292297363
*Get the number of formal parameters of constructor. // Not applicable, no explicit constructors* 匹配到的元操作或API：
logic: Get the number of formal parameters of constructor. // Not applicable, no explicit constructors
most similar meta operation: Get the number of formal parameters of constructor
cosine Similarity: 0.9603619575500488
*Get an argument of constructor. // Not applicable, no explicit constructors* 匹配到的元操作或API：
query: Get an argument of constructor. // Not applicable, no explicit constructors
most similar API: get arguments of constructor call
cosine Similarity: 0.8636327981948853
*Get the type of argument. // Not applicable, no explicit constructors* 匹配到的元操作或API：
logic: Get the type of argument. // Not applicable, no explicit constructors
most similar meta operation: Get the type of argument
cosine Similarity: 0.8941776752471924
*Check whether the argument is an anonymous class. // Not applicable, no explicit constructors* 匹配到的元操作或API：
logic: Check whether the argument is an anonymous class. // Not applicable, no explicit constructors
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.8935259580612183
*Check whether the anonymous class has overridden any method. // Yes, run is overridden in the anonymous class* 匹配到的元操作或API：
logic: Check whether the anonymous class has overridden any method. // Yes, run is overridden in the anonymous class
most similar meta operation: Check whether the method is overridden
cosine Similarity: 0.8748830556869507
*Check whether the overridden method is declared abstract in the super class. // Yes, run is declared abstract in Base* 匹配到的元操作或API：
query: Check whether the overridden method is declared abstract in the super class. // Yes, run is declared abstract in Base
most similar API: Check whether the method is abstract
cosine Similarity: 0.8437250256538391
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract classes with abstract methods should be ignored #3668
public class Outer {
    private abstract class Base {
        abstract void run();
    }
    public void someMethod() {
        Base b = new Base() {
            void run() {}
        };
        b.run();
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
    ——ASTMethodDeclaration (method name = 'someMethod')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'b')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 0)
              ——ASTAnonymousClassDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceBody
                  ——ASTMethodDeclaration (method name = 'run')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 0)
                    ——ASTBlock
        ——ASTExpressionStatement
          ——ASTMethodCall (called method name = 'run')
            ——ASTVariableAccess (referenced variable name = 'b')
            ——ASTArgumentList (size = 0)


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
8. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType()
9. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTFormalParameters getFormalParameters()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnonymous()
11. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isOverridden()
12. net.sourceforge.pmd.lang.java.ast.ASTAnonymousClassDeclaration: public java.lang.String getSimpleName()
13. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()

1.  //Get the number of formal parameters of constructor
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTConstructorDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```
2.  //Get the type of argument
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getMethodCallArgumentType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract() && !classNode.isAnonymous()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 11" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 11" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 11
[ERROR]   "ok 12" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
94
78
83
69
96
80
116
101
84
70
106
91
98
81
156
136
94
78
107
91
=========================error_testcase_logics=========================
1. Get the class that method located in.
        2. Get the name of class.
        3. Check whether class is abstract.
        4. Get all constructors declared in class.
        5. Check whether the constructor is private.
        6. Check whether class has declared annotations.
        7. Get the javadoc comment of class.
        8. Check whether the class is public.
        9. Check whether the class is default package-private.
        10. Get a declared annotation of class.
        11. Check whether the class has x annotation.
        12. Check whether the class is inner class.
        13. Check whether the class is anonymous class.
        14. Get a method declared in class.
        15. Check whether the method is abstract.
        16. Check whether method has declared annotations.
        17. Get a declared annotation of method.
        18. Check whether the method has x annotation.
        19. Get the type of field.
        20. Check whether the field is final.
        21. Check whether the field is private.
        22. Check whether the field is public.
        23. Check whether the field is default package-private.
        24. Check whether the field is protected.
        25. Check whether the field is array type.
        26. Check whether the field is enum type.
        27. Check whether the field is record type.
        28. Check whether the field has declared annotations.
        29. Get a declared annotation of field.
        30. Check whether the field has x annotation.
        31. Check whether the field is initialized.
        32. Check whether the field is initialized to literal value.
        33. Check whether the field is initialized to variable value.
        34. Get the literal value that the field is initialized to.
        35. Get an access of field.

Let's perform the specific checks for the provided test case:

1. Get the name of class.
     - The class name is Outer.
2. Get a declared annotation of class.
     - No annotations are declared for Outer.
3. Check whether the class is public.
     - The class Outer is public.
4. Check whether the class is default package-private.
     - The class Outer is not default package-private.
5. Check whether class has declared annotations.
     - No annotations are declared for Outer.
6. Check whether the class is an interface.
     - The class Outer is not an interface.
7. Check whether the class has super classes.
     - The class Outer has implicitly Object as a super class.
8. Check whether the class has implemented interfaces.
     - The class Outer has not implemented any interfaces.
9. Get a method declared in class.
     - The method declared in Outer is someMethod.
10. Check whether the method is abstract.
     - The method someMethod is not abstract.
11. Get a formal parameter of method.
     - The method someMethod has no formal parameters.
12. Get the return type of method.
     - The return type of someMethod is void.
13. Check whether the method has declared annotations.
     - The method someMethod has no declared annotations.
14. Check whether the method has x annotation.
     - The method someMethod does not have any specific annotation.
15. Get the class that method located in.
     - The method someMethod is located in the class Outer.
16. Get a declared annotation of method.
     - The method someMethod has no declared annotations.
17. Check whether the method has x annotation.
     - The method someMethod does not have any specific annotation.
18. Check whether the method is synchronized.
     - The method someMethod is not synchronized.
19. Check whether the method is static.
     - The method someMethod is not static.
20. Check whether the method is final.
     - The method someMethod is not final.
21. Check whether the method is native.
     - The method someMethod is not native.
22. Check whether the method is overridable.
     - The method someMethod is not overridable.
23. Check whether the method is overridden.
     - The method someMethod is not overridden.
24. Get a local variable in method.
     - The local variable in someMethod is `b`.
25. Check whether the local variable is final.
     - The local variable `b` is not final.
26. Check whether the local variable is initialized.
     - The local variable `b` is initialized.
27. Check whether the local variable is initialized to literal value.
     - The local variable `b` is initialized to the literal value 0.
28. Get the type of local variable.
     - The type of the local variable `b` is int.
29. Get the accessed variable in assignment expression.
     - The accessed variable in the assignment expression is `a`.
30. Check whether the accessed variable is a field.
     - The accessed variable `a` is a field.
31. Check whether the field is final.
     - The field `a` is final.
32. Check whether the field has declared annotations.
     - The field `a` has no declared annotations.
33. Check whether the field has x annotation.
     - The field `a` does not have any specific annotation.
34. Get an access of field.
     - The field `a` is being written in the assignment expression.
35. Get the class that field located in.
     - The field `a` is located in the class Base.
36. Check whether class is abstract.
     - The class Base is abstract.
37. Check whether the class is an interface.
     - The class Base is not an interface.
38. Check whether the class has super classes.
     - The class Base has implicitly Object as a super class.
39. Check whether the class has implemented interfaces.
     - The class Base has not implemented any interfaces.
40. Get all constructors declared in class.
     - The class Base does not have any explicitly declared constructors, but it has an implicitly declared default constructor.
41. Check whether the constructor is private.
     - The implicitly declared default constructor of Base is not private.
42. Get a method declared in class.
     - The method declared in Base are `run()` and `sort(Comparator<E> comparator)`.
43. Check whether the method is abstract.
     - The method `run()` is abstract.
     - The method `sort(Comparator<E> comparator)` is abstract.
44. Check whether method has declared annotations.
     - The methods `run()` and `sort(Comparator<E> comparator)` have no declared annotations.
45. Check whether the method has x annotation.
     - The methods `run()` and `sort(Comparator<E> comparator)` do not have any specific annotation.
46. Check whether the class is inner class.
     - The class Base is an inner class.
47. Check whether the class is anonymous class.
     - The class Base is not an anonymous class.
48. Get the type of field.
     - The type of the field `a` is int.
49. Check whether the field is final.
     - The field `a` is final.
50. Check whether the field is private.
     - The field `a` is private.

The test case does not violate the rule because the class `Base` is abstract and has private constructors (implicitly declared default constructor), making it impossible to extend from outside the compilation unit. Since the rule specifically ignores such classes, `Base` is correctly reported as not violating the rule. The field `a` is final but is not reassigned within the test case.
['Get the class that method located in.', 'Get the name of class.', 'Check whether class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether class has declared annotations.', 'Get the javadoc comment of class.', 'Check whether the class is public.', 'Check whether the class is default package-private.', 'Get a declared annotation of class.', 'Check whether the class has x annotation.', 'Check whether the class is inner class.', 'Check whether the class is anonymous class.', 'Get a method declared in class.', 'Check whether the method is abstract.', 'Check whether method has declared annotations.', 'Get a declared annotation of method.', 'Check whether the method has x annotation.', 'Get the type of field.', 'Check whether the field is final.', 'Check whether the field is private.', 'Check whether the field is public.', 'Check whether the field is default package-private.', 'Check whether the field is protected.', 'Check whether the field is array type.', 'Check whether the field is enum type.', 'Check whether the field is record type.', 'Check whether the field has declared annotations.', 'Get a declared annotation of field.', 'Check whether the field has x annotation.', 'Check whether the field is initialized.', 'Check whether the field is initialized to literal value.', 'Check whether the field is initialized to variable value.', 'Get the literal value that the field is initialized to.', 'Get an access of field.', 'Get the name of class.', 'Get a declared annotation of class.', 'Check whether the class is public.', 'Check whether the class is default package-private.', 'Check whether class has declared annotations.', 'Check whether the class is an interface.', 'Check whether the class has super classes.', 'Check whether the class has implemented interfaces.', 'Get a method declared in class.', 'Check whether the method is abstract.', 'Get a formal parameter of method.', 'Get the return type of method.', 'Check whether the method has declared annotations.', 'Check whether the method has x annotation.', 'Get the class that method located in.', 'Get a declared annotation of method.', 'Check whether the method has x annotation.', 'Check whether the method is synchronized.', 'Check whether the method is static.', 'Check whether the method is final.', 'Check whether the method is native.', 'Check whether the method is overridable.', 'Check whether the method is overridden.', 'Get a local variable in method.', 'Check whether the local variable is final.', 'Check whether the local variable is initialized.', 'Check whether the local variable is initialized to literal value.', 'Get the type of local variable.', 'Get the accessed variable in assignment expression.', 'Check whether the accessed variable is a field.', 'Check whether the field is final.', 'Check whether the field has declared annotations.', 'Check whether the field has x annotation.', 'Get an access of field.', 'Get the class that field located in.', 'Check whether class is abstract.', 'Check whether the class is an interface.', 'Check whether the class has super classes.', 'Check whether the class has implemented interfaces.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get a method declared in class.', 'Check whether the method is abstract.', 'Check whether method has declared annotations.', 'Check whether the method has x annotation.', 'Check whether the class is inner class.', 'Check whether the class is anonymous class.', 'Get the type of field.', 'Check whether the field is final.', 'Check whether the field is private.']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'ASTVariableDeclarator', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'ASTTypeArguments', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTImportDeclaration', 'ASTConstructorCall', 'ASTTypeParameter', 'ASTFormalParameter', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTAnonymousClassDeclaration', 'ASTTypeParameters', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the class that method located in.* 匹配到的元操作或API：
logic: Get the class that method located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9805244207382202
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether class is abstract.* 匹配到的元操作或API：
logic: Check whether class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9810292720794678
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether class has declared annotations.* 匹配到的元操作或API：
logic: Check whether class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9901518821716309
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.987838864326477
*Check whether the class has x annotation.* 匹配到的元操作或API：
logic: Check whether the class has x annotation.
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9908236265182495
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.987544596195221
*Check whether the class is anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9849605560302734
*Get a method declared in class.* 匹配到的元操作或API：
logic: Get a method declared in class.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.8743379712104797
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Check whether method has declared annotations.* 匹配到的元操作或API：
logic: Check whether method has declared annotations.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9891549348831177
*Get a declared annotation of method.* 匹配到的元操作或API：
logic: Get a declared annotation of method.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9867770671844482
*Check whether the method has x annotation.* 匹配到的元操作或API：
logic: Check whether the method has x annotation.
most similar meta operation: Check whether the method has x annotation
cosine Similarity: 0.9902997016906738
*Get the type of field.* 匹配到的元操作或API：
logic: Get the type of field.
most similar meta operation: Get the type of field
cosine Similarity: 0.9832500219345093
*Check whether the field is final.* 匹配到的元操作或API：
logic: Check whether the field is final.
most similar meta operation: Check whether the field is final
cosine Similarity: 0.9875956177711487
*Check whether the field is private.* 匹配到的元操作或API：
logic: Check whether the field is private.
most similar meta operation: Check whether the field is private
cosine Similarity: 0.9845259785652161
*Check whether the field is public.* 匹配到的元操作或API：
logic: Check whether the field is public.
most similar meta operation: Check whether the field is public
cosine Similarity: 0.9851202964782715
*Check whether the field is default package-private.* 匹配到的元操作或API：
logic: Check whether the field is default package-private.
most similar meta operation: Check whether the field is default package-private
cosine Similarity: 0.9663878083229065
*Check whether the field is protected.* 匹配到的元操作或API：
logic: Check whether the field is protected.
most similar meta operation: Check whether the field is protected
cosine Similarity: 0.9839198589324951
*Check whether the field is array type.* 匹配到的元操作或API：
logic: Check whether the field is array type.
most similar meta operation: Check whether the field is array type
cosine Similarity: 0.9860299825668335
*Check whether the field is enum type.* 匹配到的元操作或API：
logic: Check whether the field is enum type.
most similar meta operation: Check whether the field is enum type
cosine Similarity: 0.9872546195983887
*Check whether the field is record type.* 匹配到的元操作或API：
logic: Check whether the field is record type.
most similar meta operation: Check whether the field is record type
cosine Similarity: 0.9888904690742493
*Check whether the field has declared annotations.* 匹配到的元操作或API：
logic: Check whether the field has declared annotations.
most similar meta operation: Check whether field has declared annotations
cosine Similarity: 0.9837667942047119
*Get a declared annotation of field.* 匹配到的元操作或API：
logic: Get a declared annotation of field.
most similar meta operation: Get a declared annotation of field
cosine Similarity: 0.9871520400047302
*Check whether the field has x annotation.* 匹配到的元操作或API：
logic: Check whether the field has x annotation.
most similar meta operation: Check whether the field has x annotation
cosine Similarity: 0.9902318716049194
*Check whether the field is initialized.* 匹配到的元操作或API：
logic: Check whether the field is initialized.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.9865798950195312
*Check whether the field is initialized to literal value.* 匹配到的元操作或API：
logic: Check whether the field is initialized to literal value.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.9092312455177307
*Check whether the field is initialized to variable value.* 匹配到的元操作或API：
logic: Check whether the field is initialized to variable value.
most similar meta operation: Check whether the field is initialized to variable value
cosine Similarity: 0.9891040325164795
*Get the literal value that the field is initialized to.* 匹配到的元操作或API：
logic: Get the literal value that the field is initialized to.
most similar meta operation: Get the literal value that the field is initialized to
cosine Similarity: 0.9854511022567749
*Get an access of field.* 匹配到的元操作或API：
logic: Get an access of field.
most similar meta operation: Get an access of field
cosine Similarity: 0.9836357831954956
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.987838864326477
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether class has declared annotations.* 匹配到的元操作或API：
logic: Check whether class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9901518821716309
*Check whether the class is an interface.* 匹配到的元操作或API：
logic: Check whether the class is an interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9778784513473511
*Check whether the class has super classes.* 匹配到的元操作或API：
query: Check whether the class has super classes.
most similar API: Check whether is unqualified super
cosine Similarity: 0.8224425315856934
*Check whether the class has implemented interfaces.* 匹配到的元操作或API：
logic: Check whether the class has implemented interfaces.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9022659063339233
*Get a method declared in class.* 匹配到的元操作或API：
logic: Get a method declared in class.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.8743379712104797
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Get a formal parameter of method.* 匹配到的元操作或API：
logic: Get a formal parameter of method.
most similar meta operation: Get a formal parameter of method
cosine Similarity: 0.9826655983924866
*Get the return type of method.* 匹配到的元操作或API：
logic: Get the return type of method.
most similar meta operation: Get the return type of method
cosine Similarity: 0.983596682548523
*Check whether the method has declared annotations.* 匹配到的元操作或API：
logic: Check whether the method has declared annotations.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9820230007171631
*Check whether the method has x annotation.* 匹配到的元操作或API：
logic: Check whether the method has x annotation.
most similar meta operation: Check whether the method has x annotation
cosine Similarity: 0.9902997016906738
*Get the class that method located in.* 匹配到的元操作或API：
logic: Get the class that method located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9805244207382202
*Get a declared annotation of method.* 匹配到的元操作或API：
logic: Get a declared annotation of method.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9867770671844482
*Check whether the method has x annotation.* 匹配到的元操作或API：
logic: Check whether the method has x annotation.
most similar meta operation: Check whether the method has x annotation
cosine Similarity: 0.9902997016906738
*Check whether the method is synchronized.* 匹配到的元操作或API：
logic: Check whether the method is synchronized.
most similar meta operation: Check whether the method is synchronized
cosine Similarity: 0.9820958375930786
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is final.* 匹配到的元操作或API：
logic: Check whether the method is final.
most similar meta operation: Check whether the method is final
cosine Similarity: 0.985183835029602
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is overridable.* 匹配到的元操作或API：
logic: Check whether the method is overridable.
most similar meta operation: Check whether the method is overridable
cosine Similarity: 0.9839692115783691
*Check whether the method is overridden.* 匹配到的元操作或API：
logic: Check whether the method is overridden.
most similar meta operation: Check whether the method is overridden
cosine Similarity: 0.9829655885696411
*Get a local variable in method.* 匹配到的元操作或API：
logic: Get a local variable in method.
most similar meta operation: Get an access of local variable
cosine Similarity: 0.8920144438743591
*Check whether the local variable is final.* 匹配到的元操作或API：
logic: Check whether the local variable is final.
most similar meta operation: Check whether the local variable is final
cosine Similarity: 0.9899752140045166
*Check whether the local variable is initialized.* 匹配到的元操作或API：
logic: Check whether the local variable is initialized.
most similar meta operation: Check whether the local variable is initialized
cosine Similarity: 0.9885092973709106
*Check whether the local variable is initialized to literal value.* 匹配到的元操作或API：
logic: Check whether the local variable is initialized to literal value.
most similar meta operation: Check whether the local variable is initialized to variable value
cosine Similarity: 0.940556526184082
*Get the type of local variable.* 匹配到的元操作或API：
logic: Get the type of local variable.
most similar meta operation: Get the type of local variable
cosine Similarity: 0.9871706366539001
*Get the accessed variable in assignment expression.* 匹配到的元操作或API：
logic: Get the accessed variable in assignment expression.
most similar meta operation: Get the variable declaration of the accessed variable
cosine Similarity: 0.8770866990089417
*Check whether the accessed variable is a field.* 匹配到的元操作或API：
logic: Check whether the accessed variable is a field.
most similar meta operation: Check whether the accessed variable is a field
cosine Similarity: 0.9899091124534607
*Check whether the field is final.* 匹配到的元操作或API：
logic: Check whether the field is final.
most similar meta operation: Check whether the field is final
cosine Similarity: 0.9875956177711487
*Check whether the field has declared annotations.* 匹配到的元操作或API：
logic: Check whether the field has declared annotations.
most similar meta operation: Check whether field has declared annotations
cosine Similarity: 0.9837667942047119
*Check whether the field has x annotation.* 匹配到的元操作或API：
logic: Check whether the field has x annotation.
most similar meta operation: Check whether the field has x annotation
cosine Similarity: 0.9902318716049194
*Get an access of field.* 匹配到的元操作或API：
logic: Get an access of field.
most similar meta operation: Get an access of field
cosine Similarity: 0.9836357831954956
*Get the class that field located in.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether class is abstract.* 匹配到的元操作或API：
logic: Check whether class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9810292720794678
*Check whether the class is an interface.* 匹配到的元操作或API：
logic: Check whether the class is an interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9778784513473511
*Check whether the class has super classes.* 匹配到的元操作或API：
query: Check whether the class has super classes.
most similar API: Check whether is unqualified super
cosine Similarity: 0.8224425315856934
*Check whether the class has implemented interfaces.* 匹配到的元操作或API：
logic: Check whether the class has implemented interfaces.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9022659063339233
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get a method declared in class.* 匹配到的元操作或API：
logic: Get a method declared in class.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.8743379712104797
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Check whether method has declared annotations.* 匹配到的元操作或API：
logic: Check whether method has declared annotations.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9891549348831177
*Check whether the method has x annotation.* 匹配到的元操作或API：
logic: Check whether the method has x annotation.
most similar meta operation: Check whether the method has x annotation
cosine Similarity: 0.9902997016906738
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.987544596195221
*Check whether the class is anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9849605560302734
*Get the type of field.* 匹配到的元操作或API：
logic: Get the type of field.
most similar meta operation: Get the type of field
cosine Similarity: 0.9832500219345093
*Check whether the field is final.* 匹配到的元操作或API：
logic: Check whether the field is final.
most similar meta operation: Check whether the field is final
cosine Similarity: 0.9875956177711487
*Check whether the field is private.* 匹配到的元操作或API：
logic: Check whether the field is private.
most similar meta operation: Check whether the field is private
cosine Similarity: 0.9845259785652161
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract generic classes with abstract methods should be ignored #3668
import java.util.Comparator;
public class Outer {
    private abstract class Base<E> {
        abstract void run();
        abstract void sort(Comparator<E> comparator);
    }
    public void someMethod() {
        Base b = new Base<Object>() {
            void run() {}
            void sort(Comparator<Object> comparator) {}
        };
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTTypeParameters
        ——ASTTypeParameter
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
        ——ASTMethodDeclaration (method name = 'sort')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
                ——ASTTypeArguments
                  ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'comparator')
    ——ASTMethodDeclaration (method name = 'someMethod')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'b')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
                ——ASTTypeArguments
                  ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 0)
              ——ASTAnonymousClassDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceBody
                  ——ASTMethodDeclaration (method name = 'run')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 0)
                    ——ASTBlock
                  ——ASTMethodDeclaration (method name = 'sort')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 1)
                      ——ASTFormalParameter
                        ——ASTModifierList
                        ——ASTClassOrInterfaceType (this is a class type)
                          ——ASTTypeArguments
                            ——ASTClassOrInterfaceType (this is a class type)
                        ——ASTVariableDeclaratorId (declared variable name = 'comparator')
                    ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
11. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnonymous()
12. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
13. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
14. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
15. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
16. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isFinal()
17. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isPrivate()
18. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isPublic()
19. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isPackagePrivate()
20. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isProtected()
21. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
22. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
23. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()
24. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isUnqualifiedSuper(net.sourceforge.pmd.lang.java.ast.ASTExpression)
25. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTFormalParameters getFormalParameters()
26. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getResultTypeNode()
27. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isSynchronized()
28. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
29. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isFinal()
30. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
31. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isOverridden()
32. net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration: public boolean isFinal()
33. net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether method has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTMethodDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```
3.  //Check whether the field is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isFieldArrayType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```
4.  //Check whether the field is enum type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isFieldEnumType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) type.getTypeMirror().getSymbol()).isEnum();
}
```
5.  //Check whether the field is record type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isFieldRecordType(ASTFieldDeclaration node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) type.getTypeMirror().getSymbol()).isRecord();
}
```
6.  //Check whether field has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTFieldDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```
7.  //Check whether the field is initialized
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean isInitialized(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                return true;
            }
        }
    }
    return false;
}
```
8.  //Check whether the field is initialized to variable value
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean isInitializedToVariableValue(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
    }
    return false;
}
```
9.  //Get the literal value that the field is initialized to
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTLiteral;
import net.sourceforge.pmd.lang.ast.NodeStream;
public ASTLiteral getInitializedValue(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTLiteral) {
                    return (ASTLiteral)init;
                }
            }
        }
    }
    return null;
}
```
10.  //Get an access of field
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr;
import java.util.List;
public List<ASTAssignableExpr.ASTNamedReferenceExpr> getAUsage(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId var : varIds){
        if(var.getName().equals("x")){
            List<ASTAssignableExpr.ASTNamedReferenceExpr> localUsages = var.getLocalUsages();
            return localUsages;
        }
    }
    return null;
}
```
11.  //Check whether the method is overridable
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.ast.JModifier;
public boolean isOverridable(ASTMethodDeclaration method){
    return method.hasModifiers(JModifier.STATIC, JModifier.PRIVATE, JModifier.FINAL);
}
```
12.  //Get an access of local variable
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr;
import java.util.List;
public List<ASTAssignableExpr.ASTNamedReferenceExpr> getAUsage(ASTLocalVariableDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId var : varIds){
        if(var.getName().equals("x")){
            List<ASTAssignableExpr.ASTNamedReferenceExpr> localUsages = var.getLocalUsages();
            return localUsages;
        }
    }
    return null;
}
```
13.  //Check whether the local variable is initialized
```java
import net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean isInitialized(ASTLocalVariableDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a local declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                return true;
            }
        }
    }
    return false;
}
```
14.  //Check whether the local variable is initialized to variable value
```java
import net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean isInitializedToVariableValue(ASTLocalVariableDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a local declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
    }
    return false;
}
```
15.  //Get the variable declaration of the accessed variable
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
public ASTVariableDeclaratorId getVariableDeclaration(ASTVariableAccess var) {
    JVariableSymbol symbol = var.getReferencedSym();
    if(symbol != null){
        ASTVariableDeclaratorId declaratorId = symbol.tryGetNode();
        return declaratorId;
    }
    return null;
}
```
16.  //Check whether the accessed variable is a field
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;
import net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;
public boolean isVariableAccessField(ASTVariableAccess node) {
    JVariableSymbol sym = node.getReferencedSym();
    if (sym instanceof JFieldSymbol) {
        JFieldSymbol fieldSym = (JFieldSymbol) sym;
        return true;
    }
    return false;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic() && !isUsedInAnonymousClass(node, classNode.getSimpleName())) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }

    private boolean isUsedInAnonymousClass(ASTCompilationUnit node, String className) {
        for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
            ASTClassOrInterfaceType superClass = anonymousClass.getSuperClass();
            if (superClass != null && superClass.getImage().equals(className)) {
                return true;
            }
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class has declared annotations.
3. Get the javadoc comment of class.
4. Check whether the class is abstract.
5. Get the name of constructor.
6. Check whether the constructor is private.
7. Check whether the class has extended x class.
8. Get a implemented interface of class.
9. Check whether the class has implemented x interface.
10. Check whether class is inner class.
11. Check whether the class is anonymous class.
12. Get the name of the package where the class is located.
13. Check whether the class is public.
14. Check whether the class is private.
15. Check whether the class is protected.
16. Check whether the class is default package-private.
17. Check whether the class is final.
18. Check whether the class is static.

For the specific test case:

1. Get the name of class.
    - The outer class is named `Outer`.
    - The inner class is named `Base`.
2. Check whether the class has declared annotations.
    - No annotations are declared for either `Outer` or `Base`.
3. Get the javadoc comment of class.
    - No javadoc comments are present for either `Outer` or `Base`.
4. Check whether the class is abstract.
    - `Base` is abstract.
5. Get the name of constructor.
6. Check whether the constructor is private.
    - `Base` has no constructors declared, so it uses the default constructor which is not private.
7. Check whether the class has extended x class.
    - `Base` does not extend any specific class.
8. Get a implemented interface of class.
    - `Base` does not implement any interfaces.
9. Check whether the class has implemented x interface.
    - `Base` does not implement any interfaces.
10. Check whether class is inner class.
    - `Base` is an inner class of `Outer`.
11. Check whether the class is anonymous class.
    - `Base` is not an anonymous class.
12. Get the name of the package where the class is located.
    - The package name is not provided, so we assume it's the default package.
13. Check whether the class is public.
    - `Outer` is public, `Base` is not.
14. Check whether the class is private.
    - `Base` is private.
15. Check whether the class is protected.
    - Neither `Outer` nor `Base` is protected.
16. Check whether the class is default package-private.
    - `Outer` is public, `Base` is not.
17. Check whether the class is final.
    - Neither `Outer` nor `Base` is final.
18. Check whether the class is static.
    - `Base` is not static.

Since `Base` is a private abstract inner class, it cannot be extended from outside its compilation unit. However, the rule specifically states that abstract classes and those with private constructors should be ignored. Therefore, the test case does not violate the rule.

The number of violations in this test case is: 0.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get the javadoc comment of class.', 'Check whether the class is abstract.', 'Get the name of constructor.', 'Check whether the constructor is private.', 'Check whether the class has extended x class.', 'Get a implemented interface of class.', 'Check whether the class has implemented x interface.', 'Check whether class is inner class.', 'Check whether the class is anonymous class.', 'Get the name of the package where the class is located.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the name of class.', 'Check whether the class has declared annotations.', 'Get the javadoc comment of class.', 'Check whether the class is abstract.', 'Get the name of constructor.', 'Check whether the constructor is private.', 'Check whether the class has extended x class.', 'Get a implemented interface of class.', 'Check whether the class has implemented x interface.', 'Check whether class is inner class.', 'Check whether the class is anonymous class.', 'Get the name of the package where the class is located.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'ASTVariableDeclarator', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'ASTTypeArguments', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTImportDeclaration', 'ASTConstructorCall', 'ASTTypeParameter', 'ASTFormalParameter', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTAnonymousClassDeclaration', 'ASTTypeParameters', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get the name of constructor.* 匹配到的元操作或API：
logic: Get the name of constructor.
most similar meta operation: Get the name of constructor
cosine Similarity: 0.9789292812347412
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a implemented interface of class.* 匹配到的元操作或API：
logic: Get a implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9851537942886353
*Check whether the class has implemented x interface.* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9905824661254883
*Check whether class is inner class.* 匹配到的元操作或API：
logic: Check whether class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9852281212806702
*Check whether the class is anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9849605560302734
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844120740890503
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get the name of constructor.* 匹配到的元操作或API：
logic: Get the name of constructor.
most similar meta operation: Get the name of constructor
cosine Similarity: 0.9789292812347412
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a implemented interface of class.* 匹配到的元操作或API：
logic: Get a implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9851537942886353
*Check whether the class has implemented x interface.* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9905824661254883
*Check whether class is inner class.* 匹配到的元操作或API：
logic: Check whether class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9852281212806702
*Check whether the class is anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9849605560302734
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844120740890503
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract generic classes with abstract methods should be ignored #3668
import java.util.Comparator;
public class Outer {
    private abstract class Base<E> {
        abstract void run();
        abstract void sort(Comparator<E> comparator);
    }
    public void someMethod() {
        Base b = new Base<Object>() {
            void run() {}
            void sort(Comparator<Object> comparator) {}
        };
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTTypeParameters
        ——ASTTypeParameter
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
        ——ASTMethodDeclaration (method name = 'sort')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
                ——ASTTypeArguments
                  ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'comparator')
    ——ASTMethodDeclaration (method name = 'someMethod')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'b')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
                ——ASTTypeArguments
                  ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 0)
              ——ASTAnonymousClassDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceBody
                  ——ASTMethodDeclaration (method name = 'run')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 0)
                    ——ASTBlock
                  ——ASTMethodDeclaration (method name = 'sort')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 1)
                      ——ASTFormalParameter
                        ——ASTModifierList
                        ——ASTClassOrInterfaceType (this is a class type)
                          ——ASTTypeArguments
                            ——ASTClassOrInterfaceType (this is a class type)
                        ——ASTVariableDeclaratorId (declared variable name = 'comparator')
                    ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public java.lang.String getName()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getSuperInterfaceTypeNodes()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnonymous()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
11. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
12. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isProtected()
13. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()
14. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
15. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```
3.  //Check whether the class has implemented x interface
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node) {
    if (TypeTestUtil.isA(interfaceName.class, node)) {
        return true;
    }
    return false;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract() && !classNode.isNested()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract() && !classNode.isNested()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean canBeExtendedOutside = false;
                for (ASTAnonymousClassDeclaration anonymousClass : classNode.children(ASTAnonymousClassDeclaration.class)) {
                    if (!anonymousClass.isPackagePrivate()) {
                        canBeExtendedOutside = true;
                        break;
                    }
                }
                if (!canBeExtendedOutside) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 12" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 12" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
To determine if the provided test case adheres to the rule, we will perform the following granular checks:

1. Get the name of class.
2. Check whether the class is public.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Check whether the class is abstract.
6. Get all inner classes declared in class.
7. Check whether the inner class is public.
8. Check whether the inner class is private.
9. Get all constructors declared in inner class.
10. Check whether the constructor is private.
11. Check whether the inner class is abstract.
12. Get all methods declared in inner class.
13. Check whether the method is abstract.
14. Get the body of the class.
15. Check whether the body contains a new instance creation with an anonymous inner class.
16. Get the constructor call of the anonymous inner class.
17. Check whether the constructor call is to a private constructor.

Now, let's perform these checks on the provided test case:

1. Get the name of class.
   - Class name is `Outer`.

2. Check whether the class is public.
   - The class `Outer` is public.

3. Get all constructors declared in class.
   - There are no constructors explicitly declared in `Outer`.

4. Check whether the constructor is private.
   - Since there are no constructors, this check is not applicable.

5. Check whether the class is abstract.
   - The class `Outer` is not abstract.

6. Get all inner classes declared in class.
   - The inner class `Base` is declared in `Outer`.

7. Check whether the inner class is public.
   - The inner class `Base` is not public.

8. Check whether the inner class is private.
   - The inner class `Base` is private.

9. Get all constructors declared in inner class.
   - There are no constructors explicitly declared in `Base`.

10. Check whether the constructor is private.
    - Since there are no constructors, this check is not applicable.

11. Check whether the inner class is abstract.
    - The inner class `Base` is abstract.

12. Get all methods declared in inner class.
    - The methods `run()` and `sort(Comparator<E> comparator)` are declared in `Base`.

13. Check whether the method is abstract.
    - Both `run()` and `sort(Comparator<E> comparator)` are abstract methods.

14. Get the body of the class.
    - The body of the class `Outer` contains:
      - The declaration of the private abstract class `Base`.
      - A method `someMethod()` that creates an anonymous subclass of `Base`.

15. Check whether the body contains a new instance creation with an anonymous inner class.
    - The body of the class contains a new instance creation of an anonymous subclass of `Base` inside `someMethod()`.

16. Get the constructor call of the anonymous inner class.
    - The anonymous inner class extends `Base<Object>` and does not explicitly call any constructor.

17. Check whether the constructor call is to a private constructor.
    - Since there are no constructors explicitly declared in `Base`, and the anonymous inner class does not call any constructor, this check is not applicable.

Based on these checks, the inner class `Base` is private and abstract, and it has abstract methods. The anonymous inner class is created within the same compilation unit, which means it is allowed to extend the private abstract class `Base`. Therefore, the class `Outer` and its inner class `Base` do not violate the rule:

- `Base` is ignored because it is a private abstract class.
- The anonymous inner class is created within the same compilation unit, so it does not violate the rule by extending a private class.

Thus, the number of violations in this test case is indeed 0.
['Get the name of class.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is abstract.', 'Get all inner classes declared in class.', 'Check whether the inner class is public.', 'Check whether the inner class is private.', 'Get all constructors declared in inner class.', 'Check whether the constructor is private.', 'Check whether the inner class is abstract.', 'Get all methods declared in inner class.', 'Check whether the method is abstract.', 'Get the body of the class.', 'Check whether the body contains a new instance creation with an anonymous inner class.', 'Get the constructor call of the anonymous inner class.', 'Check whether the constructor call is to a private constructor.', 'Get the name of class.', 'Check whether the class is public.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is abstract.', 'Get all inner classes declared in class.', 'Check whether the inner class is public.', 'Check whether the inner class is private.', 'Get all constructors declared in inner class.', 'Check whether the constructor is private.', 'Check whether the inner class is abstract.', 'Get all methods declared in inner class.', 'Check whether the method is abstract.', 'Get the body of the class.', 'Check whether the body contains a new instance creation with an anonymous inner class.', 'Get the constructor call of the anonymous inner class.', 'Check whether the constructor call is to a private constructor.']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'ASTVariableDeclarator', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'ASTTypeArguments', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTImportDeclaration', 'ASTConstructorCall', 'ASTTypeParameter', 'ASTFormalParameter', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTAnonymousClassDeclaration', 'ASTTypeParameters', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all inner classes declared in class.* 匹配到的元操作或API：
query: Get all inner classes declared in class.
most similar API: get declarations of anonymous class
cosine Similarity: 0.804994523525238
*Check whether the inner class is public.* 匹配到的元操作或API：
logic: Check whether the inner class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9261534214019775
*Check whether the inner class is private.* 匹配到的元操作或API：
logic: Check whether the inner class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9290029406547546
*Get all constructors declared in inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the inner class is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9326449036598206
*Get all methods declared in inner class.* 匹配到的元操作或API：
query: Get all methods declared in inner class.
most similar API: get declared annotations of method
cosine Similarity: 0.8129565119743347
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Get the body of the class.* 匹配到的元操作或API：
query: Get the body of the class.
most similar API: get body of class or interface
cosine Similarity: 0.8997882008552551
*Check whether the body contains a new instance creation with an anonymous inner class.* 匹配到的元操作或API：
query: Check whether the body contains a new instance creation with an anonymous inner class.
most similar API: Check whether is anonymous class creation
cosine Similarity: 0.8551055788993835
*Get the constructor call of the anonymous inner class.* 匹配到的元操作或API：
query: Get the constructor call of the anonymous inner class.
most similar API: get anonymous class declaration of constructor call
cosine Similarity: 0.8884170055389404
*Check whether the constructor call is to a private constructor.* 匹配到的元操作或API：
logic: Check whether the constructor call is to a private constructor.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9169496893882751
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all inner classes declared in class.* 匹配到的元操作或API：
query: Get all inner classes declared in class.
most similar API: get declarations of anonymous class
cosine Similarity: 0.804994523525238
*Check whether the inner class is public.* 匹配到的元操作或API：
logic: Check whether the inner class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9261534214019775
*Check whether the inner class is private.* 匹配到的元操作或API：
logic: Check whether the inner class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9290029406547546
*Get all constructors declared in inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the inner class is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9326449036598206
*Get all methods declared in inner class.* 匹配到的元操作或API：
query: Get all methods declared in inner class.
most similar API: get declared annotations of method
cosine Similarity: 0.8129565119743347
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Get the body of the class.* 匹配到的元操作或API：
query: Get the body of the class.
most similar API: get body of class or interface
cosine Similarity: 0.8997882008552551
*Check whether the body contains a new instance creation with an anonymous inner class.* 匹配到的元操作或API：
query: Check whether the body contains a new instance creation with an anonymous inner class.
most similar API: Check whether is anonymous class creation
cosine Similarity: 0.8551055788993835
*Get the constructor call of the anonymous inner class.* 匹配到的元操作或API：
query: Get the constructor call of the anonymous inner class.
most similar API: get anonymous class declaration of constructor call
cosine Similarity: 0.8884170055389404
*Check whether the constructor call is to a private constructor.* 匹配到的元操作或API：
logic: Check whether the constructor call is to a private constructor.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9169496893882751
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract generic classes with abstract methods should be ignored #3668
import java.util.Comparator;
public class Outer {
    private abstract class Base<E> {
        abstract void run();
        abstract void sort(Comparator<E> comparator);
    }
    public void someMethod() {
        Base b = new Base<Object>() {
            void run() {}
            void sort(Comparator<Object> comparator) {}
        };
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTTypeParameters
        ——ASTTypeParameter
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
        ——ASTMethodDeclaration (method name = 'sort')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
                ——ASTTypeArguments
                  ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'comparator')
    ——ASTMethodDeclaration (method name = 'someMethod')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'b')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
                ——ASTTypeArguments
                  ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 0)
              ——ASTAnonymousClassDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceBody
                  ——ASTMethodDeclaration (method name = 'run')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 0)
                    ——ASTBlock
                  ——ASTMethodDeclaration (method name = 'sort')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 1)
                      ——ASTFormalParameter
                        ——ASTModifierList
                        ——ASTClassOrInterfaceType (this is a class type)
                          ——ASTTypeArguments
                            ——ASTClassOrInterfaceType (this is a class type)
                        ——ASTVariableDeclaratorId (declared variable name = 'comparator')
                    ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
5. net.sourceforge.pmd.lang.java.ast.ASTAnonymousClassDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
8. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTTypeBody getBody(), //Returns the body of this type declaration.
10. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isAnonymousClassCreation(net.sourceforge.pmd.lang.java.ast.ASTExpression)
11. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTAnonymousClassDeclaration getAnonymousClassDeclaration()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTClassOrInterfaceDeclaration otherClassNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
                    if (otherClassNode.getBody().getDeclarations(ASTClassOrInterfaceDeclaration.class).anyMatch(child -> child.getSuperClassType() != null && child.getSuperClassType().getSimpleName().equals(classNode.getSimpleName()))) {
                        isExtended = true;
                        break;
                    }
                }
                if (!isExtended && !isAnonymousClassInstantiated(classNode, node)) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }

    private boolean isAnonymousClassInstantiated(ASTClassOrInterfaceDeclaration classNode, ASTCompilationUnit node) {
        for (ASTConstructorCall constructorCall : node.findDescendantsOfType(ASTConstructorCall.class)) {
            ASTAnonymousClassDeclaration anonymousClass = constructorCall.getAnonymousClassDeclaration();
            if (anonymousClass != null && anonymousClass.getSuperClassType() != null && anonymousClass.getSuperClassType().getSimpleName().equals(classNode.getSimpleName())) {
                return true;
            }
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To ascertain whether the provided test case adheres to the rule, let's perform the necessary granular checks:

1. Get the name of class.
2. Check whether the class is abstract.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Check whether the class has declared annotations.
6. Get the super class of class.
7. Check whether the class is final.
8. Check whether the class is an inner class.
9. Check whether the inner class is anonymous.
10. Get the number of constructors in the class.
11. Repeat steps 3 to 10 for each inner class.

Let's apply these checks specifically to the `Base` class within the `Outer` class:

1. Get the name of class. (Base)
2. Check whether the class is abstract. (True, as Base is declared as `abstract`)
3. Get all constructors declared in class. (No constructors explicitly declared in Base)
4. Check whether the constructor is private. (No constructors to check, so this step is effectively skipped)
5. Check whether the class has declared annotations. (False, no annotations on Base)
6. Get the super class of class. (Object, as no explicit super class is mentioned)
7. Check whether the class is final. (False, Base is not declared as `final`)
8. Check whether the class is an inner class. (True, Base is an inner class of Outer)
9. Check whether the inner class is anonymous. (False, Base is not an anonymous class)
10. Get the number of constructors in the class. (0, as no constructors are explicitly declared)
11. Repeat steps 3 to 10 for each inner class. (We already checked Base, there is another anonymous inner class in `someMethod`)

Now, let's check the anonymous inner class in `someMethod`:

1. Get the name of class. (Anonymous class)
2. Check whether the class is abstract. (False, anonymous class is not abstract)
3. Get all constructors declared in class. (No constructors explicitly declared in anonymous class)
4. Check whether the constructor is private. (No constructors to check, so this step is effectively skipped)
5. Check whether the class has declared annotations. (False, no annotations on anonymous class)
6. Get the super class of class. (Base, as it extends Base<Object>)
7. Check whether the class is final. (False, anonymous class is not declared as `final`)
8. Check whether the class is an inner class. (True, anonymous class is an inner class of Outer)
9. Check whether the inner class is anonymous. (True, anonymous class is declared inline in `someMethod`)
10. Get the number of constructors in the class. (0, as no constructors are explicitly declared)
11. Check whether the class has private constructors in the superclass. (True, Base has an implicit default constructor which is private due to Base being private)

Since the `Base` class is private and abstract, it cannot be extended from outside its compilation unit. The anonymous inner class is a subclass within the same compilation unit, so it does not violate the rule. Therefore, the number of classes violating the rule in this test case is indeed 0.

The test case adheres to the rule as the abstract class `Base` is private and thus cannot be extended from outside its compilation unit, and the anonymous inner class is a subclass within the same compilation unit.
['Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has declared annotations.', 'Get the super class of class.', 'Check whether the class is final.', 'Check whether the class is an inner class.', 'Check whether the inner class is anonymous.', 'Get the number of constructors in the class.', 'Repeat steps 3 to 10 for each inner class.', 'Get the name of class. (Base)', 'Check whether the class is abstract. (True, as Base is declared as `abstract`)', 'Get all constructors declared in class. (No constructors explicitly declared in Base)', 'Check whether the constructor is private. (No constructors to check, so this step is effectively skipped)', 'Check whether the class has declared annotations. (False, no annotations on Base)', 'Get the super class of class. (Object, as no explicit super class is mentioned)', 'Check whether the class is final. (False, Base is not declared as `final`)', 'Check whether the class is an inner class. (True, Base is an inner class of Outer)', 'Check whether the inner class is anonymous. (False, Base is not an anonymous class)', 'Get the number of constructors in the class. (0, as no constructors are explicitly declared)', 'Repeat steps 3 to 10 for each inner class. (We already checked Base, there is another anonymous inner class in `someMethod`)', 'Get the name of class. (Anonymous class)', 'Check whether the class is abstract. (False, anonymous class is not abstract)', 'Get all constructors declared in class. (No constructors explicitly declared in anonymous class)', 'Check whether the constructor is private. (No constructors to check, so this step is effectively skipped)', 'Check whether the class has declared annotations. (False, no annotations on anonymous class)', 'Get the super class of class. (Base, as it extends Base<Object>)', 'Check whether the class is final. (False, anonymous class is not declared as `final`)', 'Check whether the class is an inner class. (True, anonymous class is an inner class of Outer)', 'Check whether the inner class is anonymous. (True, anonymous class is declared inline in `someMethod`)', 'Get the number of constructors in the class. (0, as no constructors are explicitly declared)', 'Check whether the class has private constructors in the superclass. (True, Base has an implicit default constructor which is private due to Base being private)']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'ASTVariableDeclarator', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'ASTTypeArguments', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTImportDeclaration', 'ASTConstructorCall', 'ASTTypeParameter', 'ASTFormalParameter', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTAnonymousClassDeclaration', 'ASTTypeParameters', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is an inner class.* 匹配到的元操作或API：
logic: Check whether the class is an inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9831405878067017
*Check whether the inner class is anonymous.* 匹配到的元操作或API：
logic: Check whether the inner class is anonymous.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9262059926986694
*Get the number of constructors in the class.* 匹配到的元操作或API：
query: Get the number of constructors in the class.
most similar API: get num children of constructor call
cosine Similarity: 0.84001225233078
*Repeat steps 3 to 10 for each inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class. (Base)* 匹配到的元操作或API：
logic: Get the name of class. (Base)
most similar meta operation: Get the name of class
cosine Similarity: 0.8921183347702026
*Check whether the class is abstract. (True, as Base is declared as `abstract`)* 匹配到的元操作或API：
logic: Check whether the class is abstract. (True, as Base is declared as `abstract`)
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9160736799240112
*Get all constructors declared in class. (No constructors explicitly declared in Base)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private. (No constructors to check, so this step is effectively skipped)* 匹配到的元操作或API：
logic: Check whether the constructor is private. (No constructors to check, so this step is effectively skipped)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9448605179786682
*Check whether the class has declared annotations. (False, no annotations on Base)* 匹配到的元操作或API：
logic: Check whether the class has declared annotations. (False, no annotations on Base)
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9392515420913696
*Get the super class of class. (Object, as no explicit super class is mentioned)* 匹配到的元操作或API：
logic: Get the super class of class. (Object, as no explicit super class is mentioned)
most similar meta operation: Get the super class of class
cosine Similarity: 0.903018593788147
*Check whether the class is final. (False, Base is not declared as `final`)* 匹配到的元操作或API：
logic: Check whether the class is final. (False, Base is not declared as `final`)
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9049978256225586
*Check whether the class is an inner class. (True, Base is an inner class of Outer)* 匹配到的元操作或API：
logic: Check whether the class is an inner class. (True, Base is an inner class of Outer)
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9138955473899841
*Check whether the inner class is anonymous. (False, Base is not an anonymous class)* 匹配到的元操作或API：
logic: Check whether the inner class is anonymous. (False, Base is not an anonymous class)
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.8853486776351929
*Get the number of constructors in the class. (0, as no constructors are explicitly declared)* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 3 to 10 for each inner class. (We already checked Base, there is another anonymous inner class in `someMethod`)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class. (Anonymous class)* 匹配到的元操作或API：
logic: Get the name of class. (Anonymous class)
most similar meta operation: Get the name of class
cosine Similarity: 0.9021998047828674
*Check whether the class is abstract. (False, anonymous class is not abstract)* 匹配到的元操作或API：
logic: Check whether the class is abstract. (False, anonymous class is not abstract)
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9291144609451294
*Get all constructors declared in class. (No constructors explicitly declared in anonymous class)* 匹配到的元操作或API：
query: Get all constructors declared in class. (No constructors explicitly declared in anonymous class)
most similar API: get declarations of anonymous class
cosine Similarity: 0.8609813451766968
*Check whether the constructor is private. (No constructors to check, so this step is effectively skipped)* 匹配到的元操作或API：
logic: Check whether the constructor is private. (No constructors to check, so this step is effectively skipped)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9448605179786682
*Check whether the class has declared annotations. (False, no annotations on anonymous class)* 匹配到的元操作或API：
logic: Check whether the class has declared annotations. (False, no annotations on anonymous class)
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9284326434135437
*Get the super class of class. (Base, as it extends Base<Object>)* 匹配到的元操作或API：
logic: Get the super class of class. (Base, as it extends Base<Object>)
most similar meta operation: Get the super class of class
cosine Similarity: 0.9023687243461609
*Check whether the class is final. (False, anonymous class is not declared as `final`)* 匹配到的元操作或API：
logic: Check whether the class is final. (False, anonymous class is not declared as `final`)
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9197206497192383
*Check whether the class is an inner class. (True, anonymous class is an inner class of Outer)* 匹配到的元操作或API：
logic: Check whether the class is an inner class. (True, anonymous class is an inner class of Outer)
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.9101197719573975
*Check whether the inner class is anonymous. (True, anonymous class is declared inline in `someMethod`)* 匹配到的元操作或API：
logic: Check whether the inner class is anonymous. (True, anonymous class is declared inline in `someMethod`)
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9056817293167114
*Get the number of constructors in the class. (0, as no constructors are explicitly declared)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has private constructors in the superclass. (True, Base has an implicit default constructor which is private due to Base being private)* 匹配到的元操作或API：
logic: Check whether the class has private constructors in the superclass. (True, Base has an implicit default constructor which is private due to Base being private)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8582320213317871
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract generic classes with abstract methods should be ignored #3668
import java.util.Comparator;
public class Outer {
    private abstract class Base<E> {
        abstract void run();
        abstract void sort(Comparator<E> comparator);
    }
    public void someMethod() {
        Base b = new Base<Object>() {
            void run() {}
            void sort(Comparator<Object> comparator) {}
        };
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTTypeParameters
        ——ASTTypeParameter
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
        ——ASTMethodDeclaration (method name = 'sort')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
                ——ASTTypeArguments
                  ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'comparator')
    ——ASTMethodDeclaration (method name = 'someMethod')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'b')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
                ——ASTTypeArguments
                  ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 0)
              ——ASTAnonymousClassDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceBody
                  ——ASTMethodDeclaration (method name = 'run')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 0)
                    ——ASTBlock
                  ——ASTMethodDeclaration (method name = 'sort')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 1)
                      ——ASTFormalParameter
                        ——ASTModifierList
                        ——ASTClassOrInterfaceType (this is a class type)
                          ——ASTTypeArguments
                            ——ASTClassOrInterfaceType (this is a class type)
                        ——ASTVariableDeclaratorId (declared variable name = 'comparator')
                    ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnonymous()
8. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public int getNumChildren()
9. net.sourceforge.pmd.lang.java.ast.ASTAnonymousClassDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic() && !isExtendedAnywhere(classNode, node) && !isAnonymousClassInstantiated(classNode, node)) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }

    private boolean isExtendedAnywhere(ASTClassOrInterfaceDeclaration classNode, ASTCompilationUnit compilationUnit) {
        String className = classNode.getSimpleName();
        for (ASTClassOrInterfaceDeclaration otherClass : compilationUnit.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!otherClass.equals(classNode) && otherClass.getSuperClassTypeNode() != null && otherClass.getSuperClassTypeNode().getName().equals(className)) {
                return true;
            }
        }
        return false;
    }

    private boolean isAnonymousClassInstantiated(ASTClassOrInterfaceDeclaration classNode, ASTCompilationUnit compilationUnit) {
        for (ASTConstructorCall constructorCall : compilationUnit.findDescendantsOfType(ASTConstructorCall.class)) {
            if (constructorCall.getNumChildren() > 0 && constructorCall.getChild(0) instanceof ASTClassOrInterfaceType) {
                ASTClassOrInterfaceType type = (ASTClassOrInterfaceType) constructorCall.getChild(0);
                if (type.getName().equals(classNode.getSimpleName())) {
                    if (constructorCall.getParent() instanceof ASTAnonymousClassDeclaration) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is abstract.
3. Check whether the class is final.
4. Get the constructors of class.
5. Check whether all constructors are private.
6. Get the name of the package where the class is located.
7. Get the class that method is located in.
8. Check whether the outer class has constructors.
9. Check whether all constructors of the outer class are private.
10. Get the name of the package where the outer class is located.
11. Get all inner classes of the outer class.
12. For each inner class, check whether the inner class is private.
13. For each inner class, check whether the inner class is abstract.
14. For each inner class, get the constructors of the inner class.
15. For each inner class, check whether all constructors are private.
16. For each inner class, get the name of the package where the inner class is located.

In this test case:

1. Get the name of class: `Base`
2. Check whether the class is abstract: True
3. Check whether the class is final: False
4. Get the constructors of class: None explicitly declared, so the default constructor is used.
5. Check whether all constructors are private: False, default constructor is not private.
6. Get the name of the package where the class is located: Not specified in the test case, but it's within the compilation unit of `Outer`.
7. Get the class that method is located in: `someMethod` is located in `Outer`.
8. Check whether the outer class has constructors: True, implicitly the default constructor is present.
9. Check whether all constructors of the outer class are private: False, default constructor is not private.
10. Get the name of the package where the outer class is located: Not specified in the test case, but it's within the compilation unit.
11. Get all inner classes of the outer class: `Base`
12. For each inner class, check whether the inner class is private: True, `Base` is a private inner class.
13. For each inner class, check whether the inner class is abstract: True, `Base` is abstract.
14. For each inner class, get the constructors of the inner class: None explicitly declared, so the default constructor is used.
15. For each inner class, check whether all constructors are private: True, default constructor is private.
16. For each inner class, get the name of the package where the inner class is located: Not specified in the test case, but it's within the compilation unit of `Outer`.

Since `Base` is a private abstract inner class and its constructors are implicitly private, it cannot be extended from outside its compilation unit. Therefore, it does not violate the rule of potentially being made final. 

The number of violations in this test case is: 0
['Get the name of class.', 'Check whether the class is abstract.', 'Check whether the class is final.', 'Get the constructors of class.', 'Check whether all constructors are private.', 'Get the name of the package where the class is located.', 'Get the class that method is located in.', 'Check whether the outer class has constructors.', 'Check whether all constructors of the outer class are private.', 'Get the name of the package where the outer class is located.', 'Get all inner classes of the outer class.', 'For each inner class, check whether the inner class is private.', 'For each inner class, check whether the inner class is abstract.', 'For each inner class, get the constructors of the inner class.', 'For each inner class, check whether all constructors are private.', 'For each inner class, get the name of the package where the inner class is located.', 'Get the name of class: `Base`', 'Check whether the class is abstract: True', 'Check whether the class is final: False', 'Get the constructors of class: None explicitly declared, so the default constructor is used.', 'Check whether all constructors are private: False, default constructor is not private.', "Get the name of the package where the class is located: Not specified in the test case, but it's within the compilation unit of `Outer`.", 'Get the class that method is located in: `someMethod` is located in `Outer`.', 'Check whether the outer class has constructors: True, implicitly the default constructor is present.', 'Check whether all constructors of the outer class are private: False, default constructor is not private.', "Get the name of the package where the outer class is located: Not specified in the test case, but it's within the compilation unit.", 'Get all inner classes of the outer class: `Base`', 'For each inner class, check whether the inner class is private: True, `Base` is a private inner class.', 'For each inner class, check whether the inner class is abstract: True, `Base` is abstract.', 'For each inner class, get the constructors of the inner class: None explicitly declared, so the default constructor is used.', 'For each inner class, check whether all constructors are private: True, default constructor is private.', "For each inner class, get the name of the package where the inner class is located: Not specified in the test case, but it's within the compilation unit of `Outer`."]
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'ASTVariableDeclarator', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'ASTTypeArguments', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTImportDeclaration', 'ASTConstructorCall', 'ASTTypeParameter', 'ASTFormalParameter', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTAnonymousClassDeclaration', 'ASTTypeParameters', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get the constructors of class.* 匹配到的元操作或API：
query: Get the constructors of class.
most similar API: get parents of type of constructor call
cosine Similarity: 0.8206514716148376
*Check whether all constructors are private.* 匹配到的元操作或API：
logic: Check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.936521589756012
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Get the class that method is located in.* 匹配到的元操作或API：
logic: Get the class that method is located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.973173975944519
*Check whether the outer class has constructors.* 匹配到的元操作或API：
query: Check whether the outer class has constructors.
most similar API: Check whether the constructor call is qualified instance creation
cosine Similarity: 0.8180806040763855
*Check whether all constructors of the outer class are private.* 匹配到的元操作或API：
logic: Check whether all constructors of the outer class are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8993951678276062
*Get the name of the package where the outer class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the outer class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9100316762924194
*Get all inner classes of the outer class.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each inner class, check whether the inner class is private.* 匹配到的元操作或API：
logic: For each inner class, check whether the inner class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.893695592880249
*For each inner class, check whether the inner class is abstract.* 匹配到的元操作或API：
logic: For each inner class, check whether the inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.8974006175994873
*For each inner class, get the constructors of the inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each inner class, check whether all constructors are private.* 匹配到的元操作或API：
logic: For each inner class, check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8869606852531433
*For each inner class, get the name of the package where the inner class is located.* 匹配到的元操作或API：
logic: For each inner class, get the name of the package where the inner class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.8934824466705322
*Get the name of class: `Base`* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is abstract: True* 匹配到的元操作或API：
logic: Check whether the class is abstract: True
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.968787670135498
*Check whether the class is final: False* 匹配到的元操作或API：
logic: Check whether the class is final: False
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9627463817596436
*Get the constructors of class: None explicitly declared, so the default constructor is used.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether all constructors are private: False, default constructor is not private.* 匹配到的元操作或API：
logic: Check whether all constructors are private: False, default constructor is not private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9034545421600342
*Get the name of the package where the class is located: Not specified in the test case, but it's within the compilation unit of `Outer`.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located: Not specified in the test case, but it's within the compilation unit of `Outer`.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.8943472504615784
*Get the class that method is located in: `someMethod` is located in `Outer`.* 匹配到的元操作或API：
logic: Get the class that method is located in: `someMethod` is located in `Outer`.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.897154688835144
*Check whether the outer class has constructors: True, implicitly the default constructor is present.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether all constructors of the outer class are private: False, default constructor is not private.* 匹配到的元操作或API：
logic: Check whether all constructors of the outer class are private: False, default constructor is not private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8796371221542358
*Get the name of the package where the outer class is located: Not specified in the test case, but it's within the compilation unit.* 匹配到的元操作或API：
logic: Get the name of the package where the outer class is located: Not specified in the test case, but it's within the compilation unit.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.8723793029785156
*Get all inner classes of the outer class: `Base`* 匹配到的元操作或API：
未匹配成功元操作或API
*For each inner class, check whether the inner class is private: True, `Base` is a private inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each inner class, check whether the inner class is abstract: True, `Base` is abstract.* 匹配到的元操作或API：
logic: For each inner class, check whether the inner class is abstract: True, `Base` is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.8532074689865112
*For each inner class, get the constructors of the inner class: None explicitly declared, so the default constructor is used.* 匹配到的元操作或API：
未匹配成功元操作或API
*For each inner class, check whether all constructors are private: True, default constructor is private.* 匹配到的元操作或API：
logic: For each inner class, check whether all constructors are private: True, default constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8767697811126709
*For each inner class, get the name of the package where the inner class is located: Not specified in the test case, but it's within the compilation unit of `Outer`.* 匹配到的元操作或API：
query: For each inner class, get the name of the package where the inner class is located: Not specified in the test case, but it's within the compilation unit of `Outer`.
most similar API: get package name of anonymous class: Returns the name of the package in which this class is declared.
cosine Similarity: 0.8130840063095093
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                addViolation(data, classNode);
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract generic classes with abstract methods should be ignored #3668
import java.util.Comparator;
public class Outer {
    private abstract class Base<E> {
        abstract void run();
        abstract void sort(Comparator<E> comparator);
    }
    public void someMethod() {
        Base b = new Base<Object>() {
            void run() {}
            void sort(Comparator<Object> comparator) {}
        };
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTTypeParameters
        ——ASTTypeParameter
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
        ——ASTMethodDeclaration (method name = 'sort')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 1)
            ——ASTFormalParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
                ——ASTTypeArguments
                  ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'comparator')
    ——ASTMethodDeclaration (method name = 'someMethod')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'b')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
                ——ASTTypeArguments
                  ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 0)
              ——ASTAnonymousClassDeclaration
                ——ASTModifierList
                ——ASTClassOrInterfaceBody
                  ——ASTMethodDeclaration (method name = 'run')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 0)
                    ——ASTBlock
                  ——ASTMethodDeclaration (method name = 'sort')
                    ——ASTModifierList
                    ——ASTVoidType (method return type = 'void')
                    ——ASTFormalParameters (size = 1)
                      ——ASTFormalParameter
                        ——ASTModifierList
                        ——ASTClassOrInterfaceType (this is a class type)
                          ——ASTTypeArguments
                            ——ASTClassOrInterfaceType (this is a class type)
                        ——ASTVariableDeclaratorId (declared variable name = 'comparator')
                    ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public java.util.List<List<T> getParentsOfType(java.lang.Class)
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType()
8. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isQualifiedInstanceCreation(), //Returns true if this expression begins with a primary expression. Such an expression creates an instance of inner member classes and their anonymous subclasses. For example, {@code new Outer().new Inner()} evaluates to an instance of the Inner class, which is nested inside the new instance of Outer.
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
10. net.sourceforge.pmd.lang.java.ast.ASTAnonymousClassDeclaration: public java.lang.String getPackageName(), //Returns the name of the package in which this class is declared.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    if (constructorCall.isQualifiedInstanceCreation()) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = constructorCall.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
                    if (anonymousClass.getPackageName().equals(classNode.getPackageName())) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = anonymousClass.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "ok 13" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
94
78
107
91
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is public.
3. Get all inner classes declared in class.
4. Check whether the inner class is abstract.
5. Get all constructors declared in inner class.
6. Check whether the constructor is private.
7. Check whether the inner class has subclasses.
8. If the inner class is abstract and has private constructors, it should be ignored.
9. If the inner class is final and all its constructors are private, it should be reported as a violation.
10. If the inner class is final, has private constructors, and has subclasses, it should be ignored.

For the provided test case:
1. Get the name of class. // Outer
2. Check whether the class is public. // Yes, Outer is public.
3. Get all inner classes declared in class. // Base, Sub
4. Check whether the inner class is abstract. // Base is abstract, Sub is not.
5. Get all constructors declared in inner class. // Base has an implicit private constructor, Sub has a private constructor.
6. Check whether the constructor is private. // Base's constructor is private, Sub's constructor is private.
7. Check whether the inner class has subclasses. // Base has Sub as a subclass, Sub has no subclass.
8. Base is abstract and has a private constructor, so it should be ignored.
9. Sub is final but has a private constructor and a subclass (Base), so it should be ignored.

The number of violations in this test case is: 0
['Get the name of class.', 'Check whether the class is public.', 'Get all inner classes declared in class.', 'Check whether the inner class is abstract.', 'Get all constructors declared in inner class.', 'Check whether the constructor is private.', 'Check whether the inner class has subclasses.', 'If the inner class is abstract and has private constructors, it should be ignored.', 'If the inner class is final and all its constructors are private, it should be reported as a violation.', 'If the inner class is final, has private constructors, and has subclasses, it should be ignored.', 'Get the name of class. // Outer', 'Check whether the class is public. // Yes, Outer is public.', 'Get all inner classes declared in class. // Base, Sub', 'Check whether the inner class is abstract. // Base is abstract, Sub is not.', 'Get all constructors declared in inner class. // Base has an implicit private constructor, Sub has a private constructor.', "Check whether the constructor is private. // Base's constructor is private, Sub's constructor is private.", 'Check whether the inner class has subclasses. // Base has Sub as a subclass, Sub has no subclass.', 'Base is abstract and has a private constructor, so it should be ignored.', 'Sub is final but has a private constructor and a subclass (Base), so it should be ignored.']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get all inner classes declared in class.* 匹配到的元操作或API：
query: Get all inner classes declared in class.
most similar API: get declarations of class or interface
cosine Similarity: 0.8037846684455872
*Check whether the inner class is abstract.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9326449036598206
*Get all constructors declared in inner class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the inner class has subclasses.* 匹配到的元操作或API：
logic: Check whether the inner class has subclasses.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.8886170387268066
*If the inner class is abstract and has private constructors, it should be ignored.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the inner class is final and all its constructors are private, it should be reported as a violation.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the inner class is final, has private constructors, and has subclasses, it should be ignored.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class. // Outer* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is public. // Yes, Outer is public.* 匹配到的元操作或API：
logic: Check whether the class is public. // Yes, Outer is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.8980279564857483
*Get all inner classes declared in class. // Base, Sub* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the inner class is abstract. // Base is abstract, Sub is not.* 匹配到的元操作或API：
logic: Check whether the inner class is abstract. // Base is abstract, Sub is not.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.8620963096618652
*Get all constructors declared in inner class. // Base has an implicit private constructor, Sub has a private constructor.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private. // Base's constructor is private, Sub's constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private. // Base's constructor is private, Sub's constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8964009284973145
*Check whether the inner class has subclasses. // Base has Sub as a subclass, Sub has no subclass.* 匹配到的元操作或API：
未匹配成功元操作或API
*Base is abstract and has a private constructor, so it should be ignored.* 匹配到的元操作或API：
未匹配成功元操作或API
*Sub is final but has a private constructor and a subclass (Base), so it should be ignored.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    if (constructorCall.isQualifiedInstanceCreation()) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = constructorCall.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
                    if (anonymousClass.getPackageName().equals(classNode.getPackageName())) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = anonymousClass.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this positive testcase:
import java.util.Comparator;
public class Outer {
    private abstract class Base<E> {
        abstract void run();
        abstract void sort(Comparator<E> comparator);
    }
    public void someMethod() {
        Base b = new Base<Object>() {
            void run() {}
            void sort(Comparator<Object> comparator) {}
        };
    }
}
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract classes without abstract methods but with subclasses should be ignored #3668
public class Outer {
    private abstract class Base {
        private void run() {}
    }
    private final class Sub extends Base {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<NodeStream<T> getDeclarations(java.lang.Class)
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    if (constructorCall.isQualifiedInstanceCreation()) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = constructorCall.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
                    if (anonymousClass.getPackageName().equals(classNode.getPackageName())) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = anonymousClass.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                // Check if the class is extended by any other class within the same compilation unit
                for (ASTClassOrInterfaceDeclaration subClass : node.children(ASTClassOrInterfaceDeclaration.class)) {
                    if (subClass.isNested() && subClass.getSuperClass() != null && subClass.getSuperClass().getImage().equals(classNode.getSimpleName())) {
                        isExtended = true;
                        break;
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To analyze this test case and ensure it adheres to the rule, we will perform the following granular checks:

1. Get the name of class.
2. Check whether the class is abstract.
3. Check whether the class is final.
4. Get a declared constructor of class.
5. Check whether the constructor is private.
6. Get the number of declared constructors of class.
7. Check whether the class has subclasses.
8. Get the name of the package where the class is located.
9. Get the name of subclass.
10. Get the name of the package where the subclass is located.
11. Check whether the class is in the same package as its subclass.

Let's perform these checks step-by-step:

1. Get the name of class.
   - The class name is `Outer`.

2. Check whether the class is abstract.
   - `Outer` is not an abstract class.

3. Check whether the class is final.
   - `Outer` is not a final class.

4. Get a declared constructor of class.
   - Default no-argument constructor.

5. Check whether the constructor is private.
   - The default constructor is not private.

6. Get the number of declared constructors of class.
   - There is one no-argument constructor (default).

7. Check whether the class has subclasses.
   - `Outer` has a subclass `Base`.

8. Get the name of the package where the class is located.
   - Not specified, assume it's in the default package.

9. Get the name of subclass.
   - The name of the subclass is `Base`.

10. Get the name of the package where the subclass is located.
    - Not specified, assume it's in the default package.

11. Check whether the class is in the same package as its subclass.
    - `Outer` and `Base` are in the same default package.

Now, we need to check `Base` and its subclass `Sub`:

1. Get the name of class.
   - The class name is `Base`.

2. Check whether the class is abstract.
   - `Base` is an abstract class.

3. Check whether the class is final.
   - `Base` is not a final class.

4. Get a declared constructor of class.
   - No constructors declared, default constructor.

5. Check whether the constructor is private.
   - The default constructor is not private.

6. Get the number of declared constructors of class.
   - There is one no-argument constructor (default).

7. Check whether the class has subclasses.
   - `Base` has a subclass `Sub`.

8. Get the name of the package where the class is located.
   - Not specified, assume it's in the default package.

9. Get the name of subclass.
   - The name of the subclass is `Sub`.

10. Get the name of the package where the subclass is located.
    - Not specified, assume it's in the default package.

11. Check whether the class is in the same package as its subclass.
    - `Base` and `Sub` are in the same default package.

Finally, we need to check `Sub`:

1. Get the name of class.
   - The class name is `Sub`.

2. Check whether the class is abstract.
   - `Sub` is not an abstract class.

3. Check whether the class is final.
   - `Sub` is a final class.

4. Get a declared constructor of class.
   - No constructors declared, default constructor.

5. Check whether the constructor is private.
   - The default constructor is not private.

6. Get the number of declared constructors of class.
   - There is one no-argument constructor (default).

7. Check whether the class has subclasses.
   - `Sub` does not have subclasses.

8. Get the name of the package where the class is located.
   - Not specified, assume it's in the default package.

9. Check whether the class is in the same compilation unit as its superclass.
   - `Sub` and `Base` are in the same compilation unit (class `Outer`).

10. Check whether the superclass has any non-private constructors.
    - `Base` has a default constructor, which is not private.

Based on these checks, `Base` is not violating the rule because it has subclasses and `Sub` is a final class. Additionally, `Sub` is not violating the rule because it is final and in the same compilation unit as its superclass `Base`. Therefore, the number of violations in this test case is 0.
['Get the name of class.', 'Check whether the class is abstract.', 'Check whether the class is final.', 'Get a declared constructor of class.', 'Check whether the constructor is private.', 'Get the number of declared constructors of class.', 'Check whether the class has subclasses.', 'Get the name of the package where the class is located.', 'Get the name of subclass.', 'Get the name of the package where the subclass is located.', 'Check whether the class is in the same package as its subclass.', 'Get the name of class.', 'Check whether the class is abstract.', 'Check whether the class is final.', 'Get a declared constructor of class.', 'Check whether the constructor is private.', 'Get the number of declared constructors of class.', 'Check whether the class has subclasses.', 'Get the name of the package where the class is located.', 'Get the name of subclass.', 'Get the name of the package where the subclass is located.', 'Check whether the class is in the same package as its subclass.', 'Get the name of class.', 'Check whether the class is abstract.', 'Check whether the class is final.', 'Get a declared constructor of class.', 'Check whether the constructor is private.', 'Get the number of declared constructors of class.', 'Check whether the class has subclasses.', 'Get the name of the package where the class is located.', 'Get the name of subclass.', 'Get the name of the package where the subclass is located.', 'Check whether the class is in the same package as its subclass.', 'Get the name of class.', 'Check whether the class is abstract.', 'Check whether the class is final.', 'Get a declared constructor of class.', 'Check whether the constructor is private.', 'Get the number of declared constructors of class.', 'Check whether the class has subclasses.', 'Get the name of the package where the class is located.', 'Check whether the class is in the same compilation unit as its superclass.', 'Check whether the superclass has any non-private constructors.']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get a declared constructor of class.* 匹配到的元操作或API：
logic: Get a declared constructor of class.
most similar meta operation: Get a declared annotation of constructor
cosine Similarity: 0.8581584095954895
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the number of declared constructors of class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Get the name of subclass.* 匹配到的元操作或API：
logic: Get the name of subclass.
most similar meta operation: Get the name of class
cosine Similarity: 0.8744382858276367
*Get the name of the package where the subclass is located.* 匹配到的元操作或API：
logic: Get the name of the package where the subclass is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.927919864654541
*Check whether the class is in the same package as its subclass.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get a declared constructor of class.* 匹配到的元操作或API：
logic: Get a declared constructor of class.
most similar meta operation: Get a declared annotation of constructor
cosine Similarity: 0.8581584095954895
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the number of declared constructors of class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Get the name of subclass.* 匹配到的元操作或API：
logic: Get the name of subclass.
most similar meta operation: Get the name of class
cosine Similarity: 0.8744382858276367
*Get the name of the package where the subclass is located.* 匹配到的元操作或API：
logic: Get the name of the package where the subclass is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.927919864654541
*Check whether the class is in the same package as its subclass.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get a declared constructor of class.* 匹配到的元操作或API：
logic: Get a declared constructor of class.
most similar meta operation: Get a declared annotation of constructor
cosine Similarity: 0.8581584095954895
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the number of declared constructors of class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Get the name of subclass.* 匹配到的元操作或API：
logic: Get the name of subclass.
most similar meta operation: Get the name of class
cosine Similarity: 0.8744382858276367
*Get the name of the package where the subclass is located.* 匹配到的元操作或API：
logic: Get the name of the package where the subclass is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.927919864654541
*Check whether the class is in the same package as its subclass.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get a declared constructor of class.* 匹配到的元操作或API：
logic: Get a declared constructor of class.
most similar meta operation: Get a declared annotation of constructor
cosine Similarity: 0.8581584095954895
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the number of declared constructors of class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class has subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is in the same compilation unit as its superclass.* 匹配到的元操作或API：
query: Check whether the class is in the same compilation unit as its superclass.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.871142566204071
*Check whether the superclass has any non-private constructors.* 匹配到的元操作或API：
logic: Check whether the superclass has any non-private constructors.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8661898374557495
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    if (constructorCall.isQualifiedInstanceCreation()) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = constructorCall.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
                    if (anonymousClass.getPackageName().equals(classNode.getPackageName())) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = anonymousClass.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this positive testcase:
import java.util.Comparator;
public class Outer {
    private abstract class Base<E> {
        abstract void run();
        abstract void sort(Comparator<E> comparator);
    }
    public void someMethod() {
        Base b = new Base<Object>() {
            void run() {}
            void sort(Comparator<Object> comparator) {}
        };
    }
}
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract classes without abstract methods but with subclasses should be ignored #3668
public class Outer {
    private abstract class Base {
        private void run() {}
    }
    private final class Sub extends Base {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    if (constructorCall.isQualifiedInstanceCreation()) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = constructorCall.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
                    if (anonymousClass.getPackageName().equals(classNode.getPackageName())) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = anonymousClass.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTClassOrInterfaceDeclaration subclass : node.children(ASTClassOrInterfaceDeclaration.class)) {
                    if (!subclass.isInterface() && !subclass.isAbstract() && subclass.hasSuperClass() && subclass.getSuperClass().isReferenceToClassSameCompilationUnit() && subclass.getSuperClass().getSimpleName().equals(classNode.getSimpleName())) {
                        isExtended = true;
                        break;
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To ascertain the adherence of the provided test case to the rule, we need to perform the following granular checks:

1. Get the name of class.
2. Check whether the class is public.
3. Get the name of the nested class.
4. Check whether the nested class is abstract.
5. Check whether the nested class is final.
6. Check whether the nested class is private.
7. Get all constructors declared in the nested class.
8. Check whether the constructor is private.
9. Check whether the nested class has subclasses.
10. Get the name of the subclass.
11. Check whether the subclass extends the nested class.
12. Check whether the subclass is private.
13. Check whether the subclass is within the same compilation unit as the nested class.

Let's break this down for the given test case:

1. Get the name of class. (Outer)
2. Check whether the class is public. (Yes, Outer is public)
3. Get the name of the nested class. (Base)
4. Check whether the nested class is abstract. (Yes, Base is abstract)
5. Check whether the nested class is final. (No, Base is not final)
6. Check whether the nested class is private. (Yes, Base is private)
7. Get all constructors declared in the nested class. (Base has an implicit default constructor)
8. Check whether the constructor is private. (No, the implicit default constructor is not private)
9. Check whether the nested class has subclasses. (Yes, Base has a subclass named Sub)
10. Get the name of the subclass. (Sub)
11. Check whether the subclass extends the nested class. (Yes, Sub extends Base)
12. Check whether the subclass is private. (Yes, Sub is private)
13. Check whether the subclass is within the same compilation unit as the nested class. (Yes, Sub is within the same compilation unit as Base)

Since Base is abstract and has subclasses, it should be ignored as per the rule description. Additionally, the rule specifically targets non-abstract classes with private constructors that are not extended from outside their compilation unit.

14. Get the name of the nested class. (Sub)
15. Check whether the nested class is final. (Yes, Sub is final)
16. Check whether the nested class is private. (Yes, Sub is private)
17. Get all constructors declared in the nested class. (Sub has an implicit default constructor)
18. Check whether the constructor is private. (No, the implicit default constructor is not private)
19. Check whether the nested class is extended from outside its compilation unit. (No, Sub is within the same compilation unit as Base)

Since Sub is a final class and is within the same compilation unit as Base, it does not violate the rule.

20. Get the name of the nested class. (Base)
21. Check whether the nested class is abstract. (Yes, Base is abstract)
22. Check whether the nested class is extended from outside its compilation unit. (No, Base has a subclass within the same compilation unit)

Since Base is abstract and has a subclass within the same compilation unit, it should be ignored as per the rule description.

The number of classes violating the rule in this test case is indeed: 0
['Get the name of class.', 'Check whether the class is public.', 'Get the name of the nested class.', 'Check whether the nested class is abstract.', 'Check whether the nested class is final.', 'Check whether the nested class is private.', 'Get all constructors declared in the nested class.', 'Check whether the constructor is private.', 'Check whether the nested class has subclasses.', 'Get the name of the subclass.', 'Check whether the subclass extends the nested class.', 'Check whether the subclass is private.', 'Check whether the subclass is within the same compilation unit as the nested class.', 'Get the name of class. (Outer)', 'Check whether the class is public. (Yes, Outer is public)', 'Get the name of the nested class. (Base)', 'Check whether the nested class is abstract. (Yes, Base is abstract)', 'Check whether the nested class is final. (No, Base is not final)', 'Check whether the nested class is private. (Yes, Base is private)', 'Get all constructors declared in the nested class. (Base has an implicit default constructor)', 'Check whether the constructor is private. (No, the implicit default constructor is not private)', 'Check whether the nested class has subclasses. (Yes, Base has a subclass named Sub)', 'Get the name of the subclass. (Sub)', 'Check whether the subclass extends the nested class. (Yes, Sub extends Base)', 'Check whether the subclass is private. (Yes, Sub is private)', 'Check whether the subclass is within the same compilation unit as the nested class. (Yes, Sub is within the same compilation unit as Base)', 'Get the name of the nested class. (Sub)', 'Check whether the nested class is final. (Yes, Sub is final)', 'Check whether the nested class is private. (Yes, Sub is private)', 'Get all constructors declared in the nested class. (Sub has an implicit default constructor)', 'Check whether the constructor is private. (No, the implicit default constructor is not private)', 'Check whether the nested class is extended from outside its compilation unit. (No, Sub is within the same compilation unit as Base)', 'Get the name of the nested class. (Base)', 'Check whether the nested class is abstract. (Yes, Base is abstract)', 'Check whether the nested class is extended from outside its compilation unit. (No, Base has a subclass within the same compilation unit)']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Get the name of the nested class.* 匹配到的元操作或API：
logic: Get the name of the nested class.
most similar meta operation: Get the name of class
cosine Similarity: 0.8711507320404053
*Check whether the nested class is abstract.* 匹配到的元操作或API：
logic: Check whether the nested class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9301541447639465
*Check whether the nested class is final.* 匹配到的元操作或API：
logic: Check whether the nested class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9336292743682861
*Check whether the nested class is private.* 匹配到的元操作或API：
logic: Check whether the nested class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9230225086212158
*Get all constructors declared in the nested class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the nested class has subclasses.* 匹配到的元操作或API：
query: Check whether the nested class has subclasses.
most similar API: Check whether the class or interface is nested
cosine Similarity: 0.8487162590026855
*Get the name of the subclass.* 匹配到的元操作或API：
logic: Get the name of the subclass.
most similar meta operation: Get the name of class
cosine Similarity: 0.8767187595367432
*Check whether the subclass extends the nested class.* 匹配到的元操作或API：
query: Check whether the subclass extends the nested class.
most similar API: Check whether the class or interface is nested
cosine Similarity: 0.8224261999130249
*Check whether the subclass is private.* 匹配到的元操作或API：
logic: Check whether the subclass is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9286090135574341
*Check whether the subclass is within the same compilation unit as the nested class.* 匹配到的元操作或API：
query: Check whether the subclass is within the same compilation unit as the nested class.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8393281102180481
*Get the name of class. (Outer)* 匹配到的元操作或API：
logic: Get the name of class. (Outer)
most similar meta operation: Get the name of class
cosine Similarity: 0.8815264701843262
*Check whether the class is public. (Yes, Outer is public)* 匹配到的元操作或API：
logic: Check whether the class is public. (Yes, Outer is public)
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9268754720687866
*Get the name of the nested class. (Base)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the nested class is abstract. (Yes, Base is abstract)* 匹配到的元操作或API：
logic: Check whether the nested class is abstract. (Yes, Base is abstract)
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.8965291976928711
*Check whether the nested class is final. (No, Base is not final)* 匹配到的元操作或API：
logic: Check whether the nested class is final. (No, Base is not final)
most similar meta operation: Check whether the class is final
cosine Similarity: 0.8905921578407288
*Check whether the nested class is private. (Yes, Base is private)* 匹配到的元操作或API：
logic: Check whether the nested class is private. (Yes, Base is private)
most similar meta operation: Check whether the class is private
cosine Similarity: 0.8855257630348206
*Get all constructors declared in the nested class. (Base has an implicit default constructor)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private. (No, the implicit default constructor is not private)* 匹配到的元操作或API：
logic: Check whether the constructor is private. (No, the implicit default constructor is not private)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9435936808586121
*Check whether the nested class has subclasses. (Yes, Base has a subclass named Sub)* 匹配到的元操作或API：
query: Check whether the nested class has subclasses. (Yes, Base has a subclass named Sub)
most similar API: Check whether the class or interface is nested
cosine Similarity: 0.8195923566818237
*Get the name of the subclass. (Sub)* 匹配到的元操作或API：
logic: Get the name of the subclass. (Sub)
most similar meta operation: Get the name of class
cosine Similarity: 0.8544204831123352
*Check whether the subclass extends the nested class. (Yes, Sub extends Base)* 匹配到的元操作或API：
query: Check whether the subclass extends the nested class. (Yes, Sub extends Base)
most similar API: Check whether the extends list has descendant of type
cosine Similarity: 0.8180795907974243
*Check whether the subclass is private. (Yes, Sub is private)* 匹配到的元操作或API：
logic: Check whether the subclass is private. (Yes, Sub is private)
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9076567888259888
*Check whether the subclass is within the same compilation unit as the nested class. (Yes, Sub is within the same compilation unit as Base)* 匹配到的元操作或API：
query: Check whether the subclass is within the same compilation unit as the nested class. (Yes, Sub is within the same compilation unit as Base)
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8251712322235107
*Get the name of the nested class. (Sub)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the nested class is final. (Yes, Sub is final)* 匹配到的元操作或API：
logic: Check whether the nested class is final. (Yes, Sub is final)
most similar meta operation: Check whether the class is final
cosine Similarity: 0.8914430141448975
*Check whether the nested class is private. (Yes, Sub is private)* 匹配到的元操作或API：
logic: Check whether the nested class is private. (Yes, Sub is private)
most similar meta operation: Check whether the class is private
cosine Similarity: 0.8842895030975342
*Get all constructors declared in the nested class. (Sub has an implicit default constructor)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private. (No, the implicit default constructor is not private)* 匹配到的元操作或API：
logic: Check whether the constructor is private. (No, the implicit default constructor is not private)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9435936808586121
*Check whether the nested class is extended from outside its compilation unit. (No, Sub is within the same compilation unit as Base)* 匹配到的元操作或API：
query: Check whether the nested class is extended from outside its compilation unit. (No, Sub is within the same compilation unit as Base)
most similar API: Check whether the compilation unit has descendant of type
cosine Similarity: 0.8102076649665833
*Get the name of the nested class. (Base)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the nested class is abstract. (Yes, Base is abstract)* 匹配到的元操作或API：
logic: Check whether the nested class is abstract. (Yes, Base is abstract)
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.8965291976928711
*Check whether the nested class is extended from outside its compilation unit. (No, Base has a subclass within the same compilation unit)* 匹配到的元操作或API：
query: Check whether the nested class is extended from outside its compilation unit. (No, Base has a subclass within the same compilation unit)
most similar API: Check whether the compilation unit has descendant of type
cosine Similarity: 0.810951828956604
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    if (constructorCall.isQualifiedInstanceCreation()) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = constructorCall.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
                    if (anonymousClass.getPackageName().equals(classNode.getPackageName())) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = anonymousClass.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this positive testcase:
import java.util.Comparator;
public class Outer {
    private abstract class Base<E> {
        abstract void run();
        abstract void sort(Comparator<E> comparator);
    }
    public void someMethod() {
        Base b = new Base<Object>() {
            void run() {}
            void sort(Comparator<Object> comparator) {}
        };
    }
}
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract classes without abstract methods but with subclasses should be ignored #3668
public class Outer {
    private abstract class Base {
        private void run() {}
    }
    private final class Sub extends Base {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested(), //Returns true if this type declaration is nested inside an interface, class or annotation.
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot
9. net.sourceforge.pmd.lang.java.ast.ASTExtendsList: public boolean hasDescendantOfType(java.lang.Class)
10. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean hasDescendantOfType(java.lang.Class)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    if (constructorCall.isQualifiedInstanceCreation()) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = constructorCall.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
                    if (anonymousClass.getPackageName().equals(classNode.getPackageName())) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = anonymousClass.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTClassOrInterfaceDeclaration otherClassNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
                    if (otherClassNode.isNested() && otherClassNode.isPrivate() && otherClassNode.hasDescendantOfType(ASTExtendsList.class)) {
                        for (ASTExtendsList extendsList : otherClassNode.children(ASTExtendsList.class)) {
                            for (ASTClassOrInterfaceType extendsType : extendsList.children(ASTClassOrInterfaceType.class)) {
                                if (extendsType.isReferenceToClassSameCompilationUnit() && extendsType.getType().getName().equals(classNode.getSimpleName())) {
                                    isExtended = true;
                                    break;
                                }
                            }
                        }
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 13" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 13" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class is abstract.
3. Get all constructors declared in class.
4. Check whether the constructor is private.
5. Get the name of class.
6. Check whether the class has subclasses.
7. Check whether the subclass is declared in the same compilation unit.
8. Repeat steps 3-7 for each constructor in the class.
9. Check whether the class is final.
10. Get the name of subclass.
11. Check whether the subclass is abstract.
12. Get all methods declared in subclass.
13. Check whether method is abstract.
14. Repeat steps 12-13 for each method in the subclass.
15. Check whether the subclass has superclasses.
16. Get the name of superclass.
17. Check whether the superclass has private constructors.
18. Repeat steps 15-17 for each superclass of the subclass.

Based on the test case provided, the steps to verify the adherence to the rule are as follows:

1. Get the name of class `Base`.
2. Check whether the class `Base` is abstract. (True)
3. Get all constructors declared in class `Base`.
4. Check whether the constructor is private. (No constructors declared, so this step does not apply)
5. Get the name of class `Sub`.
6. Check whether the class `Sub` has subclasses. (False)
7. Check whether the subclass `Sub` is declared in the same compilation unit. (True)
8. Repeat steps 3-7 for each constructor in the class `Sub`. (No constructors declared, so this step does not apply)
9. Check whether the class `Sub` is final. (True)
10. Get the name of superclass `Base`.
11. Check whether the superclass `Base` is abstract. (True)
12. Get all methods declared in subclass `Sub`.
13. Check whether method is abstract. (False)
14. Repeat steps 12-13 for each method in the subclass `Sub`. (No methods declared, so this step does not apply)
15. Check whether the subclass `Sub` has superclasses. (True, superclass `Base`)
16. Get the name of superclass `Base`.
17. Check whether the superclass `Base` has private constructors. (False, no constructors declared)

Since `Base` is an abstract class and `Sub` is a subclass of `Base` declared in the same compilation unit, and `Base` does not have any constructors (thus implicitly having a private default constructor), the rule does not apply to this test case because `Sub` cannot be instantiated outside the compilation unit due to the private constructor of `Base`. Therefore, the number of violations is: 0.
['Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Get the name of class.', 'Check whether the class has subclasses.', 'Check whether the subclass is declared in the same compilation unit.', 'Repeat steps 3-7 for each constructor in the class.', 'Check whether the class is final.', 'Get the name of subclass.', 'Check whether the subclass is abstract.', 'Get all methods declared in subclass.', 'Check whether method is abstract.', 'Repeat steps 12-13 for each method in the subclass.', 'Check whether the subclass has superclasses.', 'Get the name of superclass.', 'Check whether the superclass has private constructors.', 'Repeat steps 15-17 for each superclass of the subclass.', 'Get the name of class `Base`.', 'Check whether the class `Base` is abstract. (True)', 'Get all constructors declared in class `Base`.', 'Check whether the constructor is private. (No constructors declared, so this step does not apply)', 'Get the name of class `Sub`.', 'Check whether the class `Sub` has subclasses. (False)', 'Check whether the subclass `Sub` is declared in the same compilation unit. (True)', 'Repeat steps 3-7 for each constructor in the class `Sub`. (No constructors declared, so this step does not apply)', 'Check whether the class `Sub` is final. (True)', 'Get the name of superclass `Base`.', 'Check whether the superclass `Base` is abstract. (True)', 'Get all methods declared in subclass `Sub`.', 'Check whether method is abstract. (False)', 'Repeat steps 12-13 for each method in the subclass `Sub`. (No methods declared, so this step does not apply)', 'Check whether the subclass `Sub` has superclasses. (True, superclass `Base`)', 'Get the name of superclass `Base`.', 'Check whether the superclass `Base` has private constructors. (False, no constructors declared)']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass is declared in the same compilation unit.* 匹配到的元操作或API：
query: Check whether the subclass is declared in the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8679710030555725
*Repeat steps 3-7 for each constructor in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get the name of subclass.* 匹配到的元操作或API：
logic: Get the name of subclass.
most similar meta operation: Get the name of class
cosine Similarity: 0.8744382858276367
*Check whether the subclass is abstract.* 匹配到的元操作或API：
logic: Check whether the subclass is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9374707937240601
*Get all methods declared in subclass.* 匹配到的元操作或API：
query: Get all methods declared in subclass.
most similar API: get declared annotations of method
cosine Similarity: 0.8178576231002808
*Check whether method is abstract.* 匹配到的元操作或API：
logic: Check whether method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.98253333568573
*Repeat steps 12-13 for each method in the subclass.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass has superclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of superclass.* 匹配到的元操作或API：
logic: Get the name of superclass.
most similar meta operation: Get the super class of class
cosine Similarity: 0.8680654764175415
*Check whether the superclass has private constructors.* 匹配到的元操作或API：
logic: Check whether the superclass has private constructors.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8828073740005493
*Repeat steps 15-17 for each superclass of the subclass.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class `Base`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class `Base` is abstract. (True)* 匹配到的元操作或API：
logic: Check whether the class `Base` is abstract. (True)
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.8927003145217896
*Get all constructors declared in class `Base`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private. (No constructors declared, so this step does not apply)* 匹配到的元操作或API：
logic: Check whether the constructor is private. (No constructors declared, so this step does not apply)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9465145468711853
*Get the name of class `Sub`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class `Sub` has subclasses. (False)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass `Sub` is declared in the same compilation unit. (True)* 匹配到的元操作或API：
query: Check whether the subclass `Sub` is declared in the same compilation unit. (True)
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8272414207458496
*Repeat steps 3-7 for each constructor in the class `Sub`. (No constructors declared, so this step does not apply)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class `Sub` is final. (True)* 匹配到的元操作或API：
logic: Check whether the class `Sub` is final. (True)
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9034135341644287
*Get the name of superclass `Base`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the superclass `Base` is abstract. (True)* 匹配到的元操作或API：
logic: Check whether the superclass `Base` is abstract. (True)
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.856505274772644
*Get all methods declared in subclass `Sub`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether method is abstract. (False)* 匹配到的元操作或API：
logic: Check whether method is abstract. (False)
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.969430685043335
*Repeat steps 12-13 for each method in the subclass `Sub`. (No methods declared, so this step does not apply)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the subclass `Sub` has superclasses. (True, superclass `Base`)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of superclass `Base`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the superclass `Base` has private constructors. (False, no constructors declared)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    if (constructorCall.isQualifiedInstanceCreation()) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = constructorCall.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
                    if (anonymousClass.getPackageName().equals(classNode.getPackageName())) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = anonymousClass.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this positive testcase:
import java.util.Comparator;
public class Outer {
    private abstract class Base<E> {
        abstract void run();
        abstract void sort(Comparator<E> comparator);
    }
    public void someMethod() {
        Base b = new Base<Object>() {
            void run() {}
            void sort(Comparator<Object> comparator) {}
        };
    }
}
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract classes without abstract methods but with subclasses should be ignored #3668
public class Outer {
    private abstract class Base {
        private void run() {}
    }
    private final class Sub extends Base {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    if (constructorCall.isQualifiedInstanceCreation()) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = constructorCall.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
                    if (anonymousClass.getPackageName().equals(classNode.getPackageName())) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = anonymousClass.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTClassOrInterfaceDeclaration subClass : node.children(ASTClassOrInterfaceDeclaration.class)) {
                    if (subClass.getSuperClassTypeNode() != null && subClass.getSuperClassTypeNode().isReferenceToClassSameCompilationUnit() && subClass.getSuperClassTypeNode().getType().getSimpleName().equals(classNode.getSimpleName())) {
                        isExtended = true;
                        break;
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 13" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 13" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Check whether the class is abstract.
        3. Get all constructors declared in class.
        4. Check whether the constructor is private.
        5. Check whether the class has subclasses outside their compilation unit.
        6. Get the number of subclasses.
        7. Check whether each subclass is within the same compilation unit.
        8. Check whether the class is final.
        9. Get the name of each subclass.
        10. Check whether each subclass is abstract.
        11. Get all methods declared in each subclass.
        12. Check whether each subclass has abstract methods.
        13. Check whether the class is within the same compilation unit as its subclasses.

Based on these checks:
- For the `Base` class:
  1. The name of class is Base.
  2. Check whether the class is abstract. (True, as it is declared abstract)
  3. Get all constructors declared in class. (None found in the provided test case)
  4. Check whether the constructor is private. (N/A, as there are no constructors)
  5. Check whether the class has subclasses outside their compilation unit. (False, as Sub is within the same compilation unit)
  6. Get the number of subclasses. (1, Sub is the subclass)
  7. Check whether each subclass is within the same compilation unit. (True, Sub is within the same compilation unit as Base)
  8. Check whether the class is final. (False, Base is abstract, not final)
  9. Get the name of each subclass. (Sub)
  10. Check whether each subclass is abstract. (False, Sub is declared final)
  11. Get all methods declared in each subclass. (None found in the provided test case)
  12. Check whether each subclass has abstract methods. (False, Sub does not have any abstract methods)
  13. Check whether the class is within the same compilation unit as its subclasses. (True, Base and Sub are within the same compilation unit)

- For the `Sub` class:
  1. The name of class is Sub.
  2. Check whether the class is abstract. (False, as it is declared final)
  3. Get all constructors declared in class. (None found in the provided test case)
  4. Check whether the constructor is private. (N/A, as there are no constructors)
  5. Check whether the class has subclasses outside their compilation unit. (N/A, as Sub is final and cannot have subclasses)
  6. Check whether the class is final. (True, Sub is declared final)
  7. Check whether the class is within the same compilation unit as its subclasses. (N/A, as Sub is final and cannot have subclasses)

Since the `Base` class has a subclass `Sub` within the same compilation unit and does not violate the rule because it is abstract and does not need to be final, and the `Sub` class is final and does not have any constructors to violate the rule, the number of violations in this test case is indeed 0.
['Get the name of class.', 'Check whether the class is abstract.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class has subclasses outside their compilation unit.', 'Get the number of subclasses.', 'Check whether each subclass is within the same compilation unit.', 'Check whether the class is final.', 'Get the name of each subclass.', 'Check whether each subclass is abstract.', 'Get all methods declared in each subclass.', 'Check whether each subclass has abstract methods.', 'Check whether the class is within the same compilation unit as its subclasses.', 'The name of class is Base.', 'Check whether the class is abstract. (True, as it is declared abstract)', 'Get all constructors declared in class. (None found in the provided test case)', 'Check whether the constructor is private. (N/A, as there are no constructors)', 'Check whether the class has subclasses outside their compilation unit. (False, as Sub is within the same compilation unit)', 'Get the number of subclasses. (1, Sub is the subclass)', 'Check whether each subclass is within the same compilation unit. (True, Sub is within the same compilation unit as Base)', 'Check whether the class is final. (False, Base is abstract, not final)', 'Get the name of each subclass. (Sub)', 'Check whether each subclass is abstract. (False, Sub is declared final)', 'Get all methods declared in each subclass. (None found in the provided test case)', 'Check whether each subclass has abstract methods. (False, Sub does not have any abstract methods)', 'Check whether the class is within the same compilation unit as its subclasses. (True, Base and Sub are within the same compilation unit)', 'The name of class is Sub.', 'Check whether the class is abstract. (False, as it is declared final)', 'Get all constructors declared in class. (None found in the provided test case)', 'Check whether the constructor is private. (N/A, as there are no constructors)', 'Check whether the class has subclasses outside their compilation unit. (N/A, as Sub is final and cannot have subclasses)', 'Check whether the class is final. (True, Sub is declared final)', 'Check whether the class is within the same compilation unit as its subclasses. (N/A, as Sub is final and cannot have subclasses)']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Get all constructors declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class has subclasses outside their compilation unit.* 匹配到的元操作或API：
query: Check whether the class has subclasses outside their compilation unit.
most similar API: Check whether the compilation unit has descendant of type
cosine Similarity: 0.809569239616394
*Get the number of subclasses.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each subclass is within the same compilation unit.* 匹配到的元操作或API：
query: Check whether each subclass is within the same compilation unit.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8495346903800964
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get the name of each subclass.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each subclass is abstract.* 匹配到的元操作或API：
logic: Check whether each subclass is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9029455184936523
*Get all methods declared in each subclass.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each subclass has abstract methods.* 匹配到的元操作或API：
logic: Check whether each subclass has abstract methods.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.8829790353775024
*Check whether the class is within the same compilation unit as its subclasses.* 匹配到的元操作或API：
query: Check whether the class is within the same compilation unit as its subclasses.
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8683604001998901
*The name of class is Base.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is abstract. (True, as it is declared abstract)* 匹配到的元操作或API：
logic: Check whether the class is abstract. (True, as it is declared abstract)
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9559378027915955
*Get all constructors declared in class. (None found in the provided test case)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private. (N/A, as there are no constructors)* 匹配到的元操作或API：
logic: Check whether the constructor is private. (N/A, as there are no constructors)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9433949589729309
*Check whether the class has subclasses outside their compilation unit. (False, as Sub is within the same compilation unit)* 匹配到的元操作或API：
query: Check whether the class has subclasses outside their compilation unit. (False, as Sub is within the same compilation unit)
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8110836744308472
*Get the number of subclasses. (1, Sub is the subclass)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each subclass is within the same compilation unit. (True, Sub is within the same compilation unit as Base)* 匹配到的元操作或API：
query: Check whether each subclass is within the same compilation unit. (True, Sub is within the same compilation unit as Base)
most similar API: Check whether the compilation unit equals
cosine Similarity: 0.8331950902938843
*Check whether the class is final. (False, Base is abstract, not final)* 匹配到的元操作或API：
logic: Check whether the class is final. (False, Base is abstract, not final)
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9096812009811401
*Get the name of each subclass. (Sub)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each subclass is abstract. (False, Sub is declared final)* 匹配到的元操作或API：
logic: Check whether each subclass is abstract. (False, Sub is declared final)
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.8651697635650635
*Get all methods declared in each subclass. (None found in the provided test case)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether each subclass has abstract methods. (False, Sub does not have any abstract methods)* 匹配到的元操作或API：
logic: Check whether each subclass has abstract methods. (False, Sub does not have any abstract methods)
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.8554118275642395
*Check whether the class is within the same compilation unit as its subclasses. (True, Base and Sub are within the same compilation unit)* 匹配到的元操作或API：
query: Check whether the class is within the same compilation unit as its subclasses. (True, Base and Sub are within the same compilation unit)
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8448397517204285
*The name of class is Sub.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is abstract. (False, as it is declared final)* 匹配到的元操作或API：
logic: Check whether the class is abstract. (False, as it is declared final)
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9248504638671875
*Get all constructors declared in class. (None found in the provided test case)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor is private. (N/A, as there are no constructors)* 匹配到的元操作或API：
logic: Check whether the constructor is private. (N/A, as there are no constructors)
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9433949589729309
*Check whether the class has subclasses outside their compilation unit. (N/A, as Sub is final and cannot have subclasses)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class is final. (True, Sub is declared final)* 匹配到的元操作或API：
logic: Check whether the class is final. (True, Sub is declared final)
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9207663536071777
*Check whether the class is within the same compilation unit as its subclasses. (N/A, as Sub is final and cannot have subclasses)* 匹配到的元操作或API：
query: Check whether the class is within the same compilation unit as its subclasses. (N/A, as Sub is final and cannot have subclasses)
most similar API: Check whether the class or interface type is reference to class same compilation unit
cosine Similarity: 0.8410166501998901
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    if (constructorCall.isQualifiedInstanceCreation()) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = constructorCall.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
                    if (anonymousClass.getPackageName().equals(classNode.getPackageName())) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = anonymousClass.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this positive testcase:
import java.util.Comparator;
public class Outer {
    private abstract class Base<E> {
        abstract void run();
        abstract void sort(Comparator<E> comparator);
    }
    public void someMethod() {
        Base b = new Base<Object>() {
            void run() {}
            void sort(Comparator<Object> comparator) {}
        };
    }
}
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// Private abstract classes without abstract methods but with subclasses should be ignored #3668
public class Outer {
    private abstract class Base {
        private void run() {}
    }
    private final class Sub extends Base {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Outer')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTClassOrInterfaceDeclaration (class name = 'Base')
      ——ASTModifierList
      ——ASTClassOrInterfaceBody
        ——ASTMethodDeclaration (method name = 'run')
          ——ASTModifierList
          ——ASTVoidType (method return type = 'void')
          ——ASTFormalParameters (size = 0)
          ——ASTBlock
    ——ASTClassOrInterfaceDeclaration (class name = 'Sub')
      ——ASTModifierList
      ——ASTExtendsList
        ——ASTClassOrInterfaceType (this is a class type)
      ——ASTClassOrInterfaceBody


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
4. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean hasDescendantOfType(java.lang.Class)
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType: public boolean isReferenceToClassSameCompilationUnit(), //Checks whether the type this node is referring to is declared within the same compilation unit - either a class/interface or a enum type. You want to check this, if {@link #getType()} is null. @return {@code true} if this node referencing a type in the same compilation unit, {@code false} otherwise. @deprecated This may be removed once type resolution is afoot
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
8. net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit: public boolean equals(java.lang.Object)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    if (constructorCall.isQualifiedInstanceCreation()) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = constructorCall.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
                    if (anonymousClass.getPackageName().equals(classNode.getPackageName())) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = anonymousClass.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTClassOrInterfaceDeclaration subclass : node.children(ASTClassOrInterfaceDeclaration.class)) {
                    if (subclass.hasReferenceToClassSameCompilationUnit(classNode.getSimpleName())) {
                        isExtended = true;
                        break;
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 13
[ERROR]   "ok 14" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
99
82
84
70
107
91
=========================error_testcase_logics=========================
To evaluate whether the test case adheres to the rule, we need to perform the following granular checks:

1. Get the name of class.
2. Check whether the class has declared annotations.
3. Get a declared annotation of class.
4. Check whether the class has @Value annotation (from Lombok).
5. Get all constructors declared in class.
6. Check whether the constructor is private.
7. Check whether the class is final.

Let's go through each step:

1. Get the name of class.
   - The name of the class is `Test`.

2. Check whether the class has declared annotations.
   - The class has declared annotations.

3. Get a declared annotation of class.
   - The declared annotation is `@Value`.

4. Check whether the class has @Value annotation (from Lombok).
   - The class has the `@Value` annotation, which is from Lombok.

5. Get all constructors declared in class.
   - There is one constructor declared in the class: `private Test(int a, int b) {}`.

6. Check whether the constructor is private.
   - The constructor is private.

7. Check whether the class is final.
   - The class is not final.

In this case, the class `Test` has a private constructor and the `@Value` annotation from Lombok. Lombok's `@Value` annotation includes the `@Final` annotation on all fields and implicitly makes the class final. Therefore, even though the class is not explicitly declared as final in the source code, Lombok's processing would make it final. As such, the class does not violate the rule because it is effectively final due to Lombok's annotation processing.

The number of violations in this test case is: 0.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the class has @Value annotation (from Lombok).', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is final.', 'Get the name of class.', 'Check whether the class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the class has @Value annotation (from Lombok).', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is final.']
['ASTAnnotation', 'JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTImportDeclaration', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.987838864326477
*Check whether the class has @Value annotation (from Lombok).* 匹配到的元操作或API：
query: Check whether the class has @Value annotation (from Lombok).
most similar API: Check whether has lombok annotation
cosine Similarity: 0.8218820095062256
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.987838864326477
*Check whether the class has @Value annotation (from Lombok).* 匹配到的元操作或API：
query: Check whether the class has @Value annotation (from Lombok).
most similar API: Check whether has lombok annotation
cosine Similarity: 0.8218820095062256
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    if (constructorCall.isQualifiedInstanceCreation()) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = constructorCall.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
                    if (anonymousClass.getPackageName().equals(classNode.getPackageName())) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = anonymousClass.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this positive testcase:
import java.util.Comparator;
public class Outer {
    private abstract class Base<E> {
        abstract void run();
        abstract void sort(Comparator<E> comparator);
    }
    public void someMethod() {
        Base b = new Base<Object>() {
            void run() {}
            void sort(Comparator<Object> comparator) {}
        };
    }
}
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// [java] ClassWithOnlyPrivateConstructorsShouldBeFinal should consider lombok's @Value #4200
import lombok.Value;

@Value
public class Test {
    private Test(int a, int b) {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Test')
  ——ASTModifierList
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 2)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'a')
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'b')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil: static public boolean hasLombokAnnotation(net.sourceforge.pmd.lang.java.ast.Annotatable), //Checks whether the given node is annotated with any lombok annotation. The node should be annotateable. @param node            the Annotatable node to check @return <code>true</code> if a lombok annotation has been found
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract() && !hasLombokAnnotation(classNode)) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract() && !hasLombokAnnotation(classNode)) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    if (constructorCall.isQualifiedInstanceCreation()) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = constructorCall.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
                    if (anonymousClass.getPackageName().equals(classNode.getPackageName())) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = anonymousClass.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }

    private boolean hasLombokAnnotation(ASTClassOrInterfaceDeclaration node) {
        return JavaRuleUtil.hasLombokAnnotation(node);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class has declared annotations.
3. Get a declared annotation of class.
4. Check whether the annotation is `@Value`.
5. Get the signature of constructor.
6. Check whether the constructor is private.
7. Get the number of constructors in class.
8. Check whether all constructors are private.

Here's the granular check sequence:

1. Get the name of class.
        Result: `Test`
2. Check whether the class has declared annotations.
        Result: True (`@Value` is present)
3. Get a declared annotation of class.
        Result: `@Value`
4. Check whether the annotation is `@Value`.
        Result: True
5. Get the signature of constructor.
        Result: `Test(int a, int b)`
6. Check whether the constructor is private.
        Result: True
7. Get the number of constructors in class.
        Result: 1
8. Check whether all constructors are private.
        Result: True (since there is only one constructor and it is private)

In this case, the class `Test` has a private constructor and is annotated with `@Value`. Lombok's `@Value` annotation implies that the class is effectively final, as it generates a private constructor and prevents subclassing. Therefore, the number of violations is 0, as the rule is not triggered due to Lombok's annotation handling.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the annotation is `@Value`.', 'Get the signature of constructor.', 'Check whether the constructor is private.', 'Get the number of constructors in class.', 'Check whether all constructors are private.', 'Get the name of class.', 'Check whether the class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the annotation is `@Value`.', 'Get the signature of constructor.', 'Check whether the constructor is private.', 'Get the number of constructors in class.', 'Check whether all constructors are private.']
['ASTAnnotation', 'JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTImportDeclaration', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.987838864326477
*Check whether the annotation is `@Value`.* 匹配到的元操作或API：
query: Check whether the annotation is `@Value`.
most similar API: Check whether the annotation equals
cosine Similarity: 0.8445106148719788
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828827381134033
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the number of constructors in class.* 匹配到的元操作或API：
query: Get the number of constructors in class.
most similar API: get num children of constructor
cosine Similarity: 0.8426800966262817
*Check whether all constructors are private.* 匹配到的元操作或API：
logic: Check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.936521589756012
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.987838864326477
*Check whether the annotation is `@Value`.* 匹配到的元操作或API：
query: Check whether the annotation is `@Value`.
most similar API: Check whether the annotation equals
cosine Similarity: 0.8445106148719788
*Get the signature of constructor.* 匹配到的元操作或API：
logic: Get the signature of constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9828827381134033
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Get the number of constructors in class.* 匹配到的元操作或API：
query: Get the number of constructors in class.
most similar API: get num children of constructor
cosine Similarity: 0.8426800966262817
*Check whether all constructors are private.* 匹配到的元操作或API：
logic: Check whether all constructors are private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.936521589756012
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    if (constructorCall.isQualifiedInstanceCreation()) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = constructorCall.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
                    if (anonymousClass.getPackageName().equals(classNode.getPackageName())) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = anonymousClass.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this positive testcase:
import java.util.Comparator;
public class Outer {
    private abstract class Base<E> {
        abstract void run();
        abstract void sort(Comparator<E> comparator);
    }
    public void someMethod() {
        Base b = new Base<Object>() {
            void run() {}
            void sort(Comparator<Object> comparator) {}
        };
    }
}
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// [java] ClassWithOnlyPrivateConstructorsShouldBeFinal should consider lombok's @Value #4200
import lombok.Value;

@Value
public class Test {
    private Test(int a, int b) {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Test')
  ——ASTModifierList
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 2)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'a')
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'b')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTAnnotation: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public int getNumChildren()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal() && !isLombokValue(classNode)) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal() && !isLombokValue(classNode)) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    if (constructorCall.isQualifiedInstanceCreation()) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = constructorCall.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
                    if (anonymousClass.getPackageName().equals(classNode.getPackageName())) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = anonymousClass.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }

    private boolean isLombokValue(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.anyMatch(annotation -> annotation.getType().getSimpleName().equals("Value"));
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class has declared annotations.
3. Get a declared annotation of class.
4. Check whether the annotation name is Value.
5. Get all constructors declared in class.
6. Check whether the constructor is private.
7. Check whether the class is final.
If the class is annotated with `@Value` from Lombok and all constructors are private, but the class is not marked as final, it might still not be considered a violation due to Lombok's behavior. In this case:
8. Check whether Lombok's `@Value` annotation implies final class.
Since Lombok's `@Value` annotation implies that the class is final, we can conclude that the class does not violate the rule.
The number of violations in this test case is indeed 0.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the annotation name is Value.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is final.', "Check whether Lombok's `@Value` annotation implies final class."]
['ASTAnnotation', 'JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTImportDeclaration', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.987838864326477
*Check whether the annotation name is Value.* 匹配到的元操作或API：
query: Check whether the annotation name is Value.
most similar API: Check whether the annotation equals
cosine Similarity: 0.8542068004608154
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether Lombok's `@Value` annotation implies final class.* 匹配到的元操作或API：
query: Check whether Lombok's `@Value` annotation implies final class.
most similar API: Check whether the class or interface is final
cosine Similarity: 0.8227248191833496
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    if (constructorCall.isQualifiedInstanceCreation()) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = constructorCall.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
                    if (anonymousClass.getPackageName().equals(classNode.getPackageName())) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = anonymousClass.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this positive testcase:
import java.util.Comparator;
public class Outer {
    private abstract class Base<E> {
        abstract void run();
        abstract void sort(Comparator<E> comparator);
    }
    public void someMethod() {
        Base b = new Base<Object>() {
            void run() {}
            void sort(Comparator<Object> comparator) {}
        };
    }
}
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// [java] ClassWithOnlyPrivateConstructorsShouldBeFinal should consider lombok's @Value #4200
import lombok.Value;

@Value
public class Test {
    private Test(int a, int b) {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Test')
  ——ASTModifierList
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 2)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'a')
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'b')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTAnnotation: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal(), //Returns true if this variable, method or class is final (even implicitly).

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract() && !isLombokValue(classNode)) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract() && !isLombokValue(classNode)) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    if (constructorCall.isQualifiedInstanceCreation()) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = constructorCall.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
                    if (anonymousClass.getPackageName().equals(classNode.getPackageName())) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = anonymousClass.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }

    private boolean isLombokValue(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        for (ASTAnnotation annotation : annotations) {
            if (annotation.getType().getPackageName().equals("lombok") && annotation.getType().getSimpleName().equals("Value")) {
                return true;
            }
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class has declared annotations.
3. Get a declared annotation of class.
4. Check whether the declared annotation is `@Value`.
5. Get all constructors declared in class.
6. Check whether each constructor is private.
7. Check whether the class is final.

To determine if the class violates the rule:
1. Get the name of class. // Test
2. Check whether the class has declared annotations. // True
3. Get a declared annotation of class. // @Value
4. Check whether the declared annotation is `@Value`. // True
5. Get all constructors declared in class. // One constructor
6. Check whether each constructor is private. // True
7. Check whether the class is final. // True

Since the class `Test` is annotated with `@Value`, which implies it is final (a known behavior of Lombok's `@Value` annotation), it does not violate the rule. The number of violations in this test case is: 0.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the declared annotation is `@Value`.', 'Get all constructors declared in class.', 'Check whether each constructor is private.', 'Check whether the class is final.', 'Get the name of class. // Test', 'Check whether the class has declared annotations. // True', 'Get a declared annotation of class. // @Value', 'Check whether the declared annotation is `@Value`. // True', 'Get all constructors declared in class. // One constructor', 'Check whether each constructor is private. // True', 'Check whether the class is final. // True']
['ASTAnnotation', 'JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTImportDeclaration', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.987838864326477
*Check whether the declared annotation is `@Value`.* 匹配到的元操作或API：
query: Check whether the declared annotation is `@Value`.
most similar API: Check whether the annotation equals
cosine Similarity: 0.8250124454498291
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether each constructor is private.* 匹配到的元操作或API：
logic: Check whether each constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9442476630210876
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Get the name of class. // Test* 匹配到的元操作或API：
logic: Get the name of class. // Test
most similar meta operation: Get the name of class
cosine Similarity: 0.8692469596862793
*Check whether the class has declared annotations. // True* 匹配到的元操作或API：
logic: Check whether the class has declared annotations. // True
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9648276567459106
*Get a declared annotation of class. // @Value* 匹配到的元操作或API：
logic: Get a declared annotation of class. // @Value
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.9158761501312256
*Check whether the declared annotation is `@Value`. // True* 匹配到的元操作或API：
query: Check whether the declared annotation is `@Value`. // True
most similar API: Check whether the annotation equals
cosine Similarity: 0.81437087059021
*Get all constructors declared in class. // One constructor* 匹配到的元操作或API：
query: Get all constructors declared in class. // One constructor
most similar API: get declared annotations of constructor
cosine Similarity: 0.8067412972450256
*Check whether each constructor is private. // True* 匹配到的元操作或API：
logic: Check whether each constructor is private. // True
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9334509968757629
*Check whether the class is final. // True* 匹配到的元操作或API：
logic: Check whether the class is final. // True
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9714694023132324
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    if (constructorCall.isQualifiedInstanceCreation()) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = constructorCall.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
                    if (anonymousClass.getPackageName().equals(classNode.getPackageName())) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = anonymousClass.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this positive testcase:
import java.util.Comparator;
public class Outer {
    private abstract class Base<E> {
        abstract void run();
        abstract void sort(Comparator<E> comparator);
    }
    public void someMethod() {
        Base b = new Base<Object>() {
            void run() {}
            void sort(Comparator<Object> comparator) {}
        };
    }
}
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// [java] ClassWithOnlyPrivateConstructorsShouldBeFinal should consider lombok's @Value #4200
import lombok.Value;

@Value
public class Test {
    private Test(int a, int b) {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Test')
  ——ASTModifierList
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 2)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'a')
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'b')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTAnnotation: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract() && !isLombokValue(classNode)) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract() && !isLombokValue(classNode)) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    if (constructorCall.isQualifiedInstanceCreation()) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = constructorCall.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
                    if (anonymousClass.getPackageName().equals(classNode.getPackageName())) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = anonymousClass.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }

    private boolean isLombokValue(ASTClassOrInterfaceDeclaration classNode) {
        NodeStream<ASTAnnotation> annotations = classNode.getDeclaredAnnotations();
        for (ASTAnnotation annotation : annotations) {
            ASTClassOrInterfaceType type = annotation.getType();
            if (type != null && "lombok.Value".equals(type.getImage())) {
                return true;
            }
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class has declared annotations.
3. Get a declared annotation of class.
4. Check whether the class has @Value annotation.
5. Get all constructors declared in class.
6. Check whether the constructor is private.
7. Check whether the class is final.

In this test case:
1. The name of the class is Test.
2. The class has declared annotations.
3. A declared annotation of the class is @Value.
4. The class has the @Value annotation.
5. The class has one constructor declared.
6. The constructor is private.
7. The class is final.

Since the class is final, it does not violate the rule even though all its constructors are private. Thus, the number of violations in this test case is indeed 0.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get a declared annotation of class.', 'Check whether the class has @Value annotation.', 'Get all constructors declared in class.', 'Check whether the constructor is private.', 'Check whether the class is final.', 'The name of the class is Test.', 'The class has declared annotations.', 'A declared annotation of the class is @Value.', 'The class has the @Value annotation.', 'The class has one constructor declared.', 'The constructor is private.', 'The class is final.']
['ASTAnnotation', 'JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTImportDeclaration', 'ASTFormalParameter', 'ASTConstructorDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.987838864326477
*Check whether the class has @Value annotation.* 匹配到的元操作或API：
query: Check whether the class has @Value annotation.
most similar API: Check whether the primitive type is annotation present
cosine Similarity: 0.8156536221504211
*Get all constructors declared in class.* 匹配到的元操作或API：
query: Get all constructors declared in class.
most similar API: get declared annotations of constructor
cosine Similarity: 0.8368493318557739
*Check whether the constructor is private.* 匹配到的元操作或API：
logic: Check whether the constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.9866331219673157
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*The name of the class is Test.* 匹配到的元操作或API：
未匹配成功元操作或API
*The class has declared annotations.* 匹配到的元操作或API：
logic: The class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.8569912910461426
*A declared annotation of the class is @Value.* 匹配到的元操作或API：
未匹配成功元操作或API
*The class has the @Value annotation.* 匹配到的元操作或API：
未匹配成功元操作或API
*The class has one constructor declared.* 匹配到的元操作或API：
未匹配成功元操作或API
*The constructor is private.* 匹配到的元操作或API：
logic: The constructor is private.
most similar meta operation: Check whether the constructor is private
cosine Similarity: 0.8586611747741699
*The class is final.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Reports classes that may be made final because they cannot be extended from outside their compilation unit anyway. This is because all their constructors are private, so a subclass could not call the super constructor.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract()) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    if (constructorCall.isQualifiedInstanceCreation()) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = constructorCall.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
                    if (anonymousClass.getPackageName().equals(classNode.getPackageName())) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = anonymousClass.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
```
This checker has passed these test case:
This checker has passed this positive testcase:
import java.util.Comparator;
public class Outer {
    private abstract class Base<E> {
        abstract void run();
        abstract void sort(Comparator<E> comparator);
    }
    public void someMethod() {
        Base b = new Base<Object>() {
            void run() {}
            void sort(Comparator<Object> comparator) {}
        };
    }
}
This checker has passed this negative testcase:
public class Outer {
    private abstract class Base {
        private void run() {}
    }
}
This checker has passed this negative testcase:
public abstract class FooUtils {
    private FooUtils() {
        // private constructor can't be called from sub classes,
        // so this class can't be extended
    }
    // note: this "abstract" class does not contain abstract methods
    // it was only declared as abstract to prevent instantiation
}
This checker has passed this negative testcase:
public class Example { // false-negative here
    private Example() {
    }
}

class Another {
}


This checker is failed(false positive) on this positive test case:
```
// [java] ClassWithOnlyPrivateConstructorsShouldBeFinal should consider lombok's @Value #4200
import lombok.Value;

@Value
public class Test {
    private Test(int a, int b) {}
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Test')
  ——ASTModifierList
    ——ASTAnnotation
      ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTConstructorDeclaration
      ——ASTModifierList
      ——ASTFormalParameters (size = 2)
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'a')
        ——ASTFormalParameter
          ——ASTModifierList
          ——ASTPrimitiveType (this is a primitive type)
          ——ASTVariableDeclaratorId (declared variable name = 'b')
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTPrimitiveType: public boolean isAnnotationPresent(java.lang.Class), //Returns true if an annotation with the given type is applied to this node.
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class ClassWithOnlyPrivateConstructorsShouldBeFinalRule extends AbstractJavaRulechainRule {
    public ClassWithOnlyPrivateConstructorsShouldBeFinalRule() {
        super(ASTCompilationUnit.class);
    }

    private boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> privateConstructorClassNames = new HashSet<>();
        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (!classNode.isInterface() && !classNode.isAbstract() && !hasAnnotations(classNode)) {
                boolean hasOnlyPrivateConstructors = true;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            } else if (classNode.isAbstract() && !hasAnnotations(classNode)) {
                boolean hasOnlyPrivateConstructors = true;
                boolean hasAbstractMethods = false;
                for (ASTConstructorDeclaration constructor : classNode.children(ASTConstructorDeclaration.class)) {
                    if (!constructor.isPrivate()) {
                        hasOnlyPrivateConstructors = false;
                        break;
                    }
                }
                for (ASTMethodDeclaration method : classNode.children(ASTMethodDeclaration.class)) {
                    if (method.isAbstract()) {
                        hasAbstractMethods = true;
                        break;
                    }
                }
                if (hasOnlyPrivateConstructors && !hasAbstractMethods && !classNode.isFinal()) {
                    privateConstructorClassNames.add(classNode.getSimpleName());
                }
            }
        }

        for (ASTClassOrInterfaceDeclaration classNode : node.children(ASTClassOrInterfaceDeclaration.class)) {
            if (privateConstructorClassNames.contains(classNode.getSimpleName()) && classNode.isPublic()) {
                boolean isExtended = false;
                for (ASTConstructorCall constructorCall : node.descendants(ASTConstructorCall.class)) {
                    if (constructorCall.isQualifiedInstanceCreation()) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = constructorCall.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                for (ASTAnonymousClassDeclaration anonymousClass : node.descendants(ASTAnonymousClassDeclaration.class)) {
                    if (anonymousClass.getPackageName().equals(classNode.getPackageName())) {
                        List<ASTClassOrInterfaceDeclaration> enclosingClasses = anonymousClass.getParentsOfType(ASTClassOrInterfaceDeclaration.class);
                        for (ASTClassOrInterfaceDeclaration enclosingClass : enclosingClasses) {
                            if (enclosingClass.getSimpleName().equals(classNode.getSimpleName())) {
                                isExtended = true;
                                break;
                            }
                        }
                    }
                }
                if (!isExtended) {
                    addViolation(data, classNode);
                }
            }
        }

        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
测试用例全部通过
最终通过 9 个测试用例
正例 6 个
反例 3 个
输入token：1192954
输出token：795934
结束

规则执行完毕，时间总花销： 11034.675664663315 秒
